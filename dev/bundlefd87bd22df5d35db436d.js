/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@popperjs/core/lib/createPopper.js":
/*!*********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/createPopper.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "popperGenerator": () => (/* binding */ popperGenerator),
/* harmony export */   "createPopper": () => (/* binding */ createPopper),
/* harmony export */   "detectOverflow": () => (/* reexport safe */ _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_13__["default"])
/* harmony export */ });
/* harmony import */ var _dom_utils_getCompositeRect_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./dom-utils/getCompositeRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js");
/* harmony import */ var _dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./dom-utils/getLayoutRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js");
/* harmony import */ var _dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom-utils/listScrollParents.js */ "./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js");
/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./dom-utils/getOffsetParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./dom-utils/getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");
/* harmony import */ var _utils_orderModifiers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/orderModifiers.js */ "./node_modules/@popperjs/core/lib/utils/orderModifiers.js");
/* harmony import */ var _utils_debounce_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./utils/debounce.js */ "./node_modules/@popperjs/core/lib/utils/debounce.js");
/* harmony import */ var _utils_validateModifiers_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/validateModifiers.js */ "./node_modules/@popperjs/core/lib/utils/validateModifiers.js");
/* harmony import */ var _utils_uniqueBy_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/uniqueBy.js */ "./node_modules/@popperjs/core/lib/utils/uniqueBy.js");
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _utils_mergeByName_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/mergeByName.js */ "./node_modules/@popperjs/core/lib/utils/mergeByName.js");
/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./utils/detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom-utils/instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./enums.js */ "./node_modules/@popperjs/core/lib/enums.js");














var INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';
var INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';
var DEFAULT_OPTIONS = {
  placement: 'bottom',
  modifiers: [],
  strategy: 'absolute'
};

function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return !args.some(function (element) {
    return !(element && typeof element.getBoundingClientRect === 'function');
  });
}

function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }

  var _generatorOptions = generatorOptions,
      _generatorOptions$def = _generatorOptions.defaultModifiers,
      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
      _generatorOptions$def2 = _generatorOptions.defaultOptions,
      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper(reference, popper, options) {
    if (options === void 0) {
      options = defaultOptions;
    }

    var state = {
      placement: 'bottom',
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference,
        popper: popper
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state: state,
      setOptions: function setOptions(setOptionsAction) {
        var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options);
        state.scrollParents = {
          reference: (0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isElement)(reference) ? (0,_dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_1__["default"])(reference) : reference.contextElement ? (0,_dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_1__["default"])(reference.contextElement) : [],
          popper: (0,_dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_1__["default"])(popper)
        }; // Orders the modifiers based on their dependencies and `phase`
        // properties

        var orderedModifiers = (0,_utils_orderModifiers_js__WEBPACK_IMPORTED_MODULE_2__["default"])((0,_utils_mergeByName_js__WEBPACK_IMPORTED_MODULE_3__["default"])([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

        state.orderedModifiers = orderedModifiers.filter(function (m) {
          return m.enabled;
        }); // Validate the provided modifiers so that the consumer will get warned
        // if one of the modifiers is invalid for any reason

        if (true) {
          var modifiers = (0,_utils_uniqueBy_js__WEBPACK_IMPORTED_MODULE_4__["default"])([].concat(orderedModifiers, state.options.modifiers), function (_ref) {
            var name = _ref.name;
            return name;
          });
          (0,_utils_validateModifiers_js__WEBPACK_IMPORTED_MODULE_5__["default"])(modifiers);

          if ((0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_6__["default"])(state.options.placement) === _enums_js__WEBPACK_IMPORTED_MODULE_7__.auto) {
            var flipModifier = state.orderedModifiers.find(function (_ref2) {
              var name = _ref2.name;
              return name === 'flip';
            });

            if (!flipModifier) {
              console.error(['Popper: "auto" placements require the "flip" modifier be', 'present and enabled to work.'].join(' '));
            }
          }

          var _getComputedStyle = (0,_dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_8__["default"])(popper),
              marginTop = _getComputedStyle.marginTop,
              marginRight = _getComputedStyle.marginRight,
              marginBottom = _getComputedStyle.marginBottom,
              marginLeft = _getComputedStyle.marginLeft; // We no longer take into account `margins` on the popper, and it can
          // cause bugs with positioning, so we'll warn the consumer


          if ([marginTop, marginRight, marginBottom, marginLeft].some(function (margin) {
            return parseFloat(margin);
          })) {
            console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', 'between the popper and its reference element or boundary.', 'To replicate margin, use the `offset` modifier, as well as', 'the `padding` option in the `preventOverflow` and `flip`', 'modifiers.'].join(' '));
          }
        }

        runModifierEffects();
        return instance.update();
      },
      // Sync update â€“ it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }

        var _state$elements = state.elements,
            reference = _state$elements.reference,
            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
        // anymore

        if (!areValidElements(reference, popper)) {
          if (true) {
            console.error(INVALID_ELEMENT_ERROR);
          }

          return;
        } // Store the reference and popper rects to be read by modifiers


        state.rects = {
          reference: (0,_dom_utils_getCompositeRect_js__WEBPACK_IMPORTED_MODULE_9__["default"])(reference, (0,_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_10__["default"])(popper), state.options.strategy === 'fixed'),
          popper: (0,_dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_11__["default"])(popper)
        }; // Modifiers have the ability to reset the current update cycle. The
        // most common use case for this is the `flip` modifier changing the
        // placement, which then needs to re-run all the modifiers, because the
        // logic was previously ran for the previous placement and is therefore
        // stale/incorrect

        state.reset = false;
        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
        // is filled with the initial data specified by the modifier. This means
        // it doesn't persist and is fresh on each update.
        // To ensure persistent data, use `${name}#persistent`

        state.orderedModifiers.forEach(function (modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        var __debug_loops__ = 0;

        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (true) {
            __debug_loops__ += 1;

            if (__debug_loops__ > 100) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
          }

          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }

          var _state$orderedModifie = state.orderedModifiers[index],
              fn = _state$orderedModifie.fn,
              _state$orderedModifie2 = _state$orderedModifie.options,
              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
              name = _state$orderedModifie.name;

          if (typeof fn === 'function') {
            state = fn({
              state: state,
              options: _options,
              name: name,
              instance: instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update â€“ it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: (0,_utils_debounce_js__WEBPACK_IMPORTED_MODULE_12__["default"])(function () {
        return new Promise(function (resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };

    if (!areValidElements(reference, popper)) {
      if (true) {
        console.error(INVALID_ELEMENT_ERROR);
      }

      return instance;
    }

    instance.setOptions(options).then(function (state) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state);
      }
    }); // Modifiers have the ability to execute arbitrary code before the first
    // update cycle runs. They will be executed in the same order as the update
    // cycle. This is useful when a modifier adds some persistent data that
    // other modifiers need to use, but the modifier is run after the dependent
    // one.

    function runModifierEffects() {
      state.orderedModifiers.forEach(function (_ref3) {
        var name = _ref3.name,
            _ref3$options = _ref3.options,
            options = _ref3$options === void 0 ? {} : _ref3$options,
            effect = _ref3.effect;

        if (typeof effect === 'function') {
          var cleanupFn = effect({
            state: state,
            name: name,
            instance: instance,
            options: options
          });

          var noopFn = function noopFn() {};

          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }

    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function (fn) {
        return fn();
      });
      effectCleanupFns = [];
    }

    return instance;
  };
}
var createPopper = /*#__PURE__*/popperGenerator(); // eslint-disable-next-line import/no-unused-modules



/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/contains.js":
/*!***************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/contains.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ contains)
/* harmony export */ });
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");

function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

  if (parent.contains(child)) {
    return true;
  } // then fallback to custom implementation with Shadow DOM support
  else if (rootNode && (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isShadowRoot)(rootNode)) {
      var next = child;

      do {
        if (next && parent.isSameNode(next)) {
          return true;
        } // $FlowFixMe[prop-missing]: need a better way to handle this...


        next = next.parentNode || next.host;
      } while (next);
    } // Give up, the result is false


  return false;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getBoundingClientRect)
/* harmony export */ });
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");


function getBoundingClientRect(element, includeScale) {
  if (includeScale === void 0) {
    includeScale = false;
  }

  var rect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;

  if ((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) && includeScale) {
    var offsetHeight = element.offsetHeight;
    var offsetWidth = element.offsetWidth; // Do not attempt to divide by 0, otherwise we get `Infinity` as scale
    // Fallback to 1 in case both values are `0`

    if (offsetWidth > 0) {
      scaleX = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_1__.round)(rect.width) / offsetWidth || 1;
    }

    if (offsetHeight > 0) {
      scaleY = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_1__.round)(rect.height) / offsetHeight || 1;
    }
  }

  return {
    width: rect.width / scaleX,
    height: rect.height / scaleY,
    top: rect.top / scaleY,
    right: rect.right / scaleX,
    bottom: rect.bottom / scaleY,
    left: rect.left / scaleX,
    x: rect.left / scaleX,
    y: rect.top / scaleY
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getClippingRect)
/* harmony export */ });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _getViewportRect_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getViewportRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js");
/* harmony import */ var _getDocumentRect_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getDocumentRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js");
/* harmony import */ var _listScrollParents_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./listScrollParents.js */ "./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js");
/* harmony import */ var _getOffsetParent_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./getOffsetParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBoundingClientRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");
/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./getParentNode.js */ "./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js");
/* harmony import */ var _contains_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./contains.js */ "./node_modules/@popperjs/core/lib/dom-utils/contains.js");
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _utils_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/rectToClientRect.js */ "./node_modules/@popperjs/core/lib/utils/rectToClientRect.js");
/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../utils/math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");















function getInnerBoundingClientRect(element) {
  var rect = (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element);
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}

function getClientRectFromMixedType(element, clippingParent) {
  return clippingParent === _enums_js__WEBPACK_IMPORTED_MODULE_1__.viewport ? (0,_utils_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_2__["default"])((0,_getViewportRect_js__WEBPACK_IMPORTED_MODULE_3__["default"])(element)) : (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__.isElement)(clippingParent) ? getInnerBoundingClientRect(clippingParent) : (0,_utils_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_2__["default"])((0,_getDocumentRect_js__WEBPACK_IMPORTED_MODULE_5__["default"])((0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_6__["default"])(element)));
} // A "clipping parent" is an overflowable container with the characteristic of
// clipping (or hiding) overflowing elements with a position different from
// `initial`


function getClippingParents(element) {
  var clippingParents = (0,_listScrollParents_js__WEBPACK_IMPORTED_MODULE_7__["default"])((0,_getParentNode_js__WEBPACK_IMPORTED_MODULE_8__["default"])(element));
  var canEscapeClipping = ['absolute', 'fixed'].indexOf((0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_9__["default"])(element).position) >= 0;
  var clipperElement = canEscapeClipping && (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(element) ? (0,_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_10__["default"])(element) : element;

  if (!(0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__.isElement)(clipperElement)) {
    return [];
  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414


  return clippingParents.filter(function (clippingParent) {
    return (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__.isElement)(clippingParent) && (0,_contains_js__WEBPACK_IMPORTED_MODULE_11__["default"])(clippingParent, clipperElement) && (0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_12__["default"])(clippingParent) !== 'body';
  });
} // Gets the maximum area that the element is visible in due to any number of
// clipping parents


function getClippingRect(element, boundary, rootBoundary) {
  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents[0];
  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent);
    accRect.top = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_13__.max)(rect.top, accRect.top);
    accRect.right = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_13__.min)(rect.right, accRect.right);
    accRect.bottom = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_13__.min)(rect.bottom, accRect.bottom);
    accRect.left = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_13__.max)(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getCompositeRect)
/* harmony export */ });
/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getBoundingClientRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");
/* harmony import */ var _getNodeScroll_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./getNodeScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js");
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./getWindowScrollBarX.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _isScrollParent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./isScrollParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js");
/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");









function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_0__.round)(rect.width) / element.offsetWidth || 1;
  var scaleY = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_0__.round)(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
} // Returns the composite rect of an element relative to its offsetParent.
// Composite means it takes into account transforms as well as layout.


function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }

  var isOffsetParentAnElement = (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(offsetParent);
  var offsetParentIsScaled = (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(offsetParent) && isElementScaled(offsetParent);
  var documentElement = (0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(offsetParent);
  var rect = (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_3__["default"])(elementOrVirtualElement, offsetParentIsScaled);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };

  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if ((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_4__["default"])(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
    (0,_isScrollParent_js__WEBPACK_IMPORTED_MODULE_5__["default"])(documentElement)) {
      scroll = (0,_getNodeScroll_js__WEBPACK_IMPORTED_MODULE_6__["default"])(offsetParent);
    }

    if ((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(offsetParent)) {
      offsets = (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_3__["default"])(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = (0,_getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_7__["default"])(documentElement);
    }
  }

  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getComputedStyle)
/* harmony export */ });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");

function getComputedStyle(element) {
  return (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element).getComputedStyle(element);
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getDocumentElement)
/* harmony export */ });
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");

function getDocumentElement(element) {
  // $FlowFixMe[incompatible-return]: assume body is always available
  return (((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isElement)(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]
  element.document) || window.document).documentElement;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getDocumentRect)
/* harmony export */ });
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");
/* harmony import */ var _getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getWindowScrollBarX.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js");
/* harmony import */ var _getWindowScroll_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getWindowScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js");
/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");




 // Gets the entire size of the scrollable document area, even extending outside
// of the `<html>` and `<body>` rect bounds if horizontally scrollable

function getDocumentRect(element) {
  var _element$ownerDocumen;

  var html = (0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element);
  var winScroll = (0,_getWindowScroll_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_2__.max)(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_2__.max)(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + (0,_getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_3__["default"])(element);
  var y = -winScroll.scrollTop;

  if ((0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_4__["default"])(body || html).direction === 'rtl') {
    x += (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_2__.max)(html.clientWidth, body ? body.clientWidth : 0) - width;
  }

  return {
    width: width,
    height: height,
    x: x,
    y: y
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getHTMLElementScroll)
/* harmony export */ });
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getLayoutRect)
/* harmony export */ });
/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBoundingClientRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");
 // Returns the layout rect of an element relative to its offsetParent. Layout
// means it doesn't take into account transforms.

function getLayoutRect(element) {
  var clientRect = (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element); // Use the clientRect sizes if it's not been transformed.
  // Fixes https://github.com/popperjs/popper-core/issues/1223

  var width = element.offsetWidth;
  var height = element.offsetHeight;

  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }

  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }

  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width: width,
    height: height
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js":
/*!******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getNodeName)
/* harmony export */ });
function getNodeName(element) {
  return element ? (element.nodeName || '').toLowerCase() : null;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getNodeScroll)
/* harmony export */ });
/* harmony import */ var _getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindowScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js");
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _getHTMLElementScroll_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getHTMLElementScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js");




function getNodeScroll(node) {
  if (node === (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node) || !(0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(node)) {
    return (0,_getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__["default"])(node);
  } else {
    return (0,_getHTMLElementScroll_js__WEBPACK_IMPORTED_MODULE_3__["default"])(node);
  }
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getOffsetParent)
/* harmony export */ });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _isTableElement_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./isTableElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js");
/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getParentNode.js */ "./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js");







function getTrueOffsetParent(element) {
  if (!(0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) || // https://github.com/popperjs/popper-core/issues/837
  (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element).position === 'fixed') {
    return null;
  }

  return element.offsetParent;
} // `.offsetParent` reports `null` for fixed elements, while absolute elements
// return the containing block


function getContainingBlock(element) {
  var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') !== -1;
  var isIE = navigator.userAgent.indexOf('Trident') !== -1;

  if (isIE && (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element)) {
    // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
    var elementCss = (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element);

    if (elementCss.position === 'fixed') {
      return null;
    }
  }

  var currentNode = (0,_getParentNode_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element);

  if ((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isShadowRoot)(currentNode)) {
    currentNode = currentNode.host;
  }

  while ((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(currentNode) && ['html', 'body'].indexOf((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_3__["default"])(currentNode)) < 0) {
    var css = (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(currentNode); // This is non-exhaustive but covers the most common CSS properties that
    // create a containing block.
    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

    if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }

  return null;
} // Gets the closest ancestor positioned element. Handles some edge cases,
// such as table ancestors and cross browser bugs.


function getOffsetParent(element) {
  var window = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_4__["default"])(element);
  var offsetParent = getTrueOffsetParent(element);

  while (offsetParent && (0,_isTableElement_js__WEBPACK_IMPORTED_MODULE_5__["default"])(offsetParent) && (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(offsetParent).position === 'static') {
    offsetParent = getTrueOffsetParent(offsetParent);
  }

  if (offsetParent && ((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_3__["default"])(offsetParent) === 'html' || (0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_3__["default"])(offsetParent) === 'body' && (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(offsetParent).position === 'static')) {
    return window;
  }

  return offsetParent || getContainingBlock(element) || window;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getParentNode)
/* harmony export */ });
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");



function getParentNode(element) {
  if ((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element) === 'html') {
    return element;
  }

  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || ( // DOM Element detected
    (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isShadowRoot)(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    (0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element) // fallback

  );
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getScrollParent)
/* harmony export */ });
/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getParentNode.js */ "./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js");
/* harmony import */ var _isScrollParent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isScrollParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js");
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");




function getScrollParent(node) {
  if (['html', 'body', '#document'].indexOf((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node)) >= 0) {
    // $FlowFixMe[incompatible-return]: assume body is always available
    return node.ownerDocument.body;
  }

  if ((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(node) && (0,_isScrollParent_js__WEBPACK_IMPORTED_MODULE_2__["default"])(node)) {
    return node;
  }

  return getScrollParent((0,_getParentNode_js__WEBPACK_IMPORTED_MODULE_3__["default"])(node));
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getViewportRect)
/* harmony export */ });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindowScrollBarX.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js");



function getViewportRect(element) {
  var win = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element);
  var html = (0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0; // NB: This isn't supported on iOS <= 12. If the keyboard is open, the popper
  // can be obscured underneath it.
  // Also, `html.clientHeight` adds the bottom bar height in Safari iOS, even
  // if it isn't open, so if this isn't available, the popper will be detected
  // to overflow the bottom of the screen too early.

  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)
    // In Chrome, it returns a value very close to 0 (+/-) but contains rounding
    // errors due to floating point numbers, so we need to check precision.
    // Safari returns a number <= 0, usually < -1 when pinch-zoomed
    // Feature detection fails in mobile emulation mode in Chrome.
    // Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) <
    // 0.001
    // Fallback here: "Not Safari" userAgent

    if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }

  return {
    width: width,
    height: height,
    x: x + (0,_getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element),
    y: y
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js":
/*!****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getWindow.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getWindow)
/* harmony export */ });
function getWindow(node) {
  if (node == null) {
    return window;
  }

  if (node.toString() !== '[object Window]') {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }

  return node;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getWindowScroll)
/* harmony export */ });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");

function getWindowScroll(node) {
  var win = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft: scrollLeft,
    scrollTop: scrollTop
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getWindowScrollBarX)
/* harmony export */ });
/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBoundingClientRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");
/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindowScroll.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js");



function getWindowScrollBarX(element) {
  // If <html> has a CSS width greater than the viewport, then this will be
  // incorrect for RTL.
  // Popper 1 is broken in this case and never had a bug report so let's assume
  // it's not an issue. I don't think anyone ever specifies width on <html>
  // anyway.
  // Browsers where the left scrollbar doesn't cause an issue report `0` for
  // this (e.g. Edge 2019, IE11, Safari)
  return (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__["default"])((0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element)).left + (0,_getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__["default"])(element).scrollLeft;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isElement": () => (/* binding */ isElement),
/* harmony export */   "isHTMLElement": () => (/* binding */ isHTMLElement),
/* harmony export */   "isShadowRoot": () => (/* binding */ isShadowRoot)
/* harmony export */ });
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");


function isElement(node) {
  var OwnElement = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}

function isHTMLElement(node) {
  var OwnElement = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}

function isShadowRoot(node) {
  // IE 11 has no ShadowRoot
  if (typeof ShadowRoot === 'undefined') {
    return false;
  }

  var OwnElement = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}



/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isScrollParent)
/* harmony export */ });
/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");

function isScrollParent(element) {
  // Firefox wants us to check `-x` and `-y` variations as well
  var _getComputedStyle = (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element),
      overflow = _getComputedStyle.overflow,
      overflowX = _getComputedStyle.overflowX,
      overflowY = _getComputedStyle.overflowY;

  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isTableElement)
/* harmony export */ });
/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");

function isTableElement(element) {
  return ['table', 'td', 'th'].indexOf((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element)) >= 0;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js":
/*!************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ listScrollParents)
/* harmony export */ });
/* harmony import */ var _getScrollParent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getScrollParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js");
/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getParentNode.js */ "./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js");
/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _isScrollParent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isScrollParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js");




/*
given a DOM element, return the list of all scroll parents, up the list of ancesors
until we get to the top window object. This list is what we attach scroll listeners
to, because if any of these parent elements scroll, we'll need to re-calculate the
reference element's position.
*/

function listScrollParents(element, list) {
  var _element$ownerDocumen;

  if (list === void 0) {
    list = [];
  }

  var scrollParent = (0,_getScrollParent_js__WEBPACK_IMPORTED_MODULE_0__["default"])(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_1__["default"])(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], (0,_isScrollParent_js__WEBPACK_IMPORTED_MODULE_2__["default"])(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
  updatedList.concat(listScrollParents((0,_getParentNode_js__WEBPACK_IMPORTED_MODULE_3__["default"])(target)));
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/enums.js":
/*!**************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/enums.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "top": () => (/* binding */ top),
/* harmony export */   "bottom": () => (/* binding */ bottom),
/* harmony export */   "right": () => (/* binding */ right),
/* harmony export */   "left": () => (/* binding */ left),
/* harmony export */   "auto": () => (/* binding */ auto),
/* harmony export */   "basePlacements": () => (/* binding */ basePlacements),
/* harmony export */   "start": () => (/* binding */ start),
/* harmony export */   "end": () => (/* binding */ end),
/* harmony export */   "clippingParents": () => (/* binding */ clippingParents),
/* harmony export */   "viewport": () => (/* binding */ viewport),
/* harmony export */   "popper": () => (/* binding */ popper),
/* harmony export */   "reference": () => (/* binding */ reference),
/* harmony export */   "variationPlacements": () => (/* binding */ variationPlacements),
/* harmony export */   "placements": () => (/* binding */ placements),
/* harmony export */   "beforeRead": () => (/* binding */ beforeRead),
/* harmony export */   "read": () => (/* binding */ read),
/* harmony export */   "afterRead": () => (/* binding */ afterRead),
/* harmony export */   "beforeMain": () => (/* binding */ beforeMain),
/* harmony export */   "main": () => (/* binding */ main),
/* harmony export */   "afterMain": () => (/* binding */ afterMain),
/* harmony export */   "beforeWrite": () => (/* binding */ beforeWrite),
/* harmony export */   "write": () => (/* binding */ write),
/* harmony export */   "afterWrite": () => (/* binding */ afterWrite),
/* harmony export */   "modifierPhases": () => (/* binding */ modifierPhases)
/* harmony export */ });
var top = 'top';
var bottom = 'bottom';
var right = 'right';
var left = 'left';
var auto = 'auto';
var basePlacements = [top, bottom, right, left];
var start = 'start';
var end = 'end';
var clippingParents = 'clippingParents';
var viewport = 'viewport';
var popper = 'popper';
var reference = 'reference';
var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []); // modifiers that need to read the DOM

var beforeRead = 'beforeRead';
var read = 'read';
var afterRead = 'afterRead'; // pure-logic modifiers

var beforeMain = 'beforeMain';
var main = 'main';
var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

var beforeWrite = 'beforeWrite';
var write = 'write';
var afterWrite = 'afterWrite';
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "afterMain": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.afterMain),
/* harmony export */   "afterRead": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.afterRead),
/* harmony export */   "afterWrite": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.afterWrite),
/* harmony export */   "auto": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.auto),
/* harmony export */   "basePlacements": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.basePlacements),
/* harmony export */   "beforeMain": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.beforeMain),
/* harmony export */   "beforeRead": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.beforeRead),
/* harmony export */   "beforeWrite": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.beforeWrite),
/* harmony export */   "bottom": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.bottom),
/* harmony export */   "clippingParents": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.clippingParents),
/* harmony export */   "end": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.end),
/* harmony export */   "left": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.left),
/* harmony export */   "main": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.main),
/* harmony export */   "modifierPhases": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.modifierPhases),
/* harmony export */   "placements": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.placements),
/* harmony export */   "popper": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper),
/* harmony export */   "read": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.read),
/* harmony export */   "reference": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.reference),
/* harmony export */   "right": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.right),
/* harmony export */   "start": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.start),
/* harmony export */   "top": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.top),
/* harmony export */   "variationPlacements": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.variationPlacements),
/* harmony export */   "viewport": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.viewport),
/* harmony export */   "write": () => (/* reexport safe */ _enums_js__WEBPACK_IMPORTED_MODULE_0__.write),
/* harmony export */   "applyStyles": () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__.applyStyles),
/* harmony export */   "arrow": () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__.arrow),
/* harmony export */   "computeStyles": () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__.computeStyles),
/* harmony export */   "eventListeners": () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__.eventListeners),
/* harmony export */   "flip": () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__.flip),
/* harmony export */   "hide": () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__.hide),
/* harmony export */   "offset": () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__.offset),
/* harmony export */   "popperOffsets": () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__.popperOffsets),
/* harmony export */   "preventOverflow": () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__.preventOverflow),
/* harmony export */   "popperGenerator": () => (/* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_2__.popperGenerator),
/* harmony export */   "detectOverflow": () => (/* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   "createPopperBase": () => (/* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_2__.createPopper),
/* harmony export */   "createPopper": () => (/* reexport safe */ _popper_js__WEBPACK_IMPORTED_MODULE_4__.createPopper),
/* harmony export */   "createPopperLite": () => (/* reexport safe */ _popper_lite_js__WEBPACK_IMPORTED_MODULE_5__.createPopper)
/* harmony export */ });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _modifiers_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modifiers/index.js */ "./node_modules/@popperjs/core/lib/modifiers/index.js");
/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./createPopper.js */ "./node_modules/@popperjs/core/lib/createPopper.js");
/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./createPopper.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _popper_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./popper.js */ "./node_modules/@popperjs/core/lib/popper.js");
/* harmony import */ var _popper_lite_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./popper-lite.js */ "./node_modules/@popperjs/core/lib/popper-lite.js");

 // eslint-disable-next-line import/no-unused-modules

 // eslint-disable-next-line import/no-unused-modules

 // eslint-disable-next-line import/no-unused-modules



/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/applyStyles.js":
/*!******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/applyStyles.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _dom_utils_getNodeName_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom-utils/getNodeName.js */ "./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js");
/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom-utils/instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");

 // This modifier takes the styles prepared by the `computeStyles` modifier
// and applies them to the HTMLElements such as popper and arrow

function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function (name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name]; // arrow is optional + virtual elements

    if (!(0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) || !(0,_dom_utils_getNodeName_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element)) {
      return;
    } // Flow doesn't support to extend this property, but it's the most
    // effective way to apply styles to an HTMLElement
    // $FlowFixMe[cannot-write]


    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function (name) {
      var value = attributes[name];

      if (value === false) {
        element.removeAttribute(name);
      } else {
        element.setAttribute(name, value === true ? '' : value);
      }
    });
  });
}

function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: '0',
      top: '0',
      margin: '0'
    },
    arrow: {
      position: 'absolute'
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;

  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }

  return function () {
    Object.keys(state.elements).forEach(function (name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

      var style = styleProperties.reduce(function (style, property) {
        style[property] = '';
        return style;
      }, {}); // arrow is optional + virtual elements

      if (!(0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) || !(0,_dom_utils_getNodeName_js__WEBPACK_IMPORTED_MODULE_1__["default"])(element)) {
        return;
      }

      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function (attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'applyStyles',
  enabled: true,
  phase: 'write',
  fn: applyStyles,
  effect: effect,
  requires: ['computeStyles']
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/arrow.js":
/*!************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/arrow.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../dom-utils/getLayoutRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js");
/* harmony import */ var _dom_utils_contains_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../dom-utils/contains.js */ "./node_modules/@popperjs/core/lib/dom-utils/contains.js");
/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dom-utils/getOffsetParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/getMainAxisFromPlacement.js */ "./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js");
/* harmony import */ var _utils_within_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/within.js */ "./node_modules/@popperjs/core/lib/utils/within.js");
/* harmony import */ var _utils_mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/mergePaddingObject.js */ "./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js");
/* harmony import */ var _utils_expandToHashMap_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/expandToHashMap.js */ "./node_modules/@popperjs/core/lib/utils/expandToHashMap.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../dom-utils/instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");









 // eslint-disable-next-line import/no-unused-modules

var toPaddingObject = function toPaddingObject(padding, state) {
  padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return (0,_utils_mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(typeof padding !== 'number' ? padding : (0,_utils_expandToHashMap_js__WEBPACK_IMPORTED_MODULE_1__["default"])(padding, _enums_js__WEBPACK_IMPORTED_MODULE_2__.basePlacements));
};

function arrow(_ref) {
  var _state$modifiersData$;

  var state = _ref.state,
      name = _ref.name,
      options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets = state.modifiersData.popperOffsets;
  var basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(state.placement);
  var axis = (0,_utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_4__["default"])(basePlacement);
  var isVertical = [_enums_js__WEBPACK_IMPORTED_MODULE_2__.left, _enums_js__WEBPACK_IMPORTED_MODULE_2__.right].indexOf(basePlacement) >= 0;
  var len = isVertical ? 'height' : 'width';

  if (!arrowElement || !popperOffsets) {
    return;
  }

  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = (0,_dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_5__["default"])(arrowElement);
  var minProp = axis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_2__.top : _enums_js__WEBPACK_IMPORTED_MODULE_2__.left;
  var maxProp = axis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_2__.bottom : _enums_js__WEBPACK_IMPORTED_MODULE_2__.right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
  var startDiff = popperOffsets[axis] - state.rects.reference[axis];
  var arrowOffsetParent = (0,_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_6__["default"])(arrowElement);
  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
  // outside of the popper bounds

  var min = paddingObject[minProp];
  var max = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset = (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_7__.within)(min, center, max); // Prevents breaking syntax highlighting...

  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
}

function effect(_ref2) {
  var state = _ref2.state,
      options = _ref2.options;
  var _options$element = options.element,
      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;

  if (arrowElement == null) {
    return;
  } // CSS selector


  if (typeof arrowElement === 'string') {
    arrowElement = state.elements.popper.querySelector(arrowElement);

    if (!arrowElement) {
      return;
    }
  }

  if (true) {
    if (!(0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_8__.isHTMLElement)(arrowElement)) {
      console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', 'To use an SVG arrow, wrap it in an HTMLElement that will be used as', 'the arrow.'].join(' '));
    }
  }

  if (!(0,_dom_utils_contains_js__WEBPACK_IMPORTED_MODULE_9__["default"])(state.elements.popper, arrowElement)) {
    if (true) {
      console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', 'element.'].join(' '));
    }

    return;
  }

  state.elements.arrow = arrowElement;
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'arrow',
  enabled: true,
  phase: 'main',
  fn: arrow,
  effect: effect,
  requires: ['popperOffsets'],
  requiresIfExists: ['preventOverflow']
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/computeStyles.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/computeStyles.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "mapToStyles": () => (/* binding */ mapToStyles),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom-utils/getOffsetParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom-utils/getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
/* harmony import */ var _dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../dom-utils/getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../dom-utils/getComputedStyle.js */ "./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js");
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _utils_getVariation_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/getVariation.js */ "./node_modules/@popperjs/core/lib/utils/getVariation.js");
/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");







 // eslint-disable-next-line import/no-unused-modules

var unsetSides = {
  top: 'auto',
  right: 'auto',
  bottom: 'auto',
  left: 'auto'
}; // Round the offsets to the nearest suitable subpixel based on the DPR.
// Zooming can change the DPR, but it seems to report a value that will
// cleanly divide the values into the appropriate subpixels.

function roundOffsetsByDPR(_ref) {
  var x = _ref.x,
      y = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_0__.round)(x * dpr) / dpr || 0,
    y: (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_0__.round)(y * dpr) / dpr || 0
  };
}

function mapToStyles(_ref2) {
  var _Object$assign2;

  var popper = _ref2.popper,
      popperRect = _ref2.popperRect,
      placement = _ref2.placement,
      variation = _ref2.variation,
      offsets = _ref2.offsets,
      position = _ref2.position,
      gpuAcceleration = _ref2.gpuAcceleration,
      adaptive = _ref2.adaptive,
      roundOffsets = _ref2.roundOffsets,
      isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x,
      x = _offsets$x === void 0 ? 0 : _offsets$x,
      _offsets$y = offsets.y,
      y = _offsets$y === void 0 ? 0 : _offsets$y;

  var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({
    x: x,
    y: y
  }) : {
    x: x,
    y: y
  };

  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty('x');
  var hasY = offsets.hasOwnProperty('y');
  var sideX = _enums_js__WEBPACK_IMPORTED_MODULE_1__.left;
  var sideY = _enums_js__WEBPACK_IMPORTED_MODULE_1__.top;
  var win = window;

  if (adaptive) {
    var offsetParent = (0,_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_2__["default"])(popper);
    var heightProp = 'clientHeight';
    var widthProp = 'clientWidth';

    if (offsetParent === (0,_dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_3__["default"])(popper)) {
      offsetParent = (0,_dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_4__["default"])(popper);

      if ((0,_dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_5__["default"])(offsetParent).position !== 'static' && position === 'absolute') {
        heightProp = 'scrollHeight';
        widthProp = 'scrollWidth';
      }
    } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it


    offsetParent = offsetParent;

    if (placement === _enums_js__WEBPACK_IMPORTED_MODULE_1__.top || (placement === _enums_js__WEBPACK_IMPORTED_MODULE_1__.left || placement === _enums_js__WEBPACK_IMPORTED_MODULE_1__.right) && variation === _enums_js__WEBPACK_IMPORTED_MODULE_1__.end) {
      sideY = _enums_js__WEBPACK_IMPORTED_MODULE_1__.bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : // $FlowFixMe[prop-missing]
      offsetParent[heightProp];
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }

    if (placement === _enums_js__WEBPACK_IMPORTED_MODULE_1__.left || (placement === _enums_js__WEBPACK_IMPORTED_MODULE_1__.top || placement === _enums_js__WEBPACK_IMPORTED_MODULE_1__.bottom) && variation === _enums_js__WEBPACK_IMPORTED_MODULE_1__.end) {
      sideX = _enums_js__WEBPACK_IMPORTED_MODULE_1__.right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : // $FlowFixMe[prop-missing]
      offsetParent[widthProp];
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }

  var commonStyles = Object.assign({
    position: position
  }, adaptive && unsetSides);

  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x,
    y: y
  }) : {
    x: x,
    y: y
  };

  x = _ref4.x;
  y = _ref4.y;

  if (gpuAcceleration) {
    var _Object$assign;

    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }

  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
}

function computeStyles(_ref5) {
  var state = _ref5.state,
      options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration,
      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
      _options$adaptive = options.adaptive,
      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
      _options$roundOffsets = options.roundOffsets,
      roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;

  if (true) {
    var transitionProperty = (0,_dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_5__["default"])(state.elements.popper).transitionProperty || '';

    if (adaptive && ['transform', 'top', 'right', 'bottom', 'left'].some(function (property) {
      return transitionProperty.indexOf(property) >= 0;
    })) {
      console.warn(['Popper: Detected CSS transitions on at least one of the following', 'CSS properties: "transform", "top", "right", "bottom", "left".', '\n\n', 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', 'for smooth transitions, or remove these properties from the CSS', 'transition declaration on the popper element if only transitioning', 'opacity or background-color for example.', '\n\n', 'We recommend using the popper element as a wrapper around an inner', 'element that can have any CSS property transitioned for animations.'].join(' '));
    }
  }

  var commonStyles = {
    placement: (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_6__["default"])(state.placement),
    variation: (0,_utils_getVariation_js__WEBPACK_IMPORTED_MODULE_7__["default"])(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration: gpuAcceleration,
    isFixed: state.options.strategy === 'fixed'
  };

  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive: adaptive,
      roundOffsets: roundOffsets
    })));
  }

  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: 'absolute',
      adaptive: false,
      roundOffsets: roundOffsets
    })));
  }

  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-placement': state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'computeStyles',
  enabled: true,
  phase: 'beforeWrite',
  fn: computeStyles,
  data: {}
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/eventListeners.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/eventListeners.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom-utils/getWindow.js */ "./node_modules/@popperjs/core/lib/dom-utils/getWindow.js");
 // eslint-disable-next-line import/no-unused-modules

var passive = {
  passive: true
};

function effect(_ref) {
  var state = _ref.state,
      instance = _ref.instance,
      options = _ref.options;
  var _options$scroll = options.scroll,
      scroll = _options$scroll === void 0 ? true : _options$scroll,
      _options$resize = options.resize,
      resize = _options$resize === void 0 ? true : _options$resize;
  var window = (0,_dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

  if (scroll) {
    scrollParents.forEach(function (scrollParent) {
      scrollParent.addEventListener('scroll', instance.update, passive);
    });
  }

  if (resize) {
    window.addEventListener('resize', instance.update, passive);
  }

  return function () {
    if (scroll) {
      scrollParents.forEach(function (scrollParent) {
        scrollParent.removeEventListener('scroll', instance.update, passive);
      });
    }

    if (resize) {
      window.removeEventListener('resize', instance.update, passive);
    }
  };
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'eventListeners',
  enabled: true,
  phase: 'write',
  fn: function fn() {},
  effect: effect,
  data: {}
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/flip.js":
/*!***********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/flip.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/getOppositePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js");
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _utils_getOppositeVariationPlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/getOppositeVariationPlacement.js */ "./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js");
/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _utils_computeAutoPlacement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/computeAutoPlacement.js */ "./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _utils_getVariation_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/getVariation.js */ "./node_modules/@popperjs/core/lib/utils/getVariation.js");






 // eslint-disable-next-line import/no-unused-modules

function getExpandedFallbackPlacements(placement) {
  if ((0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement) === _enums_js__WEBPACK_IMPORTED_MODULE_1__.auto) {
    return [];
  }

  var oppositePlacement = (0,_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(placement);
  return [(0,_utils_getOppositeVariationPlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(placement), oppositePlacement, (0,_utils_getOppositeVariationPlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(oppositePlacement)];
}

function flip(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;

  if (state.modifiersData[name]._skip) {
    return;
  }

  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
      specifiedFallbackPlacements = options.fallbackPlacements,
      padding = options.padding,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      _options$flipVariatio = options.flipVariations,
      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
      allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [(0,_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
    return acc.concat((0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement) === _enums_js__WEBPACK_IMPORTED_MODULE_1__.auto ? (0,_utils_computeAutoPlacement_js__WEBPACK_IMPORTED_MODULE_4__["default"])(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding,
      flipVariations: flipVariations,
      allowedAutoPlacements: allowedAutoPlacements
    }) : placement);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements[0];

  for (var i = 0; i < placements.length; i++) {
    var placement = placements[i];

    var _basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement);

    var isStartVariation = (0,_utils_getVariation_js__WEBPACK_IMPORTED_MODULE_5__["default"])(placement) === _enums_js__WEBPACK_IMPORTED_MODULE_1__.start;
    var isVertical = [_enums_js__WEBPACK_IMPORTED_MODULE_1__.top, _enums_js__WEBPACK_IMPORTED_MODULE_1__.bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? 'width' : 'height';
    var overflow = (0,_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_6__["default"])(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      altBoundary: altBoundary,
      padding: padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? _enums_js__WEBPACK_IMPORTED_MODULE_1__.right : _enums_js__WEBPACK_IMPORTED_MODULE_1__.left : isStartVariation ? _enums_js__WEBPACK_IMPORTED_MODULE_1__.bottom : _enums_js__WEBPACK_IMPORTED_MODULE_1__.top;

    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = (0,_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(mainVariationSide);
    }

    var altVariationSide = (0,_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__["default"])(mainVariationSide);
    var checks = [];

    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }

    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }

    if (checks.every(function (check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }

    checksMap.set(placement, checks);
  }

  if (makeFallbackChecks) {
    // `2` may be desired in some cases â€“ research later
    var numberOfChecks = flipVariations ? 3 : 1;

    var _loop = function _loop(_i) {
      var fittingPlacement = placements.find(function (placement) {
        var checks = checksMap.get(placement);

        if (checks) {
          return checks.slice(0, _i).every(function (check) {
            return check;
          });
        }
      });

      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };

    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);

      if (_ret === "break") break;
    }
  }

  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'flip',
  enabled: true,
  phase: 'main',
  fn: flip,
  requiresIfExists: ['offset'],
  data: {
    _skip: false
  }
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/hide.js":
/*!***********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/hide.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");



function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }

  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}

function isAnySideFullyClipped(overflow) {
  return [_enums_js__WEBPACK_IMPORTED_MODULE_0__.top, _enums_js__WEBPACK_IMPORTED_MODULE_0__.right, _enums_js__WEBPACK_IMPORTED_MODULE_0__.bottom, _enums_js__WEBPACK_IMPORTED_MODULE_0__.left].some(function (side) {
    return overflow[side] >= 0;
  });
}

function hide(_ref) {
  var state = _ref.state,
      name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = (0,_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_1__["default"])(state, {
    elementContext: 'reference'
  });
  var popperAltOverflow = (0,_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_1__["default"])(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets: referenceClippingOffsets,
    popperEscapeOffsets: popperEscapeOffsets,
    isReferenceHidden: isReferenceHidden,
    hasPopperEscaped: hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    'data-popper-reference-hidden': isReferenceHidden,
    'data-popper-escaped': hasPopperEscaped
  });
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'hide',
  enabled: true,
  phase: 'main',
  requiresIfExists: ['preventOverflow'],
  fn: hide
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "applyStyles": () => (/* reexport safe */ _applyStyles_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "arrow": () => (/* reexport safe */ _arrow_js__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   "computeStyles": () => (/* reexport safe */ _computeStyles_js__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   "eventListeners": () => (/* reexport safe */ _eventListeners_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   "flip": () => (/* reexport safe */ _flip_js__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   "hide": () => (/* reexport safe */ _hide_js__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   "offset": () => (/* reexport safe */ _offset_js__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   "popperOffsets": () => (/* reexport safe */ _popperOffsets_js__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   "preventOverflow": () => (/* reexport safe */ _preventOverflow_js__WEBPACK_IMPORTED_MODULE_8__["default"])
/* harmony export */ });
/* harmony import */ var _applyStyles_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./applyStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/applyStyles.js");
/* harmony import */ var _arrow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./arrow.js */ "./node_modules/@popperjs/core/lib/modifiers/arrow.js");
/* harmony import */ var _computeStyles_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./computeStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/computeStyles.js");
/* harmony import */ var _eventListeners_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./eventListeners.js */ "./node_modules/@popperjs/core/lib/modifiers/eventListeners.js");
/* harmony import */ var _flip_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./flip.js */ "./node_modules/@popperjs/core/lib/modifiers/flip.js");
/* harmony import */ var _hide_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./hide.js */ "./node_modules/@popperjs/core/lib/modifiers/hide.js");
/* harmony import */ var _offset_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./offset.js */ "./node_modules/@popperjs/core/lib/modifiers/offset.js");
/* harmony import */ var _popperOffsets_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./popperOffsets.js */ "./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js");
/* harmony import */ var _preventOverflow_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./preventOverflow.js */ "./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js");










/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/offset.js":
/*!*************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/offset.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "distanceAndSkiddingToXY": () => (/* binding */ distanceAndSkiddingToXY),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");

 // eslint-disable-next-line import/no-unused-modules

function distanceAndSkiddingToXY(placement, rects, offset) {
  var basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement);
  var invertDistance = [_enums_js__WEBPACK_IMPORTED_MODULE_1__.left, _enums_js__WEBPACK_IMPORTED_MODULE_1__.top].indexOf(basePlacement) >= 0 ? -1 : 1;

  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
    placement: placement
  })) : offset,
      skidding = _ref[0],
      distance = _ref[1];

  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [_enums_js__WEBPACK_IMPORTED_MODULE_1__.left, _enums_js__WEBPACK_IMPORTED_MODULE_1__.right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}

function offset(_ref2) {
  var state = _ref2.state,
      options = _ref2.options,
      name = _ref2.name;
  var _options$offset = options.offset,
      offset = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = _enums_js__WEBPACK_IMPORTED_MODULE_1__.placements.reduce(function (acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement],
      x = _data$state$placement.x,
      y = _data$state$placement.y;

  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'offset',
  enabled: true,
  phase: 'main',
  requires: ['popperOffsets'],
  fn: offset
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_computeOffsets_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/computeOffsets.js */ "./node_modules/@popperjs/core/lib/utils/computeOffsets.js");


function popperOffsets(_ref) {
  var state = _ref.state,
      name = _ref.name;
  // Offsets are the actual position the popper needs to have to be
  // properly positioned near its reference element
  // This is the most basic placement, and will be adjusted by
  // the modifiers in the next step
  state.modifiersData[name] = (0,_utils_computeOffsets_js__WEBPACK_IMPORTED_MODULE_0__["default"])({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: 'absolute',
    placement: state.placement
  });
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'popperOffsets',
  enabled: true,
  phase: 'read',
  fn: popperOffsets,
  data: {}
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/getMainAxisFromPlacement.js */ "./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js");
/* harmony import */ var _utils_getAltAxis_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/getAltAxis.js */ "./node_modules/@popperjs/core/lib/utils/getAltAxis.js");
/* harmony import */ var _utils_within_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/within.js */ "./node_modules/@popperjs/core/lib/utils/within.js");
/* harmony import */ var _dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dom-utils/getLayoutRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js");
/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../dom-utils/getOffsetParent.js */ "./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js");
/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _utils_getVariation_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/getVariation.js */ "./node_modules/@popperjs/core/lib/utils/getVariation.js");
/* harmony import */ var _utils_getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/getFreshSideObject.js */ "./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js");
/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../utils/math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");












function preventOverflow(_ref) {
  var state = _ref.state,
      options = _ref.options,
      name = _ref.name;
  var _options$mainAxis = options.mainAxis,
      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
      _options$altAxis = options.altAxis,
      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
      boundary = options.boundary,
      rootBoundary = options.rootBoundary,
      altBoundary = options.altBoundary,
      padding = options.padding,
      _options$tether = options.tether,
      tether = _options$tether === void 0 ? true : _options$tether,
      _options$tetherOffset = options.tetherOffset,
      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = (0,_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_0__["default"])(state, {
    boundary: boundary,
    rootBoundary: rootBoundary,
    padding: padding,
    altBoundary: altBoundary
  });
  var basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__["default"])(state.placement);
  var variation = (0,_utils_getVariation_js__WEBPACK_IMPORTED_MODULE_2__["default"])(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = (0,_utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(basePlacement);
  var altAxis = (0,_utils_getAltAxis_js__WEBPACK_IMPORTED_MODULE_4__["default"])(mainAxis);
  var popperOffsets = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };

  if (!popperOffsets) {
    return;
  }

  if (checkMainAxis) {
    var _offsetModifierState$;

    var mainSide = mainAxis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.top : _enums_js__WEBPACK_IMPORTED_MODULE_5__.left;
    var altSide = mainAxis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.bottom : _enums_js__WEBPACK_IMPORTED_MODULE_5__.right;
    var len = mainAxis === 'y' ? 'height' : 'width';
    var offset = popperOffsets[mainAxis];
    var min = offset + overflow[mainSide];
    var max = offset - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === _enums_js__WEBPACK_IMPORTED_MODULE_5__.start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === _enums_js__WEBPACK_IMPORTED_MODULE_5__.start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
    // outside the reference bounds

    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? (0,_dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_6__["default"])(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : (0,_utils_getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_7__["default"])();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
    // to include its full size in the calculation. If the reference is small
    // and near the edge of a boundary, the popper can overflow even if the
    // reference is not overflowing as well (e.g. virtual elements with no
    // width or height)

    var arrowLen = (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_8__.within)(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && (0,_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_9__["default"])(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset + maxOffset - offsetModifierValue;
    var preventedOffset = (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_8__.within)(tether ? (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_10__.min)(min, tetherMin) : min, offset, tether ? (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_10__.max)(max, tetherMax) : max);
    popperOffsets[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset;
  }

  if (checkAltAxis) {
    var _offsetModifierState$2;

    var _mainSide = mainAxis === 'x' ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.top : _enums_js__WEBPACK_IMPORTED_MODULE_5__.left;

    var _altSide = mainAxis === 'x' ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.bottom : _enums_js__WEBPACK_IMPORTED_MODULE_5__.right;

    var _offset = popperOffsets[altAxis];

    var _len = altAxis === 'y' ? 'height' : 'width';

    var _min = _offset + overflow[_mainSide];

    var _max = _offset - overflow[_altSide];

    var isOriginSide = [_enums_js__WEBPACK_IMPORTED_MODULE_5__.top, _enums_js__WEBPACK_IMPORTED_MODULE_5__.left].indexOf(basePlacement) !== -1;

    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;

    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;

    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;

    var _preventedOffset = tether && isOriginSide ? (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_8__.withinMaxClamp)(_tetherMin, _offset, _tetherMax) : (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_8__.within)(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);

    popperOffsets[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }

  state.modifiersData[name] = data;
} // eslint-disable-next-line import/no-unused-modules


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  name: 'preventOverflow',
  enabled: true,
  phase: 'main',
  fn: preventOverflow,
  requiresIfExists: ['offset']
});

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/popper-lite.js":
/*!********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/popper-lite.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createPopper": () => (/* binding */ createPopper),
/* harmony export */   "popperGenerator": () => (/* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_4__.popperGenerator),
/* harmony export */   "defaultModifiers": () => (/* binding */ defaultModifiers),
/* harmony export */   "detectOverflow": () => (/* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_5__["default"])
/* harmony export */ });
/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./createPopper.js */ "./node_modules/@popperjs/core/lib/createPopper.js");
/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./createPopper.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modifiers/eventListeners.js */ "./node_modules/@popperjs/core/lib/modifiers/eventListeners.js");
/* harmony import */ var _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modifiers/popperOffsets.js */ "./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js");
/* harmony import */ var _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modifiers/computeStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/computeStyles.js");
/* harmony import */ var _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modifiers/applyStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/applyStyles.js");





var defaultModifiers = [_modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_0__["default"], _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_1__["default"], _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_2__["default"], _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_3__["default"]];
var createPopper = /*#__PURE__*/(0,_createPopper_js__WEBPACK_IMPORTED_MODULE_4__.popperGenerator)({
  defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules



/***/ }),

/***/ "./node_modules/@popperjs/core/lib/popper.js":
/*!***************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/popper.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createPopper": () => (/* binding */ createPopper),
/* harmony export */   "popperGenerator": () => (/* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_9__.popperGenerator),
/* harmony export */   "defaultModifiers": () => (/* binding */ defaultModifiers),
/* harmony export */   "detectOverflow": () => (/* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_10__["default"]),
/* harmony export */   "createPopperLite": () => (/* reexport safe */ _popper_lite_js__WEBPACK_IMPORTED_MODULE_11__.createPopper),
/* harmony export */   "applyStyles": () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.applyStyles),
/* harmony export */   "arrow": () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.arrow),
/* harmony export */   "computeStyles": () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.computeStyles),
/* harmony export */   "eventListeners": () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.eventListeners),
/* harmony export */   "flip": () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.flip),
/* harmony export */   "hide": () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.hide),
/* harmony export */   "offset": () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.offset),
/* harmony export */   "popperOffsets": () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.popperOffsets),
/* harmony export */   "preventOverflow": () => (/* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.preventOverflow)
/* harmony export */ });
/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./createPopper.js */ "./node_modules/@popperjs/core/lib/createPopper.js");
/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./createPopper.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modifiers/eventListeners.js */ "./node_modules/@popperjs/core/lib/modifiers/eventListeners.js");
/* harmony import */ var _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modifiers/popperOffsets.js */ "./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js");
/* harmony import */ var _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modifiers/computeStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/computeStyles.js");
/* harmony import */ var _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modifiers/applyStyles.js */ "./node_modules/@popperjs/core/lib/modifiers/applyStyles.js");
/* harmony import */ var _modifiers_offset_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modifiers/offset.js */ "./node_modules/@popperjs/core/lib/modifiers/offset.js");
/* harmony import */ var _modifiers_flip_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modifiers/flip.js */ "./node_modules/@popperjs/core/lib/modifiers/flip.js");
/* harmony import */ var _modifiers_preventOverflow_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modifiers/preventOverflow.js */ "./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js");
/* harmony import */ var _modifiers_arrow_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./modifiers/arrow.js */ "./node_modules/@popperjs/core/lib/modifiers/arrow.js");
/* harmony import */ var _modifiers_hide_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./modifiers/hide.js */ "./node_modules/@popperjs/core/lib/modifiers/hide.js");
/* harmony import */ var _popper_lite_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./popper-lite.js */ "./node_modules/@popperjs/core/lib/popper-lite.js");
/* harmony import */ var _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./modifiers/index.js */ "./node_modules/@popperjs/core/lib/modifiers/index.js");










var defaultModifiers = [_modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_0__["default"], _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_1__["default"], _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_2__["default"], _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_3__["default"], _modifiers_offset_js__WEBPACK_IMPORTED_MODULE_4__["default"], _modifiers_flip_js__WEBPACK_IMPORTED_MODULE_5__["default"], _modifiers_preventOverflow_js__WEBPACK_IMPORTED_MODULE_6__["default"], _modifiers_arrow_js__WEBPACK_IMPORTED_MODULE_7__["default"], _modifiers_hide_js__WEBPACK_IMPORTED_MODULE_8__["default"]];
var createPopper = /*#__PURE__*/(0,_createPopper_js__WEBPACK_IMPORTED_MODULE_9__.popperGenerator)({
  defaultModifiers: defaultModifiers
}); // eslint-disable-next-line import/no-unused-modules

 // eslint-disable-next-line import/no-unused-modules

 // eslint-disable-next-line import/no-unused-modules



/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ computeAutoPlacement)
/* harmony export */ });
/* harmony import */ var _getVariation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getVariation.js */ "./node_modules/@popperjs/core/lib/utils/getVariation.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _detectOverflow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./detectOverflow.js */ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js");
/* harmony import */ var _getBasePlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");




function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      placement = _options.placement,
      boundary = _options.boundary,
      rootBoundary = _options.rootBoundary,
      padding = _options.padding,
      flipVariations = _options.flipVariations,
      _options$allowedAutoP = _options.allowedAutoPlacements,
      allowedAutoPlacements = _options$allowedAutoP === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.placements : _options$allowedAutoP;
  var variation = (0,_getVariation_js__WEBPACK_IMPORTED_MODULE_1__["default"])(placement);
  var placements = variation ? flipVariations ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.variationPlacements : _enums_js__WEBPACK_IMPORTED_MODULE_0__.variationPlacements.filter(function (placement) {
    return (0,_getVariation_js__WEBPACK_IMPORTED_MODULE_1__["default"])(placement) === variation;
  }) : _enums_js__WEBPACK_IMPORTED_MODULE_0__.basePlacements;
  var allowedPlacements = placements.filter(function (placement) {
    return allowedAutoPlacements.indexOf(placement) >= 0;
  });

  if (allowedPlacements.length === 0) {
    allowedPlacements = placements;

    if (true) {
      console.error(['Popper: The `allowedAutoPlacements` option did not allow any', 'placements. Ensure the `placement` option matches the variation', 'of the allowed placements.', 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(' '));
    }
  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...


  var overflows = allowedPlacements.reduce(function (acc, placement) {
    acc[placement] = (0,_detectOverflow_js__WEBPACK_IMPORTED_MODULE_2__["default"])(state, {
      placement: placement,
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding
    })[(0,_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(placement)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function (a, b) {
    return overflows[a] - overflows[b];
  });
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/computeOffsets.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/computeOffsets.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ computeOffsets)
/* harmony export */ });
/* harmony import */ var _getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBasePlacement.js */ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js");
/* harmony import */ var _getVariation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getVariation.js */ "./node_modules/@popperjs/core/lib/utils/getVariation.js");
/* harmony import */ var _getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getMainAxisFromPlacement.js */ "./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");




function computeOffsets(_ref) {
  var reference = _ref.reference,
      element = _ref.element,
      placement = _ref.placement;
  var basePlacement = placement ? (0,_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__["default"])(placement) : null;
  var variation = placement ? (0,_getVariation_js__WEBPACK_IMPORTED_MODULE_1__["default"])(placement) : null;
  var commonX = reference.x + reference.width / 2 - element.width / 2;
  var commonY = reference.y + reference.height / 2 - element.height / 2;
  var offsets;

  switch (basePlacement) {
    case _enums_js__WEBPACK_IMPORTED_MODULE_2__.top:
      offsets = {
        x: commonX,
        y: reference.y - element.height
      };
      break;

    case _enums_js__WEBPACK_IMPORTED_MODULE_2__.bottom:
      offsets = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;

    case _enums_js__WEBPACK_IMPORTED_MODULE_2__.right:
      offsets = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;

    case _enums_js__WEBPACK_IMPORTED_MODULE_2__.left:
      offsets = {
        x: reference.x - element.width,
        y: commonY
      };
      break;

    default:
      offsets = {
        x: reference.x,
        y: reference.y
      };
  }

  var mainAxis = basePlacement ? (0,_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_3__["default"])(basePlacement) : null;

  if (mainAxis != null) {
    var len = mainAxis === 'y' ? 'height' : 'width';

    switch (variation) {
      case _enums_js__WEBPACK_IMPORTED_MODULE_2__.start:
        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
        break;

      case _enums_js__WEBPACK_IMPORTED_MODULE_2__.end:
        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
        break;

      default:
    }
  }

  return offsets;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/debounce.js":
/*!***********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/debounce.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ debounce)
/* harmony export */ });
function debounce(fn) {
  var pending;
  return function () {
    if (!pending) {
      pending = new Promise(function (resolve) {
        Promise.resolve().then(function () {
          pending = undefined;
          resolve(fn());
        });
      });
    }

    return pending;
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/detectOverflow.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/detectOverflow.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ detectOverflow)
/* harmony export */ });
/* harmony import */ var _dom_utils_getClippingRect_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom-utils/getClippingRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js");
/* harmony import */ var _dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../dom-utils/getDocumentElement.js */ "./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js");
/* harmony import */ var _dom_utils_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dom-utils/getBoundingClientRect.js */ "./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js");
/* harmony import */ var _computeOffsets_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./computeOffsets.js */ "./node_modules/@popperjs/core/lib/utils/computeOffsets.js");
/* harmony import */ var _rectToClientRect_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./rectToClientRect.js */ "./node_modules/@popperjs/core/lib/utils/rectToClientRect.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../dom-utils/instanceOf.js */ "./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js");
/* harmony import */ var _mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mergePaddingObject.js */ "./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js");
/* harmony import */ var _expandToHashMap_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./expandToHashMap.js */ "./node_modules/@popperjs/core/lib/utils/expandToHashMap.js");








 // eslint-disable-next-line import/no-unused-modules

function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      _options$placement = _options.placement,
      placement = _options$placement === void 0 ? state.placement : _options$placement,
      _options$boundary = _options.boundary,
      boundary = _options$boundary === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.clippingParents : _options$boundary,
      _options$rootBoundary = _options.rootBoundary,
      rootBoundary = _options$rootBoundary === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.viewport : _options$rootBoundary,
      _options$elementConte = _options.elementContext,
      elementContext = _options$elementConte === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper : _options$elementConte,
      _options$altBoundary = _options.altBoundary,
      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
      _options$padding = _options.padding,
      padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = (0,_mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_1__["default"])(typeof padding !== 'number' ? padding : (0,_expandToHashMap_js__WEBPACK_IMPORTED_MODULE_2__["default"])(padding, _enums_js__WEBPACK_IMPORTED_MODULE_0__.basePlacements));
  var altContext = elementContext === _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.reference : _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = (0,_dom_utils_getClippingRect_js__WEBPACK_IMPORTED_MODULE_3__["default"])((0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__.isElement)(element) ? element : element.contextElement || (0,_dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_5__["default"])(state.elements.popper), boundary, rootBoundary);
  var referenceClientRect = (0,_dom_utils_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_6__["default"])(state.elements.reference);
  var popperOffsets = (0,_computeOffsets_js__WEBPACK_IMPORTED_MODULE_7__["default"])({
    reference: referenceClientRect,
    element: popperRect,
    strategy: 'absolute',
    placement: placement
  });
  var popperClientRect = (0,_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_8__["default"])(Object.assign({}, popperRect, popperOffsets));
  var elementClientRect = elementContext === _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
  // 0 or negative = within the clipping rect

  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

  if (elementContext === _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper && offsetData) {
    var offset = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function (key) {
      var multiply = [_enums_js__WEBPACK_IMPORTED_MODULE_0__.right, _enums_js__WEBPACK_IMPORTED_MODULE_0__.bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [_enums_js__WEBPACK_IMPORTED_MODULE_0__.top, _enums_js__WEBPACK_IMPORTED_MODULE_0__.bottom].indexOf(key) >= 0 ? 'y' : 'x';
      overflowOffsets[key] += offset[axis] * multiply;
    });
  }

  return overflowOffsets;
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/expandToHashMap.js":
/*!******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/expandToHashMap.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ expandToHashMap)
/* harmony export */ });
function expandToHashMap(value, keys) {
  return keys.reduce(function (hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/format.js":
/*!*********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/format.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ format)
/* harmony export */ });
function format(str) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return [].concat(args).reduce(function (p, c) {
    return p.replace(/%s/, c);
  }, str);
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getAltAxis.js":
/*!*************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getAltAxis.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getAltAxis)
/* harmony export */ });
function getAltAxis(axis) {
  return axis === 'x' ? 'y' : 'x';
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getBasePlacement.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getBasePlacement.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getBasePlacement)
/* harmony export */ });

function getBasePlacement(placement) {
  return placement.split('-')[0];
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getFreshSideObject)
/* harmony export */ });
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getMainAxisFromPlacement)
/* harmony export */ });
function getMainAxisFromPlacement(placement) {
  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getOppositePlacement)
/* harmony export */ });
var hash = {
  left: 'right',
  right: 'left',
  bottom: 'top',
  top: 'bottom'
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getOppositeVariationPlacement)
/* harmony export */ });
var hash = {
  start: 'end',
  end: 'start'
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function (matched) {
    return hash[matched];
  });
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/getVariation.js":
/*!***************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getVariation.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getVariation)
/* harmony export */ });
function getVariation(placement) {
  return placement.split('-')[1];
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/math.js":
/*!*******************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/math.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "max": () => (/* binding */ max),
/* harmony export */   "min": () => (/* binding */ min),
/* harmony export */   "round": () => (/* binding */ round)
/* harmony export */ });
var max = Math.max;
var min = Math.min;
var round = Math.round;

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/mergeByName.js":
/*!**************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/mergeByName.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ mergeByName)
/* harmony export */ });
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function (merged, current) {
    var existing = merged[current.name];
    merged[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged;
  }, {}); // IE11 does not support Object.values

  return Object.keys(merged).map(function (key) {
    return merged[key];
  });
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ mergePaddingObject)
/* harmony export */ });
/* harmony import */ var _getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getFreshSideObject.js */ "./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js");

function mergePaddingObject(paddingObject) {
  return Object.assign({}, (0,_getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_0__["default"])(), paddingObject);
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/orderModifiers.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/orderModifiers.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ orderModifiers)
/* harmony export */ });
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");
 // source: https://stackoverflow.com/questions/49875255

function order(modifiers) {
  var map = new Map();
  var visited = new Set();
  var result = [];
  modifiers.forEach(function (modifier) {
    map.set(modifier.name, modifier);
  }); // On visiting object, check for its dependencies and visit them recursively

  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function (dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);

        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }

  modifiers.forEach(function (modifier) {
    if (!visited.has(modifier.name)) {
      // check for visited object
      sort(modifier);
    }
  });
  return result;
}

function orderModifiers(modifiers) {
  // order based on dependencies
  var orderedModifiers = order(modifiers); // order based on phase

  return _enums_js__WEBPACK_IMPORTED_MODULE_0__.modifierPhases.reduce(function (acc, phase) {
    return acc.concat(orderedModifiers.filter(function (modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/rectToClientRect.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/rectToClientRect.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ rectToClientRect)
/* harmony export */ });
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/uniqueBy.js":
/*!***********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/uniqueBy.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ uniqueBy)
/* harmony export */ });
function uniqueBy(arr, fn) {
  var identifiers = new Set();
  return arr.filter(function (item) {
    var identifier = fn(item);

    if (!identifiers.has(identifier)) {
      identifiers.add(identifier);
      return true;
    }
  });
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/validateModifiers.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/validateModifiers.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ validateModifiers)
/* harmony export */ });
/* harmony import */ var _format_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./format.js */ "./node_modules/@popperjs/core/lib/utils/format.js");
/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ "./node_modules/@popperjs/core/lib/enums.js");


var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
var VALID_PROPERTIES = ['name', 'enabled', 'phase', 'fn', 'effect', 'requires', 'options'];
function validateModifiers(modifiers) {
  modifiers.forEach(function (modifier) {
    [].concat(Object.keys(modifier), VALID_PROPERTIES) // IE11-compatible replacement for `new Set(iterable)`
    .filter(function (value, index, self) {
      return self.indexOf(value) === index;
    }).forEach(function (key) {
      switch (key) {
        case 'name':
          if (typeof modifier.name !== 'string') {
            console.error((0,_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', "\"" + String(modifier.name) + "\""));
          }

          break;

        case 'enabled':
          if (typeof modifier.enabled !== 'boolean') {
            console.error((0,_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', "\"" + String(modifier.enabled) + "\""));
          }

          break;

        case 'phase':
          if (_enums_js__WEBPACK_IMPORTED_MODULE_1__.modifierPhases.indexOf(modifier.phase) < 0) {
            console.error((0,_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + _enums_js__WEBPACK_IMPORTED_MODULE_1__.modifierPhases.join(', '), "\"" + String(modifier.phase) + "\""));
          }

          break;

        case 'fn':
          if (typeof modifier.fn !== 'function') {
            console.error((0,_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', "\"" + String(modifier.fn) + "\""));
          }

          break;

        case 'effect':
          if (modifier.effect != null && typeof modifier.effect !== 'function') {
            console.error((0,_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', "\"" + String(modifier.fn) + "\""));
          }

          break;

        case 'requires':
          if (modifier.requires != null && !Array.isArray(modifier.requires)) {
            console.error((0,_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', "\"" + String(modifier.requires) + "\""));
          }

          break;

        case 'requiresIfExists':
          if (!Array.isArray(modifier.requiresIfExists)) {
            console.error((0,_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', "\"" + String(modifier.requiresIfExists) + "\""));
          }

          break;

        case 'options':
        case 'data':
          break;

        default:
          console.error("PopperJS: an invalid property has been provided to the \"" + modifier.name + "\" modifier, valid properties are " + VALID_PROPERTIES.map(function (s) {
            return "\"" + s + "\"";
          }).join(', ') + "; but \"" + key + "\" was provided.");
      }

      modifier.requires && modifier.requires.forEach(function (requirement) {
        if (modifiers.find(function (mod) {
          return mod.name === requirement;
        }) == null) {
          console.error((0,_format_js__WEBPACK_IMPORTED_MODULE_0__["default"])(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
        }
      });
    });
  });
}

/***/ }),

/***/ "./node_modules/@popperjs/core/lib/utils/within.js":
/*!*********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/within.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "within": () => (/* binding */ within),
/* harmony export */   "withinMaxClamp": () => (/* binding */ withinMaxClamp)
/* harmony export */ });
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/@popperjs/core/lib/utils/math.js");

function within(min, value, max) {
  return (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.max)(min, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(value, max));
}
function withinMaxClamp(min, value, max) {
  var v = within(min, value, max);
  return v > max ? max : v;
}

/***/ }),

/***/ "./src/morse-pro/morse-pro-cw-wave.js":
/*!********************************************!*\
  !*** ./src/morse-pro/morse-pro-cw-wave.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MorseCWWave)
/* harmony export */ });
/* harmony import */ var _morse_pro_cw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./morse-pro-cw */ "./src/morse-pro/morse-pro-cw.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/*!
This code is Â© Copyright Stephen C. Phillips, 2018.
Email: steve@scphillips.com
*/

/*
Licensed under the EUPL, Version 1.2 or â€“ as soon they will be approved by the European Commission - subsequent versions of the EUPL (the "Licence");
You may not use this work except in compliance with the Licence.
You may obtain a copy of the Licence at: https://joinup.ec.europa.eu/community/eupl/
Unless required by applicable law or agreed to in writing, software distributed under the Licence is distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the Licence for the specific language governing permissions and limitations under the Licence.
*/

/**
 * Class to create sine-wave samples of standard CW Morse.
 *
 * @example
 * import MorseCWWave from 'morse-pro-cw-wave';
 * var morseCWWave = new MorseCWWave();
 * morseCWWave.translate("abc");
 * var sample = morseCWWave.getSample();
 */

var MorseCWWave = /*#__PURE__*/function (_MorseCW) {
  _inherits(MorseCWWave, _MorseCW);

  var _super = _createSuper(MorseCWWave);

  /**
   * @param {number} [frequency=550] - frequency of wave in Hz
   * @param {number} [sampleRate=8000] - sample rate for the waveform in Hz
   */
  function MorseCWWave(useProsigns, wpm, fwpm) {
    var _this;

    var frequency = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 550;
    var sampleRate = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 8000;

    _classCallCheck(this, MorseCWWave);

    _this = _super.call(this, useProsigns, wpm, fwpm);
    /** @type {number} */

    _this.singleFrequency = typeof frequency.dit == "undefined";
    _this.frequency = frequency; // frequency of wave in Hz

    /** @type {number} */

    _this.sampleRate = sampleRate; // sample rate for the waveform in Hz

    return _this;
  }
  /**
   * Get a sample waveform, not using Web Audio API (synchronous).
   * @param {number} [endPadding=0] - how much silence in ms to add to the end of the waveform.
   * @return {number[]} an array of floats in range [-1, 1] representing the wave-form.
   */


  _createClass(MorseCWWave, [{
    key: "getSample",
    value: function getSample() {
      var endPadding = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var prePadding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return MorseCWWave.getSampleGeneral(this.getTimings(true), this.frequency, this.sampleRate, endPadding, prePadding);
    }
    /**
     * Get a sample waveform, not using Web Audio API (synchronous).
     * @param {number[]} timings - millisecond timings, +ve numbers representing sound, -ve for no sound (+ve/-ve can be in any order)
     * @param {number} frequency - frequency of sound in Hz.
     * @param {number} sampleRate - sample rate in Hz.
     * @param {number} [endPadding=0] - how much silence in ms to add to the end of the waveform.
     * @return {number[]} an array of floats in range [-1, 1] representing the wave-form.
     */

  }, {
    key: "getWAASample",
    value:
    /**
     * Get a sample waveform using Web Audio API (asynchronous).
     * @param {number} [endPadding=0] - how much silence in ms to add to the end of the waveform.
     * @return {Promise(number[])} a Promise resolving to an array of floats in range [-1, 1] representing the wave-form.
     */
    function getWAASample() {
      var endPadding = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      // add minimum of 5ms silence to the end to ensure the filtered signal can finish cleanly
      endPadding = Math.max(5, endPadding);
      var timings = this.getTimings();
      timings.push(-endPadding);
      var offlineAudioContextClass = window.OfflineAudioContext || window.webkitOfflineAudioContext;

      if (offlineAudioContextClass === undefined) {
        throw new Error("No OfflineAudioContext class defined");
      } // buffer length is the Morse duration + 5ms to let the lowpass filter end cleanly


      var offlineCtx = new offlineAudioContextClass(1, this.sampleRate * (this.getDuration() + endPadding) / 1000, this.sampleRate);
      var gainNode = offlineCtx.createGain(); // empirically, the lowpass filter outputs waveform of magnitude 1.23, so need to scale it down to avoid clipping

      gainNode.gain.setValueAtTime(0.813, 0);
      var lowPassNode = offlineCtx.createBiquadFilter();
      lowPassNode.type = "lowpass";
      lowPassNode.frequency.setValueAtTime(this.frequency * 1.1, 0); // TODO: remove this magic number and make the filter configurable?

      gainNode.connect(lowPassNode);
      lowPassNode.connect(offlineCtx.destination);
      var t = 0;
      var oscillator;
      var duration;

      for (var i = 0; i < timings.length; i++) {
        duration = Math.abs(timings[i]) / 1000;

        if (timings[i] > 0) {
          // -ve timings are silence
          oscillator = offlineCtx.createOscillator();
          oscillator.type = 'sine';
          oscillator.frequency.setValueAtTime(this.frequency, t);
          oscillator.start(t);
          oscillator.stop(t + duration);
          oscillator.connect(gainNode);
        }

        t += duration;
      }

      return offlineCtx.startRendering().then(function (renderedBuffer) {
        return renderedBuffer.getChannelData(0);
      });
    }
  }], [{
    key: "getSampleGeneral",
    value: function getSampleGeneral(timings, frequency, sampleRate) {
      var endPadding = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var prePadding = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var sample = [];

      if (timings.length === 0) {
        return [];
      }

      if (prePadding > 0) {
        timings.unshift({
          "time": -1 * prePadding,
          "type": ""
        });
      }

      var noDetails = typeof timings[0].time == "undefined"; // add minimum of 5ms silence to the end to ensure the filtered signal can finish cleanly

      var silenceLength = -Math.max(5, endPadding);
      timings.push(noDetails ? silenceLength : {
        "time": silenceLength,
        "type": ""
      });
      /*
          Compute filtered signal
      */

      var firstLength = noDetails ? timings[0] : timings[0].time;
      var on = firstLength > 0 ? 1 : 0;
      var x0,
          x1 = 0,
          x2 = 0;
      var y0,
          y1 = 0,
          y2 = 0;
      var gain = 0.813; // empirically, the lowpass filter outputs waveform of magnitude 1.23, so need to scale it down to avoid clipping

      for (var t = 0; t < timings.length; t += 1) {
        var duration = sampleRate * Math.abs(noDetails ? timings[t] : timings[t].time) / 1000;

        for (var i = 0; i < duration; i += 1) {
          var ditFrequency = typeof frequency.dit == "undefined" ? frequency : frequency.dit;
          var dahFrequency = typeof frequency.dah == "undefined" ? frequency : frequency.dah;
          var ditStep = Math.PI * 2 * ditFrequency / sampleRate;
          var dahStep = Math.PI * 2 * dahFrequency / sampleRate;
          var stepToUse = ditStep;
          var freqToUse = ditFrequency;

          if (!noDetails && timings[t].type == "dah") {
            stepToUse = dahStep;
            freqToUse = dahFrequency;
          }

          x0 = on * Math.sin(i * stepToUse); // the input signal

          /*
          Compute lowpass biquad filter coefficients using method from Chromium
          */
          // set lowpass frequency cutoff to 1.5 x wave frequency

          var lowpassFreq = freqToUse * 1.5 / sampleRate;
          var q = Math.SQRT1_2;
          var sin = Math.sin(2 * Math.PI * lowpassFreq);
          var cos = Math.cos(2 * Math.PI * lowpassFreq);
          var alpha = sin / (2 * Math.pow(10, q / 20));
          var a0 = 1 + alpha;
          var b0 = (1 - cos) * 0.5 / a0;
          var b1 = (1 - cos) / a0;
          var b2 = (1 - cos) * 0.5 / a0;
          var a1 = -2 * cos / a0;
          var a2 = (1 - alpha) / a0;
          y0 = b0 * x0 + b1 * x1 + b2 * x2 - a1 * y1 - a2 * y2;
          sample.push(y0 * gain);
          x2 = x1;
          x1 = x0;
          y2 = y1;
          y1 = y0;
        }

        on = 1 - on;
      }

      return sample;
    }
  }]);

  return MorseCWWave;
}(_morse_pro_cw__WEBPACK_IMPORTED_MODULE_0__["default"]);



/***/ }),

/***/ "./src/morse-pro/morse-pro-cw.js":
/*!***************************************!*\
  !*** ./src/morse-pro/morse-pro-cw.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MorseCW)
/* harmony export */ });
/* harmony import */ var _morse_pro_wpm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./morse-pro-wpm */ "./src/morse-pro/morse-pro-wpm.js");
/* harmony import */ var _morse_pro_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./morse-pro-message */ "./src/morse-pro/morse-pro-message.js");
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/*!
This code is Â© Copyright Stephen C. Phillips, 2018.
Email: steve@scphillips.com
*/

/*
Licensed under the EUPL, Version 1.2 or â€“ as soon they will be approved by the European Commission - subsequent versions of the EUPL (the "Licence");
You may not use this work except in compliance with the Licence.
You may obtain a copy of the Licence at: https://joinup.ec.europa.eu/community/eupl/
Unless required by applicable law or agreed to in writing, software distributed under the Licence is distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the Licence for the specific language governing permissions and limitations under the Licence.
*/


/**
 * Class to create the on/off timings needed by e.g. sound generators. Timings are in milliseconds; "off" timings are negative.
 *
 * @example
 * import MorseCW from 'morse-pro-cw';
 * var morseCW = new MorseCW();
 * morseCW.translate("abc");
 * var timings = morseCW.getTimings();
 */

var MorseCW = /*#__PURE__*/function (_MorseMessage) {
  _inherits(MorseCW, _MorseMessage);

  var _super = _createSuper(MorseCW);

  /**
   * @param {boolean} [prosigns=true] - whether or not to include prosigns in the translations
   * @param {number} [wpm=20] - the speed in words per minute using PARIS as the standard word
   * @param {number} [fwpm=wpm] - the Farnsworth speed in words per minute (defaults to wpm)
   */
  function MorseCW() {
    var _this;

    var useProsigns = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    var wpm = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 20;
    var fwpm = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : wpm;

    _classCallCheck(this, MorseCW);

    _this = _super.call(this, useProsigns);
    /** @type {number} */

    _this.wpm = wpm;
    /** @type {number} */

    _this.fwpm = fwpm;
    return _this;
  }
  /** 
   * Set the WPM speed. Ensures that Farnsworth WPM is no faster than WPM.
   * @type {number} */


  _createClass(MorseCW, [{
    key: "wpm",
    get:
    /** @type {number} */
    function get() {
      return this._wpm;
    }
    /**
     * Set the Farnsworth WPM speed. Ensures that WPM is no slower than Farnsworth WPM.
     *  @type {number} */
    ,
    set: function set(wpm) {
      this._wpm = wpm;

      if (wpm < this._fwpm) {
        this._fwpm = wpm;
      }
    }
  }, {
    key: "fwpm",
    get:
    /** @type {number} */
    function get() {
      return this._fwpm;
    }
    /** 
     * Get the length of the space between words in ms.
     * @type {number} */
    ,
    set: function set(fwpm) {
      this._fwpm = fwpm;

      if (fwpm > this._wpm) {
        this._wpm = fwpm;
      }
    }
  }, {
    key: "wordSpace",
    get: function get() {
      return _morse_pro_wpm__WEBPACK_IMPORTED_MODULE_0__.wordSpace(this._wpm, this._fwpm);
    }
    /**
     * Return an array of millisecond timings.
     * With the Farnsworth method, the morse characters are played at one
     * speed and the spaces between characters at a slower speed.
     * @return {number[]}
     */

  }, {
    key: "getTimings",
    value: function getTimings(withDetails) {
      return MorseCW.getTimingsGeneral(_morse_pro_wpm__WEBPACK_IMPORTED_MODULE_0__.ditLength(this._wpm), _morse_pro_wpm__WEBPACK_IMPORTED_MODULE_0__.dahLength(this._wpm), _morse_pro_wpm__WEBPACK_IMPORTED_MODULE_0__.ditSpace(this._wpm), _morse_pro_wpm__WEBPACK_IMPORTED_MODULE_0__.charSpace(this._wpm, this._fwpm), _morse_pro_wpm__WEBPACK_IMPORTED_MODULE_0__.wordSpace(this._wpm, this._fwpm), this.morse, withDetails);
    }
    /**
     * Return an array of millisecond timings.
     * Each sound and space has a duration. The durations of the spaces are distinguished by being negative.
     * @param {number} dit - the length of a dit in milliseconds
     * @param {number} dah - the length of a dah in milliseconds (normally 3 * dit)
     * @param {number} ditSpace - the length of an intra-character space in milliseconds (1 * dit)
     * @param {number} charSpace - the length of an inter-character space in milliseconds (normally 3 * dit)
     * @param {number} wordSpace - the length of an inter-word space in milliseconds (normally 7 * dit)
     * @param {string} morse - the (canonical) morse code string (matching [.-/ ]*)
     * @return {number[]}
     */

  }, {
    key: "getDuration",
    value:
    /**
     * Get the total duration of the message in ms
     8 @return {number}
     */
    function getDuration() {
      var times = this.getTimings();
      var t = 0;

      for (var i = 0; i < times.length; i++) {
        t += Math.abs(times[i]);
      }

      return t;
    }
  }], [{
    key: "getTimingsGeneral",
    value: function getTimingsGeneral(dit, dah, ditSpace, charSpace, wordSpace, morse, withDetails) {
      //console.log("Morse: " + morse);
      morse = morse.replace(/ \/ /g, '/'); // this means that a space is only used for inter-character

      morse = morse.replace(/([\.\-])(?=[\.\-])/g, "$1+"); // put a + in between all dits and dahs

      var times = [];

      for (var i = 0; i < morse.length; i++) {
        switch (morse[i]) {
          case '.':
            times.push(dit);
            break;

          case '-':
            times.push(dah);
            break;

          case '+':
            times.push(-ditSpace);
            break;

          case " ":
            times.push(-charSpace);
            break;

          case "/":
            times.push(-wordSpace);
            break;
        }
      } //console.log("Timings: " + times);


      return !withDetails ? times : times.map(function (x) {
        var type = "";

        switch (x) {
          case dit:
            type = "dit";
            break;

          case dah:
            type = "dah";
            break;
        }

        ;
        return {
          "time": x,
          "type": type
        };
      });
    }
  }]);

  return MorseCW;
}(_morse_pro_message__WEBPACK_IMPORTED_MODULE_1__["default"]);



/***/ }),

/***/ "./src/morse-pro/morse-pro-message.js":
/*!********************************************!*\
  !*** ./src/morse-pro/morse-pro-message.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MorseMessage)
/* harmony export */ });
/* harmony import */ var _morse_pro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./morse-pro */ "./src/morse-pro/morse-pro.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

/*!
This code is Â© Copyright Stephen C. Phillips, 2018.
Email: steve@scphillips.com
*/

/*
Licensed under the EUPL, Version 1.2 or â€“ as soon they will be approved by the European Commission - subsequent versions of the EUPL (the "Licence");
You may not use this work except in compliance with the Licence.
You may obtain a copy of the Licence at: https://joinup.ec.europa.eu/community/eupl/
Unless required by applicable law or agreed to in writing, software distributed under the Licence is distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the Licence for the specific language governing permissions and limitations under the Licence.
*/

/**
 * Class for conveniently translating to and from Morse code.
 * Deals with error handling.
 * Works out if the input is Morse code or not.
 *
 * @example
 * import MorseMessage from 'morse-pro-message';
 * var morseMessage = new MorseMessage();
 * var input;
 * var output;
 * try {
 *     output = morseMessage.translate("abc");
 * catch (ex) {
 *     // input will have errors surrounded by paired '#' signs
 *     // output will be best attempt at translation, with untranslatables replaced with '#'
 *     morseMessage.clearError();  // remove all the '#'
 * }
 * if (morseMessage.inputWasMorse) {
 *     // do something
 * }
 */

var MorseMessage = /*#__PURE__*/function () {
  /**
   * @param {boolean} [prosigns=true] - whether or not to include prosigns in the translations
   */
  function MorseMessage() {
    var useProsigns = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

    _classCallCheck(this, MorseMessage);

    this.useProsigns = useProsigns;
    this.input = "";
    this.output = "";
    this.morse = "";
    this.message = "";
    this.inputWasMorse = undefined;
    this.hasError = undefined;
  }
  /**
   * @param {string} input - alphanumeric text or morse code to translate
   * @param {boolean} isMorse - whether the input is Morse code or not (if not set then the looksLikeMorse method will be used)
   */


  _createClass(MorseMessage, [{
    key: "translate",
    value: function translate(input, isMorse) {
      var translation;

      if (typeof isMorse === "undefined") {
        // make a guess: could be wrong if someone wants to translate "." into Morse for instance
        isMorse = _morse_pro__WEBPACK_IMPORTED_MODULE_0__.looksLikeMorse(input);
      }

      if (isMorse) {
        this.inputWasMorse = true;
        translation = _morse_pro__WEBPACK_IMPORTED_MODULE_0__.morse2text(input, this.useProsigns);
      } else {
        this.inputWasMorse = false;
        translation = _morse_pro__WEBPACK_IMPORTED_MODULE_0__.text2morse(input, this.useProsigns);
      }

      this.morse = translation.morse;
      this.message = translation.message;

      if (this.inputWasMorse) {
        this.input = this.morse;
        this.output = this.message;
      } else {
        this.input = this.message;
        this.output = this.morse;
      }

      this.hasError = translation.hasError;

      if (this.hasError) {
        throw new Error("Error in input");
      }

      return this.output;
    }
    /**
     * Clear all the errors from the morse and message. Useful if you want to play the sound even though it didn't translate.
     */

  }, {
    key: "clearError",
    value: function clearError() {
      if (this.inputWasMorse) {
        this.morse = this.morse.replace(/#/g, ""); // leave in the bad Morse
      } else {
        this.message = this.message.replace(/#[^#]*?#/g, "");
        this.morse = this.morse.replace(/#/g, "");
      }

      this.hasError = false;
    }
  }]);

  return MorseMessage;
}();



/***/ }),

/***/ "./src/morse-pro/morse-pro-util-riffwave.js":
/*!**************************************************!*\
  !*** ./src/morse-pro/morse-pro-util-riffwave.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getData": () => (/* binding */ getData),
/* harmony export */   "getMIMEType": () => (/* binding */ getMIMEType)
/* harmony export */ });
/*
* RIFFWAVE adapted from RIFFWAVE.js v0.03 - Audio encoder for HTML5 <audio> elements.
* Copyleft 2011 by Pedro Ladaria <pedro.ladaria at Gmail dot com>
* Public Domain
*/

/*
* Adaptation by Stephen C. Phillips, 2013-2017.
* Email: steve@scphillips.com
* Public Domain
*/

/**
 * Utility to create RIFF WAVE file data.
 *
 * @example
 * import MorseCWWave from 'morse-pro-cw-wave';
 * import * as RiffWave from 'morse-pro-util-riffwave';
 * var morseCWWave = new MorseCWWave();
 * morseCWWave.translate("abc");
 * var wav = RiffWave.getData(morseCWWave.getSample());  // returns byte array of WAV file
  */
var u32ToArray = function u32ToArray(i) {
  return [i & 0xFF, i >> 8 & 0xFF, i >> 16 & 0xFF, i >> 24 & 0xFF];
};

var u16ToArray = function u16ToArray(i) {
  return [i & 0xFF, i >> 8 & 0xFF];
};

var split16bitArray = function split16bitArray(data) {
  var r = [];
  var j = 0;
  var len = data.length;

  for (var i = 0; i < len; i++) {
    r[j++] = data[i] & 0xFF;
    r[j++] = data[i] >> 8 & 0xFF;
  }

  return r;
};

var fToU8 = function fToU8(data) {
  var r = [];

  for (var i = 0; i < data.length; i++) {
    r[i] = Math.max(Math.min(128 + Math.round(127 * data[i]), 255), 0);
  }

  return r;
};
/**
 * Convert PCM data to WAV file data.
 * @param {number[]} data - waveform data, expected to be in (and clamped to) range [-1,1]
 * @param {number} [sampleRate=8000] - the sample rate of the waveform in Hz
 * @param {number} [bitsPerSample=8] - number of bits to store each data point (8 or 16)
 * @return {number[]} - array of bytes representing the WAV file
 */


function getData(data) {
  var sampleRate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8000;
  var bitsPerSample = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 8;
  data = fToU8(data);
  var header = {
    // OFFS SIZE NOTES
    chunkId: [0x52, 0x49, 0x46, 0x46],
    // 0    4    "RIFF" = 0x52494646
    chunkSize: 0,
    // 4    4    36+SubChunk2Size = 4+(8+SubChunk1Size)+(8+SubChunk2Size)
    format: [0x57, 0x41, 0x56, 0x45],
    // 8    4    "WAVE" = 0x57415645
    subChunk1Id: [0x66, 0x6d, 0x74, 0x20],
    // 12   4    "fmt " = 0x666d7420
    subChunk1Size: 16,
    // 16   4    16 for PCM
    audioFormat: 1,
    // 20   2    PCM = 1
    numChannels: 1,
    // 22   2    Mono = 1, Stereo = 2...
    sampleRate: sampleRate,
    // 24   4    8000, 44100...
    byteRate: 0,
    // 28   4    SampleRate*NumChannels*BitsPerSample/8
    blockAlign: 0,
    // 32   2    NumChannels*BitsPerSample/8
    bitsPerSample: bitsPerSample,
    // 34   2    8 bits = 8, 16 bits = 16
    subChunk2Id: [0x64, 0x61, 0x74, 0x61],
    // 36   4    "data" = 0x64617461
    subChunk2Size: 0 // 40   4    data size = NumSamples*NumChannels*BitsPerSample/8

  };
  header.blockAlign = header.numChannels * header.bitsPerSample >> 3;
  header.byteRate = header.blockAlign * header.sampleRate;
  header.subChunk2Size = data.length * (header.bitsPerSample >> 3);
  header.chunkSize = 36 + header.subChunk2Size;
  return header.chunkId.concat(u32ToArray(header.chunkSize), header.format, header.subChunk1Id, u32ToArray(header.subChunk1Size), u16ToArray(header.audioFormat), u16ToArray(header.numChannels), u32ToArray(header.sampleRate), u32ToArray(header.byteRate), u16ToArray(header.blockAlign), u16ToArray(header.bitsPerSample), header.subChunk2Id, u32ToArray(header.subChunk2Size), header.bitsPerSample == 16 ? split16bitArray(data) : data);
}
function getMIMEType() {
  return "audio/wav";
}

/***/ }),

/***/ "./src/morse-pro/morse-pro-wpm.js":
/*!****************************************!*\
  !*** ./src/morse-pro/morse-pro-wpm.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ditLength": () => (/* binding */ ditLength),
/* harmony export */   "dahLength": () => (/* binding */ dahLength),
/* harmony export */   "ditSpace": () => (/* binding */ ditSpace),
/* harmony export */   "charSpace": () => (/* binding */ charSpace),
/* harmony export */   "wordSpace": () => (/* binding */ wordSpace),
/* harmony export */   "wpm": () => (/* binding */ wpm),
/* harmony export */   "fditLength": () => (/* binding */ fditLength),
/* harmony export */   "ratio": () => (/* binding */ ratio),
/* harmony export */   "fwpm": () => (/* binding */ fwpm)
/* harmony export */ });
/*!
This code is Â© Copyright Stephen C. Phillips, 2018.
Email: steve@scphillips.com
*/

/*
Licensed under the EUPL, Version 1.2 or â€“ as soon they will be approved by the European Commission - subsequent versions of the EUPL (the "Licence");
You may not use this work except in compliance with the Licence.
You may obtain a copy of the Licence at: https://joinup.ec.europa.eu/community/eupl/
Unless required by applicable law or agreed to in writing, software distributed under the Licence is distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the Licence for the specific language governing permissions and limitations under the Licence.
*/

/**
 * Useful constants and functions for computing the speed of Morse code.
 */
var DITS_PER_WORD = 50;
/** dits in "PARIS " */

var SPACES_IN_PARIS = 19;
/** 5x 3-dit inter-character spaces + 1x 7-dit space */

var MS_IN_MINUTE = 60000;
/** number of milliseconds in 1 minute */

/** Get the dit length in ms
 * @param {number} wpm - speed in words per minute
 * @return {integer}
 */

function ditLength(wpm) {
  return Math.round(_ditLength(wpm));
}

function _ditLength(wpm) {
  return MS_IN_MINUTE / DITS_PER_WORD / wpm;
}
/**
 * Get the dah length in ms
 * @param {number} wpm - speed in words per minute
 * @return {integer}
 */


function dahLength(wpm) {
  return Math.round(3 * _ditLength(wpm));
}
/**
 * Get the dit space in ms
 * @param {number} wpm - speed in words per minute
 * @return {integer}
 */

function ditSpace(wpm) {
  return ditLength(wpm);
}
/**
 * Get the character-space in ms
 * @param {number} wpm - speed in words per minute
 * @param {number} [fwpm = wpm] - Farnsworth speed in words per minute
 * @return {integer}
 */

function charSpace(wpm) {
  var fwpm = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : wpm;
  return Math.round(3 * _fditLength(wpm, fwpm));
}
/**
 * Get the word-space in ms
 * @param {number} wpm - speed in words per minute
 * @param {number} [fwpm = wpm] - Farnsworth speed in words per minute
 * @return {integer}
 */

function wordSpace(wpm) {
  var fwpm = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : wpm;
  return Math.round(7 * _fditLength(wpm, fwpm));
}
/**
 * Get the WPM for a given dit length in ms
 * @return {number}
 */

function wpm(ditLen) {
  return MS_IN_MINUTE / DITS_PER_WORD / ditLen;
}
/**
 * Get the Farnsworth dit length in ms for a given WPM and Farnsworth WPM. Note, actual dit-spaces should not be slowed down
 * @return {integer}
 */

function fditLength(wpm, fwpm) {
  return Math.round(_fditLength(wpm, fwpm));
}

function _fditLength(wpm, fwpm) {
  return _ditLength(wpm) * ratio(wpm, fwpm);
}
/**
 * Get the dit length ratio for a given WPM and Farnsworth WPM
 * @param {number} wpm - speed in words per minute
 * @param {number} fwpm - Farnsworth speed in words per minute
 * @return {number}
 */


function ratio(wpm, fwpm) {
  // "PARIS " is 31 units for the characters and 19 units for the inter-character spaces and inter-word space
  // One unit takes 1 * 60 / (50 * wpm)
  // The 31 units should take 31 * 60 / (50 * wpm) seconds at wpm
  // "PARIS " should take 50 * 60 / (50 * fwpm) to transmit at fwpm, or 60 / fwpm  seconds at fwpm
  // Keeping the time for the characters constant,
  // The spaces need to take: (60 / fwpm) - [31 * 60 / (50 * wpm)] seconds in total
  // The spaces are 4 inter-character spaces of 3 units and 1 inter-word space of 7 units. Their ratio must be maintained.
  // A space unit is: [(60 / fwpm) - [31 * 60 / (50 * wpm)]] / 19 seconds
  // Comparing that to 60 / (50 * wpm) gives a ratio of (50.wpm - 31.fwpm) / 19.fwpm
  return (DITS_PER_WORD * wpm - (DITS_PER_WORD - SPACES_IN_PARIS) * fwpm) / (SPACES_IN_PARIS * fwpm);
}
/** Get the Farnsworth WPM for a given WPM and ratio */

function fwpm(wpm, r) {
  return DITS_PER_WORD * wpm / (SPACES_IN_PARIS * r + (DITS_PER_WORD - SPACES_IN_PARIS));
}

/***/ }),

/***/ "./src/morse-pro/morse-pro.js":
/*!************************************!*\
  !*** ./src/morse-pro/morse-pro.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "text2morse": () => (/* binding */ text2morse),
/* harmony export */   "text2ditdah": () => (/* binding */ text2ditdah),
/* harmony export */   "morse2text": () => (/* binding */ morse2text),
/* harmony export */   "looksLikeMorse": () => (/* binding */ looksLikeMorse)
/* harmony export */ });
/*!
This code is Â© Copyright Stephen C. Phillips, 2018.
Email: steve@scphillips.com
*/

/*
Licensed under the EUPL, Version 1.2 or â€“ as soon they will be approved by the European Commission - subsequent versions of the EUPL (the "Licence");
You may not use this work except in compliance with the Licence.
You may obtain a copy of the Licence at: https://joinup.ec.europa.eu/community/eupl/
Unless required by applicable law or agreed to in writing, software distributed under the Licence is distributed on an "AS IS" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the Licence for the specific language governing permissions and limitations under the Licence.
*/

/**
 * Basic methods to translate Morse code.
 */
if (typeof String.prototype.trim === "undefined") {
  String.prototype.trim = function () {
    return String(this).replace(/^\s+|\s+$/g, '');
  };
}

var text2morseH = {
  'A': ".-",
  'B': "-...",
  'C': "-.-.",
  'D': "-..",
  'E': ".",
  'F': "..-.",
  'G': "--.",
  'H': "....",
  'I': "..",
  'J': ".---",
  'K': "-.-",
  'L': ".-..",
  'M': "--",
  'N': "-.",
  'O': "---",
  'P': ".--.",
  'Q': "--.-",
  'R': ".-.",
  'S': "...",
  'T': "-",
  'U': "..-",
  'V': "...-",
  'W': ".--",
  'X': "-..-",
  'Y': "-.--",
  'Z': "--..",
  '1': ".----",
  '2': "..---",
  '3': "...--",
  '4': "....-",
  '5': ".....",
  '6': "-....",
  '7': "--...",
  '8': "---..",
  '9': "----.",
  '0': "-----",
  '.': ".-.-.-",
  ',': "--..--",
  ':': "---...",
  '?': "..--..",
  '\'': ".----.",
  '-': "-....-",
  '/': "-..-.",
  '(': "-.--.",
  ')': "-.--.-",
  '"': ".-..-.",
  '@': ".--.-.",
  '=': "-...-",
  '&': ".-...",
  '+': ".-.-.",
  '!': "-.-.--",
  ' ': "/" //Not morse but helps translation

};
var morse2textH = {};
var prosign2morseH = {
  '<AA>': '.-.-',
  '<AR>': '.-.-.',
  '<AS>': '.-...',
  '<BK>': '-...-.-',
  '<BT>': '-...-',
  // also <TV>
  '<CL>': '-.-..-..',
  '<CT>': '-.-.-',
  '<DO>': '-..---',
  '<KN>': '-.--.',
  '<SK>': '...-.-',
  // also <VA>
  '<VA>': '...-.-',
  '<SN>': '...-.',
  // also <VE>
  '<VE>': '...-.',
  '<SOS>': '...---...'
};
var morsepro2textH = {};
var text2morseproH = {};

for (var text in text2morseH) {
  text2morseproH[text] = text2morseH[text];
  morse2textH[text2morseH[text]] = text;
  morsepro2textH[text2morseH[text]] = text;
}

for (var sign in prosign2morseH) {
  text2morseproH[sign] = prosign2morseH[sign];
  morsepro2textH[prosign2morseH[sign]] = sign;
}

var tidyText = function tidyText(text) {
  text = text.toUpperCase();
  text = text.trim();
  text = text.replace(/\s+/g, ' ');
  return text;
};
/**
 * Translate text to morse in '..- .. / --' form.
 * If something in the text is untranslatable then it is surrounded by hash-signs ('#') and a hash is placed in the morse.
 * @param {string} text - alphanumeric message
 * @param {boolean} useProsigns - true if prosigns are to be used (default is true)
 * @return {{message: string, morse: string, hasError: boolean}}
 */


function text2morse(text) {
  var useProsigns = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  text = tidyText(text);
  var ret = {
    morse: "",
    message: "",
    hasError: false
  };

  if (text === "") {
    return ret;
  }

  var tokens = [];
  var prosign;
  var token_length;

  while (text.length > 0) {
    token_length = 1;

    if (useProsigns) {
      prosign = text.match(/^<...?>/); // array of matches

      if (prosign) {
        token_length = prosign[0].length;
      }
    }

    tokens.push(text.slice(0, token_length));
    text = text.slice(token_length, text.length);
  }

  var dict;

  if (useProsigns) {
    dict = text2morseproH;
  } else {
    dict = text2morseH;
  }

  var i, c, t;

  for (i = 0; i < tokens.length; i++) {
    t = tokens[i];
    c = dict[t];

    if (c === undefined) {
      ret.message += "#" + t + "#";
      ret.morse += "# ";
      ret.hasError = true;
    } else {
      ret.message += t;
      ret.morse += c + " ";
    }
  }

  ret.morse = ret.morse.slice(0, ret.morse.length - 1);
  return ret;
}
/**
 * Translate text to morse in 'Di-di-dah dah' form.
 * @param {string} text - alphanumeric message
 * @param {boolean} useProsigns - true if prosigns are to be used (default is true)
 * @return {string}
 */

function text2ditdah(text, useProsigns) {
  // TODO: deal with errors in the translation
  var ditdah = text2morse(text, useProsigns).morse + ' '; // get the dots and dashes

  ditdah = ditdah.replace(/\./g, 'di~').replace(/\-/g, 'dah~'); // do the basic job

  ditdah = ditdah.replace(/~/g, '-'); // replace placeholder with dash

  ditdah = ditdah.replace(/\- /g, ' '); // remove trailing dashes

  ditdah = ditdah.replace(/di /g, 'dit '); // use 'dit' at end of letter

  ditdah = ditdah.replace(/ \/ /g, ', '); // do punctuation

  ditdah = ditdah.replace(/^d/, 'D'); // do capitalisation

  ditdah = ditdah.replace(/ $/, ''); // remove the space we added

  ditdah = ditdah.replace(/([th])$/, '$1.'); // add full-stop if there is anything there

  return ditdah;
}
/**
 * Canonicalise morse text.
 * Canonical form matches [.-/ ]*, has single spaces between characters, has words separated by ' / ', and has no spaces at the start or end.
 * A single '/' may be returned by this function.
 * @param {string} morse - Morse code matching [.-_/| ]*
 * @return {string} Morse code in canonical form matching [.-/ ]*
 */

var tidyMorse = function tidyMorse(morse) {
  morse = morse.replace(/\|/g, "/"); // unify the word separator

  morse = morse.replace(/\//g, " / "); // make sure word separators are spaced out

  morse = morse.replace(/\s+/g, " "); // squash multiple spaces into single spaces

  morse = morse.replace(/(\/ )+\//g, "/"); // squash multiple word separators

  morse = morse.replace(/_/g, "-"); // unify the dash character

  morse = morse.replace(/^\s+/, ""); // remove initial whitespace

  morse = morse.replace(/\s+$/, ""); // remove trailing whitespace

  return morse;
};
/**
 * Translate morse to text. Canonicalise the morse first.
 * If something in the morse is untranslatable then it is surrounded by hash-signs ('#') and a hash is placed in the text.
 * @param {string} morse - morse message using [.-_/| ] characters
 * @param {boolean} useProsigns - true if prosigns are to be used (default is true)
 * @return {{message: string, morse: string, hasError: boolean}}
 */


function morse2text(morse) {
  var useProsigns = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  morse = tidyMorse(morse);
  var ret = {
    morse: "",
    message: "",
    hasError: false
  };

  if (morse === "") {
    return ret;
  }

  var tokens = morse.split(" ");
  var dict;

  if (useProsigns) {
    dict = morsepro2textH;
  } else {
    dict = morse2textH;
  }

  var c, t;

  for (var i = 0; i < tokens.length; i++) {
    t = tokens[i];
    c = dict[t];

    if (c === undefined) {
      ret.morse += "#" + t + "# ";
      ret.message += "#";
      ret.hasError = true;
    } else {
      ret.morse += t + " ";
      ret.message += c;
    }
  }

  ret.morse = ret.morse.slice(0, ret.morse.length - 1);
  return ret;
}
/**
 * Determine whether a string is most likely morse code.
 * @param {string} input - the text
 * @return {boolean} - true if the string only has Morse characters in after executing tidyMorse
 */

function looksLikeMorse(input) {
  input = tidyMorse(input);
  return input.match(/^[/.-][ /.-]*$/) !== null;
}

/***/ }),

/***/ "./src/morseLessonPlugin.js":
/*!**********************************!*\
  !*** ./src/morseLessonPlugin.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MorseLessonPlugin)
/* harmony export */ });
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var MorseLessonPlugin = /*#__PURE__*/_createClass(function MorseLessonPlugin() {
  _classCallCheck(this, MorseLessonPlugin);
});

_defineProperty(MorseLessonPlugin, "addLessonFeatures", function (ko, ctxt) {
  ctxt.setUserTargetInitialized = function () {
    ctxt.userTargetInitialized = true;
  };

  ctxt.setSelectedClassInitialized = function () {
    ctxt.selectedClassInitialized = true;
  };

  ctxt.setLetterGroupInitialized = function () {
    console.log('setlettergroupinitialized');
    ctxt.letterGroupInitialized = true;
  };

  ctxt.setDisplaysInitialized = function () {
    ctxt.displaysInitialized = true;
  };

  ctxt.changeUserTarget = function (userTarget) {
    if (ctxt.userTargetInitialized) {
      ctxt.userTarget(userTarget); // console.log('usertarget')
    }
  };

  ctxt.changeSelectedClass = function (selectedClass) {
    if (ctxt.selectedClassInitialized) {
      ctxt.selectedClass(selectedClass);
    }
  };

  ctxt.setLetterGroup = function (letterGroup) {
    if (ctxt.letterGroupInitialized) {
      console.log('setlettergroup');
      ctxt.letterGroup(letterGroup);
    }
  };

  ctxt.setDisplaySelected = function (display) {
    if (ctxt.displaysInitialized) {
      ctxt.selectedDisplay(display);
      ctxt.setText("when we have lesson files, load ".concat(ctxt.selectedDisplay().fileName));
      ctxt.getWordList(ctxt.selectedDisplay().fileName);
    }
  };

  ctxt.initializeWordList = function () {
    fetch('wordfilesconfigs/wordlists.json').then(function (response) {
      return response.json();
    }).then(function (data) {
      ctxt.wordLists(data.fileOptions);
    })["catch"](function (err) {
      console.log('error: ' + err);
    });
  };

  ctxt.userTargets = ko.computed(function () {
    var targs = [];
    ctxt.wordLists().forEach(function (x) {
      if (!targs.find(function (y) {
        return y === x.userTarget;
      })) {
        targs.push(x.userTarget);
      }
    });
    return targs;
  }, ctxt);
  ctxt.classes = ko.computed(function () {
    var cls = [];
    ctxt.wordLists().forEach(function (x) {
      if (!cls.find(function (y) {
        return y === x["class"];
      })) {
        cls.push(x["class"]);
      }
    });
    return cls;
  }, ctxt);
  ctxt.letterGroups = ko.computed(function () {
    ctxt.letterGroupInitialized = false;
    ctxt.letterGroup('');
    var lgs = [];

    if (ctxt.selectedClass() === '' || ctxt.userTarget() === '') {
      var missing = [];

      if (ctxt.selectedClass() === '') {
        missing.push('class');
      }

      if (ctxt.userTarget() === '') {
        missing.push('user');
      }

      return ["Select ".concat(missing.join(', '))];
    }

    ctxt.wordLists().filter(function (list) {
      return list["class"] === ctxt.selectedClass() && list.userTarget === ctxt.userTarget();
    }).forEach(function (x) {
      if (!lgs.find(function (y) {
        return y === x.letterGroup;
      })) {
        lgs.push(x.letterGroup);
      }
    });
    return lgs;
  }, ctxt);
  ctxt.displays = ko.computed(function () {
    ctxt.displaysInitialized = false;
    ctxt.selectedDisplay({});
    var dps = [];

    if (ctxt.selectedClass() === '' || ctxt.userTarget() === '' || ctxt.letterGroup() === '') {
      return [{
        display: 'Select wordlist',
        fileName: 'dummy.txt'
      }];
    }

    ctxt.wordLists().filter(function (list) {
      return list["class"] === ctxt.selectedClass() && list.userTarget === ctxt.userTarget() && list.letterGroup === ctxt.letterGroup();
    }).forEach(function (x) {
      if (!dps.find(function (y) {
        return y === x.display;
      })) {
        dps.push({
          display: x.display,
          fileName: x.fileName
        });
      }
    });
    return dps;
  }, ctxt);

  ctxt.getWordList = function (filename) {
    var isText = filename.endsWith('txt');
    fetch('wordfiles/' + filename).then(function (response) {
      if (isText) {
        return response.text();
      } else {
        // assume json
        return response.json();
      }
    }).then(function (data) {
      if (isText) {
        ctxt.setText(data);
      } else {
        ctxt.randomWordList(data);
      }
    })["catch"](function (err) {
      console.log('error: ' + err);
    });
  };
});



/***/ }),

/***/ "./src/morseLoadImages.js":
/*!********************************!*\
  !*** ./src/morseLoadImages.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MorseLoadImages": () => (/* binding */ MorseLoadImages)
/* harmony export */ });
/* harmony import */ var _assets_CW_Club_logo_clear400_300x300_png__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assets/CW-Club-logo-clear400-300x300.png */ "./src/assets/CW-Club-logo-clear400-300x300.png");
/* harmony import */ var bootstrap_icons_icons_download_svg__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bootstrap-icons/icons/download.svg */ "./node_modules/bootstrap-icons/icons/download.svg");
/* harmony import */ var bootstrap_icons_icons_volume_up_svg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! bootstrap-icons/icons/volume-up.svg */ "./node_modules/bootstrap-icons/icons/volume-up.svg");
/* harmony import */ var bootstrap_icons_icons_github_svg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! bootstrap-icons/icons/github.svg */ "./node_modules/bootstrap-icons/icons/github.svg");
/* harmony import */ var bootstrap_icons_icons_book_svg__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! bootstrap-icons/icons/book.svg */ "./node_modules/bootstrap-icons/icons/book.svg");
/* harmony import */ var bootstrap_icons_icons_flag_svg__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! bootstrap-icons/icons/flag.svg */ "./node_modules/bootstrap-icons/icons/flag.svg");
/* harmony import */ var bootstrap_icons_icons_lock_svg__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! bootstrap-icons/icons/lock.svg */ "./node_modules/bootstrap-icons/icons/lock.svg");
/* harmony import */ var bootstrap_icons_icons_unlock_svg__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! bootstrap-icons/icons/unlock.svg */ "./node_modules/bootstrap-icons/icons/unlock.svg");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }









var MorseLoadImages = /*#__PURE__*/_createClass(function MorseLoadImages() {
  var _this = this;

  _classCallCheck(this, MorseLoadImages);

  _defineProperty(this, "info", []);

  _defineProperty(this, "getSrc", function (key) {
    var target = _this.info.find(function (x) {
      return x.key === key;
    });

    return target.src;
  });

  var licwlogoImg = document.getElementById('logo');
  licwlogoImg.src = _assets_CW_Club_logo_clear400_300x300_png__WEBPACK_IMPORTED_MODULE_0__;
  var downloadImg = document.getElementById('downloadImage');
  downloadImg.src = bootstrap_icons_icons_download_svg__WEBPACK_IMPORTED_MODULE_1__;
  var volumeImg = document.getElementById('volumeImage');
  volumeImg.src = bootstrap_icons_icons_volume_up_svg__WEBPACK_IMPORTED_MODULE_2__;
  var githubImg = document.getElementById('githubImage');
  githubImg.src = bootstrap_icons_icons_github_svg__WEBPACK_IMPORTED_MODULE_3__;
  var bookImg = document.getElementById('bookImage');
  bookImg.src = bootstrap_icons_icons_book_svg__WEBPACK_IMPORTED_MODULE_4__;
  var flagImg = document.getElementById('flagImage');
  flagImg.src = bootstrap_icons_icons_flag_svg__WEBPACK_IMPORTED_MODULE_5__;
  this.info.push({
    key: 'lockImage',
    src: bootstrap_icons_icons_lock_svg__WEBPACK_IMPORTED_MODULE_6__
  });
  this.info.push({
    key: 'unlockImage',
    src: bootstrap_icons_icons_unlock_svg__WEBPACK_IMPORTED_MODULE_7__
  });
});

/***/ }),

/***/ "./src/morseStringToWavBuffer.js":
/*!***************************************!*\
  !*** ./src/morseStringToWavBuffer.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MorseStringToWavBufferConfig": () => (/* binding */ MorseStringToWavBufferConfig),
/* harmony export */   "MorseStringToWavBuffer": () => (/* binding */ MorseStringToWavBuffer)
/* harmony export */ });
/* harmony import */ var _morse_pro_morse_pro_cw_wave_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./morse-pro/morse-pro-cw-wave.js */ "./src/morse-pro/morse-pro-cw-wave.js");
/* harmony import */ var _morse_pro_morse_pro_util_riffwave_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./morse-pro/morse-pro-util-riffwave.js */ "./src/morse-pro/morse-pro-util-riffwave.js");
/* harmony import */ var _morseTimingCalculator_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./morseTimingCalculator.js */ "./src/morseTimingCalculator.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




var MorseStringToWavBufferConfig = /*#__PURE__*/function () {
  function MorseStringToWavBufferConfig() {
    _classCallCheck(this, MorseStringToWavBufferConfig);

    _defineProperty(this, "word", void 0);

    _defineProperty(this, "wpm", void 0);

    _defineProperty(this, "fwpm", void 0);

    _defineProperty(this, "ditFrequency", void 0);

    _defineProperty(this, "dahFrequency", void 0);

    _defineProperty(this, "prePaddingMs", void 0);

    _defineProperty(this, "xtraWordSpaceDits", void 0);

    _defineProperty(this, "volume", void 0);
  }

  _createClass(MorseStringToWavBufferConfig, [{
    key: "frequency",
    get: function get() {
      return this.ditFrequency;
    }
  }]);

  return MorseStringToWavBufferConfig;
}();
var MorseStringToWavBuffer = /*#__PURE__*/_createClass(function MorseStringToWavBuffer() {
  _classCallCheck(this, MorseStringToWavBuffer);
});

_defineProperty(MorseStringToWavBuffer, "getInit", function (config) {
  var useProsigns = true;
  var sampleRate = 8000;
  var timingUnits = _morseTimingCalculator_js__WEBPACK_IMPORTED_MODULE_2__.MorseTimingCalculator.getTimingUnits(config.wpm, config.fwpm);
  var countUnits = new _morseTimingCalculator_js__WEBPACK_IMPORTED_MODULE_2__.MorseCountUnits();
  countUnits.extraWordSpacingDitsCount = config.xtraWordSpaceDits; // const unit = 1200 / config.fwpm
  // const wordSpace = (unit * 7) + (unit * config.xtraWordSpaceDits)

  var morseCWWave = new _morse_pro_morse_pro_cw_wave_js__WEBPACK_IMPORTED_MODULE_0__["default"](useProsigns, config.wpm, config.fwpm, {
    dit: config.ditFrequency,
    dah: config.dahFrequency
  }, sampleRate);
  morseCWWave.translate(config.word, false);
  return {
    morseCWWave: morseCWWave,
    timingUnits: timingUnits,
    countUnits: countUnits
  };
});

_defineProperty(MorseStringToWavBuffer, "createWav", function (config) {
  var init = MorseStringToWavBuffer.getInit(config);
  var ret = {}; // get wordspace

  var calcs = _morseTimingCalculator_js__WEBPACK_IMPORTED_MODULE_2__.MorseTimingCalculator.getTimes(init.timingUnits, init.countUnits);
  ret.sample = init.morseCWWave.getSample(calcs.singleWordSpaceTime, config.prePaddingMs);
  var wav = _morse_pro_morse_pro_util_riffwave_js__WEBPACK_IMPORTED_MODULE_1__.getData(ret.sample);
  ret.wav = wav;
  return ret;
});

_defineProperty(MorseStringToWavBuffer, "estimatePlayTime", function (config) {
  var init = MorseStringToWavBuffer.getInit(config);
  var timingUnits = init.timingUnits;
  var unitCounts = _morseTimingCalculator_js__WEBPACK_IMPORTED_MODULE_2__.MorseTimingCalculator.countUnits(init.morseCWWave, init.countUnits);
  var timeCalcs = _morseTimingCalculator_js__WEBPACK_IMPORTED_MODULE_2__.MorseTimingCalculator.getTimes(timingUnits, unitCounts);
  return {
    morse: init.morseCWWave.morse,
    word: config.word,
    timingUnits: timingUnits,
    unitCounts: unitCounts,
    timeCalcs: timeCalcs
  };
});

/***/ }),

/***/ "./src/morseStringUtils.js":
/*!*********************************!*\
  !*** ./src/morseStringUtils.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MorseStringUtils)
/* harmony export */ });
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var MorseStringUtils = /*#__PURE__*/_createClass(function MorseStringUtils() {
  _classCallCheck(this, MorseStringUtils);
});

_defineProperty(MorseStringUtils, "doReplacements", function (s) {
  return s // a few ad-hoc attempts to fix unicode or other problems
  // seems like apostraphe is not morse-able
  .replace(/â€™/g, '').replace(/â€˜/g, '').replace(/'/g, '') // turn percent sign into pct abbreviation
  .replace(/%/g, 'pct') // in the square brackets we add all symbols supported by morse-pro (see more-pro.js), otherwise replace with space
  // eslint-disable-next-line no-useless-escape
  .replace(/(?![\.\,\:\?\\\-\/\(\)\"\@\=\&\+\!\<\>])\W/g, ' ');
});

_defineProperty(MorseStringUtils, "splitIntoSentences", function (replaced) {
  // split on period or question mark or exclamation mark
  // eslint-disable-next-line no-useless-escape
  var splitSents = replaced.split(/([\.\?\!])/); // example
  //  "hello there. how are you? I am fine".split(/([\.\?])/)
  // eslint-disable-next-line no-irregular-whitespace
  // eslint-disable-next-line no-irregular-whitespace
  // (5)Â ['hello there', '.', ' how are you', '?', ' I am fine']
  // now put the punctuation back on the end of sentences

  var splitsGlued = splitSents.map(function (val, i, ary) {
    if (i === 0 || i % 2 === 0) {
      return val + (i + 1 < ary.length ? ary[i + 1] : '');
    } else {
      return '';
    }
  }).filter(function (y) {
    return y !== '';
  });
  return splitsGlued;
});

_defineProperty(MorseStringUtils, "getSentences", function (s, dontSplit) {
  var replaced = MorseStringUtils.doReplacements(s);
  var splitsGlued = dontSplit ? [replaced] : MorseStringUtils.splitIntoSentences(replaced);
  var sents = splitsGlued.map(function (sentence) {
    return sentence.trim() // remove double spaces
    // eslint-disable-next-line no-regex-spaces
    .replace(/  /g, ' ') // split up into words
    .split(' ') // get rid fo stray empties
    .filter(function (x) {
      return x.trim().length > 0;
    });
  }).filter(function (x) {
    return x.length > 1 || x[0] !== '.';
  });
  return sents;
});



/***/ }),

/***/ "./src/morseTimingCalculator.js":
/*!**************************************!*\
  !*** ./src/morseTimingCalculator.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MorseCountUnits": () => (/* binding */ MorseCountUnits),
/* harmony export */   "MorseTimingCalculator": () => (/* binding */ MorseTimingCalculator)
/* harmony export */ });
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var MorseCountUnits = /*#__PURE__*/_createClass(function MorseCountUnits() {
  _classCallCheck(this, MorseCountUnits);

  _defineProperty(this, "interCharacterSpaceCount", 0);

  _defineProperty(this, "intraCharacterSpaceCount", 0);

  _defineProperty(this, "ditCount", 0);

  _defineProperty(this, "dahCount", 0);

  _defineProperty(this, "wordSpacesCount", 0);

  _defineProperty(this, "extraWordSpacingDitsCount", 0);
});
var MorseTimingCalculator = /*#__PURE__*/_createClass(function MorseTimingCalculator() {
  _classCallCheck(this, MorseTimingCalculator);
});

_defineProperty(MorseTimingCalculator, "getTimingUnits", function (wpm, fwpm) {
  var calculatedSecondsPerDit = 60 / (50 * wpm);
  var calculatedUnitsMs = calculatedSecondsPerDit * 1000;
  var calculatedFWUnitSeconds = (60 / fwpm - 31 * calculatedSecondsPerDit) / 19;
  var calculatedFWUnitsMs = calculatedFWUnitSeconds * 1000;
  return {
    calculatedUnitsMs: calculatedUnitsMs,
    calculatedFWUnitsMs: calculatedFWUnitsMs,
    ditUnitMultiPlier: 1,
    dahUnitMultiplier: 3,
    intraCharacterSpaceMultiplier: 1,
    interCharacterSpaceMultiplier: 3,
    wordSpaceMultiplier: 7
  };
});

_defineProperty(MorseTimingCalculator, "countUnits", function (morsecwwav, prePopulated) {
  var cnts;

  if (prePopulated) {
    cnts = prePopulated;
  } else {
    cnts = new MorseCountUnits();
  }

  var morseWords = morsecwwav.morse.split('/');
  cnts.wordSpacesCount = morseWords.length - 1;
  morseWords.forEach(function (word) {
    var characters = word.trim().split(' ');
    cnts.interCharacterSpaceCount += characters.length - 1;
    characters.forEach(function (character) {
      cnts.intraCharacterSpaceCount += character.length - 1;
      cnts.ditCount += character.split('').filter(function (x) {
        return x === '.';
      }).length;
      cnts.dahCount += character.split('').filter(function (x) {
        return x === '-';
      }).length;
    });
  });
  return cnts;
});

_defineProperty(MorseTimingCalculator, "getTimes", function (timingUnits, countUnits) {
  var ditTime = countUnits.ditCount * timingUnits.ditUnitMultiPlier * timingUnits.calculatedUnitsMs;
  var dahTime = countUnits.dahCount * timingUnits.dahUnitMultiplier * timingUnits.calculatedUnitsMs;
  var intraCharacterSpaceTime = countUnits.intraCharacterSpaceCount * timingUnits.intraCharacterSpaceMultiplier * timingUnits.calculatedUnitsMs; // these are farnsworthed

  var interCharacterSpaceTime = countUnits.interCharacterSpaceCount * timingUnits.interCharacterSpaceMultiplier * timingUnits.calculatedFWUnitsMs;
  var wordSpaceTime = countUnits.wordSpacesCount * timingUnits.wordSpaceMultiplier * timingUnits.calculatedFWUnitsMs;
  var extraWordSpacingDitsTime = countUnits.wordSpacesCount * countUnits.extraWordSpacingDitsCount * timingUnits.ditUnitMultiPlier * timingUnits.calculatedFWUnitsMs;
  var totalTime = ditTime + dahTime + intraCharacterSpaceTime + interCharacterSpaceTime + wordSpaceTime + extraWordSpacingDitsTime; // single wordspace

  var singleWordSpaceTime = timingUnits.wordSpaceMultiplier * timingUnits.calculatedFWUnitsMs + countUnits.extraWordSpacingDitsCount * timingUnits.ditUnitMultiPlier * timingUnits.calculatedFWUnitsMs;
  var totalPlusTrail = totalTime + singleWordSpaceTime;
  return {
    totalTime: totalTime,
    ditTime: ditTime,
    dahTime: dahTime,
    intraCharacterSpaceTime: intraCharacterSpaceTime,
    interCharacterSpaceTime: interCharacterSpaceTime,
    wordSpaceTime: wordSpaceTime,
    extraWordSpacingDitsTime: extraWordSpacingDitsTime,
    singleWordSpaceTime: singleWordSpaceTime,
    totalPlusTrail: totalPlusTrail
  };
});

/***/ }),

/***/ "./src/morseWavBufferPlayer.js":
/*!*************************************!*\
  !*** ./src/morseWavBufferPlayer.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ MorseWavBufferPlayer)
/* harmony export */ });
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* abstract away the playing of wav buffer in case browser issues come up, etc
can change the code here and other code won't be affected.
*/
var MorseWavBufferPlayer = /*#__PURE__*/_createClass(function MorseWavBufferPlayer() {
  var _this = this;

  _classCallCheck(this, MorseWavBufferPlayer);

  _defineProperty(this, "myAudioContext", void 0);

  _defineProperty(this, "source", void 0);

  _defineProperty(this, "sourceEnded", true);

  _defineProperty(this, "sourceEndedCallBack", void 0);

  _defineProperty(this, "gainNode", void 0);

  _defineProperty(this, "noiseNode", void 0);

  _defineProperty(this, "noisePlaying", false);

  _defineProperty(this, "noiseGainNode", void 0);

  _defineProperty(this, "lastNoiseType", 'off');

  _defineProperty(this, "startNoise", function (config) {
    var noiseNodeMaker = null;

    var afterImport = function afterImport(def) {
      def.install();
      noiseNodeMaker();
      _this.noiseGainNode = _this.myAudioContext.createGain();

      _this.setNoiseVolume(config.noise.scaledNoiseVolume);

      _this.noiseNode.connect(_this.noiseGainNode);

      _this.noiseGainNode.connect(_this.myAudioContext.destination);

      _this.noiseNode.start();

      console.log('started a noise node');
      _this.noisePlaying = true;
    };

    switch (config.noise.type) {
      case 'white':
        noiseNodeMaker = function noiseNodeMaker() {
          _this.noiseNode = _this.myAudioContext.createWhiteNoise();
        };

        __webpack_require__.e(/*! import() */ "node_modules_white-noise-node_index_js").then(__webpack_require__.t.bind(__webpack_require__, /*! white-noise-node */ "./node_modules/white-noise-node/index.js", 23)).then(function (_ref) {
          var def = _ref["default"];
          afterImport(def);
        });
        break;

      case 'brown':
        noiseNodeMaker = function noiseNodeMaker() {
          _this.noiseNode = _this.myAudioContext.createBrownNoise();
        };

        __webpack_require__.e(/*! import() */ "node_modules_brown-noise-node_index_js").then(__webpack_require__.t.bind(__webpack_require__, /*! brown-noise-node */ "./node_modules/brown-noise-node/index.js", 23)).then(function (_ref2) {
          var def = _ref2["default"];
          afterImport(def);
        });
        break;

      case 'pink':
        noiseNodeMaker = function noiseNodeMaker() {
          _this.noiseNode = _this.myAudioContext.createPinkNoise();
        };

        __webpack_require__.e(/*! import() */ "node_modules_pink-noise-node_index_js").then(__webpack_require__.t.bind(__webpack_require__, /*! pink-noise-node */ "./node_modules/pink-noise-node/index.js", 23)).then(function (_ref3) {
          var def = _ref3["default"];
          afterImport(def);
        });
    }
  });

  _defineProperty(this, "setVolume", function (scaledVolume) {
    if (_this.myAudioContext) {
      _this.gainNode.gain.setValueAtTime(scaledVolume, _this.myAudioContext.currentTime);
    }
  });

  _defineProperty(this, "setNoiseVolume", function (scaledVolume) {
    if (_this.myAudioContext) {
      _this.noiseGainNode.gain.setValueAtTime(scaledVolume, _this.myAudioContext.currentTime);
    }
  });

  _defineProperty(this, "stopNoise", function () {
    if (_this.noiseNode && _this.noisePlaying) {
      _this.noiseNode.stop();

      _this.noisePlaying = false;
    }
  });

  _defineProperty(this, "handleNoiseSettings", function (config) {
    if (_this.myAudioContext) {
      var noiseWasPlaying = _this.noisePlaying;
      var typeChanged = config.noise.type !== _this.lastNoiseType;
      var typeIsOff = config.noise.type === 'off';

      if (typeChanged && _this.noisePlaying || typeIsOff) {
        _this.stopNoise();
      }

      if (!typeIsOff && config.playerPlaying) {
        if (noiseWasPlaying && typeChanged || !noiseWasPlaying) {
          _this.startNoise(config);
        }
      }

      _this.lastNoiseType = config.noise.type;
    }
  });

  _defineProperty(this, "play", function (wav, scaledVolume, config, onEnded) {
    _this.sourceEnded = false;
    _this.sourceEndedCallBack = onEnded;

    if (typeof _this.myAudioContext === 'undefined') {
      _this.myAudioContext = new AudioContext();
    }

    _this.gainNode = _this.myAudioContext.createGain();
    _this.source = _this.myAudioContext.createBufferSource();

    _this.source.addEventListener('ended', function () {
      // this.noiseNode.stop()
      _this.sourceEnded = true;

      _this.sourceEndedCallBack();
    });

    var mybuf = new Int8Array(wav).buffer;
    var mybuf2;

    _this.myAudioContext.decodeAudioData(mybuf, function (x) {
      // thanks https://middleearmedia.com/web-audio-api-audio-buffer/
      mybuf2 = x;
      _this.source.buffer = mybuf2;

      _this.setVolume(scaledVolume);

      _this.source.connect(_this.gainNode);

      _this.gainNode.connect(_this.myAudioContext.destination);

      _this.handleNoiseSettings(config);

      _this.source.start(0);
    }, function (e) {
      console.log('error');
      console.log(e);
    });
  });

  _defineProperty(this, "forceStop", function (pauseCallBack, killNoise) {
    if (typeof _this.myAudioContext === 'undefined') {
      pauseCallBack();
    } else {
      if (killNoise) {
        _this.stopNoise();
      }

      if (typeof _this.source !== 'undefined') {
        if (!_this.sourceEnded) {
          _this.sourceEndedCallBack = pauseCallBack;

          _this.source.stop();
        } else {
          pauseCallBack();
        }
      } else {
        pauseCallBack();
      }
    }
  });
});



/***/ }),

/***/ "./src/morseWordPlayer.js":
/*!********************************!*\
  !*** ./src/morseWordPlayer.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MorseWordPlayer": () => (/* binding */ MorseWordPlayer)
/* harmony export */ });
/* harmony import */ var _morseWavBufferPlayer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./morseWavBufferPlayer.js */ "./src/morseWavBufferPlayer.js");
/* harmony import */ var _morseStringToWavBuffer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./morseStringToWavBuffer.js */ "./src/morseStringToWavBuffer.js");
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var MorseWordPlayer = /*#__PURE__*/function () {
  function MorseWordPlayer() {
    _classCallCheck(this, MorseWordPlayer);

    _defineProperty(this, "myBufferPlayer", void 0);

    this.myBufferPlayer = new _morseWavBufferPlayer_js__WEBPACK_IMPORTED_MODULE_0__["default"]();
  }

  _createClass(MorseWordPlayer, [{
    key: "setVolume",
    value: function setVolume(volume) {
      this.myBufferPlayer.setVolume(volume / 10);
    }
  }, {
    key: "setNoiseVolume",
    value: function setNoiseVolume(volume) {
      this.myBufferPlayer.setNoiseVolume(volume / 10);
    }
  }, {
    key: "setNoiseType",
    value: function setNoiseType(config) {
      config.noise.scaledNoiseVolume = config.noise.volume / 10;
      this.myBufferPlayer.handleNoiseSettings(config);
    }
  }, {
    key: "play",
    value: function play(config, onEnded) {
      var wav = _morseStringToWavBuffer_js__WEBPACK_IMPORTED_MODULE_1__.MorseStringToWavBuffer.createWav(config);
      config.noise.scaledNoiseVolume = config.noise.volume / 10;
      this.myBufferPlayer.play(wav.wav, config.volume / 10, config, onEnded);
    }
  }, {
    key: "pause",
    value: function pause(pauseCallBack, killNoise) {
      this.myBufferPlayer.forceStop(pauseCallBack, killNoise);
    }
  }, {
    key: "getWavAndSample",
    value: function getWavAndSample(config) {
      var wav = _morseStringToWavBuffer_js__WEBPACK_IMPORTED_MODULE_1__.MorseStringToWavBuffer.createWav(config);
      return wav;
    }
  }, {
    key: "getTimeEstimate",
    value: function getTimeEstimate(config) {
      return _morseStringToWavBuffer_js__WEBPACK_IMPORTED_MODULE_1__.MorseStringToWavBuffer.estimatePlayTime(config);
    }
  }]);

  return MorseWordPlayer;
}();

/***/ }),

/***/ "./node_modules/bootstrap/dist/js/bootstrap.esm.js":
/*!*********************************************************!*\
  !*** ./node_modules/bootstrap/dist/js/bootstrap.esm.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Alert": () => (/* binding */ Alert),
/* harmony export */   "Button": () => (/* binding */ Button),
/* harmony export */   "Carousel": () => (/* binding */ Carousel),
/* harmony export */   "Collapse": () => (/* binding */ Collapse),
/* harmony export */   "Dropdown": () => (/* binding */ Dropdown),
/* harmony export */   "Modal": () => (/* binding */ Modal),
/* harmony export */   "Offcanvas": () => (/* binding */ Offcanvas),
/* harmony export */   "Popover": () => (/* binding */ Popover),
/* harmony export */   "ScrollSpy": () => (/* binding */ ScrollSpy),
/* harmony export */   "Tab": () => (/* binding */ Tab),
/* harmony export */   "Toast": () => (/* binding */ Toast),
/* harmony export */   "Tooltip": () => (/* binding */ Tooltip)
/* harmony export */ });
/* harmony import */ var _popperjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @popperjs/core */ "./node_modules/@popperjs/core/lib/index.js");
/* harmony import */ var _popperjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @popperjs/core */ "./node_modules/@popperjs/core/lib/popper.js");
/*!
  * Bootstrap v5.1.3 (https://getbootstrap.com/)
  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */


/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): util/index.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */
const MAX_UID = 1000000;
const MILLISECONDS_MULTIPLIER = 1000;
const TRANSITION_END = 'transitionend'; // Shoutout AngusCroll (https://goo.gl/pxwQGp)

const toType = obj => {
  if (obj === null || obj === undefined) {
    return `${obj}`;
  }

  return {}.toString.call(obj).match(/\s([a-z]+)/i)[1].toLowerCase();
};
/**
 * --------------------------------------------------------------------------
 * Public Util Api
 * --------------------------------------------------------------------------
 */


const getUID = prefix => {
  do {
    prefix += Math.floor(Math.random() * MAX_UID);
  } while (document.getElementById(prefix));

  return prefix;
};

const getSelector = element => {
  let selector = element.getAttribute('data-bs-target');

  if (!selector || selector === '#') {
    let hrefAttr = element.getAttribute('href'); // The only valid content that could double as a selector are IDs or classes,
    // so everything starting with `#` or `.`. If a "real" URL is used as the selector,
    // `document.querySelector` will rightfully complain it is invalid.
    // See https://github.com/twbs/bootstrap/issues/32273

    if (!hrefAttr || !hrefAttr.includes('#') && !hrefAttr.startsWith('.')) {
      return null;
    } // Just in case some CMS puts out a full URL with the anchor appended


    if (hrefAttr.includes('#') && !hrefAttr.startsWith('#')) {
      hrefAttr = `#${hrefAttr.split('#')[1]}`;
    }

    selector = hrefAttr && hrefAttr !== '#' ? hrefAttr.trim() : null;
  }

  return selector;
};

const getSelectorFromElement = element => {
  const selector = getSelector(element);

  if (selector) {
    return document.querySelector(selector) ? selector : null;
  }

  return null;
};

const getElementFromSelector = element => {
  const selector = getSelector(element);
  return selector ? document.querySelector(selector) : null;
};

const getTransitionDurationFromElement = element => {
  if (!element) {
    return 0;
  } // Get transition-duration of the element


  let {
    transitionDuration,
    transitionDelay
  } = window.getComputedStyle(element);
  const floatTransitionDuration = Number.parseFloat(transitionDuration);
  const floatTransitionDelay = Number.parseFloat(transitionDelay); // Return 0 if element or transition duration is not found

  if (!floatTransitionDuration && !floatTransitionDelay) {
    return 0;
  } // If multiple durations are defined, take the first


  transitionDuration = transitionDuration.split(',')[0];
  transitionDelay = transitionDelay.split(',')[0];
  return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
};

const triggerTransitionEnd = element => {
  element.dispatchEvent(new Event(TRANSITION_END));
};

const isElement = obj => {
  if (!obj || typeof obj !== 'object') {
    return false;
  }

  if (typeof obj.jquery !== 'undefined') {
    obj = obj[0];
  }

  return typeof obj.nodeType !== 'undefined';
};

const getElement = obj => {
  if (isElement(obj)) {
    // it's a jQuery object or a node element
    return obj.jquery ? obj[0] : obj;
  }

  if (typeof obj === 'string' && obj.length > 0) {
    return document.querySelector(obj);
  }

  return null;
};

const typeCheckConfig = (componentName, config, configTypes) => {
  Object.keys(configTypes).forEach(property => {
    const expectedTypes = configTypes[property];
    const value = config[property];
    const valueType = value && isElement(value) ? 'element' : toType(value);

    if (!new RegExp(expectedTypes).test(valueType)) {
      throw new TypeError(`${componentName.toUpperCase()}: Option "${property}" provided type "${valueType}" but expected type "${expectedTypes}".`);
    }
  });
};

const isVisible = element => {
  if (!isElement(element) || element.getClientRects().length === 0) {
    return false;
  }

  return getComputedStyle(element).getPropertyValue('visibility') === 'visible';
};

const isDisabled = element => {
  if (!element || element.nodeType !== Node.ELEMENT_NODE) {
    return true;
  }

  if (element.classList.contains('disabled')) {
    return true;
  }

  if (typeof element.disabled !== 'undefined') {
    return element.disabled;
  }

  return element.hasAttribute('disabled') && element.getAttribute('disabled') !== 'false';
};

const findShadowRoot = element => {
  if (!document.documentElement.attachShadow) {
    return null;
  } // Can find the shadow root otherwise it'll return the document


  if (typeof element.getRootNode === 'function') {
    const root = element.getRootNode();
    return root instanceof ShadowRoot ? root : null;
  }

  if (element instanceof ShadowRoot) {
    return element;
  } // when we don't find a shadow root


  if (!element.parentNode) {
    return null;
  }

  return findShadowRoot(element.parentNode);
};

const noop = () => {};
/**
 * Trick to restart an element's animation
 *
 * @param {HTMLElement} element
 * @return void
 *
 * @see https://www.charistheo.io/blog/2021/02/restart-a-css-animation-with-javascript/#restarting-a-css-animation
 */


const reflow = element => {
  // eslint-disable-next-line no-unused-expressions
  element.offsetHeight;
};

const getjQuery = () => {
  const {
    jQuery
  } = window;

  if (jQuery && !document.body.hasAttribute('data-bs-no-jquery')) {
    return jQuery;
  }

  return null;
};

const DOMContentLoadedCallbacks = [];

const onDOMContentLoaded = callback => {
  if (document.readyState === 'loading') {
    // add listener on the first call when the document is in loading state
    if (!DOMContentLoadedCallbacks.length) {
      document.addEventListener('DOMContentLoaded', () => {
        DOMContentLoadedCallbacks.forEach(callback => callback());
      });
    }

    DOMContentLoadedCallbacks.push(callback);
  } else {
    callback();
  }
};

const isRTL = () => document.documentElement.dir === 'rtl';

const defineJQueryPlugin = plugin => {
  onDOMContentLoaded(() => {
    const $ = getjQuery();
    /* istanbul ignore if */

    if ($) {
      const name = plugin.NAME;
      const JQUERY_NO_CONFLICT = $.fn[name];
      $.fn[name] = plugin.jQueryInterface;
      $.fn[name].Constructor = plugin;

      $.fn[name].noConflict = () => {
        $.fn[name] = JQUERY_NO_CONFLICT;
        return plugin.jQueryInterface;
      };
    }
  });
};

const execute = callback => {
  if (typeof callback === 'function') {
    callback();
  }
};

const executeAfterTransition = (callback, transitionElement, waitForTransition = true) => {
  if (!waitForTransition) {
    execute(callback);
    return;
  }

  const durationPadding = 5;
  const emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;
  let called = false;

  const handler = ({
    target
  }) => {
    if (target !== transitionElement) {
      return;
    }

    called = true;
    transitionElement.removeEventListener(TRANSITION_END, handler);
    execute(callback);
  };

  transitionElement.addEventListener(TRANSITION_END, handler);
  setTimeout(() => {
    if (!called) {
      triggerTransitionEnd(transitionElement);
    }
  }, emulatedDuration);
};
/**
 * Return the previous/next element of a list.
 *
 * @param {array} list    The list of elements
 * @param activeElement   The active element
 * @param shouldGetNext   Choose to get next or previous element
 * @param isCycleAllowed
 * @return {Element|elem} The proper element
 */


const getNextActiveElement = (list, activeElement, shouldGetNext, isCycleAllowed) => {
  let index = list.indexOf(activeElement); // if the element does not exist in the list return an element depending on the direction and if cycle is allowed

  if (index === -1) {
    return list[!shouldGetNext && isCycleAllowed ? list.length - 1 : 0];
  }

  const listLength = list.length;
  index += shouldGetNext ? 1 : -1;

  if (isCycleAllowed) {
    index = (index + listLength) % listLength;
  }

  return list[Math.max(0, Math.min(index, listLength - 1))];
};

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): dom/event-handler.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */
/**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */

const namespaceRegex = /[^.]*(?=\..*)\.|.*/;
const stripNameRegex = /\..*/;
const stripUidRegex = /::\d+$/;
const eventRegistry = {}; // Events storage

let uidEvent = 1;
const customEvents = {
  mouseenter: 'mouseover',
  mouseleave: 'mouseout'
};
const customEventsRegex = /^(mouseenter|mouseleave)/i;
const nativeEvents = new Set(['click', 'dblclick', 'mouseup', 'mousedown', 'contextmenu', 'mousewheel', 'DOMMouseScroll', 'mouseover', 'mouseout', 'mousemove', 'selectstart', 'selectend', 'keydown', 'keypress', 'keyup', 'orientationchange', 'touchstart', 'touchmove', 'touchend', 'touchcancel', 'pointerdown', 'pointermove', 'pointerup', 'pointerleave', 'pointercancel', 'gesturestart', 'gesturechange', 'gestureend', 'focus', 'blur', 'change', 'reset', 'select', 'submit', 'focusin', 'focusout', 'load', 'unload', 'beforeunload', 'resize', 'move', 'DOMContentLoaded', 'readystatechange', 'error', 'abort', 'scroll']);
/**
 * ------------------------------------------------------------------------
 * Private methods
 * ------------------------------------------------------------------------
 */

function getUidEvent(element, uid) {
  return uid && `${uid}::${uidEvent++}` || element.uidEvent || uidEvent++;
}

function getEvent(element) {
  const uid = getUidEvent(element);
  element.uidEvent = uid;
  eventRegistry[uid] = eventRegistry[uid] || {};
  return eventRegistry[uid];
}

function bootstrapHandler(element, fn) {
  return function handler(event) {
    event.delegateTarget = element;

    if (handler.oneOff) {
      EventHandler.off(element, event.type, fn);
    }

    return fn.apply(element, [event]);
  };
}

function bootstrapDelegationHandler(element, selector, fn) {
  return function handler(event) {
    const domElements = element.querySelectorAll(selector);

    for (let {
      target
    } = event; target && target !== this; target = target.parentNode) {
      for (let i = domElements.length; i--;) {
        if (domElements[i] === target) {
          event.delegateTarget = target;

          if (handler.oneOff) {
            EventHandler.off(element, event.type, selector, fn);
          }

          return fn.apply(target, [event]);
        }
      }
    } // To please ESLint


    return null;
  };
}

function findHandler(events, handler, delegationSelector = null) {
  const uidEventList = Object.keys(events);

  for (let i = 0, len = uidEventList.length; i < len; i++) {
    const event = events[uidEventList[i]];

    if (event.originalHandler === handler && event.delegationSelector === delegationSelector) {
      return event;
    }
  }

  return null;
}

function normalizeParams(originalTypeEvent, handler, delegationFn) {
  const delegation = typeof handler === 'string';
  const originalHandler = delegation ? delegationFn : handler;
  let typeEvent = getTypeEvent(originalTypeEvent);
  const isNative = nativeEvents.has(typeEvent);

  if (!isNative) {
    typeEvent = originalTypeEvent;
  }

  return [delegation, originalHandler, typeEvent];
}

function addHandler(element, originalTypeEvent, handler, delegationFn, oneOff) {
  if (typeof originalTypeEvent !== 'string' || !element) {
    return;
  }

  if (!handler) {
    handler = delegationFn;
    delegationFn = null;
  } // in case of mouseenter or mouseleave wrap the handler within a function that checks for its DOM position
  // this prevents the handler from being dispatched the same way as mouseover or mouseout does


  if (customEventsRegex.test(originalTypeEvent)) {
    const wrapFn = fn => {
      return function (event) {
        if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) {
          return fn.call(this, event);
        }
      };
    };

    if (delegationFn) {
      delegationFn = wrapFn(delegationFn);
    } else {
      handler = wrapFn(handler);
    }
  }

  const [delegation, originalHandler, typeEvent] = normalizeParams(originalTypeEvent, handler, delegationFn);
  const events = getEvent(element);
  const handlers = events[typeEvent] || (events[typeEvent] = {});
  const previousFn = findHandler(handlers, originalHandler, delegation ? handler : null);

  if (previousFn) {
    previousFn.oneOff = previousFn.oneOff && oneOff;
    return;
  }

  const uid = getUidEvent(originalHandler, originalTypeEvent.replace(namespaceRegex, ''));
  const fn = delegation ? bootstrapDelegationHandler(element, handler, delegationFn) : bootstrapHandler(element, handler);
  fn.delegationSelector = delegation ? handler : null;
  fn.originalHandler = originalHandler;
  fn.oneOff = oneOff;
  fn.uidEvent = uid;
  handlers[uid] = fn;
  element.addEventListener(typeEvent, fn, delegation);
}

function removeHandler(element, events, typeEvent, handler, delegationSelector) {
  const fn = findHandler(events[typeEvent], handler, delegationSelector);

  if (!fn) {
    return;
  }

  element.removeEventListener(typeEvent, fn, Boolean(delegationSelector));
  delete events[typeEvent][fn.uidEvent];
}

function removeNamespacedHandlers(element, events, typeEvent, namespace) {
  const storeElementEvent = events[typeEvent] || {};
  Object.keys(storeElementEvent).forEach(handlerKey => {
    if (handlerKey.includes(namespace)) {
      const event = storeElementEvent[handlerKey];
      removeHandler(element, events, typeEvent, event.originalHandler, event.delegationSelector);
    }
  });
}

function getTypeEvent(event) {
  // allow to get the native events from namespaced events ('click.bs.button' --> 'click')
  event = event.replace(stripNameRegex, '');
  return customEvents[event] || event;
}

const EventHandler = {
  on(element, event, handler, delegationFn) {
    addHandler(element, event, handler, delegationFn, false);
  },

  one(element, event, handler, delegationFn) {
    addHandler(element, event, handler, delegationFn, true);
  },

  off(element, originalTypeEvent, handler, delegationFn) {
    if (typeof originalTypeEvent !== 'string' || !element) {
      return;
    }

    const [delegation, originalHandler, typeEvent] = normalizeParams(originalTypeEvent, handler, delegationFn);
    const inNamespace = typeEvent !== originalTypeEvent;
    const events = getEvent(element);
    const isNamespace = originalTypeEvent.startsWith('.');

    if (typeof originalHandler !== 'undefined') {
      // Simplest case: handler is passed, remove that listener ONLY.
      if (!events || !events[typeEvent]) {
        return;
      }

      removeHandler(element, events, typeEvent, originalHandler, delegation ? handler : null);
      return;
    }

    if (isNamespace) {
      Object.keys(events).forEach(elementEvent => {
        removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1));
      });
    }

    const storeElementEvent = events[typeEvent] || {};
    Object.keys(storeElementEvent).forEach(keyHandlers => {
      const handlerKey = keyHandlers.replace(stripUidRegex, '');

      if (!inNamespace || originalTypeEvent.includes(handlerKey)) {
        const event = storeElementEvent[keyHandlers];
        removeHandler(element, events, typeEvent, event.originalHandler, event.delegationSelector);
      }
    });
  },

  trigger(element, event, args) {
    if (typeof event !== 'string' || !element) {
      return null;
    }

    const $ = getjQuery();
    const typeEvent = getTypeEvent(event);
    const inNamespace = event !== typeEvent;
    const isNative = nativeEvents.has(typeEvent);
    let jQueryEvent;
    let bubbles = true;
    let nativeDispatch = true;
    let defaultPrevented = false;
    let evt = null;

    if (inNamespace && $) {
      jQueryEvent = $.Event(event, args);
      $(element).trigger(jQueryEvent);
      bubbles = !jQueryEvent.isPropagationStopped();
      nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();
      defaultPrevented = jQueryEvent.isDefaultPrevented();
    }

    if (isNative) {
      evt = document.createEvent('HTMLEvents');
      evt.initEvent(typeEvent, bubbles, true);
    } else {
      evt = new CustomEvent(event, {
        bubbles,
        cancelable: true
      });
    } // merge custom information in our event


    if (typeof args !== 'undefined') {
      Object.keys(args).forEach(key => {
        Object.defineProperty(evt, key, {
          get() {
            return args[key];
          }

        });
      });
    }

    if (defaultPrevented) {
      evt.preventDefault();
    }

    if (nativeDispatch) {
      element.dispatchEvent(evt);
    }

    if (evt.defaultPrevented && typeof jQueryEvent !== 'undefined') {
      jQueryEvent.preventDefault();
    }

    return evt;
  }

};

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): dom/data.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

/**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */
const elementMap = new Map();
const Data = {
  set(element, key, instance) {
    if (!elementMap.has(element)) {
      elementMap.set(element, new Map());
    }

    const instanceMap = elementMap.get(element); // make it clear we only want one instance per element
    // can be removed later when multiple key/instances are fine to be used

    if (!instanceMap.has(key) && instanceMap.size !== 0) {
      // eslint-disable-next-line no-console
      console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(instanceMap.keys())[0]}.`);
      return;
    }

    instanceMap.set(key, instance);
  },

  get(element, key) {
    if (elementMap.has(element)) {
      return elementMap.get(element).get(key) || null;
    }

    return null;
  },

  remove(element, key) {
    if (!elementMap.has(element)) {
      return;
    }

    const instanceMap = elementMap.get(element);
    instanceMap.delete(key); // free up element references if there are no instances left for an element

    if (instanceMap.size === 0) {
      elementMap.delete(element);
    }
  }

};

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): base-component.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */
/**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */

const VERSION = '5.1.3';

class BaseComponent {
  constructor(element) {
    element = getElement(element);

    if (!element) {
      return;
    }

    this._element = element;
    Data.set(this._element, this.constructor.DATA_KEY, this);
  }

  dispose() {
    Data.remove(this._element, this.constructor.DATA_KEY);
    EventHandler.off(this._element, this.constructor.EVENT_KEY);
    Object.getOwnPropertyNames(this).forEach(propertyName => {
      this[propertyName] = null;
    });
  }

  _queueCallback(callback, element, isAnimated = true) {
    executeAfterTransition(callback, element, isAnimated);
  }
  /** Static */


  static getInstance(element) {
    return Data.get(getElement(element), this.DATA_KEY);
  }

  static getOrCreateInstance(element, config = {}) {
    return this.getInstance(element) || new this(element, typeof config === 'object' ? config : null);
  }

  static get VERSION() {
    return VERSION;
  }

  static get NAME() {
    throw new Error('You have to implement the static method "NAME", for each component!');
  }

  static get DATA_KEY() {
    return `bs.${this.NAME}`;
  }

  static get EVENT_KEY() {
    return `.${this.DATA_KEY}`;
  }

}

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): util/component-functions.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */

const enableDismissTrigger = (component, method = 'hide') => {
  const clickEvent = `click.dismiss${component.EVENT_KEY}`;
  const name = component.NAME;
  EventHandler.on(document, clickEvent, `[data-bs-dismiss="${name}"]`, function (event) {
    if (['A', 'AREA'].includes(this.tagName)) {
      event.preventDefault();
    }

    if (isDisabled(this)) {
      return;
    }

    const target = getElementFromSelector(this) || this.closest(`.${name}`);
    const instance = component.getOrCreateInstance(target); // Method argument is left, for Alert and only, as it doesn't implement the 'hide' method

    instance[method]();
  });
};

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): alert.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */
/**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */

const NAME$d = 'alert';
const DATA_KEY$c = 'bs.alert';
const EVENT_KEY$c = `.${DATA_KEY$c}`;
const EVENT_CLOSE = `close${EVENT_KEY$c}`;
const EVENT_CLOSED = `closed${EVENT_KEY$c}`;
const CLASS_NAME_FADE$5 = 'fade';
const CLASS_NAME_SHOW$8 = 'show';
/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */

class Alert extends BaseComponent {
  // Getters
  static get NAME() {
    return NAME$d;
  } // Public


  close() {
    const closeEvent = EventHandler.trigger(this._element, EVENT_CLOSE);

    if (closeEvent.defaultPrevented) {
      return;
    }

    this._element.classList.remove(CLASS_NAME_SHOW$8);

    const isAnimated = this._element.classList.contains(CLASS_NAME_FADE$5);

    this._queueCallback(() => this._destroyElement(), this._element, isAnimated);
  } // Private


  _destroyElement() {
    this._element.remove();

    EventHandler.trigger(this._element, EVENT_CLOSED);
    this.dispose();
  } // Static


  static jQueryInterface(config) {
    return this.each(function () {
      const data = Alert.getOrCreateInstance(this);

      if (typeof config !== 'string') {
        return;
      }

      if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {
        throw new TypeError(`No method named "${config}"`);
      }

      data[config](this);
    });
  }

}
/**
 * ------------------------------------------------------------------------
 * Data Api implementation
 * ------------------------------------------------------------------------
 */


enableDismissTrigger(Alert, 'close');
/**
 * ------------------------------------------------------------------------
 * jQuery
 * ------------------------------------------------------------------------
 * add .Alert to jQuery only if jQuery is present
 */

defineJQueryPlugin(Alert);

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): button.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */
/**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */

const NAME$c = 'button';
const DATA_KEY$b = 'bs.button';
const EVENT_KEY$b = `.${DATA_KEY$b}`;
const DATA_API_KEY$7 = '.data-api';
const CLASS_NAME_ACTIVE$3 = 'active';
const SELECTOR_DATA_TOGGLE$5 = '[data-bs-toggle="button"]';
const EVENT_CLICK_DATA_API$6 = `click${EVENT_KEY$b}${DATA_API_KEY$7}`;
/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */

class Button extends BaseComponent {
  // Getters
  static get NAME() {
    return NAME$c;
  } // Public


  toggle() {
    // Toggle class and sync the `aria-pressed` attribute with the return value of the `.toggle()` method
    this._element.setAttribute('aria-pressed', this._element.classList.toggle(CLASS_NAME_ACTIVE$3));
  } // Static


  static jQueryInterface(config) {
    return this.each(function () {
      const data = Button.getOrCreateInstance(this);

      if (config === 'toggle') {
        data[config]();
      }
    });
  }

}
/**
 * ------------------------------------------------------------------------
 * Data Api implementation
 * ------------------------------------------------------------------------
 */


EventHandler.on(document, EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$5, event => {
  event.preventDefault();
  const button = event.target.closest(SELECTOR_DATA_TOGGLE$5);
  const data = Button.getOrCreateInstance(button);
  data.toggle();
});
/**
 * ------------------------------------------------------------------------
 * jQuery
 * ------------------------------------------------------------------------
 * add .Button to jQuery only if jQuery is present
 */

defineJQueryPlugin(Button);

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): dom/manipulator.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */
function normalizeData(val) {
  if (val === 'true') {
    return true;
  }

  if (val === 'false') {
    return false;
  }

  if (val === Number(val).toString()) {
    return Number(val);
  }

  if (val === '' || val === 'null') {
    return null;
  }

  return val;
}

function normalizeDataKey(key) {
  return key.replace(/[A-Z]/g, chr => `-${chr.toLowerCase()}`);
}

const Manipulator = {
  setDataAttribute(element, key, value) {
    element.setAttribute(`data-bs-${normalizeDataKey(key)}`, value);
  },

  removeDataAttribute(element, key) {
    element.removeAttribute(`data-bs-${normalizeDataKey(key)}`);
  },

  getDataAttributes(element) {
    if (!element) {
      return {};
    }

    const attributes = {};
    Object.keys(element.dataset).filter(key => key.startsWith('bs')).forEach(key => {
      let pureKey = key.replace(/^bs/, '');
      pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1, pureKey.length);
      attributes[pureKey] = normalizeData(element.dataset[key]);
    });
    return attributes;
  },

  getDataAttribute(element, key) {
    return normalizeData(element.getAttribute(`data-bs-${normalizeDataKey(key)}`));
  },

  offset(element) {
    const rect = element.getBoundingClientRect();
    return {
      top: rect.top + window.pageYOffset,
      left: rect.left + window.pageXOffset
    };
  },

  position(element) {
    return {
      top: element.offsetTop,
      left: element.offsetLeft
    };
  }

};

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): dom/selector-engine.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */
const NODE_TEXT = 3;
const SelectorEngine = {
  find(selector, element = document.documentElement) {
    return [].concat(...Element.prototype.querySelectorAll.call(element, selector));
  },

  findOne(selector, element = document.documentElement) {
    return Element.prototype.querySelector.call(element, selector);
  },

  children(element, selector) {
    return [].concat(...element.children).filter(child => child.matches(selector));
  },

  parents(element, selector) {
    const parents = [];
    let ancestor = element.parentNode;

    while (ancestor && ancestor.nodeType === Node.ELEMENT_NODE && ancestor.nodeType !== NODE_TEXT) {
      if (ancestor.matches(selector)) {
        parents.push(ancestor);
      }

      ancestor = ancestor.parentNode;
    }

    return parents;
  },

  prev(element, selector) {
    let previous = element.previousElementSibling;

    while (previous) {
      if (previous.matches(selector)) {
        return [previous];
      }

      previous = previous.previousElementSibling;
    }

    return [];
  },

  next(element, selector) {
    let next = element.nextElementSibling;

    while (next) {
      if (next.matches(selector)) {
        return [next];
      }

      next = next.nextElementSibling;
    }

    return [];
  },

  focusableChildren(element) {
    const focusables = ['a', 'button', 'input', 'textarea', 'select', 'details', '[tabindex]', '[contenteditable="true"]'].map(selector => `${selector}:not([tabindex^="-"])`).join(', ');
    return this.find(focusables, element).filter(el => !isDisabled(el) && isVisible(el));
  }

};

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): carousel.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */
/**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */

const NAME$b = 'carousel';
const DATA_KEY$a = 'bs.carousel';
const EVENT_KEY$a = `.${DATA_KEY$a}`;
const DATA_API_KEY$6 = '.data-api';
const ARROW_LEFT_KEY = 'ArrowLeft';
const ARROW_RIGHT_KEY = 'ArrowRight';
const TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch

const SWIPE_THRESHOLD = 40;
const Default$a = {
  interval: 5000,
  keyboard: true,
  slide: false,
  pause: 'hover',
  wrap: true,
  touch: true
};
const DefaultType$a = {
  interval: '(number|boolean)',
  keyboard: 'boolean',
  slide: '(boolean|string)',
  pause: '(string|boolean)',
  wrap: 'boolean',
  touch: 'boolean'
};
const ORDER_NEXT = 'next';
const ORDER_PREV = 'prev';
const DIRECTION_LEFT = 'left';
const DIRECTION_RIGHT = 'right';
const KEY_TO_DIRECTION = {
  [ARROW_LEFT_KEY]: DIRECTION_RIGHT,
  [ARROW_RIGHT_KEY]: DIRECTION_LEFT
};
const EVENT_SLIDE = `slide${EVENT_KEY$a}`;
const EVENT_SLID = `slid${EVENT_KEY$a}`;
const EVENT_KEYDOWN = `keydown${EVENT_KEY$a}`;
const EVENT_MOUSEENTER = `mouseenter${EVENT_KEY$a}`;
const EVENT_MOUSELEAVE = `mouseleave${EVENT_KEY$a}`;
const EVENT_TOUCHSTART = `touchstart${EVENT_KEY$a}`;
const EVENT_TOUCHMOVE = `touchmove${EVENT_KEY$a}`;
const EVENT_TOUCHEND = `touchend${EVENT_KEY$a}`;
const EVENT_POINTERDOWN = `pointerdown${EVENT_KEY$a}`;
const EVENT_POINTERUP = `pointerup${EVENT_KEY$a}`;
const EVENT_DRAG_START = `dragstart${EVENT_KEY$a}`;
const EVENT_LOAD_DATA_API$2 = `load${EVENT_KEY$a}${DATA_API_KEY$6}`;
const EVENT_CLICK_DATA_API$5 = `click${EVENT_KEY$a}${DATA_API_KEY$6}`;
const CLASS_NAME_CAROUSEL = 'carousel';
const CLASS_NAME_ACTIVE$2 = 'active';
const CLASS_NAME_SLIDE = 'slide';
const CLASS_NAME_END = 'carousel-item-end';
const CLASS_NAME_START = 'carousel-item-start';
const CLASS_NAME_NEXT = 'carousel-item-next';
const CLASS_NAME_PREV = 'carousel-item-prev';
const CLASS_NAME_POINTER_EVENT = 'pointer-event';
const SELECTOR_ACTIVE$1 = '.active';
const SELECTOR_ACTIVE_ITEM = '.active.carousel-item';
const SELECTOR_ITEM = '.carousel-item';
const SELECTOR_ITEM_IMG = '.carousel-item img';
const SELECTOR_NEXT_PREV = '.carousel-item-next, .carousel-item-prev';
const SELECTOR_INDICATORS = '.carousel-indicators';
const SELECTOR_INDICATOR = '[data-bs-target]';
const SELECTOR_DATA_SLIDE = '[data-bs-slide], [data-bs-slide-to]';
const SELECTOR_DATA_RIDE = '[data-bs-ride="carousel"]';
const POINTER_TYPE_TOUCH = 'touch';
const POINTER_TYPE_PEN = 'pen';
/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */

class Carousel extends BaseComponent {
  constructor(element, config) {
    super(element);
    this._items = null;
    this._interval = null;
    this._activeElement = null;
    this._isPaused = false;
    this._isSliding = false;
    this.touchTimeout = null;
    this.touchStartX = 0;
    this.touchDeltaX = 0;
    this._config = this._getConfig(config);
    this._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, this._element);
    this._touchSupported = 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0;
    this._pointerEvent = Boolean(window.PointerEvent);

    this._addEventListeners();
  } // Getters


  static get Default() {
    return Default$a;
  }

  static get NAME() {
    return NAME$b;
  } // Public


  next() {
    this._slide(ORDER_NEXT);
  }

  nextWhenVisible() {
    // Don't call next when the page isn't visible
    // or the carousel or its parent isn't visible
    if (!document.hidden && isVisible(this._element)) {
      this.next();
    }
  }

  prev() {
    this._slide(ORDER_PREV);
  }

  pause(event) {
    if (!event) {
      this._isPaused = true;
    }

    if (SelectorEngine.findOne(SELECTOR_NEXT_PREV, this._element)) {
      triggerTransitionEnd(this._element);
      this.cycle(true);
    }

    clearInterval(this._interval);
    this._interval = null;
  }

  cycle(event) {
    if (!event) {
      this._isPaused = false;
    }

    if (this._interval) {
      clearInterval(this._interval);
      this._interval = null;
    }

    if (this._config && this._config.interval && !this._isPaused) {
      this._updateInterval();

      this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval);
    }
  }

  to(index) {
    this._activeElement = SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);

    const activeIndex = this._getItemIndex(this._activeElement);

    if (index > this._items.length - 1 || index < 0) {
      return;
    }

    if (this._isSliding) {
      EventHandler.one(this._element, EVENT_SLID, () => this.to(index));
      return;
    }

    if (activeIndex === index) {
      this.pause();
      this.cycle();
      return;
    }

    const order = index > activeIndex ? ORDER_NEXT : ORDER_PREV;

    this._slide(order, this._items[index]);
  } // Private


  _getConfig(config) {
    config = { ...Default$a,
      ...Manipulator.getDataAttributes(this._element),
      ...(typeof config === 'object' ? config : {})
    };
    typeCheckConfig(NAME$b, config, DefaultType$a);
    return config;
  }

  _handleSwipe() {
    const absDeltax = Math.abs(this.touchDeltaX);

    if (absDeltax <= SWIPE_THRESHOLD) {
      return;
    }

    const direction = absDeltax / this.touchDeltaX;
    this.touchDeltaX = 0;

    if (!direction) {
      return;
    }

    this._slide(direction > 0 ? DIRECTION_RIGHT : DIRECTION_LEFT);
  }

  _addEventListeners() {
    if (this._config.keyboard) {
      EventHandler.on(this._element, EVENT_KEYDOWN, event => this._keydown(event));
    }

    if (this._config.pause === 'hover') {
      EventHandler.on(this._element, EVENT_MOUSEENTER, event => this.pause(event));
      EventHandler.on(this._element, EVENT_MOUSELEAVE, event => this.cycle(event));
    }

    if (this._config.touch && this._touchSupported) {
      this._addTouchEventListeners();
    }
  }

  _addTouchEventListeners() {
    const hasPointerPenTouch = event => {
      return this._pointerEvent && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH);
    };

    const start = event => {
      if (hasPointerPenTouch(event)) {
        this.touchStartX = event.clientX;
      } else if (!this._pointerEvent) {
        this.touchStartX = event.touches[0].clientX;
      }
    };

    const move = event => {
      // ensure swiping with one touch and not pinching
      this.touchDeltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - this.touchStartX;
    };

    const end = event => {
      if (hasPointerPenTouch(event)) {
        this.touchDeltaX = event.clientX - this.touchStartX;
      }

      this._handleSwipe();

      if (this._config.pause === 'hover') {
        // If it's a touch-enabled device, mouseenter/leave are fired as
        // part of the mouse compatibility events on first tap - the carousel
        // would stop cycling until user tapped out of it;
        // here, we listen for touchend, explicitly pause the carousel
        // (as if it's the second time we tap on it, mouseenter compat event
        // is NOT fired) and after a timeout (to allow for mouse compatibility
        // events to fire) we explicitly restart cycling
        this.pause();

        if (this.touchTimeout) {
          clearTimeout(this.touchTimeout);
        }

        this.touchTimeout = setTimeout(event => this.cycle(event), TOUCHEVENT_COMPAT_WAIT + this._config.interval);
      }
    };

    SelectorEngine.find(SELECTOR_ITEM_IMG, this._element).forEach(itemImg => {
      EventHandler.on(itemImg, EVENT_DRAG_START, event => event.preventDefault());
    });

    if (this._pointerEvent) {
      EventHandler.on(this._element, EVENT_POINTERDOWN, event => start(event));
      EventHandler.on(this._element, EVENT_POINTERUP, event => end(event));

      this._element.classList.add(CLASS_NAME_POINTER_EVENT);
    } else {
      EventHandler.on(this._element, EVENT_TOUCHSTART, event => start(event));
      EventHandler.on(this._element, EVENT_TOUCHMOVE, event => move(event));
      EventHandler.on(this._element, EVENT_TOUCHEND, event => end(event));
    }
  }

  _keydown(event) {
    if (/input|textarea/i.test(event.target.tagName)) {
      return;
    }

    const direction = KEY_TO_DIRECTION[event.key];

    if (direction) {
      event.preventDefault();

      this._slide(direction);
    }
  }

  _getItemIndex(element) {
    this._items = element && element.parentNode ? SelectorEngine.find(SELECTOR_ITEM, element.parentNode) : [];
    return this._items.indexOf(element);
  }

  _getItemByOrder(order, activeElement) {
    const isNext = order === ORDER_NEXT;
    return getNextActiveElement(this._items, activeElement, isNext, this._config.wrap);
  }

  _triggerSlideEvent(relatedTarget, eventDirectionName) {
    const targetIndex = this._getItemIndex(relatedTarget);

    const fromIndex = this._getItemIndex(SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element));

    return EventHandler.trigger(this._element, EVENT_SLIDE, {
      relatedTarget,
      direction: eventDirectionName,
      from: fromIndex,
      to: targetIndex
    });
  }

  _setActiveIndicatorElement(element) {
    if (this._indicatorsElement) {
      const activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE$1, this._indicatorsElement);
      activeIndicator.classList.remove(CLASS_NAME_ACTIVE$2);
      activeIndicator.removeAttribute('aria-current');
      const indicators = SelectorEngine.find(SELECTOR_INDICATOR, this._indicatorsElement);

      for (let i = 0; i < indicators.length; i++) {
        if (Number.parseInt(indicators[i].getAttribute('data-bs-slide-to'), 10) === this._getItemIndex(element)) {
          indicators[i].classList.add(CLASS_NAME_ACTIVE$2);
          indicators[i].setAttribute('aria-current', 'true');
          break;
        }
      }
    }
  }

  _updateInterval() {
    const element = this._activeElement || SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);

    if (!element) {
      return;
    }

    const elementInterval = Number.parseInt(element.getAttribute('data-bs-interval'), 10);

    if (elementInterval) {
      this._config.defaultInterval = this._config.defaultInterval || this._config.interval;
      this._config.interval = elementInterval;
    } else {
      this._config.interval = this._config.defaultInterval || this._config.interval;
    }
  }

  _slide(directionOrOrder, element) {
    const order = this._directionToOrder(directionOrOrder);

    const activeElement = SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);

    const activeElementIndex = this._getItemIndex(activeElement);

    const nextElement = element || this._getItemByOrder(order, activeElement);

    const nextElementIndex = this._getItemIndex(nextElement);

    const isCycling = Boolean(this._interval);
    const isNext = order === ORDER_NEXT;
    const directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;
    const orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;

    const eventDirectionName = this._orderToDirection(order);

    if (nextElement && nextElement.classList.contains(CLASS_NAME_ACTIVE$2)) {
      this._isSliding = false;
      return;
    }

    if (this._isSliding) {
      return;
    }

    const slideEvent = this._triggerSlideEvent(nextElement, eventDirectionName);

    if (slideEvent.defaultPrevented) {
      return;
    }

    if (!activeElement || !nextElement) {
      // Some weirdness is happening, so we bail
      return;
    }

    this._isSliding = true;

    if (isCycling) {
      this.pause();
    }

    this._setActiveIndicatorElement(nextElement);

    this._activeElement = nextElement;

    const triggerSlidEvent = () => {
      EventHandler.trigger(this._element, EVENT_SLID, {
        relatedTarget: nextElement,
        direction: eventDirectionName,
        from: activeElementIndex,
        to: nextElementIndex
      });
    };

    if (this._element.classList.contains(CLASS_NAME_SLIDE)) {
      nextElement.classList.add(orderClassName);
      reflow(nextElement);
      activeElement.classList.add(directionalClassName);
      nextElement.classList.add(directionalClassName);

      const completeCallBack = () => {
        nextElement.classList.remove(directionalClassName, orderClassName);
        nextElement.classList.add(CLASS_NAME_ACTIVE$2);
        activeElement.classList.remove(CLASS_NAME_ACTIVE$2, orderClassName, directionalClassName);
        this._isSliding = false;
        setTimeout(triggerSlidEvent, 0);
      };

      this._queueCallback(completeCallBack, activeElement, true);
    } else {
      activeElement.classList.remove(CLASS_NAME_ACTIVE$2);
      nextElement.classList.add(CLASS_NAME_ACTIVE$2);
      this._isSliding = false;
      triggerSlidEvent();
    }

    if (isCycling) {
      this.cycle();
    }
  }

  _directionToOrder(direction) {
    if (![DIRECTION_RIGHT, DIRECTION_LEFT].includes(direction)) {
      return direction;
    }

    if (isRTL()) {
      return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;
    }

    return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;
  }

  _orderToDirection(order) {
    if (![ORDER_NEXT, ORDER_PREV].includes(order)) {
      return order;
    }

    if (isRTL()) {
      return order === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }

    return order === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;
  } // Static


  static carouselInterface(element, config) {
    const data = Carousel.getOrCreateInstance(element, config);
    let {
      _config
    } = data;

    if (typeof config === 'object') {
      _config = { ..._config,
        ...config
      };
    }

    const action = typeof config === 'string' ? config : _config.slide;

    if (typeof config === 'number') {
      data.to(config);
    } else if (typeof action === 'string') {
      if (typeof data[action] === 'undefined') {
        throw new TypeError(`No method named "${action}"`);
      }

      data[action]();
    } else if (_config.interval && _config.ride) {
      data.pause();
      data.cycle();
    }
  }

  static jQueryInterface(config) {
    return this.each(function () {
      Carousel.carouselInterface(this, config);
    });
  }

  static dataApiClickHandler(event) {
    const target = getElementFromSelector(this);

    if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) {
      return;
    }

    const config = { ...Manipulator.getDataAttributes(target),
      ...Manipulator.getDataAttributes(this)
    };
    const slideIndex = this.getAttribute('data-bs-slide-to');

    if (slideIndex) {
      config.interval = false;
    }

    Carousel.carouselInterface(target, config);

    if (slideIndex) {
      Carousel.getInstance(target).to(slideIndex);
    }

    event.preventDefault();
  }

}
/**
 * ------------------------------------------------------------------------
 * Data Api implementation
 * ------------------------------------------------------------------------
 */


EventHandler.on(document, EVENT_CLICK_DATA_API$5, SELECTOR_DATA_SLIDE, Carousel.dataApiClickHandler);
EventHandler.on(window, EVENT_LOAD_DATA_API$2, () => {
  const carousels = SelectorEngine.find(SELECTOR_DATA_RIDE);

  for (let i = 0, len = carousels.length; i < len; i++) {
    Carousel.carouselInterface(carousels[i], Carousel.getInstance(carousels[i]));
  }
});
/**
 * ------------------------------------------------------------------------
 * jQuery
 * ------------------------------------------------------------------------
 * add .Carousel to jQuery only if jQuery is present
 */

defineJQueryPlugin(Carousel);

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): collapse.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */
/**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */

const NAME$a = 'collapse';
const DATA_KEY$9 = 'bs.collapse';
const EVENT_KEY$9 = `.${DATA_KEY$9}`;
const DATA_API_KEY$5 = '.data-api';
const Default$9 = {
  toggle: true,
  parent: null
};
const DefaultType$9 = {
  toggle: 'boolean',
  parent: '(null|element)'
};
const EVENT_SHOW$5 = `show${EVENT_KEY$9}`;
const EVENT_SHOWN$5 = `shown${EVENT_KEY$9}`;
const EVENT_HIDE$5 = `hide${EVENT_KEY$9}`;
const EVENT_HIDDEN$5 = `hidden${EVENT_KEY$9}`;
const EVENT_CLICK_DATA_API$4 = `click${EVENT_KEY$9}${DATA_API_KEY$5}`;
const CLASS_NAME_SHOW$7 = 'show';
const CLASS_NAME_COLLAPSE = 'collapse';
const CLASS_NAME_COLLAPSING = 'collapsing';
const CLASS_NAME_COLLAPSED = 'collapsed';
const CLASS_NAME_DEEPER_CHILDREN = `:scope .${CLASS_NAME_COLLAPSE} .${CLASS_NAME_COLLAPSE}`;
const CLASS_NAME_HORIZONTAL = 'collapse-horizontal';
const WIDTH = 'width';
const HEIGHT = 'height';
const SELECTOR_ACTIVES = '.collapse.show, .collapse.collapsing';
const SELECTOR_DATA_TOGGLE$4 = '[data-bs-toggle="collapse"]';
/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */

class Collapse extends BaseComponent {
  constructor(element, config) {
    super(element);
    this._isTransitioning = false;
    this._config = this._getConfig(config);
    this._triggerArray = [];
    const toggleList = SelectorEngine.find(SELECTOR_DATA_TOGGLE$4);

    for (let i = 0, len = toggleList.length; i < len; i++) {
      const elem = toggleList[i];
      const selector = getSelectorFromElement(elem);
      const filterElement = SelectorEngine.find(selector).filter(foundElem => foundElem === this._element);

      if (selector !== null && filterElement.length) {
        this._selector = selector;

        this._triggerArray.push(elem);
      }
    }

    this._initializeChildren();

    if (!this._config.parent) {
      this._addAriaAndCollapsedClass(this._triggerArray, this._isShown());
    }

    if (this._config.toggle) {
      this.toggle();
    }
  } // Getters


  static get Default() {
    return Default$9;
  }

  static get NAME() {
    return NAME$a;
  } // Public


  toggle() {
    if (this._isShown()) {
      this.hide();
    } else {
      this.show();
    }
  }

  show() {
    if (this._isTransitioning || this._isShown()) {
      return;
    }

    let actives = [];
    let activesData;

    if (this._config.parent) {
      const children = SelectorEngine.find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent);
      actives = SelectorEngine.find(SELECTOR_ACTIVES, this._config.parent).filter(elem => !children.includes(elem)); // remove children if greater depth
    }

    const container = SelectorEngine.findOne(this._selector);

    if (actives.length) {
      const tempActiveData = actives.find(elem => container !== elem);
      activesData = tempActiveData ? Collapse.getInstance(tempActiveData) : null;

      if (activesData && activesData._isTransitioning) {
        return;
      }
    }

    const startEvent = EventHandler.trigger(this._element, EVENT_SHOW$5);

    if (startEvent.defaultPrevented) {
      return;
    }

    actives.forEach(elemActive => {
      if (container !== elemActive) {
        Collapse.getOrCreateInstance(elemActive, {
          toggle: false
        }).hide();
      }

      if (!activesData) {
        Data.set(elemActive, DATA_KEY$9, null);
      }
    });

    const dimension = this._getDimension();

    this._element.classList.remove(CLASS_NAME_COLLAPSE);

    this._element.classList.add(CLASS_NAME_COLLAPSING);

    this._element.style[dimension] = 0;

    this._addAriaAndCollapsedClass(this._triggerArray, true);

    this._isTransitioning = true;

    const complete = () => {
      this._isTransitioning = false;

      this._element.classList.remove(CLASS_NAME_COLLAPSING);

      this._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);

      this._element.style[dimension] = '';
      EventHandler.trigger(this._element, EVENT_SHOWN$5);
    };

    const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
    const scrollSize = `scroll${capitalizedDimension}`;

    this._queueCallback(complete, this._element, true);

    this._element.style[dimension] = `${this._element[scrollSize]}px`;
  }

  hide() {
    if (this._isTransitioning || !this._isShown()) {
      return;
    }

    const startEvent = EventHandler.trigger(this._element, EVENT_HIDE$5);

    if (startEvent.defaultPrevented) {
      return;
    }

    const dimension = this._getDimension();

    this._element.style[dimension] = `${this._element.getBoundingClientRect()[dimension]}px`;
    reflow(this._element);

    this._element.classList.add(CLASS_NAME_COLLAPSING);

    this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);

    const triggerArrayLength = this._triggerArray.length;

    for (let i = 0; i < triggerArrayLength; i++) {
      const trigger = this._triggerArray[i];
      const elem = getElementFromSelector(trigger);

      if (elem && !this._isShown(elem)) {
        this._addAriaAndCollapsedClass([trigger], false);
      }
    }

    this._isTransitioning = true;

    const complete = () => {
      this._isTransitioning = false;

      this._element.classList.remove(CLASS_NAME_COLLAPSING);

      this._element.classList.add(CLASS_NAME_COLLAPSE);

      EventHandler.trigger(this._element, EVENT_HIDDEN$5);
    };

    this._element.style[dimension] = '';

    this._queueCallback(complete, this._element, true);
  }

  _isShown(element = this._element) {
    return element.classList.contains(CLASS_NAME_SHOW$7);
  } // Private


  _getConfig(config) {
    config = { ...Default$9,
      ...Manipulator.getDataAttributes(this._element),
      ...config
    };
    config.toggle = Boolean(config.toggle); // Coerce string values

    config.parent = getElement(config.parent);
    typeCheckConfig(NAME$a, config, DefaultType$9);
    return config;
  }

  _getDimension() {
    return this._element.classList.contains(CLASS_NAME_HORIZONTAL) ? WIDTH : HEIGHT;
  }

  _initializeChildren() {
    if (!this._config.parent) {
      return;
    }

    const children = SelectorEngine.find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent);
    SelectorEngine.find(SELECTOR_DATA_TOGGLE$4, this._config.parent).filter(elem => !children.includes(elem)).forEach(element => {
      const selected = getElementFromSelector(element);

      if (selected) {
        this._addAriaAndCollapsedClass([element], this._isShown(selected));
      }
    });
  }

  _addAriaAndCollapsedClass(triggerArray, isOpen) {
    if (!triggerArray.length) {
      return;
    }

    triggerArray.forEach(elem => {
      if (isOpen) {
        elem.classList.remove(CLASS_NAME_COLLAPSED);
      } else {
        elem.classList.add(CLASS_NAME_COLLAPSED);
      }

      elem.setAttribute('aria-expanded', isOpen);
    });
  } // Static


  static jQueryInterface(config) {
    return this.each(function () {
      const _config = {};

      if (typeof config === 'string' && /show|hide/.test(config)) {
        _config.toggle = false;
      }

      const data = Collapse.getOrCreateInstance(this, _config);

      if (typeof config === 'string') {
        if (typeof data[config] === 'undefined') {
          throw new TypeError(`No method named "${config}"`);
        }

        data[config]();
      }
    });
  }

}
/**
 * ------------------------------------------------------------------------
 * Data Api implementation
 * ------------------------------------------------------------------------
 */


EventHandler.on(document, EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$4, function (event) {
  // preventDefault only for <a> elements (which change the URL) not inside the collapsible element
  if (event.target.tagName === 'A' || event.delegateTarget && event.delegateTarget.tagName === 'A') {
    event.preventDefault();
  }

  const selector = getSelectorFromElement(this);
  const selectorElements = SelectorEngine.find(selector);
  selectorElements.forEach(element => {
    Collapse.getOrCreateInstance(element, {
      toggle: false
    }).toggle();
  });
});
/**
 * ------------------------------------------------------------------------
 * jQuery
 * ------------------------------------------------------------------------
 * add .Collapse to jQuery only if jQuery is present
 */

defineJQueryPlugin(Collapse);

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): dropdown.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */
/**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */

const NAME$9 = 'dropdown';
const DATA_KEY$8 = 'bs.dropdown';
const EVENT_KEY$8 = `.${DATA_KEY$8}`;
const DATA_API_KEY$4 = '.data-api';
const ESCAPE_KEY$2 = 'Escape';
const SPACE_KEY = 'Space';
const TAB_KEY$1 = 'Tab';
const ARROW_UP_KEY = 'ArrowUp';
const ARROW_DOWN_KEY = 'ArrowDown';
const RIGHT_MOUSE_BUTTON = 2; // MouseEvent.button value for the secondary button, usually the right button

const REGEXP_KEYDOWN = new RegExp(`${ARROW_UP_KEY}|${ARROW_DOWN_KEY}|${ESCAPE_KEY$2}`);
const EVENT_HIDE$4 = `hide${EVENT_KEY$8}`;
const EVENT_HIDDEN$4 = `hidden${EVENT_KEY$8}`;
const EVENT_SHOW$4 = `show${EVENT_KEY$8}`;
const EVENT_SHOWN$4 = `shown${EVENT_KEY$8}`;
const EVENT_CLICK_DATA_API$3 = `click${EVENT_KEY$8}${DATA_API_KEY$4}`;
const EVENT_KEYDOWN_DATA_API = `keydown${EVENT_KEY$8}${DATA_API_KEY$4}`;
const EVENT_KEYUP_DATA_API = `keyup${EVENT_KEY$8}${DATA_API_KEY$4}`;
const CLASS_NAME_SHOW$6 = 'show';
const CLASS_NAME_DROPUP = 'dropup';
const CLASS_NAME_DROPEND = 'dropend';
const CLASS_NAME_DROPSTART = 'dropstart';
const CLASS_NAME_NAVBAR = 'navbar';
const SELECTOR_DATA_TOGGLE$3 = '[data-bs-toggle="dropdown"]';
const SELECTOR_MENU = '.dropdown-menu';
const SELECTOR_NAVBAR_NAV = '.navbar-nav';
const SELECTOR_VISIBLE_ITEMS = '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)';
const PLACEMENT_TOP = isRTL() ? 'top-end' : 'top-start';
const PLACEMENT_TOPEND = isRTL() ? 'top-start' : 'top-end';
const PLACEMENT_BOTTOM = isRTL() ? 'bottom-end' : 'bottom-start';
const PLACEMENT_BOTTOMEND = isRTL() ? 'bottom-start' : 'bottom-end';
const PLACEMENT_RIGHT = isRTL() ? 'left-start' : 'right-start';
const PLACEMENT_LEFT = isRTL() ? 'right-start' : 'left-start';
const Default$8 = {
  offset: [0, 2],
  boundary: 'clippingParents',
  reference: 'toggle',
  display: 'dynamic',
  popperConfig: null,
  autoClose: true
};
const DefaultType$8 = {
  offset: '(array|string|function)',
  boundary: '(string|element)',
  reference: '(string|element|object)',
  display: 'string',
  popperConfig: '(null|object|function)',
  autoClose: '(boolean|string)'
};
/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */

class Dropdown extends BaseComponent {
  constructor(element, config) {
    super(element);
    this._popper = null;
    this._config = this._getConfig(config);
    this._menu = this._getMenuElement();
    this._inNavbar = this._detectNavbar();
  } // Getters


  static get Default() {
    return Default$8;
  }

  static get DefaultType() {
    return DefaultType$8;
  }

  static get NAME() {
    return NAME$9;
  } // Public


  toggle() {
    return this._isShown() ? this.hide() : this.show();
  }

  show() {
    if (isDisabled(this._element) || this._isShown(this._menu)) {
      return;
    }

    const relatedTarget = {
      relatedTarget: this._element
    };
    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$4, relatedTarget);

    if (showEvent.defaultPrevented) {
      return;
    }

    const parent = Dropdown.getParentFromElement(this._element); // Totally disable Popper for Dropdowns in Navbar

    if (this._inNavbar) {
      Manipulator.setDataAttribute(this._menu, 'popper', 'none');
    } else {
      this._createPopper(parent);
    } // If this is a touch-enabled device we add extra
    // empty mouseover listeners to the body's immediate children;
    // only needed because of broken event delegation on iOS
    // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html


    if ('ontouchstart' in document.documentElement && !parent.closest(SELECTOR_NAVBAR_NAV)) {
      [].concat(...document.body.children).forEach(elem => EventHandler.on(elem, 'mouseover', noop));
    }

    this._element.focus();

    this._element.setAttribute('aria-expanded', true);

    this._menu.classList.add(CLASS_NAME_SHOW$6);

    this._element.classList.add(CLASS_NAME_SHOW$6);

    EventHandler.trigger(this._element, EVENT_SHOWN$4, relatedTarget);
  }

  hide() {
    if (isDisabled(this._element) || !this._isShown(this._menu)) {
      return;
    }

    const relatedTarget = {
      relatedTarget: this._element
    };

    this._completeHide(relatedTarget);
  }

  dispose() {
    if (this._popper) {
      this._popper.destroy();
    }

    super.dispose();
  }

  update() {
    this._inNavbar = this._detectNavbar();

    if (this._popper) {
      this._popper.update();
    }
  } // Private


  _completeHide(relatedTarget) {
    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$4, relatedTarget);

    if (hideEvent.defaultPrevented) {
      return;
    } // If this is a touch-enabled device we remove the extra
    // empty mouseover listeners we added for iOS support


    if ('ontouchstart' in document.documentElement) {
      [].concat(...document.body.children).forEach(elem => EventHandler.off(elem, 'mouseover', noop));
    }

    if (this._popper) {
      this._popper.destroy();
    }

    this._menu.classList.remove(CLASS_NAME_SHOW$6);

    this._element.classList.remove(CLASS_NAME_SHOW$6);

    this._element.setAttribute('aria-expanded', 'false');

    Manipulator.removeDataAttribute(this._menu, 'popper');
    EventHandler.trigger(this._element, EVENT_HIDDEN$4, relatedTarget);
  }

  _getConfig(config) {
    config = { ...this.constructor.Default,
      ...Manipulator.getDataAttributes(this._element),
      ...config
    };
    typeCheckConfig(NAME$9, config, this.constructor.DefaultType);

    if (typeof config.reference === 'object' && !isElement(config.reference) && typeof config.reference.getBoundingClientRect !== 'function') {
      // Popper virtual elements require a getBoundingClientRect method
      throw new TypeError(`${NAME$9.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
    }

    return config;
  }

  _createPopper(parent) {
    if (typeof _popperjs_core__WEBPACK_IMPORTED_MODULE_0__ === 'undefined') {
      throw new TypeError('Bootstrap\'s dropdowns require Popper (https://popper.js.org)');
    }

    let referenceElement = this._element;

    if (this._config.reference === 'parent') {
      referenceElement = parent;
    } else if (isElement(this._config.reference)) {
      referenceElement = getElement(this._config.reference);
    } else if (typeof this._config.reference === 'object') {
      referenceElement = this._config.reference;
    }

    const popperConfig = this._getPopperConfig();

    const isDisplayStatic = popperConfig.modifiers.find(modifier => modifier.name === 'applyStyles' && modifier.enabled === false);
    this._popper = _popperjs_core__WEBPACK_IMPORTED_MODULE_1__.createPopper(referenceElement, this._menu, popperConfig);

    if (isDisplayStatic) {
      Manipulator.setDataAttribute(this._menu, 'popper', 'static');
    }
  }

  _isShown(element = this._element) {
    return element.classList.contains(CLASS_NAME_SHOW$6);
  }

  _getMenuElement() {
    return SelectorEngine.next(this._element, SELECTOR_MENU)[0];
  }

  _getPlacement() {
    const parentDropdown = this._element.parentNode;

    if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) {
      return PLACEMENT_RIGHT;
    }

    if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) {
      return PLACEMENT_LEFT;
    } // We need to trim the value because custom properties can also include spaces


    const isEnd = getComputedStyle(this._menu).getPropertyValue('--bs-position').trim() === 'end';

    if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) {
      return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;
    }

    return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;
  }

  _detectNavbar() {
    return this._element.closest(`.${CLASS_NAME_NAVBAR}`) !== null;
  }

  _getOffset() {
    const {
      offset
    } = this._config;

    if (typeof offset === 'string') {
      return offset.split(',').map(val => Number.parseInt(val, 10));
    }

    if (typeof offset === 'function') {
      return popperData => offset(popperData, this._element);
    }

    return offset;
  }

  _getPopperConfig() {
    const defaultBsPopperConfig = {
      placement: this._getPlacement(),
      modifiers: [{
        name: 'preventOverflow',
        options: {
          boundary: this._config.boundary
        }
      }, {
        name: 'offset',
        options: {
          offset: this._getOffset()
        }
      }]
    }; // Disable Popper if we have a static display

    if (this._config.display === 'static') {
      defaultBsPopperConfig.modifiers = [{
        name: 'applyStyles',
        enabled: false
      }];
    }

    return { ...defaultBsPopperConfig,
      ...(typeof this._config.popperConfig === 'function' ? this._config.popperConfig(defaultBsPopperConfig) : this._config.popperConfig)
    };
  }

  _selectMenuItem({
    key,
    target
  }) {
    const items = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter(isVisible);

    if (!items.length) {
      return;
    } // if target isn't included in items (e.g. when expanding the dropdown)
    // allow cycling to get the last item in case key equals ARROW_UP_KEY


    getNextActiveElement(items, target, key === ARROW_DOWN_KEY, !items.includes(target)).focus();
  } // Static


  static jQueryInterface(config) {
    return this.each(function () {
      const data = Dropdown.getOrCreateInstance(this, config);

      if (typeof config !== 'string') {
        return;
      }

      if (typeof data[config] === 'undefined') {
        throw new TypeError(`No method named "${config}"`);
      }

      data[config]();
    });
  }

  static clearMenus(event) {
    if (event && (event.button === RIGHT_MOUSE_BUTTON || event.type === 'keyup' && event.key !== TAB_KEY$1)) {
      return;
    }

    const toggles = SelectorEngine.find(SELECTOR_DATA_TOGGLE$3);

    for (let i = 0, len = toggles.length; i < len; i++) {
      const context = Dropdown.getInstance(toggles[i]);

      if (!context || context._config.autoClose === false) {
        continue;
      }

      if (!context._isShown()) {
        continue;
      }

      const relatedTarget = {
        relatedTarget: context._element
      };

      if (event) {
        const composedPath = event.composedPath();
        const isMenuTarget = composedPath.includes(context._menu);

        if (composedPath.includes(context._element) || context._config.autoClose === 'inside' && !isMenuTarget || context._config.autoClose === 'outside' && isMenuTarget) {
          continue;
        } // Tab navigation through the dropdown menu or events from contained inputs shouldn't close the menu


        if (context._menu.contains(event.target) && (event.type === 'keyup' && event.key === TAB_KEY$1 || /input|select|option|textarea|form/i.test(event.target.tagName))) {
          continue;
        }

        if (event.type === 'click') {
          relatedTarget.clickEvent = event;
        }
      }

      context._completeHide(relatedTarget);
    }
  }

  static getParentFromElement(element) {
    return getElementFromSelector(element) || element.parentNode;
  }

  static dataApiKeydownHandler(event) {
    // If not input/textarea:
    //  - And not a key in REGEXP_KEYDOWN => not a dropdown command
    // If input/textarea:
    //  - If space key => not a dropdown command
    //  - If key is other than escape
    //    - If key is not up or down => not a dropdown command
    //    - If trigger inside the menu => not a dropdown command
    if (/input|textarea/i.test(event.target.tagName) ? event.key === SPACE_KEY || event.key !== ESCAPE_KEY$2 && (event.key !== ARROW_DOWN_KEY && event.key !== ARROW_UP_KEY || event.target.closest(SELECTOR_MENU)) : !REGEXP_KEYDOWN.test(event.key)) {
      return;
    }

    const isActive = this.classList.contains(CLASS_NAME_SHOW$6);

    if (!isActive && event.key === ESCAPE_KEY$2) {
      return;
    }

    event.preventDefault();
    event.stopPropagation();

    if (isDisabled(this)) {
      return;
    }

    const getToggleButton = this.matches(SELECTOR_DATA_TOGGLE$3) ? this : SelectorEngine.prev(this, SELECTOR_DATA_TOGGLE$3)[0];
    const instance = Dropdown.getOrCreateInstance(getToggleButton);

    if (event.key === ESCAPE_KEY$2) {
      instance.hide();
      return;
    }

    if (event.key === ARROW_UP_KEY || event.key === ARROW_DOWN_KEY) {
      if (!isActive) {
        instance.show();
      }

      instance._selectMenuItem(event);

      return;
    }

    if (!isActive || event.key === SPACE_KEY) {
      Dropdown.clearMenus();
    }
  }

}
/**
 * ------------------------------------------------------------------------
 * Data Api implementation
 * ------------------------------------------------------------------------
 */


EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$3, Dropdown.dataApiKeydownHandler);
EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);
EventHandler.on(document, EVENT_CLICK_DATA_API$3, Dropdown.clearMenus);
EventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);
EventHandler.on(document, EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function (event) {
  event.preventDefault();
  Dropdown.getOrCreateInstance(this).toggle();
});
/**
 * ------------------------------------------------------------------------
 * jQuery
 * ------------------------------------------------------------------------
 * add .Dropdown to jQuery only if jQuery is present
 */

defineJQueryPlugin(Dropdown);

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): util/scrollBar.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */
const SELECTOR_FIXED_CONTENT = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top';
const SELECTOR_STICKY_CONTENT = '.sticky-top';

class ScrollBarHelper {
  constructor() {
    this._element = document.body;
  }

  getWidth() {
    // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth#usage_notes
    const documentWidth = document.documentElement.clientWidth;
    return Math.abs(window.innerWidth - documentWidth);
  }

  hide() {
    const width = this.getWidth();

    this._disableOverFlow(); // give padding to element to balance the hidden scrollbar width


    this._setElementAttributes(this._element, 'paddingRight', calculatedValue => calculatedValue + width); // trick: We adjust positive paddingRight and negative marginRight to sticky-top elements to keep showing fullwidth


    this._setElementAttributes(SELECTOR_FIXED_CONTENT, 'paddingRight', calculatedValue => calculatedValue + width);

    this._setElementAttributes(SELECTOR_STICKY_CONTENT, 'marginRight', calculatedValue => calculatedValue - width);
  }

  _disableOverFlow() {
    this._saveInitialAttribute(this._element, 'overflow');

    this._element.style.overflow = 'hidden';
  }

  _setElementAttributes(selector, styleProp, callback) {
    const scrollbarWidth = this.getWidth();

    const manipulationCallBack = element => {
      if (element !== this._element && window.innerWidth > element.clientWidth + scrollbarWidth) {
        return;
      }

      this._saveInitialAttribute(element, styleProp);

      const calculatedValue = window.getComputedStyle(element)[styleProp];
      element.style[styleProp] = `${callback(Number.parseFloat(calculatedValue))}px`;
    };

    this._applyManipulationCallback(selector, manipulationCallBack);
  }

  reset() {
    this._resetElementAttributes(this._element, 'overflow');

    this._resetElementAttributes(this._element, 'paddingRight');

    this._resetElementAttributes(SELECTOR_FIXED_CONTENT, 'paddingRight');

    this._resetElementAttributes(SELECTOR_STICKY_CONTENT, 'marginRight');
  }

  _saveInitialAttribute(element, styleProp) {
    const actualValue = element.style[styleProp];

    if (actualValue) {
      Manipulator.setDataAttribute(element, styleProp, actualValue);
    }
  }

  _resetElementAttributes(selector, styleProp) {
    const manipulationCallBack = element => {
      const value = Manipulator.getDataAttribute(element, styleProp);

      if (typeof value === 'undefined') {
        element.style.removeProperty(styleProp);
      } else {
        Manipulator.removeDataAttribute(element, styleProp);
        element.style[styleProp] = value;
      }
    };

    this._applyManipulationCallback(selector, manipulationCallBack);
  }

  _applyManipulationCallback(selector, callBack) {
    if (isElement(selector)) {
      callBack(selector);
    } else {
      SelectorEngine.find(selector, this._element).forEach(callBack);
    }
  }

  isOverflowing() {
    return this.getWidth() > 0;
  }

}

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): util/backdrop.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */
const Default$7 = {
  className: 'modal-backdrop',
  isVisible: true,
  // if false, we use the backdrop helper without adding any element to the dom
  isAnimated: false,
  rootElement: 'body',
  // give the choice to place backdrop under different elements
  clickCallback: null
};
const DefaultType$7 = {
  className: 'string',
  isVisible: 'boolean',
  isAnimated: 'boolean',
  rootElement: '(element|string)',
  clickCallback: '(function|null)'
};
const NAME$8 = 'backdrop';
const CLASS_NAME_FADE$4 = 'fade';
const CLASS_NAME_SHOW$5 = 'show';
const EVENT_MOUSEDOWN = `mousedown.bs.${NAME$8}`;

class Backdrop {
  constructor(config) {
    this._config = this._getConfig(config);
    this._isAppended = false;
    this._element = null;
  }

  show(callback) {
    if (!this._config.isVisible) {
      execute(callback);
      return;
    }

    this._append();

    if (this._config.isAnimated) {
      reflow(this._getElement());
    }

    this._getElement().classList.add(CLASS_NAME_SHOW$5);

    this._emulateAnimation(() => {
      execute(callback);
    });
  }

  hide(callback) {
    if (!this._config.isVisible) {
      execute(callback);
      return;
    }

    this._getElement().classList.remove(CLASS_NAME_SHOW$5);

    this._emulateAnimation(() => {
      this.dispose();
      execute(callback);
    });
  } // Private


  _getElement() {
    if (!this._element) {
      const backdrop = document.createElement('div');
      backdrop.className = this._config.className;

      if (this._config.isAnimated) {
        backdrop.classList.add(CLASS_NAME_FADE$4);
      }

      this._element = backdrop;
    }

    return this._element;
  }

  _getConfig(config) {
    config = { ...Default$7,
      ...(typeof config === 'object' ? config : {})
    }; // use getElement() with the default "body" to get a fresh Element on each instantiation

    config.rootElement = getElement(config.rootElement);
    typeCheckConfig(NAME$8, config, DefaultType$7);
    return config;
  }

  _append() {
    if (this._isAppended) {
      return;
    }

    this._config.rootElement.append(this._getElement());

    EventHandler.on(this._getElement(), EVENT_MOUSEDOWN, () => {
      execute(this._config.clickCallback);
    });
    this._isAppended = true;
  }

  dispose() {
    if (!this._isAppended) {
      return;
    }

    EventHandler.off(this._element, EVENT_MOUSEDOWN);

    this._element.remove();

    this._isAppended = false;
  }

  _emulateAnimation(callback) {
    executeAfterTransition(callback, this._getElement(), this._config.isAnimated);
  }

}

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): util/focustrap.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */
const Default$6 = {
  trapElement: null,
  // The element to trap focus inside of
  autofocus: true
};
const DefaultType$6 = {
  trapElement: 'element',
  autofocus: 'boolean'
};
const NAME$7 = 'focustrap';
const DATA_KEY$7 = 'bs.focustrap';
const EVENT_KEY$7 = `.${DATA_KEY$7}`;
const EVENT_FOCUSIN$1 = `focusin${EVENT_KEY$7}`;
const EVENT_KEYDOWN_TAB = `keydown.tab${EVENT_KEY$7}`;
const TAB_KEY = 'Tab';
const TAB_NAV_FORWARD = 'forward';
const TAB_NAV_BACKWARD = 'backward';

class FocusTrap {
  constructor(config) {
    this._config = this._getConfig(config);
    this._isActive = false;
    this._lastTabNavDirection = null;
  }

  activate() {
    const {
      trapElement,
      autofocus
    } = this._config;

    if (this._isActive) {
      return;
    }

    if (autofocus) {
      trapElement.focus();
    }

    EventHandler.off(document, EVENT_KEY$7); // guard against infinite focus loop

    EventHandler.on(document, EVENT_FOCUSIN$1, event => this._handleFocusin(event));
    EventHandler.on(document, EVENT_KEYDOWN_TAB, event => this._handleKeydown(event));
    this._isActive = true;
  }

  deactivate() {
    if (!this._isActive) {
      return;
    }

    this._isActive = false;
    EventHandler.off(document, EVENT_KEY$7);
  } // Private


  _handleFocusin(event) {
    const {
      target
    } = event;
    const {
      trapElement
    } = this._config;

    if (target === document || target === trapElement || trapElement.contains(target)) {
      return;
    }

    const elements = SelectorEngine.focusableChildren(trapElement);

    if (elements.length === 0) {
      trapElement.focus();
    } else if (this._lastTabNavDirection === TAB_NAV_BACKWARD) {
      elements[elements.length - 1].focus();
    } else {
      elements[0].focus();
    }
  }

  _handleKeydown(event) {
    if (event.key !== TAB_KEY) {
      return;
    }

    this._lastTabNavDirection = event.shiftKey ? TAB_NAV_BACKWARD : TAB_NAV_FORWARD;
  }

  _getConfig(config) {
    config = { ...Default$6,
      ...(typeof config === 'object' ? config : {})
    };
    typeCheckConfig(NAME$7, config, DefaultType$6);
    return config;
  }

}

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): modal.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */
/**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */

const NAME$6 = 'modal';
const DATA_KEY$6 = 'bs.modal';
const EVENT_KEY$6 = `.${DATA_KEY$6}`;
const DATA_API_KEY$3 = '.data-api';
const ESCAPE_KEY$1 = 'Escape';
const Default$5 = {
  backdrop: true,
  keyboard: true,
  focus: true
};
const DefaultType$5 = {
  backdrop: '(boolean|string)',
  keyboard: 'boolean',
  focus: 'boolean'
};
const EVENT_HIDE$3 = `hide${EVENT_KEY$6}`;
const EVENT_HIDE_PREVENTED = `hidePrevented${EVENT_KEY$6}`;
const EVENT_HIDDEN$3 = `hidden${EVENT_KEY$6}`;
const EVENT_SHOW$3 = `show${EVENT_KEY$6}`;
const EVENT_SHOWN$3 = `shown${EVENT_KEY$6}`;
const EVENT_RESIZE = `resize${EVENT_KEY$6}`;
const EVENT_CLICK_DISMISS = `click.dismiss${EVENT_KEY$6}`;
const EVENT_KEYDOWN_DISMISS$1 = `keydown.dismiss${EVENT_KEY$6}`;
const EVENT_MOUSEUP_DISMISS = `mouseup.dismiss${EVENT_KEY$6}`;
const EVENT_MOUSEDOWN_DISMISS = `mousedown.dismiss${EVENT_KEY$6}`;
const EVENT_CLICK_DATA_API$2 = `click${EVENT_KEY$6}${DATA_API_KEY$3}`;
const CLASS_NAME_OPEN = 'modal-open';
const CLASS_NAME_FADE$3 = 'fade';
const CLASS_NAME_SHOW$4 = 'show';
const CLASS_NAME_STATIC = 'modal-static';
const OPEN_SELECTOR$1 = '.modal.show';
const SELECTOR_DIALOG = '.modal-dialog';
const SELECTOR_MODAL_BODY = '.modal-body';
const SELECTOR_DATA_TOGGLE$2 = '[data-bs-toggle="modal"]';
/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */

class Modal extends BaseComponent {
  constructor(element, config) {
    super(element);
    this._config = this._getConfig(config);
    this._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, this._element);
    this._backdrop = this._initializeBackDrop();
    this._focustrap = this._initializeFocusTrap();
    this._isShown = false;
    this._ignoreBackdropClick = false;
    this._isTransitioning = false;
    this._scrollBar = new ScrollBarHelper();
  } // Getters


  static get Default() {
    return Default$5;
  }

  static get NAME() {
    return NAME$6;
  } // Public


  toggle(relatedTarget) {
    return this._isShown ? this.hide() : this.show(relatedTarget);
  }

  show(relatedTarget) {
    if (this._isShown || this._isTransitioning) {
      return;
    }

    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$3, {
      relatedTarget
    });

    if (showEvent.defaultPrevented) {
      return;
    }

    this._isShown = true;

    if (this._isAnimated()) {
      this._isTransitioning = true;
    }

    this._scrollBar.hide();

    document.body.classList.add(CLASS_NAME_OPEN);

    this._adjustDialog();

    this._setEscapeEvent();

    this._setResizeEvent();

    EventHandler.on(this._dialog, EVENT_MOUSEDOWN_DISMISS, () => {
      EventHandler.one(this._element, EVENT_MOUSEUP_DISMISS, event => {
        if (event.target === this._element) {
          this._ignoreBackdropClick = true;
        }
      });
    });

    this._showBackdrop(() => this._showElement(relatedTarget));
  }

  hide() {
    if (!this._isShown || this._isTransitioning) {
      return;
    }

    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$3);

    if (hideEvent.defaultPrevented) {
      return;
    }

    this._isShown = false;

    const isAnimated = this._isAnimated();

    if (isAnimated) {
      this._isTransitioning = true;
    }

    this._setEscapeEvent();

    this._setResizeEvent();

    this._focustrap.deactivate();

    this._element.classList.remove(CLASS_NAME_SHOW$4);

    EventHandler.off(this._element, EVENT_CLICK_DISMISS);
    EventHandler.off(this._dialog, EVENT_MOUSEDOWN_DISMISS);

    this._queueCallback(() => this._hideModal(), this._element, isAnimated);
  }

  dispose() {
    [window, this._dialog].forEach(htmlElement => EventHandler.off(htmlElement, EVENT_KEY$6));

    this._backdrop.dispose();

    this._focustrap.deactivate();

    super.dispose();
  }

  handleUpdate() {
    this._adjustDialog();
  } // Private


  _initializeBackDrop() {
    return new Backdrop({
      isVisible: Boolean(this._config.backdrop),
      // 'static' option will be translated to true, and booleans will keep their value
      isAnimated: this._isAnimated()
    });
  }

  _initializeFocusTrap() {
    return new FocusTrap({
      trapElement: this._element
    });
  }

  _getConfig(config) {
    config = { ...Default$5,
      ...Manipulator.getDataAttributes(this._element),
      ...(typeof config === 'object' ? config : {})
    };
    typeCheckConfig(NAME$6, config, DefaultType$5);
    return config;
  }

  _showElement(relatedTarget) {
    const isAnimated = this._isAnimated();

    const modalBody = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog);

    if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {
      // Don't move modal's DOM position
      document.body.append(this._element);
    }

    this._element.style.display = 'block';

    this._element.removeAttribute('aria-hidden');

    this._element.setAttribute('aria-modal', true);

    this._element.setAttribute('role', 'dialog');

    this._element.scrollTop = 0;

    if (modalBody) {
      modalBody.scrollTop = 0;
    }

    if (isAnimated) {
      reflow(this._element);
    }

    this._element.classList.add(CLASS_NAME_SHOW$4);

    const transitionComplete = () => {
      if (this._config.focus) {
        this._focustrap.activate();
      }

      this._isTransitioning = false;
      EventHandler.trigger(this._element, EVENT_SHOWN$3, {
        relatedTarget
      });
    };

    this._queueCallback(transitionComplete, this._dialog, isAnimated);
  }

  _setEscapeEvent() {
    if (this._isShown) {
      EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS$1, event => {
        if (this._config.keyboard && event.key === ESCAPE_KEY$1) {
          event.preventDefault();
          this.hide();
        } else if (!this._config.keyboard && event.key === ESCAPE_KEY$1) {
          this._triggerBackdropTransition();
        }
      });
    } else {
      EventHandler.off(this._element, EVENT_KEYDOWN_DISMISS$1);
    }
  }

  _setResizeEvent() {
    if (this._isShown) {
      EventHandler.on(window, EVENT_RESIZE, () => this._adjustDialog());
    } else {
      EventHandler.off(window, EVENT_RESIZE);
    }
  }

  _hideModal() {
    this._element.style.display = 'none';

    this._element.setAttribute('aria-hidden', true);

    this._element.removeAttribute('aria-modal');

    this._element.removeAttribute('role');

    this._isTransitioning = false;

    this._backdrop.hide(() => {
      document.body.classList.remove(CLASS_NAME_OPEN);

      this._resetAdjustments();

      this._scrollBar.reset();

      EventHandler.trigger(this._element, EVENT_HIDDEN$3);
    });
  }

  _showBackdrop(callback) {
    EventHandler.on(this._element, EVENT_CLICK_DISMISS, event => {
      if (this._ignoreBackdropClick) {
        this._ignoreBackdropClick = false;
        return;
      }

      if (event.target !== event.currentTarget) {
        return;
      }

      if (this._config.backdrop === true) {
        this.hide();
      } else if (this._config.backdrop === 'static') {
        this._triggerBackdropTransition();
      }
    });

    this._backdrop.show(callback);
  }

  _isAnimated() {
    return this._element.classList.contains(CLASS_NAME_FADE$3);
  }

  _triggerBackdropTransition() {
    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);

    if (hideEvent.defaultPrevented) {
      return;
    }

    const {
      classList,
      scrollHeight,
      style
    } = this._element;
    const isModalOverflowing = scrollHeight > document.documentElement.clientHeight; // return if the following background transition hasn't yet completed

    if (!isModalOverflowing && style.overflowY === 'hidden' || classList.contains(CLASS_NAME_STATIC)) {
      return;
    }

    if (!isModalOverflowing) {
      style.overflowY = 'hidden';
    }

    classList.add(CLASS_NAME_STATIC);

    this._queueCallback(() => {
      classList.remove(CLASS_NAME_STATIC);

      if (!isModalOverflowing) {
        this._queueCallback(() => {
          style.overflowY = '';
        }, this._dialog);
      }
    }, this._dialog);

    this._element.focus();
  } // ----------------------------------------------------------------------
  // the following methods are used to handle overflowing modals
  // ----------------------------------------------------------------------


  _adjustDialog() {
    const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;

    const scrollbarWidth = this._scrollBar.getWidth();

    const isBodyOverflowing = scrollbarWidth > 0;

    if (!isBodyOverflowing && isModalOverflowing && !isRTL() || isBodyOverflowing && !isModalOverflowing && isRTL()) {
      this._element.style.paddingLeft = `${scrollbarWidth}px`;
    }

    if (isBodyOverflowing && !isModalOverflowing && !isRTL() || !isBodyOverflowing && isModalOverflowing && isRTL()) {
      this._element.style.paddingRight = `${scrollbarWidth}px`;
    }
  }

  _resetAdjustments() {
    this._element.style.paddingLeft = '';
    this._element.style.paddingRight = '';
  } // Static


  static jQueryInterface(config, relatedTarget) {
    return this.each(function () {
      const data = Modal.getOrCreateInstance(this, config);

      if (typeof config !== 'string') {
        return;
      }

      if (typeof data[config] === 'undefined') {
        throw new TypeError(`No method named "${config}"`);
      }

      data[config](relatedTarget);
    });
  }

}
/**
 * ------------------------------------------------------------------------
 * Data Api implementation
 * ------------------------------------------------------------------------
 */


EventHandler.on(document, EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function (event) {
  const target = getElementFromSelector(this);

  if (['A', 'AREA'].includes(this.tagName)) {
    event.preventDefault();
  }

  EventHandler.one(target, EVENT_SHOW$3, showEvent => {
    if (showEvent.defaultPrevented) {
      // only register focus restorer if modal will actually get shown
      return;
    }

    EventHandler.one(target, EVENT_HIDDEN$3, () => {
      if (isVisible(this)) {
        this.focus();
      }
    });
  }); // avoid conflict when clicking moddal toggler while another one is open

  const allReadyOpen = SelectorEngine.findOne(OPEN_SELECTOR$1);

  if (allReadyOpen) {
    Modal.getInstance(allReadyOpen).hide();
  }

  const data = Modal.getOrCreateInstance(target);
  data.toggle(this);
});
enableDismissTrigger(Modal);
/**
 * ------------------------------------------------------------------------
 * jQuery
 * ------------------------------------------------------------------------
 * add .Modal to jQuery only if jQuery is present
 */

defineJQueryPlugin(Modal);

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): offcanvas.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */
/**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */

const NAME$5 = 'offcanvas';
const DATA_KEY$5 = 'bs.offcanvas';
const EVENT_KEY$5 = `.${DATA_KEY$5}`;
const DATA_API_KEY$2 = '.data-api';
const EVENT_LOAD_DATA_API$1 = `load${EVENT_KEY$5}${DATA_API_KEY$2}`;
const ESCAPE_KEY = 'Escape';
const Default$4 = {
  backdrop: true,
  keyboard: true,
  scroll: false
};
const DefaultType$4 = {
  backdrop: 'boolean',
  keyboard: 'boolean',
  scroll: 'boolean'
};
const CLASS_NAME_SHOW$3 = 'show';
const CLASS_NAME_BACKDROP = 'offcanvas-backdrop';
const OPEN_SELECTOR = '.offcanvas.show';
const EVENT_SHOW$2 = `show${EVENT_KEY$5}`;
const EVENT_SHOWN$2 = `shown${EVENT_KEY$5}`;
const EVENT_HIDE$2 = `hide${EVENT_KEY$5}`;
const EVENT_HIDDEN$2 = `hidden${EVENT_KEY$5}`;
const EVENT_CLICK_DATA_API$1 = `click${EVENT_KEY$5}${DATA_API_KEY$2}`;
const EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY$5}`;
const SELECTOR_DATA_TOGGLE$1 = '[data-bs-toggle="offcanvas"]';
/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */

class Offcanvas extends BaseComponent {
  constructor(element, config) {
    super(element);
    this._config = this._getConfig(config);
    this._isShown = false;
    this._backdrop = this._initializeBackDrop();
    this._focustrap = this._initializeFocusTrap();

    this._addEventListeners();
  } // Getters


  static get NAME() {
    return NAME$5;
  }

  static get Default() {
    return Default$4;
  } // Public


  toggle(relatedTarget) {
    return this._isShown ? this.hide() : this.show(relatedTarget);
  }

  show(relatedTarget) {
    if (this._isShown) {
      return;
    }

    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$2, {
      relatedTarget
    });

    if (showEvent.defaultPrevented) {
      return;
    }

    this._isShown = true;
    this._element.style.visibility = 'visible';

    this._backdrop.show();

    if (!this._config.scroll) {
      new ScrollBarHelper().hide();
    }

    this._element.removeAttribute('aria-hidden');

    this._element.setAttribute('aria-modal', true);

    this._element.setAttribute('role', 'dialog');

    this._element.classList.add(CLASS_NAME_SHOW$3);

    const completeCallBack = () => {
      if (!this._config.scroll) {
        this._focustrap.activate();
      }

      EventHandler.trigger(this._element, EVENT_SHOWN$2, {
        relatedTarget
      });
    };

    this._queueCallback(completeCallBack, this._element, true);
  }

  hide() {
    if (!this._isShown) {
      return;
    }

    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$2);

    if (hideEvent.defaultPrevented) {
      return;
    }

    this._focustrap.deactivate();

    this._element.blur();

    this._isShown = false;

    this._element.classList.remove(CLASS_NAME_SHOW$3);

    this._backdrop.hide();

    const completeCallback = () => {
      this._element.setAttribute('aria-hidden', true);

      this._element.removeAttribute('aria-modal');

      this._element.removeAttribute('role');

      this._element.style.visibility = 'hidden';

      if (!this._config.scroll) {
        new ScrollBarHelper().reset();
      }

      EventHandler.trigger(this._element, EVENT_HIDDEN$2);
    };

    this._queueCallback(completeCallback, this._element, true);
  }

  dispose() {
    this._backdrop.dispose();

    this._focustrap.deactivate();

    super.dispose();
  } // Private


  _getConfig(config) {
    config = { ...Default$4,
      ...Manipulator.getDataAttributes(this._element),
      ...(typeof config === 'object' ? config : {})
    };
    typeCheckConfig(NAME$5, config, DefaultType$4);
    return config;
  }

  _initializeBackDrop() {
    return new Backdrop({
      className: CLASS_NAME_BACKDROP,
      isVisible: this._config.backdrop,
      isAnimated: true,
      rootElement: this._element.parentNode,
      clickCallback: () => this.hide()
    });
  }

  _initializeFocusTrap() {
    return new FocusTrap({
      trapElement: this._element
    });
  }

  _addEventListeners() {
    EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, event => {
      if (this._config.keyboard && event.key === ESCAPE_KEY) {
        this.hide();
      }
    });
  } // Static


  static jQueryInterface(config) {
    return this.each(function () {
      const data = Offcanvas.getOrCreateInstance(this, config);

      if (typeof config !== 'string') {
        return;
      }

      if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {
        throw new TypeError(`No method named "${config}"`);
      }

      data[config](this);
    });
  }

}
/**
 * ------------------------------------------------------------------------
 * Data Api implementation
 * ------------------------------------------------------------------------
 */


EventHandler.on(document, EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function (event) {
  const target = getElementFromSelector(this);

  if (['A', 'AREA'].includes(this.tagName)) {
    event.preventDefault();
  }

  if (isDisabled(this)) {
    return;
  }

  EventHandler.one(target, EVENT_HIDDEN$2, () => {
    // focus on trigger when it is closed
    if (isVisible(this)) {
      this.focus();
    }
  }); // avoid conflict when clicking a toggler of an offcanvas, while another is open

  const allReadyOpen = SelectorEngine.findOne(OPEN_SELECTOR);

  if (allReadyOpen && allReadyOpen !== target) {
    Offcanvas.getInstance(allReadyOpen).hide();
  }

  const data = Offcanvas.getOrCreateInstance(target);
  data.toggle(this);
});
EventHandler.on(window, EVENT_LOAD_DATA_API$1, () => SelectorEngine.find(OPEN_SELECTOR).forEach(el => Offcanvas.getOrCreateInstance(el).show()));
enableDismissTrigger(Offcanvas);
/**
 * ------------------------------------------------------------------------
 * jQuery
 * ------------------------------------------------------------------------
 */

defineJQueryPlugin(Offcanvas);

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): util/sanitizer.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */
const uriAttributes = new Set(['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href']);
const ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
/**
 * A pattern that recognizes a commonly useful subset of URLs that are safe.
 *
 * Shoutout to Angular https://github.com/angular/angular/blob/12.2.x/packages/core/src/sanitization/url_sanitizer.ts
 */

const SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i;
/**
 * A pattern that matches safe data URLs. Only matches image, video and audio types.
 *
 * Shoutout to Angular https://github.com/angular/angular/blob/12.2.x/packages/core/src/sanitization/url_sanitizer.ts
 */

const DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i;

const allowedAttribute = (attribute, allowedAttributeList) => {
  const attributeName = attribute.nodeName.toLowerCase();

  if (allowedAttributeList.includes(attributeName)) {
    if (uriAttributes.has(attributeName)) {
      return Boolean(SAFE_URL_PATTERN.test(attribute.nodeValue) || DATA_URL_PATTERN.test(attribute.nodeValue));
    }

    return true;
  }

  const regExp = allowedAttributeList.filter(attributeRegex => attributeRegex instanceof RegExp); // Check if a regular expression validates the attribute.

  for (let i = 0, len = regExp.length; i < len; i++) {
    if (regExp[i].test(attributeName)) {
      return true;
    }
  }

  return false;
};

const DefaultAllowlist = {
  // Global attributes allowed on any supplied element below.
  '*': ['class', 'dir', 'id', 'lang', 'role', ARIA_ATTRIBUTE_PATTERN],
  a: ['target', 'href', 'title', 'rel'],
  area: [],
  b: [],
  br: [],
  col: [],
  code: [],
  div: [],
  em: [],
  hr: [],
  h1: [],
  h2: [],
  h3: [],
  h4: [],
  h5: [],
  h6: [],
  i: [],
  img: ['src', 'srcset', 'alt', 'title', 'width', 'height'],
  li: [],
  ol: [],
  p: [],
  pre: [],
  s: [],
  small: [],
  span: [],
  sub: [],
  sup: [],
  strong: [],
  u: [],
  ul: []
};
function sanitizeHtml(unsafeHtml, allowList, sanitizeFn) {
  if (!unsafeHtml.length) {
    return unsafeHtml;
  }

  if (sanitizeFn && typeof sanitizeFn === 'function') {
    return sanitizeFn(unsafeHtml);
  }

  const domParser = new window.DOMParser();
  const createdDocument = domParser.parseFromString(unsafeHtml, 'text/html');
  const elements = [].concat(...createdDocument.body.querySelectorAll('*'));

  for (let i = 0, len = elements.length; i < len; i++) {
    const element = elements[i];
    const elementName = element.nodeName.toLowerCase();

    if (!Object.keys(allowList).includes(elementName)) {
      element.remove();
      continue;
    }

    const attributeList = [].concat(...element.attributes);
    const allowedAttributes = [].concat(allowList['*'] || [], allowList[elementName] || []);
    attributeList.forEach(attribute => {
      if (!allowedAttribute(attribute, allowedAttributes)) {
        element.removeAttribute(attribute.nodeName);
      }
    });
  }

  return createdDocument.body.innerHTML;
}

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): tooltip.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */
/**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */

const NAME$4 = 'tooltip';
const DATA_KEY$4 = 'bs.tooltip';
const EVENT_KEY$4 = `.${DATA_KEY$4}`;
const CLASS_PREFIX$1 = 'bs-tooltip';
const DISALLOWED_ATTRIBUTES = new Set(['sanitize', 'allowList', 'sanitizeFn']);
const DefaultType$3 = {
  animation: 'boolean',
  template: 'string',
  title: '(string|element|function)',
  trigger: 'string',
  delay: '(number|object)',
  html: 'boolean',
  selector: '(string|boolean)',
  placement: '(string|function)',
  offset: '(array|string|function)',
  container: '(string|element|boolean)',
  fallbackPlacements: 'array',
  boundary: '(string|element)',
  customClass: '(string|function)',
  sanitize: 'boolean',
  sanitizeFn: '(null|function)',
  allowList: 'object',
  popperConfig: '(null|object|function)'
};
const AttachmentMap = {
  AUTO: 'auto',
  TOP: 'top',
  RIGHT: isRTL() ? 'left' : 'right',
  BOTTOM: 'bottom',
  LEFT: isRTL() ? 'right' : 'left'
};
const Default$3 = {
  animation: true,
  template: '<div class="tooltip" role="tooltip">' + '<div class="tooltip-arrow"></div>' + '<div class="tooltip-inner"></div>' + '</div>',
  trigger: 'hover focus',
  title: '',
  delay: 0,
  html: false,
  selector: false,
  placement: 'top',
  offset: [0, 0],
  container: false,
  fallbackPlacements: ['top', 'right', 'bottom', 'left'],
  boundary: 'clippingParents',
  customClass: '',
  sanitize: true,
  sanitizeFn: null,
  allowList: DefaultAllowlist,
  popperConfig: null
};
const Event$2 = {
  HIDE: `hide${EVENT_KEY$4}`,
  HIDDEN: `hidden${EVENT_KEY$4}`,
  SHOW: `show${EVENT_KEY$4}`,
  SHOWN: `shown${EVENT_KEY$4}`,
  INSERTED: `inserted${EVENT_KEY$4}`,
  CLICK: `click${EVENT_KEY$4}`,
  FOCUSIN: `focusin${EVENT_KEY$4}`,
  FOCUSOUT: `focusout${EVENT_KEY$4}`,
  MOUSEENTER: `mouseenter${EVENT_KEY$4}`,
  MOUSELEAVE: `mouseleave${EVENT_KEY$4}`
};
const CLASS_NAME_FADE$2 = 'fade';
const CLASS_NAME_MODAL = 'modal';
const CLASS_NAME_SHOW$2 = 'show';
const HOVER_STATE_SHOW = 'show';
const HOVER_STATE_OUT = 'out';
const SELECTOR_TOOLTIP_INNER = '.tooltip-inner';
const SELECTOR_MODAL = `.${CLASS_NAME_MODAL}`;
const EVENT_MODAL_HIDE = 'hide.bs.modal';
const TRIGGER_HOVER = 'hover';
const TRIGGER_FOCUS = 'focus';
const TRIGGER_CLICK = 'click';
const TRIGGER_MANUAL = 'manual';
/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */

class Tooltip extends BaseComponent {
  constructor(element, config) {
    if (typeof _popperjs_core__WEBPACK_IMPORTED_MODULE_0__ === 'undefined') {
      throw new TypeError('Bootstrap\'s tooltips require Popper (https://popper.js.org)');
    }

    super(element); // private

    this._isEnabled = true;
    this._timeout = 0;
    this._hoverState = '';
    this._activeTrigger = {};
    this._popper = null; // Protected

    this._config = this._getConfig(config);
    this.tip = null;

    this._setListeners();
  } // Getters


  static get Default() {
    return Default$3;
  }

  static get NAME() {
    return NAME$4;
  }

  static get Event() {
    return Event$2;
  }

  static get DefaultType() {
    return DefaultType$3;
  } // Public


  enable() {
    this._isEnabled = true;
  }

  disable() {
    this._isEnabled = false;
  }

  toggleEnabled() {
    this._isEnabled = !this._isEnabled;
  }

  toggle(event) {
    if (!this._isEnabled) {
      return;
    }

    if (event) {
      const context = this._initializeOnDelegatedTarget(event);

      context._activeTrigger.click = !context._activeTrigger.click;

      if (context._isWithActiveTrigger()) {
        context._enter(null, context);
      } else {
        context._leave(null, context);
      }
    } else {
      if (this.getTipElement().classList.contains(CLASS_NAME_SHOW$2)) {
        this._leave(null, this);

        return;
      }

      this._enter(null, this);
    }
  }

  dispose() {
    clearTimeout(this._timeout);
    EventHandler.off(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);

    if (this.tip) {
      this.tip.remove();
    }

    this._disposePopper();

    super.dispose();
  }

  show() {
    if (this._element.style.display === 'none') {
      throw new Error('Please use show on visible elements');
    }

    if (!(this.isWithContent() && this._isEnabled)) {
      return;
    }

    const showEvent = EventHandler.trigger(this._element, this.constructor.Event.SHOW);
    const shadowRoot = findShadowRoot(this._element);
    const isInTheDom = shadowRoot === null ? this._element.ownerDocument.documentElement.contains(this._element) : shadowRoot.contains(this._element);

    if (showEvent.defaultPrevented || !isInTheDom) {
      return;
    } // A trick to recreate a tooltip in case a new title is given by using the NOT documented `data-bs-original-title`
    // This will be removed later in favor of a `setContent` method


    if (this.constructor.NAME === 'tooltip' && this.tip && this.getTitle() !== this.tip.querySelector(SELECTOR_TOOLTIP_INNER).innerHTML) {
      this._disposePopper();

      this.tip.remove();
      this.tip = null;
    }

    const tip = this.getTipElement();
    const tipId = getUID(this.constructor.NAME);
    tip.setAttribute('id', tipId);

    this._element.setAttribute('aria-describedby', tipId);

    if (this._config.animation) {
      tip.classList.add(CLASS_NAME_FADE$2);
    }

    const placement = typeof this._config.placement === 'function' ? this._config.placement.call(this, tip, this._element) : this._config.placement;

    const attachment = this._getAttachment(placement);

    this._addAttachmentClass(attachment);

    const {
      container
    } = this._config;
    Data.set(tip, this.constructor.DATA_KEY, this);

    if (!this._element.ownerDocument.documentElement.contains(this.tip)) {
      container.append(tip);
      EventHandler.trigger(this._element, this.constructor.Event.INSERTED);
    }

    if (this._popper) {
      this._popper.update();
    } else {
      this._popper = _popperjs_core__WEBPACK_IMPORTED_MODULE_1__.createPopper(this._element, tip, this._getPopperConfig(attachment));
    }

    tip.classList.add(CLASS_NAME_SHOW$2);

    const customClass = this._resolvePossibleFunction(this._config.customClass);

    if (customClass) {
      tip.classList.add(...customClass.split(' '));
    } // If this is a touch-enabled device we add extra
    // empty mouseover listeners to the body's immediate children;
    // only needed because of broken event delegation on iOS
    // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html


    if ('ontouchstart' in document.documentElement) {
      [].concat(...document.body.children).forEach(element => {
        EventHandler.on(element, 'mouseover', noop);
      });
    }

    const complete = () => {
      const prevHoverState = this._hoverState;
      this._hoverState = null;
      EventHandler.trigger(this._element, this.constructor.Event.SHOWN);

      if (prevHoverState === HOVER_STATE_OUT) {
        this._leave(null, this);
      }
    };

    const isAnimated = this.tip.classList.contains(CLASS_NAME_FADE$2);

    this._queueCallback(complete, this.tip, isAnimated);
  }

  hide() {
    if (!this._popper) {
      return;
    }

    const tip = this.getTipElement();

    const complete = () => {
      if (this._isWithActiveTrigger()) {
        return;
      }

      if (this._hoverState !== HOVER_STATE_SHOW) {
        tip.remove();
      }

      this._cleanTipClass();

      this._element.removeAttribute('aria-describedby');

      EventHandler.trigger(this._element, this.constructor.Event.HIDDEN);

      this._disposePopper();
    };

    const hideEvent = EventHandler.trigger(this._element, this.constructor.Event.HIDE);

    if (hideEvent.defaultPrevented) {
      return;
    }

    tip.classList.remove(CLASS_NAME_SHOW$2); // If this is a touch-enabled device we remove the extra
    // empty mouseover listeners we added for iOS support

    if ('ontouchstart' in document.documentElement) {
      [].concat(...document.body.children).forEach(element => EventHandler.off(element, 'mouseover', noop));
    }

    this._activeTrigger[TRIGGER_CLICK] = false;
    this._activeTrigger[TRIGGER_FOCUS] = false;
    this._activeTrigger[TRIGGER_HOVER] = false;
    const isAnimated = this.tip.classList.contains(CLASS_NAME_FADE$2);

    this._queueCallback(complete, this.tip, isAnimated);

    this._hoverState = '';
  }

  update() {
    if (this._popper !== null) {
      this._popper.update();
    }
  } // Protected


  isWithContent() {
    return Boolean(this.getTitle());
  }

  getTipElement() {
    if (this.tip) {
      return this.tip;
    }

    const element = document.createElement('div');
    element.innerHTML = this._config.template;
    const tip = element.children[0];
    this.setContent(tip);
    tip.classList.remove(CLASS_NAME_FADE$2, CLASS_NAME_SHOW$2);
    this.tip = tip;
    return this.tip;
  }

  setContent(tip) {
    this._sanitizeAndSetContent(tip, this.getTitle(), SELECTOR_TOOLTIP_INNER);
  }

  _sanitizeAndSetContent(template, content, selector) {
    const templateElement = SelectorEngine.findOne(selector, template);

    if (!content && templateElement) {
      templateElement.remove();
      return;
    } // we use append for html objects to maintain js events


    this.setElementContent(templateElement, content);
  }

  setElementContent(element, content) {
    if (element === null) {
      return;
    }

    if (isElement(content)) {
      content = getElement(content); // content is a DOM node or a jQuery

      if (this._config.html) {
        if (content.parentNode !== element) {
          element.innerHTML = '';
          element.append(content);
        }
      } else {
        element.textContent = content.textContent;
      }

      return;
    }

    if (this._config.html) {
      if (this._config.sanitize) {
        content = sanitizeHtml(content, this._config.allowList, this._config.sanitizeFn);
      }

      element.innerHTML = content;
    } else {
      element.textContent = content;
    }
  }

  getTitle() {
    const title = this._element.getAttribute('data-bs-original-title') || this._config.title;

    return this._resolvePossibleFunction(title);
  }

  updateAttachment(attachment) {
    if (attachment === 'right') {
      return 'end';
    }

    if (attachment === 'left') {
      return 'start';
    }

    return attachment;
  } // Private


  _initializeOnDelegatedTarget(event, context) {
    return context || this.constructor.getOrCreateInstance(event.delegateTarget, this._getDelegateConfig());
  }

  _getOffset() {
    const {
      offset
    } = this._config;

    if (typeof offset === 'string') {
      return offset.split(',').map(val => Number.parseInt(val, 10));
    }

    if (typeof offset === 'function') {
      return popperData => offset(popperData, this._element);
    }

    return offset;
  }

  _resolvePossibleFunction(content) {
    return typeof content === 'function' ? content.call(this._element) : content;
  }

  _getPopperConfig(attachment) {
    const defaultBsPopperConfig = {
      placement: attachment,
      modifiers: [{
        name: 'flip',
        options: {
          fallbackPlacements: this._config.fallbackPlacements
        }
      }, {
        name: 'offset',
        options: {
          offset: this._getOffset()
        }
      }, {
        name: 'preventOverflow',
        options: {
          boundary: this._config.boundary
        }
      }, {
        name: 'arrow',
        options: {
          element: `.${this.constructor.NAME}-arrow`
        }
      }, {
        name: 'onChange',
        enabled: true,
        phase: 'afterWrite',
        fn: data => this._handlePopperPlacementChange(data)
      }],
      onFirstUpdate: data => {
        if (data.options.placement !== data.placement) {
          this._handlePopperPlacementChange(data);
        }
      }
    };
    return { ...defaultBsPopperConfig,
      ...(typeof this._config.popperConfig === 'function' ? this._config.popperConfig(defaultBsPopperConfig) : this._config.popperConfig)
    };
  }

  _addAttachmentClass(attachment) {
    this.getTipElement().classList.add(`${this._getBasicClassPrefix()}-${this.updateAttachment(attachment)}`);
  }

  _getAttachment(placement) {
    return AttachmentMap[placement.toUpperCase()];
  }

  _setListeners() {
    const triggers = this._config.trigger.split(' ');

    triggers.forEach(trigger => {
      if (trigger === 'click') {
        EventHandler.on(this._element, this.constructor.Event.CLICK, this._config.selector, event => this.toggle(event));
      } else if (trigger !== TRIGGER_MANUAL) {
        const eventIn = trigger === TRIGGER_HOVER ? this.constructor.Event.MOUSEENTER : this.constructor.Event.FOCUSIN;
        const eventOut = trigger === TRIGGER_HOVER ? this.constructor.Event.MOUSELEAVE : this.constructor.Event.FOCUSOUT;
        EventHandler.on(this._element, eventIn, this._config.selector, event => this._enter(event));
        EventHandler.on(this._element, eventOut, this._config.selector, event => this._leave(event));
      }
    });

    this._hideModalHandler = () => {
      if (this._element) {
        this.hide();
      }
    };

    EventHandler.on(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);

    if (this._config.selector) {
      this._config = { ...this._config,
        trigger: 'manual',
        selector: ''
      };
    } else {
      this._fixTitle();
    }
  }

  _fixTitle() {
    const title = this._element.getAttribute('title');

    const originalTitleType = typeof this._element.getAttribute('data-bs-original-title');

    if (title || originalTitleType !== 'string') {
      this._element.setAttribute('data-bs-original-title', title || '');

      if (title && !this._element.getAttribute('aria-label') && !this._element.textContent) {
        this._element.setAttribute('aria-label', title);
      }

      this._element.setAttribute('title', '');
    }
  }

  _enter(event, context) {
    context = this._initializeOnDelegatedTarget(event, context);

    if (event) {
      context._activeTrigger[event.type === 'focusin' ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;
    }

    if (context.getTipElement().classList.contains(CLASS_NAME_SHOW$2) || context._hoverState === HOVER_STATE_SHOW) {
      context._hoverState = HOVER_STATE_SHOW;
      return;
    }

    clearTimeout(context._timeout);
    context._hoverState = HOVER_STATE_SHOW;

    if (!context._config.delay || !context._config.delay.show) {
      context.show();
      return;
    }

    context._timeout = setTimeout(() => {
      if (context._hoverState === HOVER_STATE_SHOW) {
        context.show();
      }
    }, context._config.delay.show);
  }

  _leave(event, context) {
    context = this._initializeOnDelegatedTarget(event, context);

    if (event) {
      context._activeTrigger[event.type === 'focusout' ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);
    }

    if (context._isWithActiveTrigger()) {
      return;
    }

    clearTimeout(context._timeout);
    context._hoverState = HOVER_STATE_OUT;

    if (!context._config.delay || !context._config.delay.hide) {
      context.hide();
      return;
    }

    context._timeout = setTimeout(() => {
      if (context._hoverState === HOVER_STATE_OUT) {
        context.hide();
      }
    }, context._config.delay.hide);
  }

  _isWithActiveTrigger() {
    for (const trigger in this._activeTrigger) {
      if (this._activeTrigger[trigger]) {
        return true;
      }
    }

    return false;
  }

  _getConfig(config) {
    const dataAttributes = Manipulator.getDataAttributes(this._element);
    Object.keys(dataAttributes).forEach(dataAttr => {
      if (DISALLOWED_ATTRIBUTES.has(dataAttr)) {
        delete dataAttributes[dataAttr];
      }
    });
    config = { ...this.constructor.Default,
      ...dataAttributes,
      ...(typeof config === 'object' && config ? config : {})
    };
    config.container = config.container === false ? document.body : getElement(config.container);

    if (typeof config.delay === 'number') {
      config.delay = {
        show: config.delay,
        hide: config.delay
      };
    }

    if (typeof config.title === 'number') {
      config.title = config.title.toString();
    }

    if (typeof config.content === 'number') {
      config.content = config.content.toString();
    }

    typeCheckConfig(NAME$4, config, this.constructor.DefaultType);

    if (config.sanitize) {
      config.template = sanitizeHtml(config.template, config.allowList, config.sanitizeFn);
    }

    return config;
  }

  _getDelegateConfig() {
    const config = {};

    for (const key in this._config) {
      if (this.constructor.Default[key] !== this._config[key]) {
        config[key] = this._config[key];
      }
    } // In the future can be replaced with:
    // const keysWithDifferentValues = Object.entries(this._config).filter(entry => this.constructor.Default[entry[0]] !== this._config[entry[0]])
    // `Object.fromEntries(keysWithDifferentValues)`


    return config;
  }

  _cleanTipClass() {
    const tip = this.getTipElement();
    const basicClassPrefixRegex = new RegExp(`(^|\\s)${this._getBasicClassPrefix()}\\S+`, 'g');
    const tabClass = tip.getAttribute('class').match(basicClassPrefixRegex);

    if (tabClass !== null && tabClass.length > 0) {
      tabClass.map(token => token.trim()).forEach(tClass => tip.classList.remove(tClass));
    }
  }

  _getBasicClassPrefix() {
    return CLASS_PREFIX$1;
  }

  _handlePopperPlacementChange(popperData) {
    const {
      state
    } = popperData;

    if (!state) {
      return;
    }

    this.tip = state.elements.popper;

    this._cleanTipClass();

    this._addAttachmentClass(this._getAttachment(state.placement));
  }

  _disposePopper() {
    if (this._popper) {
      this._popper.destroy();

      this._popper = null;
    }
  } // Static


  static jQueryInterface(config) {
    return this.each(function () {
      const data = Tooltip.getOrCreateInstance(this, config);

      if (typeof config === 'string') {
        if (typeof data[config] === 'undefined') {
          throw new TypeError(`No method named "${config}"`);
        }

        data[config]();
      }
    });
  }

}
/**
 * ------------------------------------------------------------------------
 * jQuery
 * ------------------------------------------------------------------------
 * add .Tooltip to jQuery only if jQuery is present
 */


defineJQueryPlugin(Tooltip);

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): popover.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */
/**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */

const NAME$3 = 'popover';
const DATA_KEY$3 = 'bs.popover';
const EVENT_KEY$3 = `.${DATA_KEY$3}`;
const CLASS_PREFIX = 'bs-popover';
const Default$2 = { ...Tooltip.Default,
  placement: 'right',
  offset: [0, 8],
  trigger: 'click',
  content: '',
  template: '<div class="popover" role="tooltip">' + '<div class="popover-arrow"></div>' + '<h3 class="popover-header"></h3>' + '<div class="popover-body"></div>' + '</div>'
};
const DefaultType$2 = { ...Tooltip.DefaultType,
  content: '(string|element|function)'
};
const Event$1 = {
  HIDE: `hide${EVENT_KEY$3}`,
  HIDDEN: `hidden${EVENT_KEY$3}`,
  SHOW: `show${EVENT_KEY$3}`,
  SHOWN: `shown${EVENT_KEY$3}`,
  INSERTED: `inserted${EVENT_KEY$3}`,
  CLICK: `click${EVENT_KEY$3}`,
  FOCUSIN: `focusin${EVENT_KEY$3}`,
  FOCUSOUT: `focusout${EVENT_KEY$3}`,
  MOUSEENTER: `mouseenter${EVENT_KEY$3}`,
  MOUSELEAVE: `mouseleave${EVENT_KEY$3}`
};
const SELECTOR_TITLE = '.popover-header';
const SELECTOR_CONTENT = '.popover-body';
/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */

class Popover extends Tooltip {
  // Getters
  static get Default() {
    return Default$2;
  }

  static get NAME() {
    return NAME$3;
  }

  static get Event() {
    return Event$1;
  }

  static get DefaultType() {
    return DefaultType$2;
  } // Overrides


  isWithContent() {
    return this.getTitle() || this._getContent();
  }

  setContent(tip) {
    this._sanitizeAndSetContent(tip, this.getTitle(), SELECTOR_TITLE);

    this._sanitizeAndSetContent(tip, this._getContent(), SELECTOR_CONTENT);
  } // Private


  _getContent() {
    return this._resolvePossibleFunction(this._config.content);
  }

  _getBasicClassPrefix() {
    return CLASS_PREFIX;
  } // Static


  static jQueryInterface(config) {
    return this.each(function () {
      const data = Popover.getOrCreateInstance(this, config);

      if (typeof config === 'string') {
        if (typeof data[config] === 'undefined') {
          throw new TypeError(`No method named "${config}"`);
        }

        data[config]();
      }
    });
  }

}
/**
 * ------------------------------------------------------------------------
 * jQuery
 * ------------------------------------------------------------------------
 * add .Popover to jQuery only if jQuery is present
 */


defineJQueryPlugin(Popover);

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): scrollspy.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */
/**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */

const NAME$2 = 'scrollspy';
const DATA_KEY$2 = 'bs.scrollspy';
const EVENT_KEY$2 = `.${DATA_KEY$2}`;
const DATA_API_KEY$1 = '.data-api';
const Default$1 = {
  offset: 10,
  method: 'auto',
  target: ''
};
const DefaultType$1 = {
  offset: 'number',
  method: 'string',
  target: '(string|element)'
};
const EVENT_ACTIVATE = `activate${EVENT_KEY$2}`;
const EVENT_SCROLL = `scroll${EVENT_KEY$2}`;
const EVENT_LOAD_DATA_API = `load${EVENT_KEY$2}${DATA_API_KEY$1}`;
const CLASS_NAME_DROPDOWN_ITEM = 'dropdown-item';
const CLASS_NAME_ACTIVE$1 = 'active';
const SELECTOR_DATA_SPY = '[data-bs-spy="scroll"]';
const SELECTOR_NAV_LIST_GROUP$1 = '.nav, .list-group';
const SELECTOR_NAV_LINKS = '.nav-link';
const SELECTOR_NAV_ITEMS = '.nav-item';
const SELECTOR_LIST_ITEMS = '.list-group-item';
const SELECTOR_LINK_ITEMS = `${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}, .${CLASS_NAME_DROPDOWN_ITEM}`;
const SELECTOR_DROPDOWN$1 = '.dropdown';
const SELECTOR_DROPDOWN_TOGGLE$1 = '.dropdown-toggle';
const METHOD_OFFSET = 'offset';
const METHOD_POSITION = 'position';
/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */

class ScrollSpy extends BaseComponent {
  constructor(element, config) {
    super(element);
    this._scrollElement = this._element.tagName === 'BODY' ? window : this._element;
    this._config = this._getConfig(config);
    this._offsets = [];
    this._targets = [];
    this._activeTarget = null;
    this._scrollHeight = 0;
    EventHandler.on(this._scrollElement, EVENT_SCROLL, () => this._process());
    this.refresh();

    this._process();
  } // Getters


  static get Default() {
    return Default$1;
  }

  static get NAME() {
    return NAME$2;
  } // Public


  refresh() {
    const autoMethod = this._scrollElement === this._scrollElement.window ? METHOD_OFFSET : METHOD_POSITION;
    const offsetMethod = this._config.method === 'auto' ? autoMethod : this._config.method;
    const offsetBase = offsetMethod === METHOD_POSITION ? this._getScrollTop() : 0;
    this._offsets = [];
    this._targets = [];
    this._scrollHeight = this._getScrollHeight();
    const targets = SelectorEngine.find(SELECTOR_LINK_ITEMS, this._config.target);
    targets.map(element => {
      const targetSelector = getSelectorFromElement(element);
      const target = targetSelector ? SelectorEngine.findOne(targetSelector) : null;

      if (target) {
        const targetBCR = target.getBoundingClientRect();

        if (targetBCR.width || targetBCR.height) {
          return [Manipulator[offsetMethod](target).top + offsetBase, targetSelector];
        }
      }

      return null;
    }).filter(item => item).sort((a, b) => a[0] - b[0]).forEach(item => {
      this._offsets.push(item[0]);

      this._targets.push(item[1]);
    });
  }

  dispose() {
    EventHandler.off(this._scrollElement, EVENT_KEY$2);
    super.dispose();
  } // Private


  _getConfig(config) {
    config = { ...Default$1,
      ...Manipulator.getDataAttributes(this._element),
      ...(typeof config === 'object' && config ? config : {})
    };
    config.target = getElement(config.target) || document.documentElement;
    typeCheckConfig(NAME$2, config, DefaultType$1);
    return config;
  }

  _getScrollTop() {
    return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;
  }

  _getScrollHeight() {
    return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);
  }

  _getOffsetHeight() {
    return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;
  }

  _process() {
    const scrollTop = this._getScrollTop() + this._config.offset;

    const scrollHeight = this._getScrollHeight();

    const maxScroll = this._config.offset + scrollHeight - this._getOffsetHeight();

    if (this._scrollHeight !== scrollHeight) {
      this.refresh();
    }

    if (scrollTop >= maxScroll) {
      const target = this._targets[this._targets.length - 1];

      if (this._activeTarget !== target) {
        this._activate(target);
      }

      return;
    }

    if (this._activeTarget && scrollTop < this._offsets[0] && this._offsets[0] > 0) {
      this._activeTarget = null;

      this._clear();

      return;
    }

    for (let i = this._offsets.length; i--;) {
      const isActiveTarget = this._activeTarget !== this._targets[i] && scrollTop >= this._offsets[i] && (typeof this._offsets[i + 1] === 'undefined' || scrollTop < this._offsets[i + 1]);

      if (isActiveTarget) {
        this._activate(this._targets[i]);
      }
    }
  }

  _activate(target) {
    this._activeTarget = target;

    this._clear();

    const queries = SELECTOR_LINK_ITEMS.split(',').map(selector => `${selector}[data-bs-target="${target}"],${selector}[href="${target}"]`);
    const link = SelectorEngine.findOne(queries.join(','), this._config.target);
    link.classList.add(CLASS_NAME_ACTIVE$1);

    if (link.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) {
      SelectorEngine.findOne(SELECTOR_DROPDOWN_TOGGLE$1, link.closest(SELECTOR_DROPDOWN$1)).classList.add(CLASS_NAME_ACTIVE$1);
    } else {
      SelectorEngine.parents(link, SELECTOR_NAV_LIST_GROUP$1).forEach(listGroup => {
        // Set triggered links parents as active
        // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor
        SelectorEngine.prev(listGroup, `${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}`).forEach(item => item.classList.add(CLASS_NAME_ACTIVE$1)); // Handle special case when .nav-link is inside .nav-item

        SelectorEngine.prev(listGroup, SELECTOR_NAV_ITEMS).forEach(navItem => {
          SelectorEngine.children(navItem, SELECTOR_NAV_LINKS).forEach(item => item.classList.add(CLASS_NAME_ACTIVE$1));
        });
      });
    }

    EventHandler.trigger(this._scrollElement, EVENT_ACTIVATE, {
      relatedTarget: target
    });
  }

  _clear() {
    SelectorEngine.find(SELECTOR_LINK_ITEMS, this._config.target).filter(node => node.classList.contains(CLASS_NAME_ACTIVE$1)).forEach(node => node.classList.remove(CLASS_NAME_ACTIVE$1));
  } // Static


  static jQueryInterface(config) {
    return this.each(function () {
      const data = ScrollSpy.getOrCreateInstance(this, config);

      if (typeof config !== 'string') {
        return;
      }

      if (typeof data[config] === 'undefined') {
        throw new TypeError(`No method named "${config}"`);
      }

      data[config]();
    });
  }

}
/**
 * ------------------------------------------------------------------------
 * Data Api implementation
 * ------------------------------------------------------------------------
 */


EventHandler.on(window, EVENT_LOAD_DATA_API, () => {
  SelectorEngine.find(SELECTOR_DATA_SPY).forEach(spy => new ScrollSpy(spy));
});
/**
 * ------------------------------------------------------------------------
 * jQuery
 * ------------------------------------------------------------------------
 * add .ScrollSpy to jQuery only if jQuery is present
 */

defineJQueryPlugin(ScrollSpy);

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): tab.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */
/**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */

const NAME$1 = 'tab';
const DATA_KEY$1 = 'bs.tab';
const EVENT_KEY$1 = `.${DATA_KEY$1}`;
const DATA_API_KEY = '.data-api';
const EVENT_HIDE$1 = `hide${EVENT_KEY$1}`;
const EVENT_HIDDEN$1 = `hidden${EVENT_KEY$1}`;
const EVENT_SHOW$1 = `show${EVENT_KEY$1}`;
const EVENT_SHOWN$1 = `shown${EVENT_KEY$1}`;
const EVENT_CLICK_DATA_API = `click${EVENT_KEY$1}${DATA_API_KEY}`;
const CLASS_NAME_DROPDOWN_MENU = 'dropdown-menu';
const CLASS_NAME_ACTIVE = 'active';
const CLASS_NAME_FADE$1 = 'fade';
const CLASS_NAME_SHOW$1 = 'show';
const SELECTOR_DROPDOWN = '.dropdown';
const SELECTOR_NAV_LIST_GROUP = '.nav, .list-group';
const SELECTOR_ACTIVE = '.active';
const SELECTOR_ACTIVE_UL = ':scope > li > .active';
const SELECTOR_DATA_TOGGLE = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]';
const SELECTOR_DROPDOWN_TOGGLE = '.dropdown-toggle';
const SELECTOR_DROPDOWN_ACTIVE_CHILD = ':scope > .dropdown-menu .active';
/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */

class Tab extends BaseComponent {
  // Getters
  static get NAME() {
    return NAME$1;
  } // Public


  show() {
    if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && this._element.classList.contains(CLASS_NAME_ACTIVE)) {
      return;
    }

    let previous;
    const target = getElementFromSelector(this._element);

    const listElement = this._element.closest(SELECTOR_NAV_LIST_GROUP);

    if (listElement) {
      const itemSelector = listElement.nodeName === 'UL' || listElement.nodeName === 'OL' ? SELECTOR_ACTIVE_UL : SELECTOR_ACTIVE;
      previous = SelectorEngine.find(itemSelector, listElement);
      previous = previous[previous.length - 1];
    }

    const hideEvent = previous ? EventHandler.trigger(previous, EVENT_HIDE$1, {
      relatedTarget: this._element
    }) : null;
    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$1, {
      relatedTarget: previous
    });

    if (showEvent.defaultPrevented || hideEvent !== null && hideEvent.defaultPrevented) {
      return;
    }

    this._activate(this._element, listElement);

    const complete = () => {
      EventHandler.trigger(previous, EVENT_HIDDEN$1, {
        relatedTarget: this._element
      });
      EventHandler.trigger(this._element, EVENT_SHOWN$1, {
        relatedTarget: previous
      });
    };

    if (target) {
      this._activate(target, target.parentNode, complete);
    } else {
      complete();
    }
  } // Private


  _activate(element, container, callback) {
    const activeElements = container && (container.nodeName === 'UL' || container.nodeName === 'OL') ? SelectorEngine.find(SELECTOR_ACTIVE_UL, container) : SelectorEngine.children(container, SELECTOR_ACTIVE);
    const active = activeElements[0];
    const isTransitioning = callback && active && active.classList.contains(CLASS_NAME_FADE$1);

    const complete = () => this._transitionComplete(element, active, callback);

    if (active && isTransitioning) {
      active.classList.remove(CLASS_NAME_SHOW$1);

      this._queueCallback(complete, element, true);
    } else {
      complete();
    }
  }

  _transitionComplete(element, active, callback) {
    if (active) {
      active.classList.remove(CLASS_NAME_ACTIVE);
      const dropdownChild = SelectorEngine.findOne(SELECTOR_DROPDOWN_ACTIVE_CHILD, active.parentNode);

      if (dropdownChild) {
        dropdownChild.classList.remove(CLASS_NAME_ACTIVE);
      }

      if (active.getAttribute('role') === 'tab') {
        active.setAttribute('aria-selected', false);
      }
    }

    element.classList.add(CLASS_NAME_ACTIVE);

    if (element.getAttribute('role') === 'tab') {
      element.setAttribute('aria-selected', true);
    }

    reflow(element);

    if (element.classList.contains(CLASS_NAME_FADE$1)) {
      element.classList.add(CLASS_NAME_SHOW$1);
    }

    let parent = element.parentNode;

    if (parent && parent.nodeName === 'LI') {
      parent = parent.parentNode;
    }

    if (parent && parent.classList.contains(CLASS_NAME_DROPDOWN_MENU)) {
      const dropdownElement = element.closest(SELECTOR_DROPDOWN);

      if (dropdownElement) {
        SelectorEngine.find(SELECTOR_DROPDOWN_TOGGLE, dropdownElement).forEach(dropdown => dropdown.classList.add(CLASS_NAME_ACTIVE));
      }

      element.setAttribute('aria-expanded', true);
    }

    if (callback) {
      callback();
    }
  } // Static


  static jQueryInterface(config) {
    return this.each(function () {
      const data = Tab.getOrCreateInstance(this);

      if (typeof config === 'string') {
        if (typeof data[config] === 'undefined') {
          throw new TypeError(`No method named "${config}"`);
        }

        data[config]();
      }
    });
  }

}
/**
 * ------------------------------------------------------------------------
 * Data Api implementation
 * ------------------------------------------------------------------------
 */


EventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {
  if (['A', 'AREA'].includes(this.tagName)) {
    event.preventDefault();
  }

  if (isDisabled(this)) {
    return;
  }

  const data = Tab.getOrCreateInstance(this);
  data.show();
});
/**
 * ------------------------------------------------------------------------
 * jQuery
 * ------------------------------------------------------------------------
 * add .Tab to jQuery only if jQuery is present
 */

defineJQueryPlugin(Tab);

/**
 * --------------------------------------------------------------------------
 * Bootstrap (v5.1.3): toast.js
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 * --------------------------------------------------------------------------
 */
/**
 * ------------------------------------------------------------------------
 * Constants
 * ------------------------------------------------------------------------
 */

const NAME = 'toast';
const DATA_KEY = 'bs.toast';
const EVENT_KEY = `.${DATA_KEY}`;
const EVENT_MOUSEOVER = `mouseover${EVENT_KEY}`;
const EVENT_MOUSEOUT = `mouseout${EVENT_KEY}`;
const EVENT_FOCUSIN = `focusin${EVENT_KEY}`;
const EVENT_FOCUSOUT = `focusout${EVENT_KEY}`;
const EVENT_HIDE = `hide${EVENT_KEY}`;
const EVENT_HIDDEN = `hidden${EVENT_KEY}`;
const EVENT_SHOW = `show${EVENT_KEY}`;
const EVENT_SHOWN = `shown${EVENT_KEY}`;
const CLASS_NAME_FADE = 'fade';
const CLASS_NAME_HIDE = 'hide'; // @deprecated - kept here only for backwards compatibility

const CLASS_NAME_SHOW = 'show';
const CLASS_NAME_SHOWING = 'showing';
const DefaultType = {
  animation: 'boolean',
  autohide: 'boolean',
  delay: 'number'
};
const Default = {
  animation: true,
  autohide: true,
  delay: 5000
};
/**
 * ------------------------------------------------------------------------
 * Class Definition
 * ------------------------------------------------------------------------
 */

class Toast extends BaseComponent {
  constructor(element, config) {
    super(element);
    this._config = this._getConfig(config);
    this._timeout = null;
    this._hasMouseInteraction = false;
    this._hasKeyboardInteraction = false;

    this._setListeners();
  } // Getters


  static get DefaultType() {
    return DefaultType;
  }

  static get Default() {
    return Default;
  }

  static get NAME() {
    return NAME;
  } // Public


  show() {
    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW);

    if (showEvent.defaultPrevented) {
      return;
    }

    this._clearTimeout();

    if (this._config.animation) {
      this._element.classList.add(CLASS_NAME_FADE);
    }

    const complete = () => {
      this._element.classList.remove(CLASS_NAME_SHOWING);

      EventHandler.trigger(this._element, EVENT_SHOWN);

      this._maybeScheduleHide();
    };

    this._element.classList.remove(CLASS_NAME_HIDE); // @deprecated


    reflow(this._element);

    this._element.classList.add(CLASS_NAME_SHOW);

    this._element.classList.add(CLASS_NAME_SHOWING);

    this._queueCallback(complete, this._element, this._config.animation);
  }

  hide() {
    if (!this._element.classList.contains(CLASS_NAME_SHOW)) {
      return;
    }

    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);

    if (hideEvent.defaultPrevented) {
      return;
    }

    const complete = () => {
      this._element.classList.add(CLASS_NAME_HIDE); // @deprecated


      this._element.classList.remove(CLASS_NAME_SHOWING);

      this._element.classList.remove(CLASS_NAME_SHOW);

      EventHandler.trigger(this._element, EVENT_HIDDEN);
    };

    this._element.classList.add(CLASS_NAME_SHOWING);

    this._queueCallback(complete, this._element, this._config.animation);
  }

  dispose() {
    this._clearTimeout();

    if (this._element.classList.contains(CLASS_NAME_SHOW)) {
      this._element.classList.remove(CLASS_NAME_SHOW);
    }

    super.dispose();
  } // Private


  _getConfig(config) {
    config = { ...Default,
      ...Manipulator.getDataAttributes(this._element),
      ...(typeof config === 'object' && config ? config : {})
    };
    typeCheckConfig(NAME, config, this.constructor.DefaultType);
    return config;
  }

  _maybeScheduleHide() {
    if (!this._config.autohide) {
      return;
    }

    if (this._hasMouseInteraction || this._hasKeyboardInteraction) {
      return;
    }

    this._timeout = setTimeout(() => {
      this.hide();
    }, this._config.delay);
  }

  _onInteraction(event, isInteracting) {
    switch (event.type) {
      case 'mouseover':
      case 'mouseout':
        this._hasMouseInteraction = isInteracting;
        break;

      case 'focusin':
      case 'focusout':
        this._hasKeyboardInteraction = isInteracting;
        break;
    }

    if (isInteracting) {
      this._clearTimeout();

      return;
    }

    const nextElement = event.relatedTarget;

    if (this._element === nextElement || this._element.contains(nextElement)) {
      return;
    }

    this._maybeScheduleHide();
  }

  _setListeners() {
    EventHandler.on(this._element, EVENT_MOUSEOVER, event => this._onInteraction(event, true));
    EventHandler.on(this._element, EVENT_MOUSEOUT, event => this._onInteraction(event, false));
    EventHandler.on(this._element, EVENT_FOCUSIN, event => this._onInteraction(event, true));
    EventHandler.on(this._element, EVENT_FOCUSOUT, event => this._onInteraction(event, false));
  }

  _clearTimeout() {
    clearTimeout(this._timeout);
    this._timeout = null;
  } // Static


  static jQueryInterface(config) {
    return this.each(function () {
      const data = Toast.getOrCreateInstance(this, config);

      if (typeof config === 'string') {
        if (typeof data[config] === 'undefined') {
          throw new TypeError(`No method named "${config}"`);
        }

        data[config](this);
      }
    });
  }

}

enableDismissTrigger(Toast);
/**
 * ------------------------------------------------------------------------
 * jQuery
 * ------------------------------------------------------------------------
 * add .Toast to jQuery only if jQuery is present
 */

defineJQueryPlugin(Toast);


//# sourceMappingURL=bootstrap.esm.js.map


/***/ }),

/***/ "./node_modules/knockout/build/output/knockout-latest.js":
/*!***************************************************************!*\
  !*** ./node_modules/knockout/build/output/knockout-latest.js ***!
  \***************************************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * Knockout JavaScript library v3.5.1
 * (c) The Knockout.js team - http://knockoutjs.com/
 * License: MIT (http://www.opensource.org/licenses/mit-license.php)
 */

(function() {(function(n){var A=this||(0,eval)("this"),w=A.document,R=A.navigator,v=A.jQuery,H=A.JSON;v||"undefined"===typeof jQuery||(v=jQuery);(function(n){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports,__webpack_require__], __WEBPACK_AMD_DEFINE_FACTORY__ = (n),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):0})(function(S,T){function K(a,c){return null===a||typeof a in W?a===c:!1}function X(b,c){var d;return function(){d||(d=a.a.setTimeout(function(){d=n;b()},c))}}function Y(b,c){var d;return function(){clearTimeout(d);
d=a.a.setTimeout(b,c)}}function Z(a,c){c&&"change"!==c?"beforeChange"===c?this.pc(a):this.gb(a,c):this.qc(a)}function aa(a,c){null!==c&&c.s&&c.s()}function ba(a,c){var d=this.qd,e=d[r];e.ra||(this.Qb&&this.mb[c]?(d.uc(c,a,this.mb[c]),this.mb[c]=null,--this.Qb):e.I[c]||d.uc(c,a,e.J?{da:a}:d.$c(a)),a.Ja&&a.gd())}var a="undefined"!==typeof S?S:{};a.b=function(b,c){for(var d=b.split("."),e=a,f=0;f<d.length-1;f++)e=e[d[f]];e[d[d.length-1]]=c};a.L=function(a,c,d){a[c]=d};a.version="3.5.1";a.b("version",
a.version);a.options={deferUpdates:!1,useOnlyNativeEvents:!1,foreachHidesDestroyed:!1};a.a=function(){function b(a,b){for(var c in a)f.call(a,c)&&b(c,a[c])}function c(a,b){if(b)for(var c in b)f.call(b,c)&&(a[c]=b[c]);return a}function d(a,b){a.__proto__=b;return a}function e(b,c,d,e){var l=b[c].match(q)||[];a.a.D(d.match(q),function(b){a.a.Na(l,b,e)});b[c]=l.join(" ")}var f=Object.prototype.hasOwnProperty,g={__proto__:[]}instanceof Array,h="function"===typeof Symbol,m={},k={};m[R&&/Firefox\/2/i.test(R.userAgent)?
"KeyboardEvent":"UIEvents"]=["keyup","keydown","keypress"];m.MouseEvents="click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave".split(" ");b(m,function(a,b){if(b.length)for(var c=0,d=b.length;c<d;c++)k[b[c]]=a});var l={propertychange:!0},p=w&&function(){for(var a=3,b=w.createElement("div"),c=b.getElementsByTagName("i");b.innerHTML="\x3c!--[if gt IE "+ ++a+"]><i></i><![endif]--\x3e",c[0];);return 4<a?a:n}(),q=/\S+/g,t;return{Jc:["authenticity_token",/^__RequestVerificationToken(_.*)?$/],
D:function(a,b,c){for(var d=0,e=a.length;d<e;d++)b.call(c,a[d],d,a)},A:"function"==typeof Array.prototype.indexOf?function(a,b){return Array.prototype.indexOf.call(a,b)}:function(a,b){for(var c=0,d=a.length;c<d;c++)if(a[c]===b)return c;return-1},Lb:function(a,b,c){for(var d=0,e=a.length;d<e;d++)if(b.call(c,a[d],d,a))return a[d];return n},Pa:function(b,c){var d=a.a.A(b,c);0<d?b.splice(d,1):0===d&&b.shift()},wc:function(b){var c=[];b&&a.a.D(b,function(b){0>a.a.A(c,b)&&c.push(b)});return c},Mb:function(a,
b,c){var d=[];if(a)for(var e=0,l=a.length;e<l;e++)d.push(b.call(c,a[e],e));return d},jb:function(a,b,c){var d=[];if(a)for(var e=0,l=a.length;e<l;e++)b.call(c,a[e],e)&&d.push(a[e]);return d},Nb:function(a,b){if(b instanceof Array)a.push.apply(a,b);else for(var c=0,d=b.length;c<d;c++)a.push(b[c]);return a},Na:function(b,c,d){var e=a.a.A(a.a.bc(b),c);0>e?d&&b.push(c):d||b.splice(e,1)},Ba:g,extend:c,setPrototypeOf:d,Ab:g?d:c,P:b,Ga:function(a,b,c){if(!a)return a;var d={},e;for(e in a)f.call(a,e)&&(d[e]=
b.call(c,a[e],e,a));return d},Tb:function(b){for(;b.firstChild;)a.removeNode(b.firstChild)},Yb:function(b){b=a.a.la(b);for(var c=(b[0]&&b[0].ownerDocument||w).createElement("div"),d=0,e=b.length;d<e;d++)c.appendChild(a.oa(b[d]));return c},Ca:function(b,c){for(var d=0,e=b.length,l=[];d<e;d++){var k=b[d].cloneNode(!0);l.push(c?a.oa(k):k)}return l},va:function(b,c){a.a.Tb(b);if(c)for(var d=0,e=c.length;d<e;d++)b.appendChild(c[d])},Xc:function(b,c){var d=b.nodeType?[b]:b;if(0<d.length){for(var e=d[0],
l=e.parentNode,k=0,f=c.length;k<f;k++)l.insertBefore(c[k],e);k=0;for(f=d.length;k<f;k++)a.removeNode(d[k])}},Ua:function(a,b){if(a.length){for(b=8===b.nodeType&&b.parentNode||b;a.length&&a[0].parentNode!==b;)a.splice(0,1);for(;1<a.length&&a[a.length-1].parentNode!==b;)a.length--;if(1<a.length){var c=a[0],d=a[a.length-1];for(a.length=0;c!==d;)a.push(c),c=c.nextSibling;a.push(d)}}return a},Zc:function(a,b){7>p?a.setAttribute("selected",b):a.selected=b},Db:function(a){return null===a||a===n?"":a.trim?
a.trim():a.toString().replace(/^[\s\xa0]+|[\s\xa0]+$/g,"")},Ud:function(a,b){a=a||"";return b.length>a.length?!1:a.substring(0,b.length)===b},vd:function(a,b){if(a===b)return!0;if(11===a.nodeType)return!1;if(b.contains)return b.contains(1!==a.nodeType?a.parentNode:a);if(b.compareDocumentPosition)return 16==(b.compareDocumentPosition(a)&16);for(;a&&a!=b;)a=a.parentNode;return!!a},Sb:function(b){return a.a.vd(b,b.ownerDocument.documentElement)},kd:function(b){return!!a.a.Lb(b,a.a.Sb)},R:function(a){return a&&
a.tagName&&a.tagName.toLowerCase()},Ac:function(b){return a.onError?function(){try{return b.apply(this,arguments)}catch(c){throw a.onError&&a.onError(c),c;}}:b},setTimeout:function(b,c){return setTimeout(a.a.Ac(b),c)},Gc:function(b){setTimeout(function(){a.onError&&a.onError(b);throw b;},0)},B:function(b,c,d){var e=a.a.Ac(d);d=l[c];if(a.options.useOnlyNativeEvents||d||!v)if(d||"function"!=typeof b.addEventListener)if("undefined"!=typeof b.attachEvent){var k=function(a){e.call(b,a)},f="on"+c;b.attachEvent(f,
k);a.a.K.za(b,function(){b.detachEvent(f,k)})}else throw Error("Browser doesn't support addEventListener or attachEvent");else b.addEventListener(c,e,!1);else t||(t="function"==typeof v(b).on?"on":"bind"),v(b)[t](c,e)},Fb:function(b,c){if(!b||!b.nodeType)throw Error("element must be a DOM node when calling triggerEvent");var d;"input"===a.a.R(b)&&b.type&&"click"==c.toLowerCase()?(d=b.type,d="checkbox"==d||"radio"==d):d=!1;if(a.options.useOnlyNativeEvents||!v||d)if("function"==typeof w.createEvent)if("function"==
typeof b.dispatchEvent)d=w.createEvent(k[c]||"HTMLEvents"),d.initEvent(c,!0,!0,A,0,0,0,0,0,!1,!1,!1,!1,0,b),b.dispatchEvent(d);else throw Error("The supplied element doesn't support dispatchEvent");else if(d&&b.click)b.click();else if("undefined"!=typeof b.fireEvent)b.fireEvent("on"+c);else throw Error("Browser doesn't support triggering events");else v(b).trigger(c)},f:function(b){return a.O(b)?b():b},bc:function(b){return a.O(b)?b.v():b},Eb:function(b,c,d){var l;c&&("object"===typeof b.classList?
(l=b.classList[d?"add":"remove"],a.a.D(c.match(q),function(a){l.call(b.classList,a)})):"string"===typeof b.className.baseVal?e(b.className,"baseVal",c,d):e(b,"className",c,d))},Bb:function(b,c){var d=a.a.f(c);if(null===d||d===n)d="";var e=a.h.firstChild(b);!e||3!=e.nodeType||a.h.nextSibling(e)?a.h.va(b,[b.ownerDocument.createTextNode(d)]):e.data=d;a.a.Ad(b)},Yc:function(a,b){a.name=b;if(7>=p)try{var c=a.name.replace(/[&<>'"]/g,function(a){return"&#"+a.charCodeAt(0)+";"});a.mergeAttributes(w.createElement("<input name='"+
c+"'/>"),!1)}catch(d){}},Ad:function(a){9<=p&&(a=1==a.nodeType?a:a.parentNode,a.style&&(a.style.zoom=a.style.zoom))},wd:function(a){if(p){var b=a.style.width;a.style.width=0;a.style.width=b}},Pd:function(b,c){b=a.a.f(b);c=a.a.f(c);for(var d=[],e=b;e<=c;e++)d.push(e);return d},la:function(a){for(var b=[],c=0,d=a.length;c<d;c++)b.push(a[c]);return b},Da:function(a){return h?Symbol(a):a},Zd:6===p,$d:7===p,W:p,Lc:function(b,c){for(var d=a.a.la(b.getElementsByTagName("input")).concat(a.a.la(b.getElementsByTagName("textarea"))),
e="string"==typeof c?function(a){return a.name===c}:function(a){return c.test(a.name)},l=[],k=d.length-1;0<=k;k--)e(d[k])&&l.push(d[k]);return l},Nd:function(b){return"string"==typeof b&&(b=a.a.Db(b))?H&&H.parse?H.parse(b):(new Function("return "+b))():null},hc:function(b,c,d){if(!H||!H.stringify)throw Error("Cannot find JSON.stringify(). Some browsers (e.g., IE < 8) don't support it natively, but you can overcome this by adding a script reference to json2.js, downloadable from http://www.json.org/json2.js");
return H.stringify(a.a.f(b),c,d)},Od:function(c,d,e){e=e||{};var l=e.params||{},k=e.includeFields||this.Jc,f=c;if("object"==typeof c&&"form"===a.a.R(c))for(var f=c.action,h=k.length-1;0<=h;h--)for(var g=a.a.Lc(c,k[h]),m=g.length-1;0<=m;m--)l[g[m].name]=g[m].value;d=a.a.f(d);var p=w.createElement("form");p.style.display="none";p.action=f;p.method="post";for(var q in d)c=w.createElement("input"),c.type="hidden",c.name=q,c.value=a.a.hc(a.a.f(d[q])),p.appendChild(c);b(l,function(a,b){var c=w.createElement("input");
c.type="hidden";c.name=a;c.value=b;p.appendChild(c)});w.body.appendChild(p);e.submitter?e.submitter(p):p.submit();setTimeout(function(){p.parentNode.removeChild(p)},0)}}}();a.b("utils",a.a);a.b("utils.arrayForEach",a.a.D);a.b("utils.arrayFirst",a.a.Lb);a.b("utils.arrayFilter",a.a.jb);a.b("utils.arrayGetDistinctValues",a.a.wc);a.b("utils.arrayIndexOf",a.a.A);a.b("utils.arrayMap",a.a.Mb);a.b("utils.arrayPushAll",a.a.Nb);a.b("utils.arrayRemoveItem",a.a.Pa);a.b("utils.cloneNodes",a.a.Ca);a.b("utils.createSymbolOrString",
a.a.Da);a.b("utils.extend",a.a.extend);a.b("utils.fieldsIncludedWithJsonPost",a.a.Jc);a.b("utils.getFormFields",a.a.Lc);a.b("utils.objectMap",a.a.Ga);a.b("utils.peekObservable",a.a.bc);a.b("utils.postJson",a.a.Od);a.b("utils.parseJson",a.a.Nd);a.b("utils.registerEventHandler",a.a.B);a.b("utils.stringifyJson",a.a.hc);a.b("utils.range",a.a.Pd);a.b("utils.toggleDomNodeCssClass",a.a.Eb);a.b("utils.triggerEvent",a.a.Fb);a.b("utils.unwrapObservable",a.a.f);a.b("utils.objectForEach",a.a.P);a.b("utils.addOrRemoveItem",
a.a.Na);a.b("utils.setTextContent",a.a.Bb);a.b("unwrap",a.a.f);Function.prototype.bind||(Function.prototype.bind=function(a){var c=this;if(1===arguments.length)return function(){return c.apply(a,arguments)};var d=Array.prototype.slice.call(arguments,1);return function(){var e=d.slice(0);e.push.apply(e,arguments);return c.apply(a,e)}});a.a.g=new function(){var b=0,c="__ko__"+(new Date).getTime(),d={},e,f;a.a.W?(e=function(a,e){var f=a[c];if(!f||"null"===f||!d[f]){if(!e)return n;f=a[c]="ko"+b++;d[f]=
{}}return d[f]},f=function(a){var b=a[c];return b?(delete d[b],a[c]=null,!0):!1}):(e=function(a,b){var d=a[c];!d&&b&&(d=a[c]={});return d},f=function(a){return a[c]?(delete a[c],!0):!1});return{get:function(a,b){var c=e(a,!1);return c&&c[b]},set:function(a,b,c){(a=e(a,c!==n))&&(a[b]=c)},Ub:function(a,b,c){a=e(a,!0);return a[b]||(a[b]=c)},clear:f,Z:function(){return b++ +c}}};a.b("utils.domData",a.a.g);a.b("utils.domData.clear",a.a.g.clear);a.a.K=new function(){function b(b,c){var d=a.a.g.get(b,e);
d===n&&c&&(d=[],a.a.g.set(b,e,d));return d}function c(c){var e=b(c,!1);if(e)for(var e=e.slice(0),k=0;k<e.length;k++)e[k](c);a.a.g.clear(c);a.a.K.cleanExternalData(c);g[c.nodeType]&&d(c.childNodes,!0)}function d(b,d){for(var e=[],l,f=0;f<b.length;f++)if(!d||8===b[f].nodeType)if(c(e[e.length]=l=b[f]),b[f]!==l)for(;f--&&-1==a.a.A(e,b[f]););}var e=a.a.g.Z(),f={1:!0,8:!0,9:!0},g={1:!0,9:!0};return{za:function(a,c){if("function"!=typeof c)throw Error("Callback must be a function");b(a,!0).push(c)},yb:function(c,
d){var f=b(c,!1);f&&(a.a.Pa(f,d),0==f.length&&a.a.g.set(c,e,n))},oa:function(b){a.u.G(function(){f[b.nodeType]&&(c(b),g[b.nodeType]&&d(b.getElementsByTagName("*")))});return b},removeNode:function(b){a.oa(b);b.parentNode&&b.parentNode.removeChild(b)},cleanExternalData:function(a){v&&"function"==typeof v.cleanData&&v.cleanData([a])}}};a.oa=a.a.K.oa;a.removeNode=a.a.K.removeNode;a.b("cleanNode",a.oa);a.b("removeNode",a.removeNode);a.b("utils.domNodeDisposal",a.a.K);a.b("utils.domNodeDisposal.addDisposeCallback",
a.a.K.za);a.b("utils.domNodeDisposal.removeDisposeCallback",a.a.K.yb);(function(){var b=[0,"",""],c=[1,"<table>","</table>"],d=[3,"<table><tbody><tr>","</tr></tbody></table>"],e=[1,"<select multiple='multiple'>","</select>"],f={thead:c,tbody:c,tfoot:c,tr:[2,"<table><tbody>","</tbody></table>"],td:d,th:d,option:e,optgroup:e},g=8>=a.a.W;a.a.ua=function(c,d){var e;if(v)if(v.parseHTML)e=v.parseHTML(c,d)||[];else{if((e=v.clean([c],d))&&e[0]){for(var l=e[0];l.parentNode&&11!==l.parentNode.nodeType;)l=l.parentNode;
l.parentNode&&l.parentNode.removeChild(l)}}else{(e=d)||(e=w);var l=e.parentWindow||e.defaultView||A,p=a.a.Db(c).toLowerCase(),q=e.createElement("div"),t;t=(p=p.match(/^(?:\x3c!--.*?--\x3e\s*?)*?<([a-z]+)[\s>]/))&&f[p[1]]||b;p=t[0];t="ignored<div>"+t[1]+c+t[2]+"</div>";"function"==typeof l.innerShiv?q.appendChild(l.innerShiv(t)):(g&&e.body.appendChild(q),q.innerHTML=t,g&&q.parentNode.removeChild(q));for(;p--;)q=q.lastChild;e=a.a.la(q.lastChild.childNodes)}return e};a.a.Md=function(b,c){var d=a.a.ua(b,
c);return d.length&&d[0].parentElement||a.a.Yb(d)};a.a.fc=function(b,c){a.a.Tb(b);c=a.a.f(c);if(null!==c&&c!==n)if("string"!=typeof c&&(c=c.toString()),v)v(b).html(c);else for(var d=a.a.ua(c,b.ownerDocument),e=0;e<d.length;e++)b.appendChild(d[e])}})();a.b("utils.parseHtmlFragment",a.a.ua);a.b("utils.setHtml",a.a.fc);a.aa=function(){function b(c,e){if(c)if(8==c.nodeType){var f=a.aa.Uc(c.nodeValue);null!=f&&e.push({ud:c,Kd:f})}else if(1==c.nodeType)for(var f=0,g=c.childNodes,h=g.length;f<h;f++)b(g[f],
e)}var c={};return{Xb:function(a){if("function"!=typeof a)throw Error("You can only pass a function to ko.memoization.memoize()");var b=(4294967296*(1+Math.random())|0).toString(16).substring(1)+(4294967296*(1+Math.random())|0).toString(16).substring(1);c[b]=a;return"\x3c!--[ko_memo:"+b+"]--\x3e"},bd:function(a,b){var f=c[a];if(f===n)throw Error("Couldn't find any memo with ID "+a+". Perhaps it's already been unmemoized.");try{return f.apply(null,b||[]),!0}finally{delete c[a]}},cd:function(c,e){var f=
[];b(c,f);for(var g=0,h=f.length;g<h;g++){var m=f[g].ud,k=[m];e&&a.a.Nb(k,e);a.aa.bd(f[g].Kd,k);m.nodeValue="";m.parentNode&&m.parentNode.removeChild(m)}},Uc:function(a){return(a=a.match(/^\[ko_memo\:(.*?)\]$/))?a[1]:null}}}();a.b("memoization",a.aa);a.b("memoization.memoize",a.aa.Xb);a.b("memoization.unmemoize",a.aa.bd);a.b("memoization.parseMemoText",a.aa.Uc);a.b("memoization.unmemoizeDomNodeAndDescendants",a.aa.cd);a.na=function(){function b(){if(f)for(var b=f,c=0,d;h<f;)if(d=e[h++]){if(h>b){if(5E3<=
++c){h=f;a.a.Gc(Error("'Too much recursion' after processing "+c+" task groups."));break}b=f}try{d()}catch(p){a.a.Gc(p)}}}function c(){b();h=f=e.length=0}var d,e=[],f=0,g=1,h=0;A.MutationObserver?d=function(a){var b=w.createElement("div");(new MutationObserver(a)).observe(b,{attributes:!0});return function(){b.classList.toggle("foo")}}(c):d=w&&"onreadystatechange"in w.createElement("script")?function(a){var b=w.createElement("script");b.onreadystatechange=function(){b.onreadystatechange=null;w.documentElement.removeChild(b);
b=null;a()};w.documentElement.appendChild(b)}:function(a){setTimeout(a,0)};return{scheduler:d,zb:function(b){f||a.na.scheduler(c);e[f++]=b;return g++},cancel:function(a){a=a-(g-f);a>=h&&a<f&&(e[a]=null)},resetForTesting:function(){var a=f-h;h=f=e.length=0;return a},Sd:b}}();a.b("tasks",a.na);a.b("tasks.schedule",a.na.zb);a.b("tasks.runEarly",a.na.Sd);a.Ta={throttle:function(b,c){b.throttleEvaluation=c;var d=null;return a.$({read:b,write:function(e){clearTimeout(d);d=a.a.setTimeout(function(){b(e)},
c)}})},rateLimit:function(a,c){var d,e,f;"number"==typeof c?d=c:(d=c.timeout,e=c.method);a.Hb=!1;f="function"==typeof e?e:"notifyWhenChangesStop"==e?Y:X;a.ub(function(a){return f(a,d,c)})},deferred:function(b,c){if(!0!==c)throw Error("The 'deferred' extender only accepts the value 'true', because it is not supported to turn deferral off once enabled.");b.Hb||(b.Hb=!0,b.ub(function(c){var e,f=!1;return function(){if(!f){a.na.cancel(e);e=a.na.zb(c);try{f=!0,b.notifySubscribers(n,"dirty")}finally{f=
!1}}}}))},notify:function(a,c){a.equalityComparer="always"==c?null:K}};var W={undefined:1,"boolean":1,number:1,string:1};a.b("extenders",a.Ta);a.ic=function(b,c,d){this.da=b;this.lc=c;this.mc=d;this.Ib=!1;this.fb=this.Jb=null;a.L(this,"dispose",this.s);a.L(this,"disposeWhenNodeIsRemoved",this.l)};a.ic.prototype.s=function(){this.Ib||(this.fb&&a.a.K.yb(this.Jb,this.fb),this.Ib=!0,this.mc(),this.da=this.lc=this.mc=this.Jb=this.fb=null)};a.ic.prototype.l=function(b){this.Jb=b;a.a.K.za(b,this.fb=this.s.bind(this))};
a.T=function(){a.a.Ab(this,D);D.qb(this)};var D={qb:function(a){a.U={change:[]};a.sc=1},subscribe:function(b,c,d){var e=this;d=d||"change";var f=new a.ic(e,c?b.bind(c):b,function(){a.a.Pa(e.U[d],f);e.hb&&e.hb(d)});e.Qa&&e.Qa(d);e.U[d]||(e.U[d]=[]);e.U[d].push(f);return f},notifySubscribers:function(b,c){c=c||"change";"change"===c&&this.Gb();if(this.Wa(c)){var d="change"===c&&this.ed||this.U[c].slice(0);try{a.u.xc();for(var e=0,f;f=d[e];++e)f.Ib||f.lc(b)}finally{a.u.end()}}},ob:function(){return this.sc},
Dd:function(a){return this.ob()!==a},Gb:function(){++this.sc},ub:function(b){var c=this,d=a.O(c),e,f,g,h,m;c.gb||(c.gb=c.notifySubscribers,c.notifySubscribers=Z);var k=b(function(){c.Ja=!1;d&&h===c&&(h=c.nc?c.nc():c());var a=f||m&&c.sb(g,h);m=f=e=!1;a&&c.gb(g=h)});c.qc=function(a,b){b&&c.Ja||(m=!b);c.ed=c.U.change.slice(0);c.Ja=e=!0;h=a;k()};c.pc=function(a){e||(g=a,c.gb(a,"beforeChange"))};c.rc=function(){m=!0};c.gd=function(){c.sb(g,c.v(!0))&&(f=!0)}},Wa:function(a){return this.U[a]&&this.U[a].length},
Bd:function(b){if(b)return this.U[b]&&this.U[b].length||0;var c=0;a.a.P(this.U,function(a,b){"dirty"!==a&&(c+=b.length)});return c},sb:function(a,c){return!this.equalityComparer||!this.equalityComparer(a,c)},toString:function(){return"[object Object]"},extend:function(b){var c=this;b&&a.a.P(b,function(b,e){var f=a.Ta[b];"function"==typeof f&&(c=f(c,e)||c)});return c}};a.L(D,"init",D.qb);a.L(D,"subscribe",D.subscribe);a.L(D,"extend",D.extend);a.L(D,"getSubscriptionsCount",D.Bd);a.a.Ba&&a.a.setPrototypeOf(D,
Function.prototype);a.T.fn=D;a.Qc=function(a){return null!=a&&"function"==typeof a.subscribe&&"function"==typeof a.notifySubscribers};a.b("subscribable",a.T);a.b("isSubscribable",a.Qc);a.S=a.u=function(){function b(a){d.push(e);e=a}function c(){e=d.pop()}var d=[],e,f=0;return{xc:b,end:c,cc:function(b){if(e){if(!a.Qc(b))throw Error("Only subscribable things can act as dependencies");e.od.call(e.pd,b,b.fd||(b.fd=++f))}},G:function(a,d,e){try{return b(),a.apply(d,e||[])}finally{c()}},qa:function(){if(e)return e.o.qa()},
Va:function(){if(e)return e.o.Va()},Ya:function(){if(e)return e.Ya},o:function(){if(e)return e.o}}}();a.b("computedContext",a.S);a.b("computedContext.getDependenciesCount",a.S.qa);a.b("computedContext.getDependencies",a.S.Va);a.b("computedContext.isInitial",a.S.Ya);a.b("computedContext.registerDependency",a.S.cc);a.b("ignoreDependencies",a.Yd=a.u.G);var I=a.a.Da("_latestValue");a.ta=function(b){function c(){if(0<arguments.length)return c.sb(c[I],arguments[0])&&(c.ya(),c[I]=arguments[0],c.xa()),this;
a.u.cc(c);return c[I]}c[I]=b;a.a.Ba||a.a.extend(c,a.T.fn);a.T.fn.qb(c);a.a.Ab(c,F);a.options.deferUpdates&&a.Ta.deferred(c,!0);return c};var F={equalityComparer:K,v:function(){return this[I]},xa:function(){this.notifySubscribers(this[I],"spectate");this.notifySubscribers(this[I])},ya:function(){this.notifySubscribers(this[I],"beforeChange")}};a.a.Ba&&a.a.setPrototypeOf(F,a.T.fn);var G=a.ta.Ma="__ko_proto__";F[G]=a.ta;a.O=function(b){if((b="function"==typeof b&&b[G])&&b!==F[G]&&b!==a.o.fn[G])throw Error("Invalid object that looks like an observable; possibly from another Knockout instance");
return!!b};a.Za=function(b){return"function"==typeof b&&(b[G]===F[G]||b[G]===a.o.fn[G]&&b.Nc)};a.b("observable",a.ta);a.b("isObservable",a.O);a.b("isWriteableObservable",a.Za);a.b("isWritableObservable",a.Za);a.b("observable.fn",F);a.L(F,"peek",F.v);a.L(F,"valueHasMutated",F.xa);a.L(F,"valueWillMutate",F.ya);a.Ha=function(b){b=b||[];if("object"!=typeof b||!("length"in b))throw Error("The argument passed when initializing an observable array must be an array, or null, or undefined.");b=a.ta(b);a.a.Ab(b,
a.Ha.fn);return b.extend({trackArrayChanges:!0})};a.Ha.fn={remove:function(b){for(var c=this.v(),d=[],e="function"!=typeof b||a.O(b)?function(a){return a===b}:b,f=0;f<c.length;f++){var g=c[f];if(e(g)){0===d.length&&this.ya();if(c[f]!==g)throw Error("Array modified during remove; cannot remove item");d.push(g);c.splice(f,1);f--}}d.length&&this.xa();return d},removeAll:function(b){if(b===n){var c=this.v(),d=c.slice(0);this.ya();c.splice(0,c.length);this.xa();return d}return b?this.remove(function(c){return 0<=
a.a.A(b,c)}):[]},destroy:function(b){var c=this.v(),d="function"!=typeof b||a.O(b)?function(a){return a===b}:b;this.ya();for(var e=c.length-1;0<=e;e--){var f=c[e];d(f)&&(f._destroy=!0)}this.xa()},destroyAll:function(b){return b===n?this.destroy(function(){return!0}):b?this.destroy(function(c){return 0<=a.a.A(b,c)}):[]},indexOf:function(b){var c=this();return a.a.A(c,b)},replace:function(a,c){var d=this.indexOf(a);0<=d&&(this.ya(),this.v()[d]=c,this.xa())},sorted:function(a){var c=this().slice(0);
return a?c.sort(a):c.sort()},reversed:function(){return this().slice(0).reverse()}};a.a.Ba&&a.a.setPrototypeOf(a.Ha.fn,a.ta.fn);a.a.D("pop push reverse shift sort splice unshift".split(" "),function(b){a.Ha.fn[b]=function(){var a=this.v();this.ya();this.zc(a,b,arguments);var d=a[b].apply(a,arguments);this.xa();return d===a?this:d}});a.a.D(["slice"],function(b){a.Ha.fn[b]=function(){var a=this();return a[b].apply(a,arguments)}});a.Pc=function(b){return a.O(b)&&"function"==typeof b.remove&&"function"==
typeof b.push};a.b("observableArray",a.Ha);a.b("isObservableArray",a.Pc);a.Ta.trackArrayChanges=function(b,c){function d(){function c(){if(m){var d=[].concat(b.v()||[]),e;if(b.Wa("arrayChange")){if(!f||1<m)f=a.a.Pb(k,d,b.Ob);e=f}k=d;f=null;m=0;e&&e.length&&b.notifySubscribers(e,"arrayChange")}}e?c():(e=!0,h=b.subscribe(function(){++m},null,"spectate"),k=[].concat(b.v()||[]),f=null,g=b.subscribe(c))}b.Ob={};c&&"object"==typeof c&&a.a.extend(b.Ob,c);b.Ob.sparse=!0;if(!b.zc){var e=!1,f=null,g,h,m=0,
k,l=b.Qa,p=b.hb;b.Qa=function(a){l&&l.call(b,a);"arrayChange"===a&&d()};b.hb=function(a){p&&p.call(b,a);"arrayChange"!==a||b.Wa("arrayChange")||(g&&g.s(),h&&h.s(),h=g=null,e=!1,k=n)};b.zc=function(b,c,d){function l(a,b,c){return k[k.length]={status:a,value:b,index:c}}if(e&&!m){var k=[],p=b.length,g=d.length,h=0;switch(c){case "push":h=p;case "unshift":for(c=0;c<g;c++)l("added",d[c],h+c);break;case "pop":h=p-1;case "shift":p&&l("deleted",b[h],h);break;case "splice":c=Math.min(Math.max(0,0>d[0]?p+d[0]:
d[0]),p);for(var p=1===g?p:Math.min(c+(d[1]||0),p),g=c+g-2,h=Math.max(p,g),U=[],L=[],n=2;c<h;++c,++n)c<p&&L.push(l("deleted",b[c],c)),c<g&&U.push(l("added",d[n],c));a.a.Kc(L,U);break;default:return}f=k}}}};var r=a.a.Da("_state");a.o=a.$=function(b,c,d){function e(){if(0<arguments.length){if("function"===typeof f)f.apply(g.nb,arguments);else throw Error("Cannot write a value to a ko.computed unless you specify a 'write' option. If you wish to read the current value, don't pass any parameters.");return this}g.ra||
a.u.cc(e);(g.ka||g.J&&e.Xa())&&e.ha();return g.X}"object"===typeof b?d=b:(d=d||{},b&&(d.read=b));if("function"!=typeof d.read)throw Error("Pass a function that returns the value of the ko.computed");var f=d.write,g={X:n,sa:!0,ka:!0,rb:!1,jc:!1,ra:!1,wb:!1,J:!1,Wc:d.read,nb:c||d.owner,l:d.disposeWhenNodeIsRemoved||d.l||null,Sa:d.disposeWhen||d.Sa,Rb:null,I:{},V:0,Ic:null};e[r]=g;e.Nc="function"===typeof f;a.a.Ba||a.a.extend(e,a.T.fn);a.T.fn.qb(e);a.a.Ab(e,C);d.pure?(g.wb=!0,g.J=!0,a.a.extend(e,da)):
d.deferEvaluation&&a.a.extend(e,ea);a.options.deferUpdates&&a.Ta.deferred(e,!0);g.l&&(g.jc=!0,g.l.nodeType||(g.l=null));g.J||d.deferEvaluation||e.ha();g.l&&e.ja()&&a.a.K.za(g.l,g.Rb=function(){e.s()});return e};var C={equalityComparer:K,qa:function(){return this[r].V},Va:function(){var b=[];a.a.P(this[r].I,function(a,d){b[d.Ka]=d.da});return b},Vb:function(b){if(!this[r].V)return!1;var c=this.Va();return-1!==a.a.A(c,b)?!0:!!a.a.Lb(c,function(a){return a.Vb&&a.Vb(b)})},uc:function(a,c,d){if(this[r].wb&&
c===this)throw Error("A 'pure' computed must not be called recursively");this[r].I[a]=d;d.Ka=this[r].V++;d.La=c.ob()},Xa:function(){var a,c,d=this[r].I;for(a in d)if(Object.prototype.hasOwnProperty.call(d,a)&&(c=d[a],this.Ia&&c.da.Ja||c.da.Dd(c.La)))return!0},Jd:function(){this.Ia&&!this[r].rb&&this.Ia(!1)},ja:function(){var a=this[r];return a.ka||0<a.V},Rd:function(){this.Ja?this[r].ka&&(this[r].sa=!0):this.Hc()},$c:function(a){if(a.Hb){var c=a.subscribe(this.Jd,this,"dirty"),d=a.subscribe(this.Rd,
this);return{da:a,s:function(){c.s();d.s()}}}return a.subscribe(this.Hc,this)},Hc:function(){var b=this,c=b.throttleEvaluation;c&&0<=c?(clearTimeout(this[r].Ic),this[r].Ic=a.a.setTimeout(function(){b.ha(!0)},c)):b.Ia?b.Ia(!0):b.ha(!0)},ha:function(b){var c=this[r],d=c.Sa,e=!1;if(!c.rb&&!c.ra){if(c.l&&!a.a.Sb(c.l)||d&&d()){if(!c.jc){this.s();return}}else c.jc=!1;c.rb=!0;try{e=this.zd(b)}finally{c.rb=!1}return e}},zd:function(b){var c=this[r],d=!1,e=c.wb?n:!c.V,d={qd:this,mb:c.I,Qb:c.V};a.u.xc({pd:d,
od:ba,o:this,Ya:e});c.I={};c.V=0;var f=this.yd(c,d);c.V?d=this.sb(c.X,f):(this.s(),d=!0);d&&(c.J?this.Gb():this.notifySubscribers(c.X,"beforeChange"),c.X=f,this.notifySubscribers(c.X,"spectate"),!c.J&&b&&this.notifySubscribers(c.X),this.rc&&this.rc());e&&this.notifySubscribers(c.X,"awake");return d},yd:function(b,c){try{var d=b.Wc;return b.nb?d.call(b.nb):d()}finally{a.u.end(),c.Qb&&!b.J&&a.a.P(c.mb,aa),b.sa=b.ka=!1}},v:function(a){var c=this[r];(c.ka&&(a||!c.V)||c.J&&this.Xa())&&this.ha();return c.X},
ub:function(b){a.T.fn.ub.call(this,b);this.nc=function(){this[r].J||(this[r].sa?this.ha():this[r].ka=!1);return this[r].X};this.Ia=function(a){this.pc(this[r].X);this[r].ka=!0;a&&(this[r].sa=!0);this.qc(this,!a)}},s:function(){var b=this[r];!b.J&&b.I&&a.a.P(b.I,function(a,b){b.s&&b.s()});b.l&&b.Rb&&a.a.K.yb(b.l,b.Rb);b.I=n;b.V=0;b.ra=!0;b.sa=!1;b.ka=!1;b.J=!1;b.l=n;b.Sa=n;b.Wc=n;this.Nc||(b.nb=n)}},da={Qa:function(b){var c=this,d=c[r];if(!d.ra&&d.J&&"change"==b){d.J=!1;if(d.sa||c.Xa())d.I=null,d.V=
0,c.ha()&&c.Gb();else{var e=[];a.a.P(d.I,function(a,b){e[b.Ka]=a});a.a.D(e,function(a,b){var e=d.I[a],m=c.$c(e.da);m.Ka=b;m.La=e.La;d.I[a]=m});c.Xa()&&c.ha()&&c.Gb()}d.ra||c.notifySubscribers(d.X,"awake")}},hb:function(b){var c=this[r];c.ra||"change"!=b||this.Wa("change")||(a.a.P(c.I,function(a,b){b.s&&(c.I[a]={da:b.da,Ka:b.Ka,La:b.La},b.s())}),c.J=!0,this.notifySubscribers(n,"asleep"))},ob:function(){var b=this[r];b.J&&(b.sa||this.Xa())&&this.ha();return a.T.fn.ob.call(this)}},ea={Qa:function(a){"change"!=
a&&"beforeChange"!=a||this.v()}};a.a.Ba&&a.a.setPrototypeOf(C,a.T.fn);var N=a.ta.Ma;C[N]=a.o;a.Oc=function(a){return"function"==typeof a&&a[N]===C[N]};a.Fd=function(b){return a.Oc(b)&&b[r]&&b[r].wb};a.b("computed",a.o);a.b("dependentObservable",a.o);a.b("isComputed",a.Oc);a.b("isPureComputed",a.Fd);a.b("computed.fn",C);a.L(C,"peek",C.v);a.L(C,"dispose",C.s);a.L(C,"isActive",C.ja);a.L(C,"getDependenciesCount",C.qa);a.L(C,"getDependencies",C.Va);a.xb=function(b,c){if("function"===typeof b)return a.o(b,
c,{pure:!0});b=a.a.extend({},b);b.pure=!0;return a.o(b,c)};a.b("pureComputed",a.xb);(function(){function b(a,f,g){g=g||new d;a=f(a);if("object"!=typeof a||null===a||a===n||a instanceof RegExp||a instanceof Date||a instanceof String||a instanceof Number||a instanceof Boolean)return a;var h=a instanceof Array?[]:{};g.save(a,h);c(a,function(c){var d=f(a[c]);switch(typeof d){case "boolean":case "number":case "string":case "function":h[c]=d;break;case "object":case "undefined":var l=g.get(d);h[c]=l!==
n?l:b(d,f,g)}});return h}function c(a,b){if(a instanceof Array){for(var c=0;c<a.length;c++)b(c);"function"==typeof a.toJSON&&b("toJSON")}else for(c in a)b(c)}function d(){this.keys=[];this.values=[]}a.ad=function(c){if(0==arguments.length)throw Error("When calling ko.toJS, pass the object you want to convert.");return b(c,function(b){for(var c=0;a.O(b)&&10>c;c++)b=b();return b})};a.toJSON=function(b,c,d){b=a.ad(b);return a.a.hc(b,c,d)};d.prototype={constructor:d,save:function(b,c){var d=a.a.A(this.keys,
b);0<=d?this.values[d]=c:(this.keys.push(b),this.values.push(c))},get:function(b){b=a.a.A(this.keys,b);return 0<=b?this.values[b]:n}}})();a.b("toJS",a.ad);a.b("toJSON",a.toJSON);a.Wd=function(b,c,d){function e(c){var e=a.xb(b,d).extend({ma:"always"}),h=e.subscribe(function(a){a&&(h.s(),c(a))});e.notifySubscribers(e.v());return h}return"function"!==typeof Promise||c?e(c.bind(d)):new Promise(e)};a.b("when",a.Wd);(function(){a.w={M:function(b){switch(a.a.R(b)){case "option":return!0===b.__ko__hasDomDataOptionValue__?
a.a.g.get(b,a.c.options.$b):7>=a.a.W?b.getAttributeNode("value")&&b.getAttributeNode("value").specified?b.value:b.text:b.value;case "select":return 0<=b.selectedIndex?a.w.M(b.options[b.selectedIndex]):n;default:return b.value}},cb:function(b,c,d){switch(a.a.R(b)){case "option":"string"===typeof c?(a.a.g.set(b,a.c.options.$b,n),"__ko__hasDomDataOptionValue__"in b&&delete b.__ko__hasDomDataOptionValue__,b.value=c):(a.a.g.set(b,a.c.options.$b,c),b.__ko__hasDomDataOptionValue__=!0,b.value="number"===
typeof c?c:"");break;case "select":if(""===c||null===c)c=n;for(var e=-1,f=0,g=b.options.length,h;f<g;++f)if(h=a.w.M(b.options[f]),h==c||""===h&&c===n){e=f;break}if(d||0<=e||c===n&&1<b.size)b.selectedIndex=e,6===a.a.W&&a.a.setTimeout(function(){b.selectedIndex=e},0);break;default:if(null===c||c===n)c="";b.value=c}}}})();a.b("selectExtensions",a.w);a.b("selectExtensions.readValue",a.w.M);a.b("selectExtensions.writeValue",a.w.cb);a.m=function(){function b(b){b=a.a.Db(b);123===b.charCodeAt(0)&&(b=b.slice(1,
-1));b+="\n,";var c=[],d=b.match(e),p,q=[],h=0;if(1<d.length){for(var x=0,B;B=d[x];++x){var u=B.charCodeAt(0);if(44===u){if(0>=h){c.push(p&&q.length?{key:p,value:q.join("")}:{unknown:p||q.join("")});p=h=0;q=[];continue}}else if(58===u){if(!h&&!p&&1===q.length){p=q.pop();continue}}else if(47===u&&1<B.length&&(47===B.charCodeAt(1)||42===B.charCodeAt(1)))continue;else 47===u&&x&&1<B.length?(u=d[x-1].match(f))&&!g[u[0]]&&(b=b.substr(b.indexOf(B)+1),d=b.match(e),x=-1,B="/"):40===u||123===u||91===u?++h:
41===u||125===u||93===u?--h:p||q.length||34!==u&&39!==u||(B=B.slice(1,-1));q.push(B)}if(0<h)throw Error("Unbalanced parentheses, braces, or brackets");}return c}var c=["true","false","null","undefined"],d=/^(?:[$_a-z][$\w]*|(.+)(\.\s*[$_a-z][$\w]*|\[.+\]))$/i,e=RegExp("\"(?:\\\\.|[^\"])*\"|'(?:\\\\.|[^'])*'|`(?:\\\\.|[^`])*`|/\\*(?:[^*]|\\*+[^*/])*\\*+/|//.*\n|/(?:\\\\.|[^/])+/w*|[^\\s:,/][^,\"'`{}()/:[\\]]*[^\\s,\"'`{}()/:[\\]]|[^\\s]","g"),f=/[\])"'A-Za-z0-9_$]+$/,g={"in":1,"return":1,"typeof":1},
h={};return{Ra:[],wa:h,ac:b,vb:function(e,f){function l(b,e){var f;if(!x){var k=a.getBindingHandler(b);if(k&&k.preprocess&&!(e=k.preprocess(e,b,l)))return;if(k=h[b])f=e,0<=a.a.A(c,f)?f=!1:(k=f.match(d),f=null===k?!1:k[1]?"Object("+k[1]+")"+k[2]:f),k=f;k&&q.push("'"+("string"==typeof h[b]?h[b]:b)+"':function(_z){"+f+"=_z}")}g&&(e="function(){return "+e+" }");p.push("'"+b+"':"+e)}f=f||{};var p=[],q=[],g=f.valueAccessors,x=f.bindingParams,B="string"===typeof e?b(e):e;a.a.D(B,function(a){l(a.key||a.unknown,
a.value)});q.length&&l("_ko_property_writers","{"+q.join(",")+" }");return p.join(",")},Id:function(a,b){for(var c=0;c<a.length;c++)if(a[c].key==b)return!0;return!1},eb:function(b,c,d,e,f){if(b&&a.O(b))!a.Za(b)||f&&b.v()===e||b(e);else if((b=c.get("_ko_property_writers"))&&b[d])b[d](e)}}}();a.b("expressionRewriting",a.m);a.b("expressionRewriting.bindingRewriteValidators",a.m.Ra);a.b("expressionRewriting.parseObjectLiteral",a.m.ac);a.b("expressionRewriting.preProcessBindings",a.m.vb);a.b("expressionRewriting._twoWayBindings",
a.m.wa);a.b("jsonExpressionRewriting",a.m);a.b("jsonExpressionRewriting.insertPropertyAccessorsIntoJson",a.m.vb);(function(){function b(a){return 8==a.nodeType&&g.test(f?a.text:a.nodeValue)}function c(a){return 8==a.nodeType&&h.test(f?a.text:a.nodeValue)}function d(d,e){for(var f=d,h=1,g=[];f=f.nextSibling;){if(c(f)&&(a.a.g.set(f,k,!0),h--,0===h))return g;g.push(f);b(f)&&h++}if(!e)throw Error("Cannot find closing comment tag to match: "+d.nodeValue);return null}function e(a,b){var c=d(a,b);return c?
0<c.length?c[c.length-1].nextSibling:a.nextSibling:null}var f=w&&"\x3c!--test--\x3e"===w.createComment("test").text,g=f?/^\x3c!--\s*ko(?:\s+([\s\S]+))?\s*--\x3e$/:/^\s*ko(?:\s+([\s\S]+))?\s*$/,h=f?/^\x3c!--\s*\/ko\s*--\x3e$/:/^\s*\/ko\s*$/,m={ul:!0,ol:!0},k="__ko_matchedEndComment__";a.h={ea:{},childNodes:function(a){return b(a)?d(a):a.childNodes},Ea:function(c){if(b(c)){c=a.h.childNodes(c);for(var d=0,e=c.length;d<e;d++)a.removeNode(c[d])}else a.a.Tb(c)},va:function(c,d){if(b(c)){a.h.Ea(c);for(var e=
c.nextSibling,f=0,k=d.length;f<k;f++)e.parentNode.insertBefore(d[f],e)}else a.a.va(c,d)},Vc:function(a,c){var d;b(a)?(d=a.nextSibling,a=a.parentNode):d=a.firstChild;d?c!==d&&a.insertBefore(c,d):a.appendChild(c)},Wb:function(c,d,e){e?(e=e.nextSibling,b(c)&&(c=c.parentNode),e?d!==e&&c.insertBefore(d,e):c.appendChild(d)):a.h.Vc(c,d)},firstChild:function(a){if(b(a))return!a.nextSibling||c(a.nextSibling)?null:a.nextSibling;if(a.firstChild&&c(a.firstChild))throw Error("Found invalid end comment, as the first child of "+
a);return a.firstChild},nextSibling:function(d){b(d)&&(d=e(d));if(d.nextSibling&&c(d.nextSibling)){var f=d.nextSibling;if(c(f)&&!a.a.g.get(f,k))throw Error("Found end comment without a matching opening comment, as child of "+d);return null}return d.nextSibling},Cd:b,Vd:function(a){return(a=(f?a.text:a.nodeValue).match(g))?a[1]:null},Sc:function(d){if(m[a.a.R(d)]){var f=d.firstChild;if(f){do if(1===f.nodeType){var k;k=f.firstChild;var h=null;if(k){do if(h)h.push(k);else if(b(k)){var g=e(k,!0);g?k=
g:h=[k]}else c(k)&&(h=[k]);while(k=k.nextSibling)}if(k=h)for(h=f.nextSibling,g=0;g<k.length;g++)h?d.insertBefore(k[g],h):d.appendChild(k[g])}while(f=f.nextSibling)}}}}})();a.b("virtualElements",a.h);a.b("virtualElements.allowedBindings",a.h.ea);a.b("virtualElements.emptyNode",a.h.Ea);a.b("virtualElements.insertAfter",a.h.Wb);a.b("virtualElements.prepend",a.h.Vc);a.b("virtualElements.setDomNodeChildren",a.h.va);(function(){a.ga=function(){this.nd={}};a.a.extend(a.ga.prototype,{nodeHasBindings:function(b){switch(b.nodeType){case 1:return null!=
b.getAttribute("data-bind")||a.j.getComponentNameForNode(b);case 8:return a.h.Cd(b);default:return!1}},getBindings:function(b,c){var d=this.getBindingsString(b,c),d=d?this.parseBindingsString(d,c,b):null;return a.j.tc(d,b,c,!1)},getBindingAccessors:function(b,c){var d=this.getBindingsString(b,c),d=d?this.parseBindingsString(d,c,b,{valueAccessors:!0}):null;return a.j.tc(d,b,c,!0)},getBindingsString:function(b){switch(b.nodeType){case 1:return b.getAttribute("data-bind");case 8:return a.h.Vd(b);default:return null}},
parseBindingsString:function(b,c,d,e){try{var f=this.nd,g=b+(e&&e.valueAccessors||""),h;if(!(h=f[g])){var m,k="with($context){with($data||{}){return{"+a.m.vb(b,e)+"}}}";m=new Function("$context","$element",k);h=f[g]=m}return h(c,d)}catch(l){throw l.message="Unable to parse bindings.\nBindings value: "+b+"\nMessage: "+l.message,l;}}});a.ga.instance=new a.ga})();a.b("bindingProvider",a.ga);(function(){function b(b){var c=(b=a.a.g.get(b,z))&&b.N;c&&(b.N=null,c.Tc())}function c(c,d,e){this.node=c;this.yc=
d;this.kb=[];this.H=!1;d.N||a.a.K.za(c,b);e&&e.N&&(e.N.kb.push(c),this.Kb=e)}function d(a){return function(){return a}}function e(a){return a()}function f(b){return a.a.Ga(a.u.G(b),function(a,c){return function(){return b()[c]}})}function g(b,c,e){return"function"===typeof b?f(b.bind(null,c,e)):a.a.Ga(b,d)}function h(a,b){return f(this.getBindings.bind(this,a,b))}function m(b,c){var d=a.h.firstChild(c);if(d){var e,f=a.ga.instance,l=f.preprocessNode;if(l){for(;e=d;)d=a.h.nextSibling(e),l.call(f,e);
d=a.h.firstChild(c)}for(;e=d;)d=a.h.nextSibling(e),k(b,e)}a.i.ma(c,a.i.H)}function k(b,c){var d=b,e=1===c.nodeType;e&&a.h.Sc(c);if(e||a.ga.instance.nodeHasBindings(c))d=p(c,null,b).bindingContextForDescendants;d&&!u[a.a.R(c)]&&m(d,c)}function l(b){var c=[],d={},e=[];a.a.P(b,function ca(f){if(!d[f]){var k=a.getBindingHandler(f);k&&(k.after&&(e.push(f),a.a.D(k.after,function(c){if(b[c]){if(-1!==a.a.A(e,c))throw Error("Cannot combine the following bindings, because they have a cyclic dependency: "+e.join(", "));
ca(c)}}),e.length--),c.push({key:f,Mc:k}));d[f]=!0}});return c}function p(b,c,d){var f=a.a.g.Ub(b,z,{}),k=f.hd;if(!c){if(k)throw Error("You cannot apply bindings multiple times to the same element.");f.hd=!0}k||(f.context=d);f.Zb||(f.Zb={});var g;if(c&&"function"!==typeof c)g=c;else{var p=a.ga.instance,q=p.getBindingAccessors||h,m=a.$(function(){if(g=c?c(d,b):q.call(p,b,d)){if(d[t])d[t]();if(d[B])d[B]()}return g},null,{l:b});g&&m.ja()||(m=null)}var x=d,u;if(g){var J=function(){return a.a.Ga(m?m():
g,e)},r=m?function(a){return function(){return e(m()[a])}}:function(a){return g[a]};J.get=function(a){return g[a]&&e(r(a))};J.has=function(a){return a in g};a.i.H in g&&a.i.subscribe(b,a.i.H,function(){var c=(0,g[a.i.H])();if(c){var d=a.h.childNodes(b);d.length&&c(d,a.Ec(d[0]))}});a.i.pa in g&&(x=a.i.Cb(b,d),a.i.subscribe(b,a.i.pa,function(){var c=(0,g[a.i.pa])();c&&a.h.firstChild(b)&&c(b)}));f=l(g);a.a.D(f,function(c){var d=c.Mc.init,e=c.Mc.update,f=c.key;if(8===b.nodeType&&!a.h.ea[f])throw Error("The binding '"+
f+"' cannot be used with virtual elements");try{"function"==typeof d&&a.u.G(function(){var a=d(b,r(f),J,x.$data,x);if(a&&a.controlsDescendantBindings){if(u!==n)throw Error("Multiple bindings ("+u+" and "+f+") are trying to control descendant bindings of the same element. You cannot use these bindings together on the same element.");u=f}}),"function"==typeof e&&a.$(function(){e(b,r(f),J,x.$data,x)},null,{l:b})}catch(k){throw k.message='Unable to process binding "'+f+": "+g[f]+'"\nMessage: '+k.message,
k;}})}f=u===n;return{shouldBindDescendants:f,bindingContextForDescendants:f&&x}}function q(b,c){return b&&b instanceof a.fa?b:new a.fa(b,n,n,c)}var t=a.a.Da("_subscribable"),x=a.a.Da("_ancestorBindingInfo"),B=a.a.Da("_dataDependency");a.c={};var u={script:!0,textarea:!0,template:!0};a.getBindingHandler=function(b){return a.c[b]};var J={};a.fa=function(b,c,d,e,f){function k(){var b=p?h():h,f=a.a.f(b);c?(a.a.extend(l,c),x in c&&(l[x]=c[x])):(l.$parents=[],l.$root=f,l.ko=a);l[t]=q;g?f=l.$data:(l.$rawData=
b,l.$data=f);d&&(l[d]=f);e&&e(l,c,f);if(c&&c[t]&&!a.S.o().Vb(c[t]))c[t]();m&&(l[B]=m);return l.$data}var l=this,g=b===J,h=g?n:b,p="function"==typeof h&&!a.O(h),q,m=f&&f.dataDependency;f&&f.exportDependencies?k():(q=a.xb(k),q.v(),q.ja()?q.equalityComparer=null:l[t]=n)};a.fa.prototype.createChildContext=function(b,c,d,e){!e&&c&&"object"==typeof c&&(e=c,c=e.as,d=e.extend);if(c&&e&&e.noChildContext){var f="function"==typeof b&&!a.O(b);return new a.fa(J,this,null,function(a){d&&d(a);a[c]=f?b():b},e)}return new a.fa(b,
this,c,function(a,b){a.$parentContext=b;a.$parent=b.$data;a.$parents=(b.$parents||[]).slice(0);a.$parents.unshift(a.$parent);d&&d(a)},e)};a.fa.prototype.extend=function(b,c){return new a.fa(J,this,null,function(c){a.a.extend(c,"function"==typeof b?b(c):b)},c)};var z=a.a.g.Z();c.prototype.Tc=function(){this.Kb&&this.Kb.N&&this.Kb.N.sd(this.node)};c.prototype.sd=function(b){a.a.Pa(this.kb,b);!this.kb.length&&this.H&&this.Cc()};c.prototype.Cc=function(){this.H=!0;this.yc.N&&!this.kb.length&&(this.yc.N=
null,a.a.K.yb(this.node,b),a.i.ma(this.node,a.i.pa),this.Tc())};a.i={H:"childrenComplete",pa:"descendantsComplete",subscribe:function(b,c,d,e,f){var k=a.a.g.Ub(b,z,{});k.Fa||(k.Fa=new a.T);f&&f.notifyImmediately&&k.Zb[c]&&a.u.G(d,e,[b]);return k.Fa.subscribe(d,e,c)},ma:function(b,c){var d=a.a.g.get(b,z);if(d&&(d.Zb[c]=!0,d.Fa&&d.Fa.notifySubscribers(b,c),c==a.i.H))if(d.N)d.N.Cc();else if(d.N===n&&d.Fa&&d.Fa.Wa(a.i.pa))throw Error("descendantsComplete event not supported for bindings on this node");
},Cb:function(b,d){var e=a.a.g.Ub(b,z,{});e.N||(e.N=new c(b,e,d[x]));return d[x]==e?d:d.extend(function(a){a[x]=e})}};a.Td=function(b){return(b=a.a.g.get(b,z))&&b.context};a.ib=function(b,c,d){1===b.nodeType&&a.h.Sc(b);return p(b,c,q(d))};a.ld=function(b,c,d){d=q(d);return a.ib(b,g(c,d,b),d)};a.Oa=function(a,b){1!==b.nodeType&&8!==b.nodeType||m(q(a),b)};a.vc=function(a,b,c){!v&&A.jQuery&&(v=A.jQuery);if(2>arguments.length){if(b=w.body,!b)throw Error("ko.applyBindings: could not find document.body; has the document been loaded?");
}else if(!b||1!==b.nodeType&&8!==b.nodeType)throw Error("ko.applyBindings: first parameter should be your view model; second parameter should be a DOM node");k(q(a,c),b)};a.Dc=function(b){return!b||1!==b.nodeType&&8!==b.nodeType?n:a.Td(b)};a.Ec=function(b){return(b=a.Dc(b))?b.$data:n};a.b("bindingHandlers",a.c);a.b("bindingEvent",a.i);a.b("bindingEvent.subscribe",a.i.subscribe);a.b("bindingEvent.startPossiblyAsyncContentBinding",a.i.Cb);a.b("applyBindings",a.vc);a.b("applyBindingsToDescendants",a.Oa);
a.b("applyBindingAccessorsToNode",a.ib);a.b("applyBindingsToNode",a.ld);a.b("contextFor",a.Dc);a.b("dataFor",a.Ec)})();(function(b){function c(c,e){var k=Object.prototype.hasOwnProperty.call(f,c)?f[c]:b,l;k?k.subscribe(e):(k=f[c]=new a.T,k.subscribe(e),d(c,function(b,d){var e=!(!d||!d.synchronous);g[c]={definition:b,Gd:e};delete f[c];l||e?k.notifySubscribers(b):a.na.zb(function(){k.notifySubscribers(b)})}),l=!0)}function d(a,b){e("getConfig",[a],function(c){c?e("loadComponent",[a,c],function(a){b(a,
c)}):b(null,null)})}function e(c,d,f,l){l||(l=a.j.loaders.slice(0));var g=l.shift();if(g){var q=g[c];if(q){var t=!1;if(q.apply(g,d.concat(function(a){t?f(null):null!==a?f(a):e(c,d,f,l)}))!==b&&(t=!0,!g.suppressLoaderExceptions))throw Error("Component loaders must supply values by invoking the callback, not by returning values synchronously.");}else e(c,d,f,l)}else f(null)}var f={},g={};a.j={get:function(d,e){var f=Object.prototype.hasOwnProperty.call(g,d)?g[d]:b;f?f.Gd?a.u.G(function(){e(f.definition)}):
a.na.zb(function(){e(f.definition)}):c(d,e)},Bc:function(a){delete g[a]},oc:e};a.j.loaders=[];a.b("components",a.j);a.b("components.get",a.j.get);a.b("components.clearCachedDefinition",a.j.Bc)})();(function(){function b(b,c,d,e){function g(){0===--B&&e(h)}var h={},B=2,u=d.template;d=d.viewModel;u?f(c,u,function(c){a.j.oc("loadTemplate",[b,c],function(a){h.template=a;g()})}):g();d?f(c,d,function(c){a.j.oc("loadViewModel",[b,c],function(a){h[m]=a;g()})}):g()}function c(a,b,d){if("function"===typeof b)d(function(a){return new b(a)});
else if("function"===typeof b[m])d(b[m]);else if("instance"in b){var e=b.instance;d(function(){return e})}else"viewModel"in b?c(a,b.viewModel,d):a("Unknown viewModel value: "+b)}function d(b){switch(a.a.R(b)){case "script":return a.a.ua(b.text);case "textarea":return a.a.ua(b.value);case "template":if(e(b.content))return a.a.Ca(b.content.childNodes)}return a.a.Ca(b.childNodes)}function e(a){return A.DocumentFragment?a instanceof DocumentFragment:a&&11===a.nodeType}function f(a,b,c){"string"===typeof b.require?
T||A.require?(T||A.require)([b.require],function(a){a&&"object"===typeof a&&a.Xd&&a["default"]&&(a=a["default"]);c(a)}):a("Uses require, but no AMD loader is present"):c(b)}function g(a){return function(b){throw Error("Component '"+a+"': "+b);}}var h={};a.j.register=function(b,c){if(!c)throw Error("Invalid configuration for "+b);if(a.j.tb(b))throw Error("Component "+b+" is already registered");h[b]=c};a.j.tb=function(a){return Object.prototype.hasOwnProperty.call(h,a)};a.j.unregister=function(b){delete h[b];
a.j.Bc(b)};a.j.Fc={getConfig:function(b,c){c(a.j.tb(b)?h[b]:null)},loadComponent:function(a,c,d){var e=g(a);f(e,c,function(c){b(a,e,c,d)})},loadTemplate:function(b,c,f){b=g(b);if("string"===typeof c)f(a.a.ua(c));else if(c instanceof Array)f(c);else if(e(c))f(a.a.la(c.childNodes));else if(c.element)if(c=c.element,A.HTMLElement?c instanceof HTMLElement:c&&c.tagName&&1===c.nodeType)f(d(c));else if("string"===typeof c){var h=w.getElementById(c);h?f(d(h)):b("Cannot find element with ID "+c)}else b("Unknown element type: "+
c);else b("Unknown template value: "+c)},loadViewModel:function(a,b,d){c(g(a),b,d)}};var m="createViewModel";a.b("components.register",a.j.register);a.b("components.isRegistered",a.j.tb);a.b("components.unregister",a.j.unregister);a.b("components.defaultLoader",a.j.Fc);a.j.loaders.push(a.j.Fc);a.j.dd=h})();(function(){function b(b,e){var f=b.getAttribute("params");if(f){var f=c.parseBindingsString(f,e,b,{valueAccessors:!0,bindingParams:!0}),f=a.a.Ga(f,function(c){return a.o(c,null,{l:b})}),g=a.a.Ga(f,
function(c){var e=c.v();return c.ja()?a.o({read:function(){return a.a.f(c())},write:a.Za(e)&&function(a){c()(a)},l:b}):e});Object.prototype.hasOwnProperty.call(g,"$raw")||(g.$raw=f);return g}return{$raw:{}}}a.j.getComponentNameForNode=function(b){var c=a.a.R(b);if(a.j.tb(c)&&(-1!=c.indexOf("-")||"[object HTMLUnknownElement]"==""+b||8>=a.a.W&&b.tagName===c))return c};a.j.tc=function(c,e,f,g){if(1===e.nodeType){var h=a.j.getComponentNameForNode(e);if(h){c=c||{};if(c.component)throw Error('Cannot use the "component" binding on a custom element matching a component');
var m={name:h,params:b(e,f)};c.component=g?function(){return m}:m}}return c};var c=new a.ga;9>a.a.W&&(a.j.register=function(a){return function(b){return a.apply(this,arguments)}}(a.j.register),w.createDocumentFragment=function(b){return function(){var c=b(),f=a.j.dd,g;for(g in f);return c}}(w.createDocumentFragment))})();(function(){function b(b,c,d){c=c.template;if(!c)throw Error("Component '"+b+"' has no template");b=a.a.Ca(c);a.h.va(d,b)}function c(a,b,c){var d=a.createViewModel;return d?d.call(a,
b,c):b}var d=0;a.c.component={init:function(e,f,g,h,m){function k(){var a=l&&l.dispose;"function"===typeof a&&a.call(l);q&&q.s();p=l=q=null}var l,p,q,t=a.a.la(a.h.childNodes(e));a.h.Ea(e);a.a.K.za(e,k);a.o(function(){var g=a.a.f(f()),h,u;"string"===typeof g?h=g:(h=a.a.f(g.name),u=a.a.f(g.params));if(!h)throw Error("No component name specified");var n=a.i.Cb(e,m),z=p=++d;a.j.get(h,function(d){if(p===z){k();if(!d)throw Error("Unknown component '"+h+"'");b(h,d,e);var f=c(d,u,{element:e,templateNodes:t});
d=n.createChildContext(f,{extend:function(a){a.$component=f;a.$componentTemplateNodes=t}});f&&f.koDescendantsComplete&&(q=a.i.subscribe(e,a.i.pa,f.koDescendantsComplete,f));l=f;a.Oa(d,e)}})},null,{l:e});return{controlsDescendantBindings:!0}}};a.h.ea.component=!0})();var V={"class":"className","for":"htmlFor"};a.c.attr={update:function(b,c){var d=a.a.f(c())||{};a.a.P(d,function(c,d){d=a.a.f(d);var g=c.indexOf(":"),g="lookupNamespaceURI"in b&&0<g&&b.lookupNamespaceURI(c.substr(0,g)),h=!1===d||null===
d||d===n;h?g?b.removeAttributeNS(g,c):b.removeAttribute(c):d=d.toString();8>=a.a.W&&c in V?(c=V[c],h?b.removeAttribute(c):b[c]=d):h||(g?b.setAttributeNS(g,c,d):b.setAttribute(c,d));"name"===c&&a.a.Yc(b,h?"":d)})}};(function(){a.c.checked={after:["value","attr"],init:function(b,c,d){function e(){var e=b.checked,f=g();if(!a.S.Ya()&&(e||!m&&!a.S.qa())){var k=a.u.G(c);if(l){var q=p?k.v():k,z=t;t=f;z!==f?e&&(a.a.Na(q,f,!0),a.a.Na(q,z,!1)):a.a.Na(q,f,e);p&&a.Za(k)&&k(q)}else h&&(f===n?f=e:e||(f=n)),a.m.eb(k,
d,"checked",f,!0)}}function f(){var d=a.a.f(c()),e=g();l?(b.checked=0<=a.a.A(d,e),t=e):b.checked=h&&e===n?!!d:g()===d}var g=a.xb(function(){if(d.has("checkedValue"))return a.a.f(d.get("checkedValue"));if(q)return d.has("value")?a.a.f(d.get("value")):b.value}),h="checkbox"==b.type,m="radio"==b.type;if(h||m){var k=c(),l=h&&a.a.f(k)instanceof Array,p=!(l&&k.push&&k.splice),q=m||l,t=l?g():n;m&&!b.name&&a.c.uniqueName.init(b,function(){return!0});a.o(e,null,{l:b});a.a.B(b,"click",e);a.o(f,null,{l:b});
k=n}}};a.m.wa.checked=!0;a.c.checkedValue={update:function(b,c){b.value=a.a.f(c())}}})();a.c["class"]={update:function(b,c){var d=a.a.Db(a.a.f(c()));a.a.Eb(b,b.__ko__cssValue,!1);b.__ko__cssValue=d;a.a.Eb(b,d,!0)}};a.c.css={update:function(b,c){var d=a.a.f(c());null!==d&&"object"==typeof d?a.a.P(d,function(c,d){d=a.a.f(d);a.a.Eb(b,c,d)}):a.c["class"].update(b,c)}};a.c.enable={update:function(b,c){var d=a.a.f(c());d&&b.disabled?b.removeAttribute("disabled"):d||b.disabled||(b.disabled=!0)}};a.c.disable=
{update:function(b,c){a.c.enable.update(b,function(){return!a.a.f(c())})}};a.c.event={init:function(b,c,d,e,f){var g=c()||{};a.a.P(g,function(g){"string"==typeof g&&a.a.B(b,g,function(b){var k,l=c()[g];if(l){try{var p=a.a.la(arguments);e=f.$data;p.unshift(e);k=l.apply(e,p)}finally{!0!==k&&(b.preventDefault?b.preventDefault():b.returnValue=!1)}!1===d.get(g+"Bubble")&&(b.cancelBubble=!0,b.stopPropagation&&b.stopPropagation())}})})}};a.c.foreach={Rc:function(b){return function(){var c=b(),d=a.a.bc(c);
if(!d||"number"==typeof d.length)return{foreach:c,templateEngine:a.ba.Ma};a.a.f(c);return{foreach:d.data,as:d.as,noChildContext:d.noChildContext,includeDestroyed:d.includeDestroyed,afterAdd:d.afterAdd,beforeRemove:d.beforeRemove,afterRender:d.afterRender,beforeMove:d.beforeMove,afterMove:d.afterMove,templateEngine:a.ba.Ma}}},init:function(b,c){return a.c.template.init(b,a.c.foreach.Rc(c))},update:function(b,c,d,e,f){return a.c.template.update(b,a.c.foreach.Rc(c),d,e,f)}};a.m.Ra.foreach=!1;a.h.ea.foreach=
!0;a.c.hasfocus={init:function(b,c,d){function e(e){b.__ko_hasfocusUpdating=!0;var f=b.ownerDocument;if("activeElement"in f){var g;try{g=f.activeElement}catch(l){g=f.body}e=g===b}f=c();a.m.eb(f,d,"hasfocus",e,!0);b.__ko_hasfocusLastValue=e;b.__ko_hasfocusUpdating=!1}var f=e.bind(null,!0),g=e.bind(null,!1);a.a.B(b,"focus",f);a.a.B(b,"focusin",f);a.a.B(b,"blur",g);a.a.B(b,"focusout",g);b.__ko_hasfocusLastValue=!1},update:function(b,c){var d=!!a.a.f(c());b.__ko_hasfocusUpdating||b.__ko_hasfocusLastValue===
d||(d?b.focus():b.blur(),!d&&b.__ko_hasfocusLastValue&&b.ownerDocument.body.focus(),a.u.G(a.a.Fb,null,[b,d?"focusin":"focusout"]))}};a.m.wa.hasfocus=!0;a.c.hasFocus=a.c.hasfocus;a.m.wa.hasFocus="hasfocus";a.c.html={init:function(){return{controlsDescendantBindings:!0}},update:function(b,c){a.a.fc(b,c())}};(function(){function b(b,d,e){a.c[b]={init:function(b,c,h,m,k){var l,p,q={},t,x,n;if(d){m=h.get("as");var u=h.get("noChildContext");n=!(m&&u);q={as:m,noChildContext:u,exportDependencies:n}}x=(t=
"render"==h.get("completeOn"))||h.has(a.i.pa);a.o(function(){var h=a.a.f(c()),m=!e!==!h,u=!p,r;if(n||m!==l){x&&(k=a.i.Cb(b,k));if(m){if(!d||n)q.dataDependency=a.S.o();r=d?k.createChildContext("function"==typeof h?h:c,q):a.S.qa()?k.extend(null,q):k}u&&a.S.qa()&&(p=a.a.Ca(a.h.childNodes(b),!0));m?(u||a.h.va(b,a.a.Ca(p)),a.Oa(r,b)):(a.h.Ea(b),t||a.i.ma(b,a.i.H));l=m}},null,{l:b});return{controlsDescendantBindings:!0}}};a.m.Ra[b]=!1;a.h.ea[b]=!0}b("if");b("ifnot",!1,!0);b("with",!0)})();a.c.let={init:function(b,
c,d,e,f){c=f.extend(c);a.Oa(c,b);return{controlsDescendantBindings:!0}}};a.h.ea.let=!0;var Q={};a.c.options={init:function(b){if("select"!==a.a.R(b))throw Error("options binding applies only to SELECT elements");for(;0<b.length;)b.remove(0);return{controlsDescendantBindings:!0}},update:function(b,c,d){function e(){return a.a.jb(b.options,function(a){return a.selected})}function f(a,b,c){var d=typeof b;return"function"==d?b(a):"string"==d?a[b]:c}function g(c,d){if(x&&l)a.i.ma(b,a.i.H);else if(t.length){var e=
0<=a.a.A(t,a.w.M(d[0]));a.a.Zc(d[0],e);x&&!e&&a.u.G(a.a.Fb,null,[b,"change"])}}var h=b.multiple,m=0!=b.length&&h?b.scrollTop:null,k=a.a.f(c()),l=d.get("valueAllowUnset")&&d.has("value"),p=d.get("optionsIncludeDestroyed");c={};var q,t=[];l||(h?t=a.a.Mb(e(),a.w.M):0<=b.selectedIndex&&t.push(a.w.M(b.options[b.selectedIndex])));k&&("undefined"==typeof k.length&&(k=[k]),q=a.a.jb(k,function(b){return p||b===n||null===b||!a.a.f(b._destroy)}),d.has("optionsCaption")&&(k=a.a.f(d.get("optionsCaption")),null!==
k&&k!==n&&q.unshift(Q)));var x=!1;c.beforeRemove=function(a){b.removeChild(a)};k=g;d.has("optionsAfterRender")&&"function"==typeof d.get("optionsAfterRender")&&(k=function(b,c){g(0,c);a.u.G(d.get("optionsAfterRender"),null,[c[0],b!==Q?b:n])});a.a.ec(b,q,function(c,e,g){g.length&&(t=!l&&g[0].selected?[a.w.M(g[0])]:[],x=!0);e=b.ownerDocument.createElement("option");c===Q?(a.a.Bb(e,d.get("optionsCaption")),a.w.cb(e,n)):(g=f(c,d.get("optionsValue"),c),a.w.cb(e,a.a.f(g)),c=f(c,d.get("optionsText"),g),
a.a.Bb(e,c));return[e]},c,k);if(!l){var B;h?B=t.length&&e().length<t.length:B=t.length&&0<=b.selectedIndex?a.w.M(b.options[b.selectedIndex])!==t[0]:t.length||0<=b.selectedIndex;B&&a.u.G(a.a.Fb,null,[b,"change"])}(l||a.S.Ya())&&a.i.ma(b,a.i.H);a.a.wd(b);m&&20<Math.abs(m-b.scrollTop)&&(b.scrollTop=m)}};a.c.options.$b=a.a.g.Z();a.c.selectedOptions={init:function(b,c,d){function e(){var e=c(),f=[];a.a.D(b.getElementsByTagName("option"),function(b){b.selected&&f.push(a.w.M(b))});a.m.eb(e,d,"selectedOptions",
f)}function f(){var d=a.a.f(c()),e=b.scrollTop;d&&"number"==typeof d.length&&a.a.D(b.getElementsByTagName("option"),function(b){var c=0<=a.a.A(d,a.w.M(b));b.selected!=c&&a.a.Zc(b,c)});b.scrollTop=e}if("select"!=a.a.R(b))throw Error("selectedOptions binding applies only to SELECT elements");var g;a.i.subscribe(b,a.i.H,function(){g?e():(a.a.B(b,"change",e),g=a.o(f,null,{l:b}))},null,{notifyImmediately:!0})},update:function(){}};a.m.wa.selectedOptions=!0;a.c.style={update:function(b,c){var d=a.a.f(c()||
{});a.a.P(d,function(c,d){d=a.a.f(d);if(null===d||d===n||!1===d)d="";if(v)v(b).css(c,d);else if(/^--/.test(c))b.style.setProperty(c,d);else{c=c.replace(/-(\w)/g,function(a,b){return b.toUpperCase()});var g=b.style[c];b.style[c]=d;d===g||b.style[c]!=g||isNaN(d)||(b.style[c]=d+"px")}})}};a.c.submit={init:function(b,c,d,e,f){if("function"!=typeof c())throw Error("The value for a submit binding must be a function");a.a.B(b,"submit",function(a){var d,e=c();try{d=e.call(f.$data,b)}finally{!0!==d&&(a.preventDefault?
a.preventDefault():a.returnValue=!1)}})}};a.c.text={init:function(){return{controlsDescendantBindings:!0}},update:function(b,c){a.a.Bb(b,c())}};a.h.ea.text=!0;(function(){if(A&&A.navigator){var b=function(a){if(a)return parseFloat(a[1])},c=A.navigator.userAgent,d,e,f,g,h;(d=A.opera&&A.opera.version&&parseInt(A.opera.version()))||(h=b(c.match(/Edge\/([^ ]+)$/)))||b(c.match(/Chrome\/([^ ]+)/))||(e=b(c.match(/Version\/([^ ]+) Safari/)))||(f=b(c.match(/Firefox\/([^ ]+)/)))||(g=a.a.W||b(c.match(/MSIE ([^ ]+)/)))||
(g=b(c.match(/rv:([^ )]+)/)))}if(8<=g&&10>g)var m=a.a.g.Z(),k=a.a.g.Z(),l=function(b){var c=this.activeElement;(c=c&&a.a.g.get(c,k))&&c(b)},p=function(b,c){var d=b.ownerDocument;a.a.g.get(d,m)||(a.a.g.set(d,m,!0),a.a.B(d,"selectionchange",l));a.a.g.set(b,k,c)};a.c.textInput={init:function(b,c,k){function l(c,d){a.a.B(b,c,d)}function m(){var d=a.a.f(c());if(null===d||d===n)d="";L!==n&&d===L?a.a.setTimeout(m,4):b.value!==d&&(y=!0,b.value=d,y=!1,v=b.value)}function r(){w||(L=b.value,w=a.a.setTimeout(z,
4))}function z(){clearTimeout(w);L=w=n;var d=b.value;v!==d&&(v=d,a.m.eb(c(),k,"textInput",d))}var v=b.value,w,L,A=9==a.a.W?r:z,y=!1;g&&l("keypress",z);11>g&&l("propertychange",function(a){y||"value"!==a.propertyName||A(a)});8==g&&(l("keyup",z),l("keydown",z));p&&(p(b,A),l("dragend",r));(!g||9<=g)&&l("input",A);5>e&&"textarea"===a.a.R(b)?(l("keydown",r),l("paste",r),l("cut",r)):11>d?l("keydown",r):4>f?(l("DOMAutoComplete",z),l("dragdrop",z),l("drop",z)):h&&"number"===b.type&&l("keydown",r);l("change",
z);l("blur",z);a.o(m,null,{l:b})}};a.m.wa.textInput=!0;a.c.textinput={preprocess:function(a,b,c){c("textInput",a)}}})();a.c.uniqueName={init:function(b,c){if(c()){var d="ko_unique_"+ ++a.c.uniqueName.rd;a.a.Yc(b,d)}}};a.c.uniqueName.rd=0;a.c.using={init:function(b,c,d,e,f){var g;d.has("as")&&(g={as:d.get("as"),noChildContext:d.get("noChildContext")});c=f.createChildContext(c,g);a.Oa(c,b);return{controlsDescendantBindings:!0}}};a.h.ea.using=!0;a.c.value={init:function(b,c,d){var e=a.a.R(b),f="input"==
e;if(!f||"checkbox"!=b.type&&"radio"!=b.type){var g=[],h=d.get("valueUpdate"),m=!1,k=null;h&&("string"==typeof h?g=[h]:g=a.a.wc(h),a.a.Pa(g,"change"));var l=function(){k=null;m=!1;var e=c(),f=a.w.M(b);a.m.eb(e,d,"value",f)};!a.a.W||!f||"text"!=b.type||"off"==b.autocomplete||b.form&&"off"==b.form.autocomplete||-1!=a.a.A(g,"propertychange")||(a.a.B(b,"propertychange",function(){m=!0}),a.a.B(b,"focus",function(){m=!1}),a.a.B(b,"blur",function(){m&&l()}));a.a.D(g,function(c){var d=l;a.a.Ud(c,"after")&&
(d=function(){k=a.w.M(b);a.a.setTimeout(l,0)},c=c.substring(5));a.a.B(b,c,d)});var p;p=f&&"file"==b.type?function(){var d=a.a.f(c());null===d||d===n||""===d?b.value="":a.u.G(l)}:function(){var f=a.a.f(c()),g=a.w.M(b);if(null!==k&&f===k)a.a.setTimeout(p,0);else if(f!==g||g===n)"select"===e?(g=d.get("valueAllowUnset"),a.w.cb(b,f,g),g||f===a.w.M(b)||a.u.G(l)):a.w.cb(b,f)};if("select"===e){var q;a.i.subscribe(b,a.i.H,function(){q?d.get("valueAllowUnset")?p():l():(a.a.B(b,"change",l),q=a.o(p,null,{l:b}))},
null,{notifyImmediately:!0})}else a.a.B(b,"change",l),a.o(p,null,{l:b})}else a.ib(b,{checkedValue:c})},update:function(){}};a.m.wa.value=!0;a.c.visible={update:function(b,c){var d=a.a.f(c()),e="none"!=b.style.display;d&&!e?b.style.display="":!d&&e&&(b.style.display="none")}};a.c.hidden={update:function(b,c){a.c.visible.update(b,function(){return!a.a.f(c())})}};(function(b){a.c[b]={init:function(c,d,e,f,g){return a.c.event.init.call(this,c,function(){var a={};a[b]=d();return a},e,f,g)}}})("click");
a.ca=function(){};a.ca.prototype.renderTemplateSource=function(){throw Error("Override renderTemplateSource");};a.ca.prototype.createJavaScriptEvaluatorBlock=function(){throw Error("Override createJavaScriptEvaluatorBlock");};a.ca.prototype.makeTemplateSource=function(b,c){if("string"==typeof b){c=c||w;var d=c.getElementById(b);if(!d)throw Error("Cannot find template with ID "+b);return new a.C.F(d)}if(1==b.nodeType||8==b.nodeType)return new a.C.ia(b);throw Error("Unknown template type: "+b);};a.ca.prototype.renderTemplate=
function(a,c,d,e){a=this.makeTemplateSource(a,e);return this.renderTemplateSource(a,c,d,e)};a.ca.prototype.isTemplateRewritten=function(a,c){return!1===this.allowTemplateRewriting?!0:this.makeTemplateSource(a,c).data("isRewritten")};a.ca.prototype.rewriteTemplate=function(a,c,d){a=this.makeTemplateSource(a,d);c=c(a.text());a.text(c);a.data("isRewritten",!0)};a.b("templateEngine",a.ca);a.kc=function(){function b(b,c,d,h){b=a.m.ac(b);for(var m=a.m.Ra,k=0;k<b.length;k++){var l=b[k].key;if(Object.prototype.hasOwnProperty.call(m,
l)){var p=m[l];if("function"===typeof p){if(l=p(b[k].value))throw Error(l);}else if(!p)throw Error("This template engine does not support the '"+l+"' binding within its templates");}}d="ko.__tr_ambtns(function($context,$element){return(function(){return{ "+a.m.vb(b,{valueAccessors:!0})+" } })()},'"+d.toLowerCase()+"')";return h.createJavaScriptEvaluatorBlock(d)+c}var c=/(<([a-z]+\d*)(?:\s+(?!data-bind\s*=\s*)[a-z0-9\-]+(?:=(?:\"[^\"]*\"|\'[^\']*\'|[^>]*))?)*\s+)data-bind\s*=\s*(["'])([\s\S]*?)\3/gi,
d=/\x3c!--\s*ko\b\s*([\s\S]*?)\s*--\x3e/g;return{xd:function(b,c,d){c.isTemplateRewritten(b,d)||c.rewriteTemplate(b,function(b){return a.kc.Ld(b,c)},d)},Ld:function(a,f){return a.replace(c,function(a,c,d,e,l){return b(l,c,d,f)}).replace(d,function(a,c){return b(c,"\x3c!-- ko --\x3e","#comment",f)})},md:function(b,c){return a.aa.Xb(function(d,h){var m=d.nextSibling;m&&m.nodeName.toLowerCase()===c&&a.ib(m,b,h)})}}}();a.b("__tr_ambtns",a.kc.md);(function(){a.C={};a.C.F=function(b){if(this.F=b){var c=
a.a.R(b);this.ab="script"===c?1:"textarea"===c?2:"template"==c&&b.content&&11===b.content.nodeType?3:4}};a.C.F.prototype.text=function(){var b=1===this.ab?"text":2===this.ab?"value":"innerHTML";if(0==arguments.length)return this.F[b];var c=arguments[0];"innerHTML"===b?a.a.fc(this.F,c):this.F[b]=c};var b=a.a.g.Z()+"_";a.C.F.prototype.data=function(c){if(1===arguments.length)return a.a.g.get(this.F,b+c);a.a.g.set(this.F,b+c,arguments[1])};var c=a.a.g.Z();a.C.F.prototype.nodes=function(){var b=this.F;
if(0==arguments.length){var e=a.a.g.get(b,c)||{},f=e.lb||(3===this.ab?b.content:4===this.ab?b:n);if(!f||e.jd){var g=this.text();g&&g!==e.bb&&(f=a.a.Md(g,b.ownerDocument),a.a.g.set(b,c,{lb:f,bb:g,jd:!0}))}return f}e=arguments[0];this.ab!==n&&this.text("");a.a.g.set(b,c,{lb:e})};a.C.ia=function(a){this.F=a};a.C.ia.prototype=new a.C.F;a.C.ia.prototype.constructor=a.C.ia;a.C.ia.prototype.text=function(){if(0==arguments.length){var b=a.a.g.get(this.F,c)||{};b.bb===n&&b.lb&&(b.bb=b.lb.innerHTML);return b.bb}a.a.g.set(this.F,
c,{bb:arguments[0]})};a.b("templateSources",a.C);a.b("templateSources.domElement",a.C.F);a.b("templateSources.anonymousTemplate",a.C.ia)})();(function(){function b(b,c,d){var e;for(c=a.h.nextSibling(c);b&&(e=b)!==c;)b=a.h.nextSibling(e),d(e,b)}function c(c,d){if(c.length){var e=c[0],f=c[c.length-1],g=e.parentNode,h=a.ga.instance,m=h.preprocessNode;if(m){b(e,f,function(a,b){var c=a.previousSibling,d=m.call(h,a);d&&(a===e&&(e=d[0]||b),a===f&&(f=d[d.length-1]||c))});c.length=0;if(!e)return;e===f?c.push(e):
(c.push(e,f),a.a.Ua(c,g))}b(e,f,function(b){1!==b.nodeType&&8!==b.nodeType||a.vc(d,b)});b(e,f,function(b){1!==b.nodeType&&8!==b.nodeType||a.aa.cd(b,[d])});a.a.Ua(c,g)}}function d(a){return a.nodeType?a:0<a.length?a[0]:null}function e(b,e,f,h,m){m=m||{};var n=(b&&d(b)||f||{}).ownerDocument,B=m.templateEngine||g;a.kc.xd(f,B,n);f=B.renderTemplate(f,h,m,n);if("number"!=typeof f.length||0<f.length&&"number"!=typeof f[0].nodeType)throw Error("Template engine must return an array of DOM nodes");n=!1;switch(e){case "replaceChildren":a.h.va(b,
f);n=!0;break;case "replaceNode":a.a.Xc(b,f);n=!0;break;case "ignoreTargetNode":break;default:throw Error("Unknown renderMode: "+e);}n&&(c(f,h),m.afterRender&&a.u.G(m.afterRender,null,[f,h[m.as||"$data"]]),"replaceChildren"==e&&a.i.ma(b,a.i.H));return f}function f(b,c,d){return a.O(b)?b():"function"===typeof b?b(c,d):b}var g;a.gc=function(b){if(b!=n&&!(b instanceof a.ca))throw Error("templateEngine must inherit from ko.templateEngine");g=b};a.dc=function(b,c,h,m,t){h=h||{};if((h.templateEngine||g)==
n)throw Error("Set a template engine before calling renderTemplate");t=t||"replaceChildren";if(m){var x=d(m);return a.$(function(){var g=c&&c instanceof a.fa?c:new a.fa(c,null,null,null,{exportDependencies:!0}),n=f(b,g.$data,g),g=e(m,t,n,g,h);"replaceNode"==t&&(m=g,x=d(m))},null,{Sa:function(){return!x||!a.a.Sb(x)},l:x&&"replaceNode"==t?x.parentNode:x})}return a.aa.Xb(function(d){a.dc(b,c,h,d,"replaceNode")})};a.Qd=function(b,d,g,h,m){function x(b,c){a.u.G(a.a.ec,null,[h,b,u,g,r,c]);a.i.ma(h,a.i.H)}
function r(a,b){c(b,v);g.afterRender&&g.afterRender(b,a);v=null}function u(a,c){v=m.createChildContext(a,{as:z,noChildContext:g.noChildContext,extend:function(a){a.$index=c;z&&(a[z+"Index"]=c)}});var d=f(b,a,v);return e(h,"ignoreTargetNode",d,v,g)}var v,z=g.as,w=!1===g.includeDestroyed||a.options.foreachHidesDestroyed&&!g.includeDestroyed;if(w||g.beforeRemove||!a.Pc(d))return a.$(function(){var b=a.a.f(d)||[];"undefined"==typeof b.length&&(b=[b]);w&&(b=a.a.jb(b,function(b){return b===n||null===b||
!a.a.f(b._destroy)}));x(b)},null,{l:h});x(d.v());var A=d.subscribe(function(a){x(d(),a)},null,"arrayChange");A.l(h);return A};var h=a.a.g.Z(),m=a.a.g.Z();a.c.template={init:function(b,c){var d=a.a.f(c());if("string"==typeof d||"name"in d)a.h.Ea(b);else if("nodes"in d){d=d.nodes||[];if(a.O(d))throw Error('The "nodes" option must be a plain, non-observable array.');var e=d[0]&&d[0].parentNode;e&&a.a.g.get(e,m)||(e=a.a.Yb(d),a.a.g.set(e,m,!0));(new a.C.ia(b)).nodes(e)}else if(d=a.h.childNodes(b),0<d.length)e=
a.a.Yb(d),(new a.C.ia(b)).nodes(e);else throw Error("Anonymous template defined, but no template content was provided");return{controlsDescendantBindings:!0}},update:function(b,c,d,e,f){var g=c();c=a.a.f(g);d=!0;e=null;"string"==typeof c?c={}:(g="name"in c?c.name:b,"if"in c&&(d=a.a.f(c["if"])),d&&"ifnot"in c&&(d=!a.a.f(c.ifnot)),d&&!g&&(d=!1));"foreach"in c?e=a.Qd(g,d&&c.foreach||[],c,b,f):d?(d=f,"data"in c&&(d=f.createChildContext(c.data,{as:c.as,noChildContext:c.noChildContext,exportDependencies:!0})),
e=a.dc(g,d,c,b)):a.h.Ea(b);f=e;(c=a.a.g.get(b,h))&&"function"==typeof c.s&&c.s();a.a.g.set(b,h,!f||f.ja&&!f.ja()?n:f)}};a.m.Ra.template=function(b){b=a.m.ac(b);return 1==b.length&&b[0].unknown||a.m.Id(b,"name")?null:"This template engine does not support anonymous templates nested within its templates"};a.h.ea.template=!0})();a.b("setTemplateEngine",a.gc);a.b("renderTemplate",a.dc);a.a.Kc=function(a,c,d){if(a.length&&c.length){var e,f,g,h,m;for(e=f=0;(!d||e<d)&&(h=a[f]);++f){for(g=0;m=c[g];++g)if(h.value===
m.value){h.moved=m.index;m.moved=h.index;c.splice(g,1);e=g=0;break}e+=g}}};a.a.Pb=function(){function b(b,d,e,f,g){var h=Math.min,m=Math.max,k=[],l,p=b.length,q,n=d.length,r=n-p||1,v=p+n+1,u,w,z;for(l=0;l<=p;l++)for(w=u,k.push(u=[]),z=h(n,l+r),q=m(0,l-1);q<=z;q++)u[q]=q?l?b[l-1]===d[q-1]?w[q-1]:h(w[q]||v,u[q-1]||v)+1:q+1:l+1;h=[];m=[];r=[];l=p;for(q=n;l||q;)n=k[l][q]-1,q&&n===k[l][q-1]?m.push(h[h.length]={status:e,value:d[--q],index:q}):l&&n===k[l-1][q]?r.push(h[h.length]={status:f,value:b[--l],index:l}):
(--q,--l,g.sparse||h.push({status:"retained",value:d[q]}));a.a.Kc(r,m,!g.dontLimitMoves&&10*p);return h.reverse()}return function(a,d,e){e="boolean"===typeof e?{dontLimitMoves:e}:e||{};a=a||[];d=d||[];return a.length<d.length?b(a,d,"added","deleted",e):b(d,a,"deleted","added",e)}}();a.b("utils.compareArrays",a.a.Pb);(function(){function b(b,c,d,h,m){var k=[],l=a.$(function(){var l=c(d,m,a.a.Ua(k,b))||[];0<k.length&&(a.a.Xc(k,l),h&&a.u.G(h,null,[d,l,m]));k.length=0;a.a.Nb(k,l)},null,{l:b,Sa:function(){return!a.a.kd(k)}});
return{Y:k,$:l.ja()?l:n}}var c=a.a.g.Z(),d=a.a.g.Z();a.a.ec=function(e,f,g,h,m,k){function l(b){y={Aa:b,pb:a.ta(w++)};v.push(y);r||F.push(y)}function p(b){y=t[b];w!==y.pb.v()&&D.push(y);y.pb(w++);a.a.Ua(y.Y,e);v.push(y)}function q(b,c){if(b)for(var d=0,e=c.length;d<e;d++)a.a.D(c[d].Y,function(a){b(a,d,c[d].Aa)})}f=f||[];"undefined"==typeof f.length&&(f=[f]);h=h||{};var t=a.a.g.get(e,c),r=!t,v=[],u=0,w=0,z=[],A=[],C=[],D=[],F=[],y,I=0;if(r)a.a.D(f,l);else{if(!k||t&&t._countWaitingForRemove){var E=
a.a.Mb(t,function(a){return a.Aa});k=a.a.Pb(E,f,{dontLimitMoves:h.dontLimitMoves,sparse:!0})}for(var E=0,G,H,K;G=k[E];E++)switch(H=G.moved,K=G.index,G.status){case "deleted":for(;u<K;)p(u++);H===n&&(y=t[u],y.$&&(y.$.s(),y.$=n),a.a.Ua(y.Y,e).length&&(h.beforeRemove&&(v.push(y),I++,y.Aa===d?y=null:C.push(y)),y&&z.push.apply(z,y.Y)));u++;break;case "added":for(;w<K;)p(u++);H!==n?(A.push(v.length),p(H)):l(G.value)}for(;w<f.length;)p(u++);v._countWaitingForRemove=I}a.a.g.set(e,c,v);q(h.beforeMove,D);a.a.D(z,
h.beforeRemove?a.oa:a.removeNode);var M,O,P;try{P=e.ownerDocument.activeElement}catch(N){}if(A.length)for(;(E=A.shift())!=n;){y=v[E];for(M=n;E;)if((O=v[--E].Y)&&O.length){M=O[O.length-1];break}for(f=0;u=y.Y[f];M=u,f++)a.h.Wb(e,u,M)}for(E=0;y=v[E];E++){y.Y||a.a.extend(y,b(e,g,y.Aa,m,y.pb));for(f=0;u=y.Y[f];M=u,f++)a.h.Wb(e,u,M);!y.Ed&&m&&(m(y.Aa,y.Y,y.pb),y.Ed=!0,M=y.Y[y.Y.length-1])}P&&e.ownerDocument.activeElement!=P&&P.focus();q(h.beforeRemove,C);for(E=0;E<C.length;++E)C[E].Aa=d;q(h.afterMove,D);
q(h.afterAdd,F)}})();a.b("utils.setDomNodeChildrenFromArrayMapping",a.a.ec);a.ba=function(){this.allowTemplateRewriting=!1};a.ba.prototype=new a.ca;a.ba.prototype.constructor=a.ba;a.ba.prototype.renderTemplateSource=function(b,c,d,e){if(c=(9>a.a.W?0:b.nodes)?b.nodes():null)return a.a.la(c.cloneNode(!0).childNodes);b=b.text();return a.a.ua(b,e)};a.ba.Ma=new a.ba;a.gc(a.ba.Ma);a.b("nativeTemplateEngine",a.ba);(function(){a.$a=function(){var a=this.Hd=function(){if(!v||!v.tmpl)return 0;try{if(0<=v.tmpl.tag.tmpl.open.toString().indexOf("__"))return 2}catch(a){}return 1}();
this.renderTemplateSource=function(b,e,f,g){g=g||w;f=f||{};if(2>a)throw Error("Your version of jQuery.tmpl is too old. Please upgrade to jQuery.tmpl 1.0.0pre or later.");var h=b.data("precompiled");h||(h=b.text()||"",h=v.template(null,"{{ko_with $item.koBindingContext}}"+h+"{{/ko_with}}"),b.data("precompiled",h));b=[e.$data];e=v.extend({koBindingContext:e},f.templateOptions);e=v.tmpl(h,b,e);e.appendTo(g.createElement("div"));v.fragments={};return e};this.createJavaScriptEvaluatorBlock=function(a){return"{{ko_code ((function() { return "+
a+" })()) }}"};this.addTemplate=function(a,b){w.write("<script type='text/html' id='"+a+"'>"+b+"\x3c/script>")};0<a&&(v.tmpl.tag.ko_code={open:"__.push($1 || '');"},v.tmpl.tag.ko_with={open:"with($1) {",close:"} "})};a.$a.prototype=new a.ca;a.$a.prototype.constructor=a.$a;var b=new a.$a;0<b.Hd&&a.gc(b);a.b("jqueryTmplTemplateEngine",a.$a)})()})})();})();


/***/ }),

/***/ "./node_modules/bootstrap/dist/css/bootstrap.min.css":
/*!***********************************************************!*\
  !*** ./node_modules/bootstrap/dist/css/bootstrap.min.css ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/bootstrap-icons/icons/book.svg":
/*!*****************************************************!*\
  !*** ./node_modules/bootstrap-icons/icons/book.svg ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "book.svg";

/***/ }),

/***/ "./node_modules/bootstrap-icons/icons/download.svg":
/*!*********************************************************!*\
  !*** ./node_modules/bootstrap-icons/icons/download.svg ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "download.svg";

/***/ }),

/***/ "./node_modules/bootstrap-icons/icons/flag.svg":
/*!*****************************************************!*\
  !*** ./node_modules/bootstrap-icons/icons/flag.svg ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "flag.svg";

/***/ }),

/***/ "./node_modules/bootstrap-icons/icons/github.svg":
/*!*******************************************************!*\
  !*** ./node_modules/bootstrap-icons/icons/github.svg ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "github.svg";

/***/ }),

/***/ "./node_modules/bootstrap-icons/icons/lock.svg":
/*!*****************************************************!*\
  !*** ./node_modules/bootstrap-icons/icons/lock.svg ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "lock.svg";

/***/ }),

/***/ "./node_modules/bootstrap-icons/icons/unlock.svg":
/*!*******************************************************!*\
  !*** ./node_modules/bootstrap-icons/icons/unlock.svg ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "unlock.svg";

/***/ }),

/***/ "./node_modules/bootstrap-icons/icons/volume-up.svg":
/*!**********************************************************!*\
  !*** ./node_modules/bootstrap-icons/icons/volume-up.svg ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "volume-up.svg";

/***/ }),

/***/ "./src/assets/CW-Club-logo-clear400-300x300.png":
/*!******************************************************!*\
  !*** ./src/assets/CW-Club-logo-clear400-300x300.png ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "CW-Club-logo-clear400-300x300.png";

/***/ }),

/***/ "./node_modules/js-cookie/dist/js.cookie.mjs":
/*!***************************************************!*\
  !*** ./node_modules/js-cookie/dist/js.cookie.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*! js-cookie v3.0.1 | MIT */
/* eslint-disable no-var */
function assign (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      target[key] = source[key];
    }
  }
  return target
}
/* eslint-enable no-var */

/* eslint-disable no-var */
var defaultConverter = {
  read: function (value) {
    if (value[0] === '"') {
      value = value.slice(1, -1);
    }
    return value.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent)
  },
  write: function (value) {
    return encodeURIComponent(value).replace(
      /%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g,
      decodeURIComponent
    )
  }
};
/* eslint-enable no-var */

/* eslint-disable no-var */

function init (converter, defaultAttributes) {
  function set (key, value, attributes) {
    if (typeof document === 'undefined') {
      return
    }

    attributes = assign({}, defaultAttributes, attributes);

    if (typeof attributes.expires === 'number') {
      attributes.expires = new Date(Date.now() + attributes.expires * 864e5);
    }
    if (attributes.expires) {
      attributes.expires = attributes.expires.toUTCString();
    }

    key = encodeURIComponent(key)
      .replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent)
      .replace(/[()]/g, escape);

    var stringifiedAttributes = '';
    for (var attributeName in attributes) {
      if (!attributes[attributeName]) {
        continue
      }

      stringifiedAttributes += '; ' + attributeName;

      if (attributes[attributeName] === true) {
        continue
      }

      // Considers RFC 6265 section 5.2:
      // ...
      // 3.  If the remaining unparsed-attributes contains a %x3B (";")
      //     character:
      // Consume the characters of the unparsed-attributes up to,
      // not including, the first %x3B (";") character.
      // ...
      stringifiedAttributes += '=' + attributes[attributeName].split(';')[0];
    }

    return (document.cookie =
      key + '=' + converter.write(value, key) + stringifiedAttributes)
  }

  function get (key) {
    if (typeof document === 'undefined' || (arguments.length && !key)) {
      return
    }

    // To prevent the for loop in the first place assign an empty array
    // in case there are no cookies at all.
    var cookies = document.cookie ? document.cookie.split('; ') : [];
    var jar = {};
    for (var i = 0; i < cookies.length; i++) {
      var parts = cookies[i].split('=');
      var value = parts.slice(1).join('=');

      try {
        var foundKey = decodeURIComponent(parts[0]);
        jar[foundKey] = converter.read(value, foundKey);

        if (key === foundKey) {
          break
        }
      } catch (e) {}
    }

    return key ? jar[key] : jar
  }

  return Object.create(
    {
      set: set,
      get: get,
      remove: function (key, attributes) {
        set(
          key,
          '',
          assign({}, attributes, {
            expires: -1
          })
        );
      },
      withAttributes: function (attributes) {
        return init(this.converter, assign({}, this.attributes, attributes))
      },
      withConverter: function (converter) {
        return init(assign({}, this.converter, converter), this.attributes)
      }
    },
    {
      attributes: { value: Object.freeze(defaultAttributes) },
      converter: { value: Object.freeze(converter) }
    }
  )
}

var api = init(defaultConverter, { path: '/' });
/* eslint-enable no-var */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (api);


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	(() => {
/******/ 		var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 			}
/******/ 			def['default'] = () => (value);
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + "" + {"src_morseRssPlugin_js":"154c2861fb85831827cc","node_modules_white-noise-node_index_js":"8f7211d8dbf839594ec8","node_modules_brown-noise-node_index_js":"48020e170357a54e2db8","node_modules_pink-noise-node_index_js":"66d191406f6888a7dd66","vendors-node_modules_rss-parser_index_js":"0cb61bdc9e18dfc50131","_ed1b-_d17e":"5907fc2f770bc1ae75aa"}[chunkId] + ".js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get mini-css chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.miniCssF = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return undefined;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		// data-webpack is not used as build has no uniqueName
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 		
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			;
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"bundle": 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						} else installedChunks[chunkId] = 0;
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunk"] = self["webpackChunk"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!**********************!*\
  !*** ./src/morse.js ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var knockout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! knockout */ "./node_modules/knockout/build/output/knockout-latest.js");
/* harmony import */ var knockout__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(knockout__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var bootstrap_dist_css_bootstrap_min_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bootstrap/dist/css/bootstrap.min.css */ "./node_modules/bootstrap/dist/css/bootstrap.min.css");
/* harmony import */ var bootstrap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! bootstrap */ "./node_modules/bootstrap/dist/js/bootstrap.esm.js");
/* harmony import */ var _morseStringUtils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./morseStringUtils.js */ "./src/morseStringUtils.js");
/* harmony import */ var _morseStringToWavBuffer_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./morseStringToWavBuffer.js */ "./src/morseStringToWavBuffer.js");
/* harmony import */ var _morseWordPlayer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./morseWordPlayer.js */ "./src/morseWordPlayer.js");
/* harmony import */ var js_cookie__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! js-cookie */ "./node_modules/js-cookie/dist/js.cookie.mjs");
/* harmony import */ var _morseLessonPlugin_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./morseLessonPlugin.js */ "./src/morseLessonPlugin.js");
/* harmony import */ var _morseLoadImages_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./morseLoadImages.js */ "./src/morseLoadImages.js");
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

 // see https://getbootstrap.com/docs/5.0/getting-started/webpack/

 // You can specify which plugins you need
// Note that even though these don't seem to be used directly,
// they are used by the accordian.
// eslint-disable-next-line no-unused-vars




 // NOTE: moved this to dynamic import() so that non-RSS users don't need to bother
// even loading this code into the browser:
// import RSSParser from 'rss-parser';





var MorseViewModel = /*#__PURE__*/_createClass(function MorseViewModel() {
  var _this = this;

  _classCallCheck(this, MorseViewModel);

  _defineProperty(this, "textBuffer", knockout__WEBPACK_IMPORTED_MODULE_0___default().observable(''));

  _defineProperty(this, "trueWpm", knockout__WEBPACK_IMPORTED_MODULE_0___default().observable(20));

  _defineProperty(this, "trueFwpm", knockout__WEBPACK_IMPORTED_MODULE_0___default().observable(20));

  _defineProperty(this, "syncWpm", knockout__WEBPACK_IMPORTED_MODULE_0___default().observable(true));

  _defineProperty(this, "wpm", knockout__WEBPACK_IMPORTED_MODULE_0___default().pureComputed({
    read: function read() {
      return _this.trueWpm();
    },
    write: function write(value) {
      _this.trueWpm(value);

      if (_this.syncWpm() || parseInt(value) < parseInt(_this.trueFwpm())) {
        _this.trueFwpm(value);
      }
    },
    owner: this
  }));

  _defineProperty(this, "fwpm", knockout__WEBPACK_IMPORTED_MODULE_0___default().pureComputed({
    read: function read() {
      if (!_this.syncWpm()) {
        if (parseInt(_this.trueFwpm()) <= parseInt(_this.trueWpm())) {
          return _this.trueFwpm();
        } else {
          return _this.trueWpm();
        }
      } else {
        _this.trueFwpm(_this.trueWpm());

        return _this.trueFwpm();
      }
    },
    write: function write(value) {
      if (parseInt(value) <= parseInt(_this.trueWpm())) {
        _this.trueFwpm(value);
      }
    },
    owner: this
  }));

  _defineProperty(this, "trudDitFrequency", knockout__WEBPACK_IMPORTED_MODULE_0___default().observable(550));

  _defineProperty(this, "truDahFrequency", knockout__WEBPACK_IMPORTED_MODULE_0___default().observable(550));

  _defineProperty(this, "syncFreq", knockout__WEBPACK_IMPORTED_MODULE_0___default().observable(true));

  _defineProperty(this, "ditFrequency", knockout__WEBPACK_IMPORTED_MODULE_0___default().pureComputed({
    read: function read() {
      return _this.trudDitFrequency();
    },
    write: function write(value) {
      _this.trudDitFrequency(value);

      if (_this.syncFreq()) {
        _this.truDahFrequency(value);
      }
    },
    owner: this
  }));

  _defineProperty(this, "dahFrequency", knockout__WEBPACK_IMPORTED_MODULE_0___default().pureComputed({
    read: function read() {
      if (!_this.syncFreq()) {
        return _this.truDahFrequency();
      } else {
        _this.truDahFrequency(_this.trudDitFrequency());

        return _this.trudDitFrequency();
      }
    },
    write: function write(value) {
      _this.truDahFrequency(value);
    },
    owner: this
  }));

  _defineProperty(this, "hideList", knockout__WEBPACK_IMPORTED_MODULE_0___default().observable(true));

  _defineProperty(this, "currentSentanceIndex", knockout__WEBPACK_IMPORTED_MODULE_0___default().observable(0));

  _defineProperty(this, "currentIndex", knockout__WEBPACK_IMPORTED_MODULE_0___default().observable(0));

  _defineProperty(this, "playerPlaying", knockout__WEBPACK_IMPORTED_MODULE_0___default().observable(false));

  _defineProperty(this, "lastFullPlayTime", knockout__WEBPACK_IMPORTED_MODULE_0___default().observable(new Date(1900, 0, 0)));

  _defineProperty(this, "preSpace", knockout__WEBPACK_IMPORTED_MODULE_0___default().observable(0));

  _defineProperty(this, "preSpaceUsed", knockout__WEBPACK_IMPORTED_MODULE_0___default().observable(false));

  _defineProperty(this, "xtraWordSpaceDits", knockout__WEBPACK_IMPORTED_MODULE_0___default().observable(0));

  _defineProperty(this, "flaggedWords", knockout__WEBPACK_IMPORTED_MODULE_0___default().observable(''));

  _defineProperty(this, "isShuffled", knockout__WEBPACK_IMPORTED_MODULE_0___default().observable(false));

  _defineProperty(this, "trailReveal", knockout__WEBPACK_IMPORTED_MODULE_0___default().observable(false));

  _defineProperty(this, "preShuffled", '');

  _defineProperty(this, "wordLists", knockout__WEBPACK_IMPORTED_MODULE_0___default().observableArray());

  _defineProperty(this, "morseWordPlayer", new _morseWordPlayer_js__WEBPACK_IMPORTED_MODULE_5__.MorseWordPlayer());

  _defineProperty(this, "rawText", knockout__WEBPACK_IMPORTED_MODULE_0___default().observable());

  _defineProperty(this, "showingText", knockout__WEBPACK_IMPORTED_MODULE_0___default().observable('hello world'));

  _defineProperty(this, "showRaw", knockout__WEBPACK_IMPORTED_MODULE_0___default().observable(true));

  _defineProperty(this, "rssEnabled", knockout__WEBPACK_IMPORTED_MODULE_0___default().observable(false));

  _defineProperty(this, "volume", knockout__WEBPACK_IMPORTED_MODULE_0___default().observable(10));

  _defineProperty(this, "noiseEnabled", knockout__WEBPACK_IMPORTED_MODULE_0___default().observable(false));

  _defineProperty(this, "noiseVolume", knockout__WEBPACK_IMPORTED_MODULE_0___default().observable(2));

  _defineProperty(this, "noiseType", knockout__WEBPACK_IMPORTED_MODULE_0___default().observable('off'));

  _defineProperty(this, "userTarget", knockout__WEBPACK_IMPORTED_MODULE_0___default().observable(''));

  _defineProperty(this, "selectedClass", knockout__WEBPACK_IMPORTED_MODULE_0___default().observable(''));

  _defineProperty(this, "userTargetInitialized", false);

  _defineProperty(this, "selectedClassInitialized", false);

  _defineProperty(this, "letterGroupInitialized", false);

  _defineProperty(this, "displaysInitialized", false);

  _defineProperty(this, "letterGroup", knockout__WEBPACK_IMPORTED_MODULE_0___default().observable(''));

  _defineProperty(this, "selectedDisplay", knockout__WEBPACK_IMPORTED_MODULE_0___default().observable({}));

  _defineProperty(this, "lastPlayFullStart", null);

  _defineProperty(this, "randomizeLessons", knockout__WEBPACK_IMPORTED_MODULE_0___default().observable(true));

  _defineProperty(this, "ifOverrideTime", knockout__WEBPACK_IMPORTED_MODULE_0___default().observable(false));

  _defineProperty(this, "overrideMins", knockout__WEBPACK_IMPORTED_MODULE_0___default().observable(2));

  _defineProperty(this, "customGroup", knockout__WEBPACK_IMPORTED_MODULE_0___default().observable(''));

  _defineProperty(this, "ifOverrideMinMax", knockout__WEBPACK_IMPORTED_MODULE_0___default().observable(false));

  _defineProperty(this, "trueOverrideMin", knockout__WEBPACK_IMPORTED_MODULE_0___default().observable(3));

  _defineProperty(this, "overrideMin", knockout__WEBPACK_IMPORTED_MODULE_0___default().pureComputed({
    read: function read() {
      return _this.trueOverrideMin();
    },
    write: function write(value) {
      _this.trueOverrideMin(value);

      if (_this.syncSize()) {
        _this.trueOverrideMax(value);
      }
    },
    owner: this
  }));

  _defineProperty(this, "trueOverrideMax", knockout__WEBPACK_IMPORTED_MODULE_0___default().observable(3));

  _defineProperty(this, "overrideMax", knockout__WEBPACK_IMPORTED_MODULE_0___default().pureComputed({
    read: function read() {
      if (!_this.syncSize()) {
        return _this.trueOverrideMax();
      } else {
        _this.trueOverrideMax(_this.trueOverrideMin());

        return _this.trueOverrideMin();
      }
    },
    write: function write(value) {
      if (value >= _this.trueOverrideMin()) {
        _this.trueOverrideMax(value);
      }
    },
    owner: this
  }));

  _defineProperty(this, "ifParseSentences", knockout__WEBPACK_IMPORTED_MODULE_0___default().observable(false));

  _defineProperty(this, "ifStickySets", knockout__WEBPACK_IMPORTED_MODULE_0___default().observable(true));

  _defineProperty(this, "stickySets", knockout__WEBPACK_IMPORTED_MODULE_0___default().observable('BK'));

  _defineProperty(this, "runningPlayMs", knockout__WEBPACK_IMPORTED_MODULE_0___default().observable(0));

  _defineProperty(this, "lastPartialPlayStart", knockout__WEBPACK_IMPORTED_MODULE_0___default().observable());

  _defineProperty(this, "isPaused", knockout__WEBPACK_IMPORTED_MODULE_0___default().observable(false));

  _defineProperty(this, "syncSize", knockout__WEBPACK_IMPORTED_MODULE_0___default().observable(true));

  _defineProperty(this, "morseLoadImages", knockout__WEBPACK_IMPORTED_MODULE_0___default().observable());

  _defineProperty(this, "loadCookies", function () {
    // load any existing cookie values
    // helper
    var booleanize = function booleanize(x) {
      if (x === 'true ' || x === 'false') {
        return x === true;
      } else {
        return x;
      }
    };

    var cks = js_cookie__WEBPACK_IMPORTED_MODULE_6__["default"].get();

    if (cks) {
      var specialHandling = [];

      for (var key in cks) {
        switch (key) {
          case 'syncWpm':
          case 'wpm':
          case 'fwpm':
          case 'syncFreq':
          case 'ditFrequency':
          case 'dahFrequency':
            specialHandling.push({
              key: key,
              val: booleanize(cks[key])
            });
            break;

          default:
            if (typeof _this[key] !== 'undefined') {
              _this[key](cks[key]);
            }

        }
      }

      var target = specialHandling.find(function (x) {
        return x.key === 'syncWpm';
      });

      if (target) {
        _this[target.key](target.val);
      }

      target = specialHandling.find(function (x) {
        return x.key === 'syncFreq';
      });

      if (target) {
        _this[target.key](target.val);
      }

      specialHandling.forEach(function (x) {
        _this[x.key](x.val);
      });
    }
  });

  _defineProperty(this, "getParameterByName", function (name) {
    var url = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window.location.href;
    // eslint-disable-next-line no-useless-escape
    name = name.replace(/[\[\]]/g, '\\$&');
    var regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)');
    var results = regex.exec(url);
    if (!results) return null;
    if (!results[2]) return '';
    return decodeURIComponent(results[2].replace(/\+/g, ' '));
  });

  _defineProperty(this, "changeSentance", function () {
    _this.currentIndex(0);
  });

  _defineProperty(this, "setText", function (s) {
    if (_this.showRaw()) {
      _this.showingText(s);
    } else {
      _this.rawText(s);
    }
  });

  _defineProperty(this, "sentences", knockout__WEBPACK_IMPORTED_MODULE_0___default().computed(function () {
    if (!_this.rawText()) {
      return [];
    }

    return _morseStringUtils_js__WEBPACK_IMPORTED_MODULE_3__["default"].getSentences(_this.rawText(), !_this.ifParseSentences());
  }, this));

  _defineProperty(this, "sentenceMax", knockout__WEBPACK_IMPORTED_MODULE_0___default().computed(function () {
    return _this.sentences().length - 1;
  }, this));

  _defineProperty(this, "words", knockout__WEBPACK_IMPORTED_MODULE_0___default().computed(function () {
    return _this.sentences()[_this.currentSentanceIndex()];
  }, this));

  _defineProperty(this, "flaggedWordsCount", knockout__WEBPACK_IMPORTED_MODULE_0___default().computed(function () {
    if (!_this.flaggedWords().trim()) {
      return 0;
    }

    return _this.flaggedWords().trim().split(' ').length;
  }, this));

  _defineProperty(this, "shuffleWords", function () {
    if (!_this.isShuffled()) {
      _this.preShuffled = _this.rawText();

      _this.setText(_this.rawText().split(' ').sort(function () {
        return 0.5 - Math.random();
      }).join(' '));
    } else {
      _this.setText(_this.preShuffled);
    }

    _this.isShuffled(!_this.isShuffled());
  });

  _defineProperty(this, "incrementIndex", function () {
    if (_this.currentIndex() < _this.words().length - 1) {
      _this.currentIndex(_this.currentIndex() + 1);
    } else {
      // move to next sentence
      if (_this.currentSentanceIndex() < _this.sentenceMax()) {
        _this.currentSentanceIndex(Number(_this.currentSentanceIndex()) + 1);

        _this.currentIndex(0);
      }
    }
  });

  _defineProperty(this, "decrementIndex", function () {
    _this.morseWordPlayer.pause(function () {
      if (_this.currentIndex() > 0 && _this.words().length > 1) {
        _this.currentIndex(_this.currentIndex() - 1); // experience shows it is good to put a little pause here
        // so they dont' blur together


        setTimeout(_this.doPlay, 1000);
      }
    });
  });

  _defineProperty(this, "fullRewind", function () {
    // if (this.sentenceMax()>0) {
    _this.currentSentanceIndex(0);

    _this.currentIndex(0); // }

  });

  _defineProperty(this, "sentanceRewind", function () {
    // if (this.sentenceMax()>0) {
    // self.currentSentanceIndex(0);
    _this.currentIndex(0); // }

  });

  _defineProperty(this, "setWordIndex", function (index) {
    if (!_this.playerPlaying()) {
      _this.currentIndex(index);
    } else {
      _this.doPause(false, false);

      _this.currentIndex(index);

      _this.doPlay(false, false);
    }
  });

  _defineProperty(this, "addFlaggedWord", function (word) {
    if (!_this.flaggedWords().trim()) {
      _this.flaggedWords(_this.flaggedWords().trim() + word);
    } else {
      // deal with double click which is also used to pick a word
      var words = _this.flaggedWords().trim().split(' ');

      var lastWord = words[words.length - 1];

      if (lastWord === word) {
        // we have either a double click scenario, or otherwise user
        // selected word twice so either way assume removal
        words.pop();
      } else {
        words.push(word);
      }

      if (words.length === 0) {
        _this.flaggedWords('');
      } else {
        _this.flaggedWords(words.join(' '));
      }
    }
  });

  _defineProperty(this, "setFlagged", function () {
    _this.setText(_this.flaggedWords());

    _this.fullRewind();
  });

  _defineProperty(this, "doCustomGroup", function () {
    if (_this.customGroup()) {
      var data = {
        letters: _this.customGroup().trim().replace(/ /g, '')
      };

      _this.randomWordList(data, true);
    }
  });

  _defineProperty(this, "randomWordList", function (data, ifCustom) {
    var str = '';

    var splitWithProsignsAndStcikys = function splitWithProsignsAndStcikys(s) {
      var stickys = '';

      if (_this.ifStickySets() && _this.stickySets().trim()) {
        stickys = '|' + _this.stickySets().toUpperCase().trim().replace(/ {2}/g, ' ').replace(/ /g, '|');
      }

      var regStr = "<.*?>".concat(stickys, "|[^<.*?>]|\\W"); // console.log(regStr)

      var re = new RegExp(regStr, 'g');
      var match = s.toUpperCase().match(re); // console.log(match)

      return match;
    };

    var chars = splitWithProsignsAndStcikys(data.letters);
    var seconds = 0;
    var controlTime = _this.ifOverrideTime() || ifCustom ? _this.overrideMins() * 60 : data.practiceSeconds;
    var minWordSize = _this.ifOverrideMinMax() || ifCustom ? _this.overrideMin() : data.minWordSize;
    var maxWordSize = _this.ifOverrideMinMax() || ifCustom ? _this.overrideMax() : data.maxWordSize; // Fn to generate random number min/max inclusive
    // https://www.geeksforgeeks.org/how-to-generate-random-number-in-given-range-using-javascript/

    var randomNumber = function randomNumber(min, max) {
      min = Math.ceil(min);
      max = Math.floor(max);
      return Math.floor(Math.random() * (max - min + 1)) + min;
    };

    do {
      var word = '';

      if (_this.randomizeLessons()) {
        // determine word length
        var wordLength = minWordSize === maxWordSize ? minWordSize : randomNumber(minWordSize, maxWordSize);

        for (var j = 1; j <= wordLength; j++) {
          // for each letter
          // determine the letter
          word += chars[randomNumber(1, chars.length) - 1];
        }
      } else {
        word = data.letters;
      }

      str += seconds > 0 ? ' ' + word.toUpperCase() : word.toUpperCase();

      var config = _this.getMorseStringToWavBufferConfig(str);

      var est = _this.morseWordPlayer.getTimeEstimate(config);

      seconds = est.timeCalcs.totalTime / 1000;
    } while (seconds < controlTime);

    _this.setText(str);
  });

  _defineProperty(this, "getMorseStringToWavBufferConfig", function (text) {
    var config = new _morseStringToWavBuffer_js__WEBPACK_IMPORTED_MODULE_4__.MorseStringToWavBufferConfig();
    config.word = text;
    config.wpm = parseInt(_this.wpm());
    config.fwpm = parseInt(_this.fwpm());
    config.ditFrequency = parseInt(_this.ditFrequency());
    config.dahFrequency = parseInt(_this.dahFrequency());
    config.prePaddingMs = _this.preSpaceUsed() ? 0 : _this.preSpace() * 1000;
    config.xtraWordSpaceDits = parseInt(_this.xtraWordSpaceDits());
    config.volume = parseInt(_this.volume());
    config.noise = {
      type: _this.noiseEnabled() ? _this.noiseType() : 'off',
      volume: parseInt(_this.noiseVolume())
    };
    config.playerPlaying = _this.playerPlaying();
    return config;
  });

  _defineProperty(this, "doPlay", function (playJustEnded, fromPlayButton) {
    // we get here several ways:
    // 1. user presses play for the first time
    // 1a. set prespaceused to false, so it will get used.
    // 1b. set the elapsed ms to 0
    // 2. user presses play after a pause
    // 2a. set prespaceused to false, so it will get used again.
    // 3. we just finished playing a word
    // 4. user might press play to re-play a word
    var wasPlayerPlaying = _this.playerPlaying();

    var freshStart = fromPlayButton && !wasPlayerPlaying;

    if (!_this.lastPlayFullStart || _this.lastFullPlayTime() > _this.lastPlayFullStart) {
      _this.lastPlayFullStart = Date.now();
    }

    _this.isPaused(false);

    _this.playerPlaying(true);

    if (!playJustEnded) {
      _this.preSpaceUsed(false);
    }

    if (freshStart) {
      _this.runningPlayMs(0);
    } // experience shows it is good to put a little pause here when user forces us here,
    // e.g. hitting back or play b/c word was misunderstood,
    // so they dont' blur together.


    if (_this.doPlayTimeOut) {
      clearTimeout(_this.doPlayTimeOut);
    }

    _this.doPlayTimeOut = setTimeout(function () {
      return _this.morseWordPlayer.pause(function () {
        var config = _this.getMorseStringToWavBufferConfig(_this.words()[_this.currentIndex()]);

        _this.morseWordPlayer.play(config, _this.playEnded);

        _this.lastPartialPlayStart(Date.now());

        _this.preSpaceUsed(true);
      });
    }, playJustEnded || fromPlayButton ? 0 : 1000);
  });

  _defineProperty(this, "playEnded", function () {
    _this.runningPlayMs(_this.runningPlayMs() + (Date.now() - _this.lastPartialPlayStart()));

    if (_this.currentIndex() < _this.words().length - 1) {
      _this.incrementIndex();

      _this.doPlay(true);
    } else if (_this.currentSentanceIndex() < _this.sentenceMax()) {
      // move to next sentence
      _this.currentSentanceIndex(Number(_this.currentSentanceIndex()) + 1);

      _this.currentIndex(0);

      _this.doPlay(true);
    } else {
      // nothing more to play
      _this.doPause(true);
    }
  });

  _defineProperty(this, "doPause", function (fullRewind, fromPauseButton) {
    if (fromPauseButton) {
      _this.runningPlayMs(_this.runningPlayMs() + (Date.now() - _this.lastPartialPlayStart()));

      _this.isPaused(!_this.isPaused());
    }

    _this.playerPlaying(false);

    _this.morseWordPlayer.pause(function () {
      // we're here if a complete rawtext finished
      console.log('settinglastfullplaytime');

      _this.lastFullPlayTime(Date.now());

      console.log("playtime:".concat(_this.lastFullPlayTime() - _this.lastPlayFullStart)); // TODO make this more generic for any future "plugins"

      if (_this.rssPlayCallback) {
        _this.rssPlayCallback();
      }

      _this.preSpaceUsed(false);
    }, true);

    if (fullRewind) {
      _this.fullRewind();
    }
  });

  _defineProperty(this, "inputFileChange", function (file) {
    // thanks to https://newbedev.com/how-to-access-file-input-with-knockout-binding
    var fr = new FileReader();

    fr.onload = function (data) {
      _this.setText(data.target.result);
    };

    fr.readAsText(file);
  });

  _defineProperty(this, "doDownload", function () {
    var allWords = '';

    var sentences = _this.sentences();

    sentences.forEach(function (sentence) {
      sentence.forEach(function (word) {
        allWords += allWords.length > 0 ? ' ' + word : word;
      });
    });

    var config = _this.getMorseStringToWavBufferConfig(allWords);

    var wav = _this.morseWordPlayer.getWavAndSample(config);

    var ary = new Uint8Array(wav.wav);
    var link = document.getElementById('downloadLink');
    var blob = new Blob([ary], {
      type: 'audio/wav'
    });
    link.href = URL.createObjectURL(blob);
    link.download = 'morse.wav';
    link.dispatchEvent(new MouseEvent('click'));
  });

  _defineProperty(this, "dummy", function () {
    console.log('dummy');
  });

  _defineProperty(this, "timeEstimate", knockout__WEBPACK_IMPORTED_MODULE_0___default().computed(function () {
    // this computed doesn't seem bound to anything but .rawText, but for some reason it is
    // still recomputing on wpm/fwpm/xtra changes, so...ok
    if (!_this.rawText()) {
      return 0;
    }

    var config = _this.getMorseStringToWavBufferConfig(_this.rawText());

    var est = _this.morseWordPlayer.getTimeEstimate(config);

    var minutes = Math.floor(est.timeCalcs.totalTime / 60000);
    var seconds = (est.timeCalcs.totalTime % 60000 / 1000).toFixed(0);
    var normedSeconds = (seconds < 10 ? '0' : '') + seconds;
    var timeFigures = {
      minutes: minutes,
      seconds: seconds,
      normedSeconds: normedSeconds
    };
    console.log(timeFigures);
    console.log(est);
    return timeFigures;
  }, this));

  _defineProperty(this, "playingTime", knockout__WEBPACK_IMPORTED_MODULE_0___default().computed(function () {
    var minutes = Math.floor(_this.runningPlayMs() / 60000);
    var seconds = (_this.runningPlayMs() % 60000 / 1000).toFixed(0);
    var normedSeconds = (seconds < 10 ? '0' : '') + seconds;
    var timeFigures = {
      minutes: minutes,
      seconds: seconds,
      normedSeconds: normedSeconds
    }; // console.log(timeFigures)
    // console.log(est)

    return timeFigures;
  }, this));

  this.morseLoadImages(new _morseLoadImages_js__WEBPACK_IMPORTED_MODULE_8__.MorseLoadImages()); // create the helper extenders

  (knockout__WEBPACK_IMPORTED_MODULE_0___default().extenders.saveCookie) = function (target, option) {
    target.subscribe(function (newValue) {
      js_cookie__WEBPACK_IMPORTED_MODULE_6__["default"].set(option, newValue, {
        expires: 365
      });
    });
    return target;
  };

  (knockout__WEBPACK_IMPORTED_MODULE_0___default().extenders.showingChange) = function (target, option) {
    target.subscribe(function (newValue) {
      if (_this.showRaw()) {
        _this.rawText(newValue);
      }
    });
    return target;
  };

  (knockout__WEBPACK_IMPORTED_MODULE_0___default().extenders.showRawChange) = function (target, option) {
    target.subscribe(function (newValue) {
      // console.log(option + ": " + newValue);
      if (newValue) {
        _this.showingText(_this.rawText());
      } else {
        _this.showingText('');
      }
    });
    return target;
  };

  (knockout__WEBPACK_IMPORTED_MODULE_0___default().extenders.setVolume) = function (target, option) {
    target.subscribe(function (newValue) {
      _this.morseWordPlayer.setVolume(newValue);
    });
    return target;
  };

  (knockout__WEBPACK_IMPORTED_MODULE_0___default().extenders.setNoiseVolume) = function (target, option) {
    target.subscribe(function (newValue) {
      _this.morseWordPlayer.setNoiseVolume(newValue);
    });
    return target;
  };

  (knockout__WEBPACK_IMPORTED_MODULE_0___default().extenders.setNoiseType) = function (target, option) {
    target.subscribe(function (newValue) {
      var config = _this.getMorseStringToWavBufferConfig('');

      config.noise.type = _this.noiseEnabled() ? newValue : 'off';

      _this.morseWordPlayer.setNoiseType(config);
    });
    return target;
  }; // apply extenders


  this.wpm.extend({
    saveCookie: 'wpm'
  });
  this.fwpm.extend({
    saveCookie: 'fwpm'
  });
  this.ditFrequency.extend({
    saveCookie: 'ditFrequency'
  });
  this.dahFrequency.extend({
    saveCookie: 'dahFrequency'
  });
  this.hideList.extend({
    saveCookie: 'hideList'
  });
  this.showingText.extend({
    showingChange: 'showingChange'
  });
  this.showRaw.extend({
    showRawChange: 'showRawChange'
  });
  this.preSpace.extend({
    saveCookie: 'preSpace'
  });
  this.xtraWordSpaceDits.extend({
    saveCookie: 'xtraWordSpaceDits'
  });
  this.volume.extend({
    saveCookie: 'volume'
  }).extend({
    setVolume: 'volume'
  });
  this.noiseVolume.extend({
    saveCookie: 'noiseVolume'
  }).extend({
    setNoiseVolume: 'noiseVolume'
  });
  this.noiseType.extend({
    saveCookie: 'noiseType'
  }).extend({
    setNoiseType: 'noiseType'
  });
  this.syncWpm.extend({
    saveCookie: 'syncWpm'
  });
  this.syncFreq.extend({
    saveCookie: 'syncFreq'
  }); // initialize the main rawText

  this.rawText(this.showingText());
  _morseLessonPlugin_js__WEBPACK_IMPORTED_MODULE_7__["default"].addLessonFeatures((knockout__WEBPACK_IMPORTED_MODULE_0___default()), this); // check for RSS feature turned on

  if (this.getParameterByName('rssEnabled')) {
    __webpack_require__.e(/*! import() */ "src_morseRssPlugin_js").then(__webpack_require__.bind(__webpack_require__, /*! ./morseRssPlugin.js */ "./src/morseRssPlugin.js")).then(function (_ref) {
      var MorseRssPlugin = _ref["default"];
      MorseRssPlugin.addRssFeatures((knockout__WEBPACK_IMPORTED_MODULE_0___default()), _this); // don't set this until the plugin has initialized above

      _this.rssEnabled(true); // possibly rss-related cookies missed
      // TODO probably in general 'plugins' should be some sort of promise based
      // and load cookies after all plugins but for now just do this....


      _this.loadCookies();
    });
  } // check for noise feature turned on


  if (this.getParameterByName('noiseEnabled')) {
    this.noiseEnabled(true);
  }

  this.loadCookies(); // initialize the wordlist

  this.initializeWordList();
}); // eslint-disable-next-line new-cap


knockout__WEBPACK_IMPORTED_MODULE_0___default().applyBindings(new MorseViewModel());
})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QzFDLHVDQUF1QyxJQUFJO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDZDQUE2QyxTQUFTO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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QTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdELE9BQU87QUFDdkQ7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMENBQTBDLFNBQVM7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHFGQUFxRjs7QUFFckY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FBRUw7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLDJDQUEyQyxlQUFlO0FBQzFEOztBQUVBO0FBQ0EsNENBQTRDLGVBQWU7QUFDM0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdELE9BQU87QUFDdkQ7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUcsR0FBRzs7QUFFTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtB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Q0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ04scUJBQXFCLHdEQUFtQjtBQUN4Qzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDZDQUE2QztBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsNEJBQTRCLEdBQUcsa0NBQWtDO0FBQzNHOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZUFBZTtBQUNmO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQsNEJBQTRCO0FBQ25GOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0QsT0FBTztBQUN6RDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0IsV0FBVztBQUNuQztBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLG1CQUFtQixZQUFZO0FBQy9CLGVBQWUsWUFBWTtBQUMzQixpQkFBaUIsWUFBWTtBQUM3Qix1QkFBdUIsWUFBWTtBQUNuQyxpQkFBaUIsWUFBWTtBQUM3QixxQkFBcUIsWUFBWTtBQUNqQyx1QkFBdUIsWUFBWTtBQUNuQywyQkFBMkIsWUFBWTtBQUN2QywyQkFBMkIsWUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtELE9BQU87QUFDekQ7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLFdBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxZQUFZO0FBQzlDLDhCQUE4QixZQUFZO0FBQzFDLG1DQUFtQyxZQUFZLEVBQUUsZUFBZTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtQkFBbUIsSUFBSSxvQkFBb0IsS0FBSyx5QkFBeUI7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBLGVBQWU7QUFDZjtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHVDQUF1QyxJQUFJO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxzRUFBc0UsU0FBUyxtQkFBbUIsT0FBTyxLQUFLLFNBQVMsU0FBUyxPQUFPO0FBQ3ZJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsbUJBQW1CLElBQUksb0JBQW9CLDZEQUE2RDs7QUFFbEo7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLFdBQVc7QUFDbkM7QUFDQSw0QkFBNEIsWUFBWTtBQUN4QyxnQ0FBZ0MsWUFBWTtBQUM1Qyw0QkFBNEIsWUFBWTtBQUN4Qyw4QkFBOEIsWUFBWTtBQUMxQyxxQ0FBcUMsWUFBWSxFQUFFLGFBQWE7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0QsT0FBTztBQUN6RDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CLG9DQUFvQyxVQUFVO0FBQzlDLGtDQUFrQyxVQUFVO0FBQzVDLGdDQUFnQyxVQUFVO0FBQzFDLGtDQUFrQyxVQUFVO0FBQzVDLDBCQUEwQixVQUFVO0FBQ3BDLDhCQUE4QixVQUFVO0FBQ3hDLDBCQUEwQixVQUFVO0FBQ3BDLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxxREFBcUQ7OztBQUdyRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9EQUFvRDs7O0FBR3BEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7OztBQUdKO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0QsT0FBTztBQUN6RDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVrSDtBQUNsSDs7Ozs7Ozs7Ozs7QUN0NEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxhQUFhLDRFQUE0RSwyQ0FBMkMsYUFBYSxLQUFzQyxDQUFDLGlDQUFPLENBQUMsT0FBUyxDQUFDLG1CQUFTLENBQUMsb0NBQUMsQ0FBQztBQUFBO0FBQUE7QUFBQSxrR0FBQyxDQUFDLENBQXlGLENBQUMsZ0JBQWdCLGdCQUFnQix3Q0FBd0MsZ0JBQWdCLE1BQU0sa0JBQWtCLGdDQUFnQyxJQUFJLElBQUksTUFBTSxnQkFBZ0IsTUFBTSxrQkFBa0I7QUFDcmdCLHVCQUF1QixnQkFBZ0Isc0VBQXNFLGlCQUFpQixxQkFBcUIsaUJBQWlCLHFCQUFxQixrR0FBa0csS0FBSyx3QkFBd0Isa0NBQWtDLGtCQUFrQiwrQkFBK0IsYUFBYSxjQUFjLG9CQUFvQixvQkFBb0IsUUFBUSxrQkFBa0I7QUFDeGUsV0FBVyxXQUFXLGlFQUFpRSxlQUFlLGdCQUFnQixzQ0FBc0MsZ0JBQWdCLDZDQUE2QyxTQUFTLGdCQUFnQixjQUFjLFNBQVMsb0JBQW9CLHdCQUF3Qiw2QkFBNkIsY0FBYyxFQUFFLGlCQUFpQix5Q0FBeUMsYUFBYSxrREFBa0QsTUFBTTtBQUNqZSwyREFBMkQsK0dBQStHLGtCQUFrQixtQ0FBbUMsSUFBSSxjQUFjLEVBQUUsT0FBTyxrQkFBa0IsaUJBQWlCLG1FQUFtRSxxRUFBcUUsRUFBRSxlQUFlLGNBQWMsT0FBTztBQUMzYyxrQkFBa0IsdUJBQXVCLElBQUksdUJBQXVCLDREQUE0RCx5Q0FBeUMsZUFBZSx1QkFBdUIsSUFBSSx5QkFBeUIsU0FBUyxvQkFBb0IsdUJBQXVCLElBQUksc0NBQXNDLFNBQVMsa0JBQWtCLGlCQUFpQixtQ0FBbUMsZ0JBQWdCLFNBQVMsdUJBQXVCLHdCQUF3QixFQUFFLFNBQVM7QUFDNWUsS0FBSyxTQUFTLDRCQUE0QixJQUFJLDZCQUE2QixTQUFTLG9CQUFvQixTQUFTLDRCQUE0QixJQUFJLG1DQUFtQyxTQUFTLGtCQUFrQix3Q0FBd0MsNEJBQTRCLElBQUksaUJBQWlCLFNBQVMsb0JBQW9CLHlCQUF5QixrQ0FBa0MsZ0VBQWdFLGVBQWUsUUFBUSxHQUFHO0FBQzFkLG9CQUFvQixTQUFTLGdCQUFnQixLQUFLLGFBQWEsNEJBQTRCLGdCQUFnQixZQUFZLDRFQUE0RSxJQUFJLDhCQUE4QixTQUFTLGtCQUFrQiw0QkFBNEIsSUFBSSxLQUFLLHlCQUF5QixvQkFBb0IsU0FBUyxrQkFBa0IsVUFBVSw0QkFBNEIsSUFBSSx3QkFBd0Isa0JBQWtCLHVCQUF1QixlQUFlO0FBQ3ZlLDhCQUE4QixJQUFJLDJCQUEyQixJQUFJLGVBQWUsSUFBSSx3QkFBd0Isa0JBQWtCLGFBQWEsc0NBQXNDLDhCQUE4QixlQUFlLEtBQUsseUNBQXlDLFlBQVksZUFBZSwyQkFBMkIsZUFBZSxNQUFNLDJCQUEyQixXQUFXLFNBQVMsa0JBQWtCLDhDQUE4QyxnQkFBZ0I7QUFDdGQsMkRBQTJELGtCQUFrQixRQUFRLHdEQUF3RCxrQkFBa0Isa0JBQWtCLDRCQUE0QiwrREFBK0QsMEVBQTBFLEtBQUssUUFBUSxnQkFBZ0IsVUFBVSxnQkFBZ0IsaURBQWlELGdCQUFnQix5QkFBeUIsZUFBZTtBQUN0ZixtQ0FBbUMsZ0JBQWdCLDRCQUE0QixJQUFJLCtCQUErQixTQUFTLGtDQUFrQyxHQUFHLDBCQUEwQiwrQkFBK0IsZ0JBQWdCLHNCQUFzQix3QkFBd0IsU0FBUyxJQUFJLG1CQUFtQixnQkFBZ0IsT0FBTywwSEFBMEgsa0JBQWtCLFlBQVksVUFBVTtBQUNoZixHQUFHLHNCQUFzQixtQkFBbUIsRUFBRSw0RUFBNEUsZ0NBQWdDLGdFQUFnRSxrQkFBa0IsdUZBQXVGLE1BQU0saUdBQWlHO0FBQzFhLCtIQUErSCx1RUFBdUUsNkJBQTZCLDREQUE0RCw4REFBOEQscUJBQXFCLGVBQWUsb0JBQW9CLGdCQUFnQixzQkFBc0Isb0JBQW9CLE1BQU07QUFDcmQsOERBQThELHNCQUFzQiw0RkFBNEYsa0JBQWtCLGVBQWUsd0JBQXdCLHdCQUF3Qiw2RkFBNkYsVUFBVSxrQkFBa0IsU0FBUyxZQUFZLDRDQUE0Qyw2QkFBNkIsRUFBRSxFQUFFO0FBQzVkLGFBQWEsV0FBVyxnQkFBZ0IsNEVBQTRFLGdCQUFnQixNQUFNLG9CQUFvQixnQkFBZ0IsaUJBQWlCLGtCQUFrQixXQUFXLFdBQVcsaUJBQWlCLEtBQUssY0FBYyxTQUFTLGdCQUFnQiw0QkFBNEIsSUFBSSxpQkFBaUIsU0FBUyxnQkFBZ0IscUJBQXFCLHdDQUF3QztBQUMzYSxpQ0FBaUMsa0JBQWtCLGFBQWEsc0JBQXNCLG1CQUFtQixLQUFLLDBCQUEwQixTQUFTLGdCQUFnQixpR0FBaUcsb0JBQW9CO0FBQ3RSLGlDQUFpQyxvQkFBb0IsUUFBUSxrQkFBa0IsZ0NBQWdDLHlFQUF5RSxLQUFLLDBDQUEwQyxLQUFLLDRCQUE0QixXQUFXLDhCQUE4Qix1QkFBdUIsV0FBVyxnQkFBZ0IsZ0hBQWdILGtCQUFrQjtBQUNyZSxnQkFBZ0IsU0FBUyxVQUFVLGlCQUFpQixFQUFFLHNCQUFzQixzQ0FBc0Msc0JBQXNCLDRCQUE0QixNQUFNLEdBQUcsaUJBQWlCLGdDQUFnQywrQkFBK0IsZ0NBQWdDLDJDQUEyQyxnQ0FBZ0MsNkJBQTZCLGlDQUFpQyxvQ0FBb0MsK0JBQStCO0FBQ3plLFFBQVEsK0JBQStCLCtDQUErQyxrQ0FBa0MsOEJBQThCLG1DQUFtQyw2QkFBNkIsOEJBQThCLHdDQUF3QyxrQ0FBa0MsMEJBQTBCLDBDQUEwQyxpQ0FBaUMsb0NBQW9DLGlDQUFpQztBQUN4ZSxRQUFRLG1DQUFtQyxvQkFBb0IsOERBQThELFdBQVcsMENBQTBDLDZCQUE2Qiw4Q0FBOEMsa0JBQWtCLGlCQUFpQiwwQkFBMEIscUJBQXFCLEVBQUUscUJBQXFCLDRDQUE0QyxLQUFLLHVCQUF1QixXQUFXLDBCQUEwQixlQUFlLGdCQUFnQjtBQUNsZixHQUFHLFlBQVksZUFBZSxXQUFXLHVDQUF1QyxtQkFBbUIsV0FBVyxpQkFBaUIsRUFBRSxTQUFTLGVBQWUsZ0NBQWdDLEVBQUUsT0FBTyxrQkFBa0IsY0FBYyxlQUFlLHFCQUFxQix5QkFBeUIsb0JBQW9CLFVBQVUsc0JBQXNCLHNCQUFzQixpQkFBaUIsMkJBQTJCLHVDQUF1QyxxQkFBcUIsZ0JBQWdCO0FBQ2plLGtDQUFrQyxTQUFTLGNBQWMsY0FBYyw4QkFBOEIsV0FBVyxZQUFZLGVBQWUsMkJBQTJCLGtDQUFrQyxnQkFBZ0IsbUJBQW1CLFdBQVcsb0VBQW9FLHVCQUF1QixHQUFHLG1CQUFtQixlQUFlLElBQUksV0FBVyxPQUFPLGlCQUFpQixtRUFBbUUsZ0JBQWdCO0FBQ2hmLEdBQUcsY0FBYywrQ0FBK0MsZ0JBQWdCLGlCQUFpQixvRUFBb0UsRUFBRSxTQUFTLHdCQUF3QixRQUFRLDBDQUEwQywrQkFBK0IsdURBQXVELGNBQWMsOEJBQThCLHNCQUFzQiwrQkFBK0IsbUNBQW1DO0FBQ3BkLFVBQVUsNERBQTRELFlBQVksa0pBQWtKLGlHQUFpRyxZQUFZLHFCQUFxQixNQUFNLDJDQUEyQyxLQUFLLDZCQUE2QixlQUFlLHlDQUF5QztBQUNqZiwyQ0FBMkMsS0FBSyxhQUFhLDRGQUE0Rix1RUFBdUUsT0FBTyxzQ0FBc0MscUlBQXFJLEtBQUssSUFBSSxlQUFlLGlDQUFpQyxVQUFVLHFCQUFxQjtBQUMxZSxHQUFHLGdEQUFnRCxxQkFBcUIsVUFBVSxXQUFXLDBFQUEwRSw2Q0FBNkMsV0FBVyx5QkFBeUIsSUFBSSxzQ0FBc0MsNEJBQTRCLGdCQUFnQixnQkFBZ0IsdUJBQXVCLDJCQUEyQixpQkFBaUIsVUFBVSxFQUFFLDREQUE0RCxJQUFJO0FBQzdlLEdBQUcsU0FBUyxPQUFPLGVBQWUsZ0dBQWdHLDRIQUE0SCxPQUFPLHFDQUFxQyxrQkFBa0IsV0FBVyxvR0FBb0csSUFBSSw4QkFBOEIsUUFBUSxhQUFhLGtCQUFrQjtBQUNwZixHQUFHLE9BQU8sdUJBQXVCLElBQUksS0FBSyxvQkFBb0IsZUFBZSxtQkFBbUIsZUFBZSwyQ0FBMkMsZ0JBQWdCLHNEQUFzRCxHQUFHLHdCQUF3QixtQ0FBbUMscUNBQXFDLHlDQUF5QywwREFBMEQsZ0JBQWdCLGFBQWEsdUJBQXVCLElBQUksY0FBYyxRQUFRO0FBQ3BmLEtBQUssSUFBSSwwRUFBMEUsTUFBTSxJQUFJLElBQUksSUFBSSxTQUFTLFlBQVksYUFBYSxJQUFJLGVBQWUsdUJBQXVCLGlDQUFpQyw2QkFBNkIscUNBQXFDLGNBQWMsRUFBRSxrQkFBa0IsMkJBQTJCLHNFQUFzRSxnQ0FBZ0MsZ0NBQWdDLDBCQUEwQjtBQUNqZixPQUFPLEtBQUssaUNBQWlDLGFBQWEsaUJBQWlCLE9BQU8sMkJBQTJCLHFCQUFxQixTQUFTLFdBQVcsb0JBQW9CLFVBQVUsdUJBQXVCLDRCQUE0QixVQUFVLGVBQWUsU0FBUyxPQUFPLEdBQUcsa0JBQWtCLDhCQUE4Qiw4QkFBOEIsTUFBTSx1QkFBdUIsdUJBQXVCLFdBQVcsWUFBWSx5QkFBeUIsZ0JBQWdCLDRCQUE0QixLQUFLO0FBQ3RmLElBQUksRUFBRSx5QkFBeUIsVUFBVSxnREFBZ0QsUUFBUSx3REFBd0QsaUJBQWlCLGdCQUFnQixFQUFFLHdCQUF3QiwrSUFBK0ksZ0NBQWdDLFdBQVcsa0JBQWtCLE9BQU8sZUFBZSxhQUFhLElBQUksb0NBQW9DLFFBQVE7QUFDbmYsTUFBTSxHQUFHLHNCQUFzQix3Q0FBd0MsT0FBTywyQ0FBMkMsc0JBQXNCLHFCQUFxQixVQUFVLFVBQVUsVUFBVSxXQUFXLHFCQUFxQiwyQkFBMkIsNkNBQTZDLDRCQUE0QixpSEFBaUgsNkJBQTZCLFVBQVU7QUFDOWQsZUFBZSxlQUFlLFlBQVksT0FBTyxlQUFlLEtBQUssV0FBVyxPQUFPLDJCQUEyQixXQUFXLGNBQWMsMENBQTBDLGlCQUFpQixjQUFjLEVBQUUsY0FBYyxvQkFBb0IsZUFBZSxTQUFTLGlDQUFpQyxjQUFjLHdCQUF3QixlQUFlLGdEQUFnRCxJQUFJLFNBQVMsY0FBYyxPQUFPLGtCQUFrQixRQUFRLFlBQVksZUFBZSxlQUFlO0FBQzVmLGVBQWUscUJBQXFCLGVBQWUsVUFBVSxnQkFBZ0IsOEJBQThCLHVEQUF1RCxtQkFBbUIsUUFBUSw4QkFBOEIsc0JBQXNCLFNBQVMsYUFBYSxFQUFFLG1CQUFtQixnQkFBZ0IseUJBQXlCLFVBQVUsSUFBSSxLQUFLLGlCQUFpQixpQ0FBaUMsZ0JBQWdCLE1BQU0sZ0JBQWdCLHlCQUF5QixnQkFBZ0IsbUNBQW1DO0FBQzVmLGVBQWUsMkNBQTJDLFFBQVEsMkJBQTJCLDJCQUEyQixFQUFFLFNBQVMsa0JBQWtCLDBEQUEwRCxxQkFBcUIsd0JBQXdCLG9CQUFvQixXQUFXLHlCQUF5QixjQUFjLG9DQUFvQyxFQUFFLFdBQVcsbUJBQW1CLCtCQUErQix5QkFBeUIsb0NBQW9DO0FBQ2xlLG9CQUFvQixTQUFTLGlCQUFpQix3RkFBd0Ysd0JBQXdCLDJCQUEyQixtQkFBbUIsY0FBYyxVQUFVLElBQUksYUFBYSxVQUFVLGVBQWUsT0FBTywwQkFBMEIsTUFBTSw0RUFBNEUsb0NBQW9DLG1CQUFtQixJQUFJLDRCQUE0QixRQUFRLEtBQUssZUFBZSxxQkFBcUI7QUFDemdCLGNBQWMscUJBQXFCLGVBQWUsaUJBQWlCLGNBQWMsa0JBQWtCLEdBQUcsMkJBQTJCLG1EQUFtRCw4Q0FBOEMsd0NBQXdDLGlEQUFpRCxxQ0FBcUMsNkJBQTZCLGlCQUFpQixhQUFhO0FBQzNaLFVBQVUsWUFBWSxPQUFPLDZCQUE2QixhQUFhLFlBQVksNENBQTRDLFVBQVUsT0FBTyxnQ0FBZ0MsZUFBZSxlQUFlLDJDQUEyQyxnQ0FBZ0MsZUFBZSxpREFBaUQscUNBQXFDLDZCQUE2QixVQUFVLGdCQUFnQixzSEFBc0g7QUFDM2lCLFdBQVcsaUJBQWlCLG1FQUFtRSx1QkFBdUIsd0JBQXdCLGtDQUFrQyxpQ0FBaUMsdUJBQXVCLGtCQUFrQiw4QkFBOEIsOEJBQThCLGlCQUFpQixRQUFRLHlKQUF5SixVQUFVO0FBQ2xmLFNBQVMsaUJBQWlCLHFCQUFxQixHQUFHLFNBQVMsbUJBQW1CLG1FQUFtRSxhQUFhLE9BQU8sV0FBVyxLQUFLLFdBQVcsU0FBUyx3QkFBd0IsdURBQXVELHFCQUFxQixVQUFVLGNBQWMsS0FBSyxvQkFBb0IsU0FBUyx1QkFBdUIsVUFBVSw0QkFBNEIsVUFBVSxxQkFBcUIsVUFBVSxTQUFTLGlDQUFpQztBQUN2ZixXQUFXLEtBQUsscUJBQXFCLDBEQUEwRCxhQUFhLEdBQUcsVUFBVSxxQkFBcUIsS0FBSyxLQUFLLFdBQVcsc0JBQXNCLFVBQVUsd0JBQXdCLHFDQUFxQyxTQUFTLDZCQUE2QixxQkFBcUIsS0FBSyxxQkFBcUIsYUFBYSxrQkFBa0IsdUJBQXVCLHNCQUFzQiwwQ0FBMEMsb0JBQW9CO0FBQy9kLDRCQUE0QixxQkFBcUIsbUNBQW1DLDRDQUE0QywwRUFBMEUsc0JBQXNCLGVBQWUsVUFBVSx1QkFBdUIsOEJBQThCLFVBQVUscUJBQXFCLEVBQUUsNEJBQTRCLHNCQUFzQixhQUFhLGdDQUFnQyxFQUFFLGlCQUFpQjtBQUNqYyxlQUFlLDRCQUE0Qiw4QkFBOEIscUNBQXFDLGFBQWEsYUFBYSxNQUFNLDZCQUE2Qix3QkFBd0IsOEJBQThCLElBQUksSUFBSSxPQUFPLElBQUksbURBQW1ELHFDQUFxQyxJQUFJLGtFQUFrRSxRQUFRLDBDQUEwQyxlQUFlLFVBQVU7QUFDN2QsZ0JBQWdCLGlCQUFpQixlQUFlLHdCQUF3QixpQkFBaUIsZUFBZSwrRUFBK0UscUJBQXFCLGtCQUFrQixvQkFBb0IsMEJBQTBCLFVBQVUsbUNBQW1DLFVBQVUsZ0JBQWdCLHVCQUF1QixJQUFJLHdCQUF3QixNQUFNLGlCQUFpQixvQ0FBb0MsTUFBTTtBQUN2YyxTQUFTLGdGQUFnRixJQUFJLHdFQUF3RSxZQUFZLE1BQU0sZUFBZSxRQUFRLHVCQUF1Qix3QkFBd0IsYUFBYSx1QkFBdUIsaURBQWlELGlLQUFpSyxZQUFZO0FBQy9mLFVBQVUsNEJBQTRCLFdBQVcsZ0NBQWdDLGdCQUFnQixzR0FBc0csaUJBQWlCLGdKQUFnSixjQUFjLE9BQU8sMkJBQTJCLDZCQUE2QixhQUFhLFlBQVk7QUFDOWMsb0NBQW9DLDRDQUE0Qyx3Q0FBd0MsK0JBQStCLDBDQUEwQyxNQUFNLEVBQUUsVUFBVSxPQUFPLGlDQUFpQyxpQkFBaUIsZUFBZSxTQUFTLDhCQUE4QixhQUFhLEVBQUUsU0FBUyxnQkFBZ0IsdUJBQXVCLGdCQUFnQixnREFBZ0QscUJBQXFCLEVBQUUsb0JBQW9CO0FBQzVlLHlFQUF5RSxlQUFlLGlCQUFpQixZQUFZLGVBQWUsb0JBQW9CLDJHQUEyRyxlQUFlLGtDQUFrQyxlQUFlLGNBQWMsbUJBQW1CLGVBQWUsOENBQThDLGdCQUFnQixTQUFTO0FBQzFiLE1BQU0sT0FBTyxrQkFBa0IsTUFBTSxRQUFRLGlDQUFpQyxlQUFlLGtDQUFrQyx1RUFBdUUsU0FBUyw0QkFBNEIsZ0JBQWdCLDBCQUEwQixpQkFBaUIsOEJBQThCLFVBQVUsU0FBUyxRQUFRLGFBQWEsUUFBUSxJQUFJLGFBQWEsUUFBUSxRQUFRLFVBQVUsZ0JBQWdCLG9DQUFvQyx1QkFBdUIsUUFBUTtBQUNsZixrQkFBa0IsRUFBRSxPQUFPLE1BQU0sbUJBQW1CLHFDQUFxQyxtS0FBbUssdUNBQXVDLFNBQVMsa0JBQWtCLElBQUksV0FBVyw2QkFBNkIsUUFBUSxtREFBbUQsZUFBZSxjQUFjLDZDQUE2QyxXQUFXO0FBQzFmLGVBQWUsdUJBQXVCLG1CQUFtQixnREFBZ0Qsa0JBQWtCLG9CQUFvQixtQkFBbUIsY0FBYyxtQkFBbUIsa0JBQWtCLGNBQWMsY0FBYyxtQ0FBbUMsV0FBVyxFQUFFLDhCQUE4QixNQUFNLE1BQU0sUUFBUSxRQUFRLFFBQVEsT0FBTyxNQUFNLE9BQU8sT0FBTyxtQkFBbUIsS0FBSyxlQUFlLGtCQUFrQiw0QkFBNEIsT0FBTztBQUMxZCxpQkFBaUIsS0FBSyxTQUFTLHdCQUF3QixVQUFVLEVBQUUsc0JBQXNCLDBCQUEwQixPQUFPLFVBQVUsU0FBUyxFQUFFLHVCQUF1Qix3Q0FBd0MsZ0JBQWdCLGNBQWMsK0RBQStELGNBQWMsd0JBQXdCLFFBQVEsNkNBQTZDLGVBQWUsY0FBYyxrQ0FBa0MsNkJBQTZCLEtBQUssZUFBZTtBQUN0ZixpQ0FBaUMscUNBQXFDLGNBQWMsU0FBUyxpQkFBaUIseUNBQXlDLGlCQUFpQiwrQkFBK0Isb0JBQW9CLCtCQUErQix1QkFBdUIsMkJBQTJCLHFCQUFxQixrQkFBa0IscUJBQXFCLHVCQUF1QixtQ0FBbUMsOEJBQThCLG1CQUFtQjtBQUNuZCxHQUFHLFFBQVEsRUFBRSxlQUFlLElBQUksVUFBVSxpQkFBaUIseUJBQXlCLFlBQVksa0JBQWtCLFdBQVcsT0FBTyx3SkFBd0osK0JBQStCLFlBQVksZ0JBQWdCLGNBQWMsaUJBQWlCLGtFQUFrRSxNQUFNLDhDQUE4QztBQUM1ZSxjQUFjLEVBQUUsU0FBUyxnQkFBZ0IsdUJBQXVCLFlBQVksV0FBVyxTQUFTLHlDQUF5QyxxQkFBcUIsYUFBYSxhQUFhLGVBQWUsaUJBQWlCLGlHQUFpRyx1QkFBdUIsWUFBWSxhQUFhLFVBQVUsU0FBUyxHQUFHLHlCQUF5QixVQUFVLHNCQUFzQixhQUFhLGlDQUFpQztBQUN0ZSxHQUFHLDhEQUE4RCxpQkFBaUIscUJBQXFCLCtCQUErQixJQUFJLGlCQUFpQix1QkFBdUIscUJBQXFCLGNBQWMsd0JBQXdCLFlBQVksNEJBQTRCLGdCQUFnQixFQUFFLDJCQUEyQixTQUFTLGtFQUFrRSxpQkFBaUIsWUFBWSxLQUFLLGNBQWMsaUJBQWlCO0FBQzljLCtIQUErSCw0RUFBNEUsd0JBQXdCLG9CQUFvQixpQkFBaUI7QUFDeFEsZUFBZSxNQUFNLHNDQUFzQyxzQ0FBc0MsSUFBSSxrREFBa0QsSUFBSSxNQUFNLG1GQUFtRixrQkFBa0IsSUFBSSxNQUFNLGdDQUFnQyxhQUFhLElBQUksNEJBQTRCLHdDQUF3QywwQ0FBMEMsZUFBZSxjQUFjLFlBQVk7QUFDeGQsS0FBSyxTQUFTLGlDQUFpQyxlQUFlLGNBQWMsT0FBTyxLQUFLLHNCQUFzQixXQUFXLFNBQVMsb0JBQW9CLHVCQUF1QixFQUFFLHNCQUFzQixFQUFFLE1BQU0sS0FBSyxVQUFVLGdCQUFnQix5QkFBeUIsVUFBVSxVQUFVLGtGQUFrRjtBQUMzVywyRUFBMkUsVUFBVSxtRUFBbUUsU0FBUyxnUEFBZ1Asc0JBQXNCLG1EQUFtRCw2QkFBNkI7QUFDdmYsS0FBSyxPQUFPLGlDQUFpQyxnQkFBZ0IsTUFBTSxPQUFPLDZCQUE2QixvREFBb0QsaUdBQWlHLDZEQUE2RCxTQUFTLEdBQUcsa0JBQWtCLGNBQWMsR0FBRyxxQkFBcUIsUUFBUSxnRkFBZ0Ysb0JBQW9CO0FBQ3plLFNBQVMsRUFBRSxxQ0FBcUMsaUJBQWlCLEdBQUcsbUJBQW1CLGtCQUFrQixZQUFZLFdBQVcsNEJBQTRCLFNBQVMsd0JBQXdCLDBDQUEwQywwREFBMEQsR0FBRywrQkFBK0IsMkRBQTJELHFEQUFxRCxxREFBcUQ7QUFDeGUsUUFBUSxtQ0FBbUMsc0VBQXNFLFlBQVksY0FBYyxtREFBbUQsY0FBYyxtREFBbUQsZ0JBQWdCLHFCQUFxQixnQkFBZ0IsRUFBRSxnREFBZ0QsVUFBVSxVQUFVLDRFQUE0RSxZQUFZLGdCQUFnQixhQUFhO0FBQy9lLHdEQUF3RCwyTEFBMkwsWUFBWSw4QkFBOEIsS0FBSyxLQUFLLHdCQUF3Qiw4QkFBOEIsZ0JBQWdCLFNBQVMsb0JBQW9CLHVCQUF1QixJQUFJLHVCQUF1QixlQUFlLGtCQUFrQixTQUFTLFVBQVU7QUFDaGYsNkJBQTZCLElBQUksc0NBQXNDLGlCQUFpQixrQkFBa0IsTUFBTSxxREFBcUQsOENBQThDLG9CQUFvQixxR0FBcUcsd0JBQXdCLGtFQUFrRTtBQUN0YSxHQUFHLG9CQUFvQix5QkFBeUIsZUFBZSxvQ0FBb0Msb0JBQW9CLDZHQUE2RyxZQUFZLHFCQUFxQixxQkFBcUIsb0RBQW9ELGdCQUFnQixnQkFBZ0IsbUJBQW1CLE1BQU0sc0JBQXNCLE1BQU0sZUFBZSxXQUFXLE1BQU0sa0JBQWtCLGNBQWMsY0FBYztBQUNqZixRQUFRLG1CQUFtQix1QkFBdUIsK0JBQStCLFdBQVcsaURBQWlELDJCQUEyQixJQUFJLDJCQUEyQiw4Q0FBOEMsd0NBQXdDLDBDQUEwQyxzQ0FBc0MsaURBQWlELFlBQVksZ0JBQWdCLFlBQVksMkJBQTJCLDRCQUE0QixtQkFBbUI7QUFDaGhCLDREQUE0RCx3QkFBd0Isa0JBQWtCLDJCQUEyQiwyRUFBMkUsd0JBQXdCLG1DQUFtQyxzRUFBc0Usa0JBQWtCLE9BQU8sd0JBQXdCLCtCQUErQixtQkFBbUIsMENBQTBDLHdCQUF3QixxQkFBcUI7QUFDdmdCLHNDQUFzQyxJQUFJLDhDQUE4QyxjQUFjLHdCQUF3QixjQUFjLEVBQUUsT0FBTyxrQkFBa0IsRUFBRSx3Q0FBd0MsU0FBUyxjQUFjLFNBQVMsNkZBQTZGLEVBQUUsdUJBQXVCLElBQUksNEJBQTRCLFlBQVksY0FBYyw4QkFBOEIscUJBQXFCLGtCQUFrQixZQUFZO0FBQ2xmLEVBQUUsV0FBVyxVQUFVLG1CQUFtQixtQ0FBbUMsY0FBYyxrQkFBa0IsVUFBVSxjQUFjLFdBQVcsY0FBYyxxQ0FBcUMsa0JBQWtCLGVBQWUsRUFBRSxrQkFBa0IsNERBQTRELGdCQUFnQiwwQ0FBMEMsZ0JBQWdCLHdCQUF3QixNQUFNLHlDQUF5QyxNQUFNLEtBQUssSUFBSTtBQUNwZCxvQkFBb0IsS0FBSyxJQUFJLDZCQUE2QixnQkFBZ0IsZ0JBQWdCLHlCQUF5QixhQUFhLGtGQUFrRix3QkFBd0IsY0FBYyxhQUFhLE1BQU0sdUJBQXVCLFVBQVUsNkJBQTZCLGtEQUFrRCxTQUFTO0FBQ3BZLE9BQU8sc0JBQXNCLFdBQVcsR0FBRyxTQUFTLEVBQUUsU0FBUyxrQkFBa0IscUJBQXFCLFNBQVMsT0FBTyxrRkFBa0YsUUFBUSxpQkFBaUIsY0FBYyxFQUFFLE1BQU0sZ0NBQWdDLEtBQUssZ0VBQWdFLDZCQUE2QixlQUFlLGVBQWUsU0FBUyxPQUFPLElBQUksRUFBRSxvQkFBb0IsVUFBVSxNQUFNLGlCQUFpQjtBQUNsZSxLQUFLLGlCQUFpQixrQkFBa0Isa0JBQWtCLGFBQWEsYUFBYSxrQkFBa0Isc0JBQXNCLGtCQUFrQixlQUFlLDZDQUE2QyxxQkFBcUIsTUFBTSx3QkFBd0IsMkJBQTJCLEVBQUUsOERBQThELHNCQUFzQiwyQkFBMkIsR0FBRyxPQUFPLG9CQUFvQixzQ0FBc0M7QUFDN2MsNENBQTRDLElBQUksdUNBQXVDLDRCQUE0QixvQ0FBb0MsdUxBQXVMLEtBQUssdUNBQXVDLHNCQUFzQixPQUFPLElBQUksRUFBRSxTQUFTO0FBQ3RhLElBQUksRUFBRSxRQUFRLE9BQU8sMkRBQTJELGdCQUFnQixnREFBZ0QsMkZBQTJGLE9BQU8sT0FBTyxtQ0FBbUMsZ0NBQWdDLGVBQWUsU0FBUyx5QkFBeUIsYUFBYSx5QkFBeUIseUVBQXlFLE9BQU87QUFDbmUsYUFBYSxZQUFZLFlBQVkscUNBQXFDLFlBQVksZUFBZSxtRkFBbUYscUZBQXFGLG9EQUFvRCxtREFBbUQsMkJBQTJCLG9DQUFvQyx3Q0FBd0MsUUFBUSxhQUFhLElBQUk7QUFDcGYscUJBQXFCLG1CQUFtQixrQkFBa0IscUNBQXFDLDhCQUE4QixRQUFRLEtBQUssb0NBQW9DLHdDQUF3QywwQ0FBMEMsS0FBSyxnQkFBZ0IsMEJBQTBCLDZDQUE2QywyQkFBMkIsa0JBQWtCLG9DQUFvQywwQkFBMEIsVUFBVTtBQUNqZCxnRUFBZ0UsS0FBSyw0RUFBNEUscUJBQXFCLEVBQUUscUJBQXFCLGdEQUFnRCw2QkFBNkIsa0JBQWtCLHFCQUFxQiw4RUFBOEU7QUFDL1gsQ0FBQyxrQkFBa0IscUJBQXFCLEVBQUUsMkJBQTJCLHNDQUFzQyxPQUFPLElBQUksaUJBQWlCLHFDQUFxQyxxQkFBcUIsMEJBQTBCLG9CQUFvQixxQkFBcUIsT0FBTywyQkFBMkIsbUJBQW1CLDJDQUEyQyxxQkFBcUIsMkJBQTJCLHVCQUF1Qiw0RUFBNEU7QUFDdmYsQ0FBQyxxSEFBcUgsd0NBQXdDLGFBQWEsaUJBQWlCLG9EQUFvRCxpQkFBaUIsNkJBQTZCLDJCQUEyQix3QkFBd0IsNENBQTRDLDREQUE0RCwwQkFBMEI7QUFDbmQsd0NBQXdDLGdDQUFnQyx1QkFBdUIsb0JBQW9CLElBQUksYUFBYSxnQkFBZ0IseURBQXlELGtFQUFrRSw0QkFBNEIsTUFBTSxtQkFBbUIsWUFBWSwrQ0FBK0MsdUJBQXVCLEVBQUUsUUFBUSxnQkFBZ0IsOEJBQThCLHNDQUFzQztBQUNwZixHQUFHLGVBQWUsRUFBRSxvQkFBb0IsNEJBQTRCLGdCQUFnQixNQUFNLFdBQVcsTUFBTSxTQUFTLGtDQUFrQyxtQ0FBbUMsaUtBQWlLLGdCQUFnQixhQUFhLFFBQVEsTUFBTSxLQUFLLGtCQUFrQix1REFBdUQsd0JBQXdCLGdCQUFnQjtBQUMzZixtQkFBbUIsZ0JBQWdCLFNBQVMsZ0JBQWdCLFlBQVksT0FBTyxlQUFlLHNCQUFzQiw4QkFBOEIsK0NBQStDLElBQUksWUFBWSxvQkFBb0IsYUFBYSxjQUFjLFFBQVEsa0JBQWtCLGNBQWMsb0JBQW9CLHdDQUF3QyxhQUFhLElBQUksRUFBRSxNQUFNLG9CQUFvQix5Q0FBeUMsT0FBTyxJQUFJLEVBQUUsTUFBTSxrQkFBa0IsdUNBQXVDLGdCQUFnQjtBQUN0aEIseUNBQXlDLHdCQUF3QixpQkFBaUIsYUFBYSxTQUFTLEVBQUUsd0VBQXdFLGNBQWMsaUJBQWlCLG9DQUFvQyx1Q0FBdUMsb0VBQW9FLDRCQUE0QixjQUFjLDJFQUEyRSxrQkFBa0I7QUFDdmUsb0RBQW9ELDZEQUE2RCxLQUFLLHVEQUF1RCxjQUFjLG1CQUFtQix1Q0FBdUMsU0FBUywyQkFBMkIsa0RBQWtELGtFQUFrRSxRQUFRLG1CQUFtQixrREFBa0QsMkJBQTJCO0FBQ3JmLFdBQVcsUUFBUSx3QkFBd0IsdUJBQXVCLCtCQUErQixXQUFXLGtCQUFrQixXQUFXLEVBQUUsOEJBQThCLE9BQU8sb0NBQW9DLGdDQUFnQyxxQ0FBcUMsNkdBQTZHLDZCQUE2QiwwQkFBMEIsOENBQThDO0FBQzNlLEdBQUcscUNBQXFDLCtCQUErQixjQUFjLHdCQUF3Qix3Q0FBd0Msc0NBQXNDLDRDQUE0Qyx1Q0FBdUMseUJBQXlCLFNBQVMsSUFBSSxZQUFZLGdCQUFnQiwrQkFBK0IsTUFBTSxtQ0FBbUMsbUNBQW1DLHlCQUF5QixtQkFBbUIsSUFBSSxFQUFFO0FBQzdlLFlBQVksWUFBWSxtQkFBbUIsZ0JBQWdCLGtCQUFrQiw0QkFBNEIsT0FBTyxLQUFLLElBQUksRUFBRSwyREFBMkQsU0FBUyxPQUFPLFNBQVMsd0NBQXdDLGVBQWUsMkdBQTJHLHlCQUF5QixtQkFBbUIscUNBQXFDLE1BQU0sUUFBUTtBQUNoZCxPQUFPLHNCQUFzQix5QkFBeUIsU0FBUyxJQUFJLFVBQVUsZUFBZSxtQ0FBbUMsbUJBQW1CLGdDQUFnQyxvREFBb0Qsa0JBQWtCLHFCQUFxQixZQUFZLFVBQVUsNEJBQTRCLElBQUksWUFBWSxrQkFBa0IsYUFBYSx1REFBdUQsWUFBWSxZQUFZLGtCQUFrQix3QkFBd0I7QUFDdmUsT0FBTyxRQUFRLGVBQWUseUJBQXlCLGFBQWEsbUJBQW1CLGlDQUFpQyxTQUFTLFdBQVcsc0NBQXNDLFVBQVUsY0FBYyxlQUFlLHFCQUFxQiw0REFBNEQsaURBQWlELDBCQUEwQixzQkFBc0IsVUFBVSxJQUFJLCtDQUErQyxTQUFTLGFBQWEsMEJBQTBCO0FBQ3hmLDBCQUEwQixtQkFBbUIsZUFBZSw2QkFBNkIsRUFBRSxrRkFBa0YsSUFBSSxXQUFXLEVBQUUsT0FBTyxJQUFJLEVBQUUsT0FBTyxpQ0FBaUMsb0JBQW9CLElBQUksT0FBTyxxQ0FBcUMsVUFBVSxxQkFBcUIscUJBQXFCLHNCQUFzQixXQUFXO0FBQzVZLFNBQVMsaUVBQWlFLDJHQUEyRyw2QkFBNkIsSUFBSSxZQUFZLGFBQWEsNENBQTRDLGFBQWEsc0JBQXNCLGtDQUFrQyxlQUFlLE1BQU0sb0JBQW9CLElBQUksdURBQXVELGlCQUFpQjtBQUNyZCxtQkFBbUIsYUFBYSx1QkFBdUIsK0RBQStELHNCQUFzQiw2REFBNkQseURBQXlELHlDQUF5QyxTQUFTLGtGQUFrRiw2Q0FBNkMsU0FBUyxFQUFFLFlBQVksSUFBSSxFQUFFLG1CQUFtQixZQUFZLElBQUk7QUFDbmYsT0FBTyxrQkFBa0Isa0JBQWtCLHFCQUFxQixxQkFBcUIsSUFBSSxjQUFjLHFCQUFxQix5QkFBeUIsOEJBQThCLG1CQUFtQixpQkFBaUIsU0FBUyxxQkFBcUIsaUJBQWlCLG1EQUFtRCxXQUFXLGNBQWMsNkJBQTZCLFlBQVkscUJBQXFCLGlCQUFpQiw2RUFBNkU7QUFDOWUsQ0FBQyxxQkFBcUIsK0JBQStCLGtCQUFrQixJQUFJLFdBQVcseUJBQXlCLGNBQWMsb0JBQW9CLDBDQUEwQyxlQUFlLE1BQU0sSUFBSSx3QkFBd0IsVUFBVSxhQUFhLGVBQWUsUUFBUSwrREFBK0Qsb0ZBQW9GLEVBQUUsSUFBSSxhQUFhLGVBQWUsa0JBQWtCO0FBQ2plLHdDQUF3QyxrQ0FBa0MsU0FBUyxPQUFPLDRPQUE0TyxvQkFBb0IsOENBQThDLDRCQUE0Qix3REFBd0Qsa0JBQWtCO0FBQzllLEdBQUcsY0FBYyxxQkFBcUIsY0FBYywyQkFBMkIsc0JBQXNCLHdCQUF3QixNQUFNLElBQUksa0JBQWtCLFNBQVMsU0FBUyxRQUFRLE1BQU0sNEJBQTRCLDJCQUEyQiwyQkFBMkIsd0NBQXdDLG1CQUFtQixxQkFBcUIsa0JBQWtCLHNCQUFzQiw0QkFBNEIsc0JBQXNCLG1CQUFtQjtBQUN4YyxxSUFBcUksbUJBQW1CLDBCQUEwQiwyQkFBMkIsVUFBVSxnQkFBZ0IsT0FBTywrQkFBK0Isc0JBQXNCLGdCQUFnQixZQUFZLGtCQUFrQixRQUFRLHlCQUF5QixZQUFZLE9BQU8sTUFBTSxjQUFjLDhCQUE4QixVQUFVLEdBQUcsNENBQTRDO0FBQ2hmLDhDQUE4QyxlQUFlLGtDQUFrQyxhQUFhLG1CQUFtQixNQUFNLGtDQUFrQyxpRkFBaUYsOENBQThDLG9FQUFvRSxLQUFLLE9BQU8sSUFBSSxFQUFFLE9BQU8saUNBQWlDLGFBQWEsYUFBYSxRQUFRLGlCQUFpQixhQUFhLElBQUksU0FBUztBQUNqZixTQUFTLGNBQWMsVUFBVSxPQUFPLGlDQUFpQyxjQUFjLFNBQVMsYUFBYSxpQkFBaUIsc0ZBQXNGLEtBQUssV0FBVyxhQUFhLE9BQU8sK0JBQStCLHdCQUF3QixhQUFhLG9DQUFvQyxrQkFBa0IsRUFBRSxrQkFBa0IsZUFBZSw0Q0FBNEMsZ0JBQWdCLHdCQUF3QixrQkFBa0I7QUFDM2Ysd0JBQXdCLGVBQWUsd0NBQXdDLDhJQUE4SSxLQUFLLFdBQVcseUZBQXlGLGlFQUFpRSw4Q0FBOEM7QUFDcmIseUJBQXlCLFNBQVMsMkJBQTJCLGtCQUFrQixJQUFJLDhGQUE4RixPQUFPLHlEQUF5RCxFQUFFLDJCQUEyQixzREFBc0QsMENBQTBDO0FBQzlXLGFBQWEsVUFBVSxNQUFNLE9BQU8sTUFBTSx1SUFBdUksbUNBQW1DLCtCQUErQixVQUFVLGlEQUFpRCx5QkFBeUIscUJBQXFCLHFCQUFxQixhQUFhLGVBQWUsbURBQW1ELDZCQUE2QixFQUFFO0FBQy9kLEdBQUcsYUFBYSwrQkFBK0IsaUZBQWlGLDJCQUEyQiwyQkFBMkIsRUFBRSxjQUFjLDZGQUE2RixNQUFNLGlDQUFpQyx5Q0FBeUMsSUFBSSxHQUFHLE9BQU8scUJBQXFCLEVBQUUsc0JBQXNCLDBCQUEwQixXQUFXLHFCQUFxQjtBQUN4ZSxFQUFFLEVBQUUsc0JBQXNCLFdBQVcsZ0NBQWdDLG1CQUFtQiwrQ0FBK0MsS0FBSyxtQ0FBbUMsdUJBQXVCLEVBQUUsaUJBQWlCLGFBQWEscURBQXFELElBQUksWUFBWSx5QkFBeUIsMkZBQTJGLDZCQUE2QixZQUFZLElBQUksb0JBQW9CLFFBQVE7QUFDeGUsc0NBQXNDLElBQUksVUFBVSxnQkFBZ0IsT0FBTywrQkFBK0Isc0JBQXNCLGdCQUFnQixlQUFlLFlBQVksbUJBQW1CLGtCQUFrQiw2QkFBNkIsbUNBQW1DO0FBQ2hSLDhCQUE4Qix3REFBd0QseUJBQXlCLDRCQUE0QixpQkFBaUIsc0JBQXNCLGlFQUFpRSxrQkFBa0IsZUFBZSxxQkFBcUIsZ0JBQWdCLGFBQWEsYUFBYSxpQkFBaUIsd0JBQXdCLDhFQUE4RSxhQUFhO0FBQ3ZkLElBQUksYUFBYSxnQkFBZ0IsTUFBTSxjQUFjLHlDQUF5QyxzQ0FBc0MsbUJBQW1CLHFDQUFxQyxrQ0FBa0MsRUFBRSxvQ0FBb0MsMkJBQTJCLHlCQUF5QixzTEFBc0w7QUFDOWUsR0FBRyxZQUFZLFlBQVksSUFBSSxJQUFJLG9CQUFvQixlQUFlLDJCQUEyQixtQkFBbUIsSUFBSSxnQkFBZ0IsbUJBQW1CLFFBQVEsd0NBQXdDLGVBQWUsb0JBQW9CLFdBQVcseUJBQXlCLE1BQU0saUJBQWlCLHNEQUFzRCxFQUFFLDRCQUE0QixVQUFVLE9BQU8saUNBQWlDLGdCQUFnQixXQUFXLHFCQUFxQjtBQUMvZCxFQUFFLDRDQUE0Qyw0Q0FBNEMsNkRBQTZELGlCQUFpQixPQUFPLEtBQUsscUJBQXFCLHVCQUF1QiwySkFBMkosS0FBSyw2QkFBNkIsS0FBSyw0QkFBNEIsT0FBTyxHQUFHLG9CQUFvQixRQUFRO0FBQ3BlLGNBQWMsV0FBVyxvQkFBb0IsbUJBQW1CLGFBQWEsRUFBRSxNQUFNLCtCQUErQixpQkFBaUIsNENBQTRDLFlBQVksNEJBQTRCLHVDQUF1QyxvSEFBb0gsaUJBQWlCLE1BQU0saUNBQWlDLHNFQUFzRSxJQUFJLEdBQUc7QUFDemYsTUFBTSxxQkFBcUIsRUFBRSxxQ0FBcUMsSUFBSSxFQUFFLGFBQWEsZUFBZSxFQUFFLHNCQUFzQixnQkFBZ0IsYUFBYSxxQkFBcUIsMkNBQTJDLDJEQUEyRCxZQUFZLHFCQUFxQixnQ0FBZ0Msa0JBQWtCLElBQUksYUFBYSxRQUFRLHlCQUF5Qiw2Q0FBNkMsU0FBUyxTQUFTLFNBQVMsVUFBVTtBQUMzZSxrQkFBa0IsK0NBQStDLCtDQUErQyx5REFBeUQseURBQXlELGdEQUFnRCx1QkFBdUIsT0FBTywwQkFBMEIscURBQXFELG9CQUFvQixxREFBcUQsMkNBQTJDO0FBQ25mLGtCQUFrQiwrQkFBK0IsMkNBQTJDLGlEQUFpRCw0RkFBNEYsK0NBQStDLCtCQUErQixjQUFjLFVBQVUsMEJBQTBCLDJCQUEyQixnQkFBZ0Isb0JBQW9CLFlBQVkscUJBQXFCLFdBQVcsS0FBSyxlQUFlO0FBQ3hlLElBQUksV0FBVywwQkFBMEIsbUNBQW1DLDJHQUEyRyw4Q0FBOEMsa0JBQWtCLFFBQVEsWUFBWSxrQkFBa0IsT0FBTyxJQUFJLHlCQUF5Qiw2Q0FBNkM7QUFDOVcsMENBQTBDLE9BQU8sbUJBQW1CLDREQUE0RCxvQkFBb0IsSUFBSSxrQkFBa0IsdUNBQXVDLGtCQUFrQiwwQkFBMEIsNkNBQTZDLEVBQUUsa0JBQWtCLDZCQUE2QixvQkFBb0IsNkNBQTZDLElBQUksR0FBRywyQkFBMkIsWUFBWSxPQUFPLGtCQUFrQixhQUFhO0FBQ2hmLFNBQVMsZ0dBQWdHLGdDQUFnQyx5REFBeUQsd0NBQXdDLG1CQUFtQiw4Q0FBOEMsb0JBQW9CLGlDQUFpQyxxREFBcUQsb0NBQW9DLGdCQUFnQixpQ0FBaUM7QUFDMWUsd0JBQXdCLHdCQUF3QixpREFBaUQsYUFBYSxrQkFBa0IseURBQXlELGdCQUFnQixHQUFHLFNBQVMsZUFBZSwyQkFBMkIsZUFBZSxLQUFLLEdBQUcsbUJBQW1CLFVBQVUsMkJBQTJCLG9DQUFvQyxpQ0FBaUMsd0JBQXdCLDhCQUE4QixzQ0FBc0MsWUFBWTtBQUMzZixHQUFHLGdCQUFnQixHQUFHLDJCQUEyQix3Q0FBd0MsZ0RBQWdELElBQUksWUFBWSxrQkFBa0IsTUFBTSx5QkFBeUIsYUFBYSw2QkFBNkIsZ0JBQWdCLGFBQWEsNkVBQTZFLE1BQU0sb0JBQW9CLHNDQUFzQyxvREFBb0QsRUFBRSxXQUFXLGFBQWE7QUFDNWUsMEJBQTBCLGtCQUFrQiwwQ0FBMEMsRUFBRSxrQkFBa0IsK0NBQStDLEVBQUUsYUFBYSxjQUFjLHlDQUF5QyxzQkFBc0IsUUFBUSxxQkFBcUIsc0NBQXNDLGVBQWUsNEJBQTRCLDBJQUEwSSxLQUFLLFVBQVU7QUFDNWYsR0FBRyxLQUFLLE1BQU0sK0JBQStCLEtBQUssTUFBTSw4QkFBOEIsK0NBQStDLGdIQUFnSCxTQUFTLGtCQUFrQixpREFBaUQsTUFBTSxpQkFBaUIsZ0dBQWdHLEtBQUsseUJBQXlCLFFBQVE7QUFDOWQscUVBQXFFLHVCQUF1QixNQUFNLFdBQVcsc0JBQXNCLHdEQUF3RCxzQkFBc0Isa0NBQWtDLCtCQUErQixPQUFPLGNBQWMscUJBQXFCLHNDQUFzQyxFQUFFLDJCQUEyQiw0QkFBNEIsR0FBRyx5QkFBeUIsZ0JBQWdCLGlDQUFpQztBQUN4ZSxnQkFBZ0IsT0FBTyxrQ0FBa0MsT0FBTyxnQkFBZ0IsMEJBQTBCLHdEQUF3RCxXQUFXLHFCQUFxQixFQUFFLGVBQWUscUNBQXFDLDZGQUE2RixxREFBcUQsbUJBQW1CLHNDQUFzQywyQkFBMkI7QUFDOWQsbUJBQW1CLEdBQUcsS0FBSyxPQUFPLElBQUksRUFBRSxTQUFTLDhCQUE4QixTQUFTLHFCQUFxQixPQUFPLFVBQVUsNEJBQTRCLGNBQWMsbUJBQW1CLGlCQUFpQiw0Q0FBNEMscUJBQXFCLGNBQWMsbUZBQW1GLDRCQUE0QixtREFBbUQseUJBQXlCO0FBQ3RkLG1DQUFtQyxxRkFBcUYsT0FBTywrQkFBK0IsNEJBQTRCLFVBQVUsV0FBVyxLQUFLLE9BQU8sdUJBQXVCLHdHQUF3RyxrR0FBa0csOERBQThEO0FBQzFmLDJCQUEyQixJQUFJLGtEQUFrRCx1Q0FBdUMsNEJBQTRCLFlBQVksaUpBQWlKLG1CQUFtQixJQUFJLDhCQUE4QiwyQkFBMkIsdUJBQXVCLHVCQUF1QixjQUFjLFVBQVUsb0JBQW9CLEtBQUssUUFBUSxPQUFPO0FBQy9lLFNBQVMsZ0JBQWdCLGdCQUFnQixjQUFjLE1BQU0sTUFBTSxRQUFRLGtCQUFrQixzQkFBc0IsZ0ZBQWdGLFFBQVEsS0FBSywrQ0FBK0MsS0FBSyxtRUFBbUUsS0FBSyxLQUFLLEtBQUssSUFBSSxRQUFRLEtBQUssa0RBQWtELDhCQUE4Qix1Q0FBdUMsOEJBQThCO0FBQzVmLDJCQUEyQiw2QkFBNkIsR0FBRyxvQ0FBb0MsbUJBQW1CLHVCQUF1Qix3QkFBd0IsaUJBQWlCLE9BQU8sUUFBUSxRQUFRLGdGQUFnRixHQUFHLGtDQUFrQyxZQUFZLHNCQUFzQiwwQkFBMEIsNkJBQTZCLG1EQUFtRCxXQUFXLFlBQVksT0FBTyxrQkFBa0Isa0JBQWtCO0FBQzVnQixPQUFPLGtCQUFrQiw0QkFBNEIsNkJBQTZCLGNBQWMsR0FBRyxtQkFBbUIsVUFBVSxhQUFhLGNBQWMsT0FBTyx3QkFBd0IsVUFBVSxjQUFjLFVBQVUsZ0JBQWdCLDRCQUE0QixJQUFJLDZCQUE2QixlQUFlLEVBQUUsUUFBUSxzQ0FBc0MsUUFBUSxzRUFBc0UsZ0JBQWdCLEtBQUssb0NBQW9DO0FBQy9lLHFCQUFxQixZQUFZLEVBQUUsY0FBYywwQ0FBMEMsRUFBRSxrQkFBa0IsT0FBTyx5Q0FBeUMsb0JBQW9CLElBQUksUUFBUSw4SUFBOEksSUFBSSxNQUFNLGtCQUFrQixJQUFJLFFBQVEseUNBQXlDLEtBQUssV0FBVyxRQUFRLDJCQUEyQixpQkFBaUIsa0JBQWtCO0FBQ3BmLGtDQUFrQyxVQUFVLElBQUksZ0NBQWdDLFVBQVUsaUJBQWlCLGlCQUFpQixFQUFFLE9BQU8sUUFBUSxFQUFFLDRCQUE0QixnQkFBZ0IsTUFBTSxRQUFRLFNBQVMsc0JBQXNCLFFBQVEsT0FBTyxLQUFLLHNDQUFzQyxRQUFRLFNBQVMsc0JBQXNCLHlEQUF5RCwrQ0FBK0Msb0JBQW9CLFFBQVEsV0FBVyxjQUFjO0FBQ3RlLGlCQUFpQixJQUFJLHVEQUF1RCxnQkFBZ0IsZ0NBQWdDLHdCQUF3QixnQ0FBZ0Msc0RBQXNELGtGQUFrRixXQUFXLG9CQUFvQixpQkFBaUIsY0FBYyxpQ0FBaUMsWUFBWSxnQkFBZ0IseUJBQXlCLHdCQUF3QixJQUFJLDZEQUE2RCxVQUFVLFNBQVM7QUFDNWpCLDRDQUE0QyxPQUFPLFFBQVEsK0dBQStHLDRCQUE0Qix3Q0FBd0MsZ0NBQWdDLE9BQU8sVUFBVSw0QkFBNEIsWUFBWSxZQUFZLG1CQUFtQixvQkFBb0IsZ0JBQWdCLG1DQUFtQyxlQUFlLFVBQVUsZ0RBQWdELFNBQVMsdUJBQXVCO0FBQ3RoQixLQUFLLE9BQU8sR0FBRywrQkFBK0Isa0VBQWtFLDBCQUEwQix3QkFBd0IsRUFBRSxxQkFBcUIsZ0JBQWdCLFdBQVcsRUFBRSxHQUFHLHdCQUF3QixnQ0FBZ0MsZUFBZSxnQkFBZ0IscUNBQXFDLElBQUksRUFBRSxLQUFLOzs7Ozs7Ozs7Ozs7O0FDMUloVzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLEVBQUU7QUFDdEMsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSx1RUFBdUU7QUFDdkU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQSw2Q0FBNkM7QUFDN0MsT0FBTztBQUNQO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsS0FBSztBQUNMO0FBQ0Esb0JBQW9CLHlDQUF5QztBQUM3RCxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBOztBQUVBLG1DQUFtQyxXQUFXO0FBQzlDOztBQUVBLGlFQUFlLEdBQUcsRUFBQzs7Ozs7OztVQ3JJbkI7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBOztVQUVBO1VBQ0E7Ozs7O1dDNUJBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxpQ0FBaUMsV0FBVztXQUM1QztXQUNBOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLHNEQUFzRDtXQUN0RCxzQ0FBc0MsaUVBQWlFO1dBQ3ZHO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7Ozs7V0N6QkE7V0FDQTtXQUNBO1dBQ0E7V0FDQSx5Q0FBeUMsd0NBQXdDO1dBQ2pGO1dBQ0E7V0FDQTs7Ozs7V0NQQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLEVBQUU7V0FDRjs7Ozs7V0NSQTtXQUNBO1dBQ0E7V0FDQSw2QkFBNkIscVZBQXFWO1dBQ2xYOzs7OztXQ0pBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7Ozs7O1dDSkE7V0FDQTtXQUNBO1dBQ0E7V0FDQSxHQUFHO1dBQ0g7V0FDQTtXQUNBLENBQUM7Ozs7O1dDUEQ7Ozs7O1dDQUE7V0FDQTtXQUNBO1dBQ0E7V0FDQSx1QkFBdUIsNEJBQTRCO1dBQ25EO1dBQ0E7V0FDQTtXQUNBLGlCQUFpQixvQkFBb0I7V0FDckM7V0FDQSxzQ0FBc0MsWUFBWTtXQUNsRDtXQUNBO1dBQ0E7V0FDQTtXQUNBOztXQUVBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7O1dBRUE7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLG1FQUFtRSxpQ0FBaUM7V0FDcEc7V0FDQTtXQUNBO1dBQ0E7Ozs7O1dDekNBO1dBQ0E7V0FDQTtXQUNBLHVEQUF1RCxpQkFBaUI7V0FDeEU7V0FDQSxnREFBZ0QsYUFBYTtXQUM3RDs7Ozs7V0NOQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOzs7OztXQ0pBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBOzs7OztXQ2ZBOztXQUVBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7V0FFQTtXQUNBO1dBQ0E7V0FDQSxpQ0FBaUM7O1dBRWpDO1dBQ0E7V0FDQTtXQUNBLEtBQUs7V0FDTCxlQUFlO1dBQ2Y7V0FDQTtXQUNBOztXQUVBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxNQUFNO1dBQ047V0FDQTtXQUNBOztXQUVBOztXQUVBOztXQUVBOztXQUVBOztXQUVBOztXQUVBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLE1BQU0scUJBQXFCO1dBQzNCO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7V0FFQTs7V0FFQTtXQUNBO1dBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQ25GQTs7Q0FFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUVBO0FBQ0E7Q0FHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztJQUVNK0csMkNBQ0osMEJBQWU7QUFBQTs7QUFBQTs7QUFBQSxzQ0FtR0Q1TCwwREFBQSxDQUFjLEVBQWQsQ0FuR0M7O0FBQUEsbUNBb0dKQSwwREFBQSxDQUFjLEVBQWQsQ0FwR0k7O0FBQUEsb0NBcUdIQSwwREFBQSxDQUFjLEVBQWQsQ0FyR0c7O0FBQUEsbUNBc0dKQSwwREFBQSxDQUFjLElBQWQsQ0F0R0k7O0FBQUEsK0JBd0dSQSw0REFBQSxDQUFnQjtBQUNwQitMLElBQUFBLElBQUksRUFBRSxnQkFBTTtBQUNWLGFBQU8sS0FBSSxDQUFDQyxPQUFMLEVBQVA7QUFDRCxLQUhtQjtBQUlwQkMsSUFBQUEsS0FBSyxFQUFFLGVBQUNDLEtBQUQsRUFBVztBQUNoQixXQUFJLENBQUNGLE9BQUwsQ0FBYUUsS0FBYjs7QUFDQSxVQUFJLEtBQUksQ0FBQ0MsT0FBTCxNQUFrQkMsUUFBUSxDQUFDRixLQUFELENBQVIsR0FBa0JFLFFBQVEsQ0FBQyxLQUFJLENBQUNDLFFBQUwsRUFBRCxDQUFoRCxFQUFtRTtBQUNqRSxhQUFJLENBQUNBLFFBQUwsQ0FBY0gsS0FBZDtBQUNEO0FBQ0YsS0FUbUI7QUFVcEJJLElBQUFBLEtBQUssRUFBRTtBQVZhLEdBQWhCLENBeEdROztBQUFBLGdDQXFIUHRNLDREQUFBLENBQWdCO0FBQ3JCK0wsSUFBQUEsSUFBSSxFQUFFLGdCQUFNO0FBQ1YsVUFBSSxDQUFDLEtBQUksQ0FBQ0ksT0FBTCxFQUFMLEVBQXFCO0FBQ25CLFlBQUlDLFFBQVEsQ0FBQyxLQUFJLENBQUNDLFFBQUwsRUFBRCxDQUFSLElBQTZCRCxRQUFRLENBQUMsS0FBSSxDQUFDSixPQUFMLEVBQUQsQ0FBekMsRUFBMkQ7QUFDekQsaUJBQU8sS0FBSSxDQUFDSyxRQUFMLEVBQVA7QUFDRCxTQUZELE1BRU87QUFDTCxpQkFBTyxLQUFJLENBQUNMLE9BQUwsRUFBUDtBQUNEO0FBQ0YsT0FORCxNQU1PO0FBQ0wsYUFBSSxDQUFDSyxRQUFMLENBQWMsS0FBSSxDQUFDTCxPQUFMLEVBQWQ7O0FBQ0EsZUFBTyxLQUFJLENBQUNLLFFBQUwsRUFBUDtBQUNEO0FBQ0YsS0Fab0I7QUFhckJKLElBQUFBLEtBQUssRUFBRSxlQUFDQyxLQUFELEVBQVc7QUFDaEIsVUFBSUUsUUFBUSxDQUFDRixLQUFELENBQVIsSUFBbUJFLFFBQVEsQ0FBQyxLQUFJLENBQUNKLE9BQUwsRUFBRCxDQUEvQixFQUFpRDtBQUMvQyxhQUFJLENBQUNLLFFBQUwsQ0FBY0gsS0FBZDtBQUNEO0FBQ0YsS0FqQm9CO0FBa0JyQkksSUFBQUEsS0FBSyxFQUFFO0FBbEJjLEdBQWhCLENBckhPOztBQUFBLDRDQTBJS3RNLDBEQUFBLENBQWMsR0FBZCxDQTFJTDs7QUFBQSwyQ0EySUlBLDBEQUFBLENBQWMsR0FBZCxDQTNJSjs7QUFBQSxvQ0E0SUhBLDBEQUFBLENBQWMsSUFBZCxDQTVJRzs7QUFBQSx3Q0E2SUNBLDREQUFBLENBQWdCO0FBQzdCK0wsSUFBQUEsSUFBSSxFQUFFLGdCQUFNO0FBQ1YsYUFBTyxLQUFJLENBQUNRLGdCQUFMLEVBQVA7QUFDRCxLQUg0QjtBQUk3Qk4sSUFBQUEsS0FBSyxFQUFFLGVBQUNDLEtBQUQsRUFBVztBQUNoQixXQUFJLENBQUNLLGdCQUFMLENBQXNCTCxLQUF0Qjs7QUFDQSxVQUFJLEtBQUksQ0FBQ00sUUFBTCxFQUFKLEVBQXFCO0FBQ25CLGFBQUksQ0FBQ0MsZUFBTCxDQUFxQlAsS0FBckI7QUFDRDtBQUNGLEtBVDRCO0FBVTdCSSxJQUFBQSxLQUFLLEVBQUU7QUFWc0IsR0FBaEIsQ0E3SUQ7O0FBQUEsd0NBMEpDdE0sNERBQUEsQ0FBZ0I7QUFDN0IrTCxJQUFBQSxJQUFJLEVBQUUsZ0JBQU07QUFDVixVQUFJLENBQUMsS0FBSSxDQUFDUyxRQUFMLEVBQUwsRUFBc0I7QUFDcEIsZUFBTyxLQUFJLENBQUNDLGVBQUwsRUFBUDtBQUNELE9BRkQsTUFFTztBQUNMLGFBQUksQ0FBQ0EsZUFBTCxDQUFxQixLQUFJLENBQUNGLGdCQUFMLEVBQXJCOztBQUNBLGVBQU8sS0FBSSxDQUFDQSxnQkFBTCxFQUFQO0FBQ0Q7QUFDRixLQVI0QjtBQVM3Qk4sSUFBQUEsS0FBSyxFQUFFLGVBQUNDLEtBQUQsRUFBVztBQUNoQixXQUFJLENBQUNPLGVBQUwsQ0FBcUJQLEtBQXJCO0FBQ0QsS0FYNEI7QUFZN0JJLElBQUFBLEtBQUssRUFBRTtBQVpzQixHQUFoQixDQTFKRDs7QUFBQSxvQ0F5S0h0TSwwREFBQSxDQUFjLElBQWQsQ0F6S0c7O0FBQUEsZ0RBMEtTQSwwREFBQSxDQUFjLENBQWQsQ0ExS1Q7O0FBQUEsd0NBMktDQSwwREFBQSxDQUFjLENBQWQsQ0EzS0Q7O0FBQUEseUNBNEtFQSwwREFBQSxDQUFjLEtBQWQsQ0E1S0Y7O0FBQUEsNENBNktLQSwwREFBQSxDQUFjLElBQUkwTSxJQUFKLENBQVMsSUFBVCxFQUFlLENBQWYsRUFBa0IsQ0FBbEIsQ0FBZCxDQTdLTDs7QUFBQSxvQ0E4S0gxTSwwREFBQSxDQUFjLENBQWQsQ0E5S0c7O0FBQUEsd0NBK0tDQSwwREFBQSxDQUFjLEtBQWQsQ0EvS0Q7O0FBQUEsNkNBZ0xNQSwwREFBQSxDQUFjLENBQWQsQ0FoTE47O0FBQUEsd0NBaUxDQSwwREFBQSxDQUFjLEVBQWQsQ0FqTEQ7O0FBQUEsc0NBa0xEQSwwREFBQSxDQUFjLEtBQWQsQ0FsTEM7O0FBQUEsdUNBbUxBQSwwREFBQSxDQUFjLEtBQWQsQ0FuTEE7O0FBQUEsdUNBb0xBLEVBcExBOztBQUFBLHFDQXFMRkEsK0RBQUEsRUFyTEU7O0FBQUEsMkNBc0xJLElBQUlpTCxnRUFBSixFQXRMSjs7QUFBQSxtQ0F1TEpqTCwwREFBQSxFQXZMSTs7QUFBQSx1Q0F3TEFBLDBEQUFBLENBQWMsYUFBZCxDQXhMQTs7QUFBQSxtQ0F5TEpBLDBEQUFBLENBQWMsSUFBZCxDQXpMSTs7QUFBQSxzQ0EwTERBLDBEQUFBLENBQWMsS0FBZCxDQTFMQzs7QUFBQSxrQ0EyTExBLDBEQUFBLENBQWMsRUFBZCxDQTNMSzs7QUFBQSx3Q0E0TENBLDBEQUFBLENBQWMsS0FBZCxDQTVMRDs7QUFBQSx1Q0E2TEFBLDBEQUFBLENBQWMsQ0FBZCxDQTdMQTs7QUFBQSxxQ0E4TEZBLDBEQUFBLENBQWMsS0FBZCxDQTlMRTs7QUFBQSxzQ0ErTERBLDBEQUFBLENBQWMsRUFBZCxDQS9MQzs7QUFBQSx5Q0FnTUVBLDBEQUFBLENBQWMsRUFBZCxDQWhNRjs7QUFBQSxpREFpTVUsS0FqTVY7O0FBQUEsb0RBa01hLEtBbE1iOztBQUFBLGtEQW1NVyxLQW5NWDs7QUFBQSwrQ0FvTVEsS0FwTVI7O0FBQUEsdUNBcU1BQSwwREFBQSxDQUFjLEVBQWQsQ0FyTUE7O0FBQUEsMkNBc01JQSwwREFBQSxDQUFjLEVBQWQsQ0F0TUo7O0FBQUEsNkNBdU1NLElBdk1OOztBQUFBLDRDQXdNS0EsMERBQUEsQ0FBYyxJQUFkLENBeE1MOztBQUFBLDBDQXlNR0EsMERBQUEsQ0FBYyxLQUFkLENBek1IOztBQUFBLHdDQTBNQ0EsMERBQUEsQ0FBYyxDQUFkLENBMU1EOztBQUFBLHVDQTJNQUEsMERBQUEsQ0FBYyxFQUFkLENBM01BOztBQUFBLDRDQTRNS0EsMERBQUEsQ0FBYyxLQUFkLENBNU1MOztBQUFBLDJDQTZNSUEsMERBQUEsQ0FBYyxDQUFkLENBN01KOztBQUFBLHVDQThNQUEsNERBQUEsQ0FBZ0I7QUFDNUIrTCxJQUFBQSxJQUFJLEVBQUUsZ0JBQU07QUFDVixhQUFPLEtBQUksQ0FBQ2EsZUFBTCxFQUFQO0FBQ0QsS0FIMkI7QUFJNUJYLElBQUFBLEtBQUssRUFBRSxlQUFDQyxLQUFELEVBQVc7QUFDaEIsV0FBSSxDQUFDVSxlQUFMLENBQXFCVixLQUFyQjs7QUFDQSxVQUFJLEtBQUksQ0FBQ1csUUFBTCxFQUFKLEVBQXFCO0FBQ25CLGFBQUksQ0FBQ0MsZUFBTCxDQUFxQlosS0FBckI7QUFDRDtBQUNGLEtBVDJCO0FBVTVCSSxJQUFBQSxLQUFLLEVBQUU7QUFWcUIsR0FBaEIsQ0E5TUE7O0FBQUEsMkNBMk5JdE0sMERBQUEsQ0FBYyxDQUFkLENBM05KOztBQUFBLHVDQTROQUEsNERBQUEsQ0FBZ0I7QUFDNUIrTCxJQUFBQSxJQUFJLEVBQUUsZ0JBQU07QUFDVixVQUFJLENBQUMsS0FBSSxDQUFDYyxRQUFMLEVBQUwsRUFBc0I7QUFDcEIsZUFBTyxLQUFJLENBQUNDLGVBQUwsRUFBUDtBQUNELE9BRkQsTUFFTztBQUNMLGFBQUksQ0FBQ0EsZUFBTCxDQUFxQixLQUFJLENBQUNGLGVBQUwsRUFBckI7O0FBQ0EsZUFBTyxLQUFJLENBQUNBLGVBQUwsRUFBUDtBQUNEO0FBQ0YsS0FSMkI7QUFTNUJYLElBQUFBLEtBQUssRUFBRSxlQUFDQyxLQUFELEVBQVc7QUFDaEIsVUFBSUEsS0FBSyxJQUFJLEtBQUksQ0FBQ1UsZUFBTCxFQUFiLEVBQXFDO0FBQ25DLGFBQUksQ0FBQ0UsZUFBTCxDQUFxQlosS0FBckI7QUFDRDtBQUNGLEtBYjJCO0FBYzVCSSxJQUFBQSxLQUFLLEVBQUU7QUFkcUIsR0FBaEIsQ0E1TkE7O0FBQUEsNENBNk9LdE0sMERBQUEsQ0FBYyxLQUFkLENBN09MOztBQUFBLHdDQThPQ0EsMERBQUEsQ0FBYyxJQUFkLENBOU9EOztBQUFBLHNDQStPREEsMERBQUEsQ0FBYyxJQUFkLENBL09DOztBQUFBLHlDQWdQRUEsMERBQUEsQ0FBYyxDQUFkLENBaFBGOztBQUFBLGdEQWlQU0EsMERBQUEsRUFqUFQ7O0FBQUEsb0NBa1BMQSwwREFBQSxDQUFjLEtBQWQsQ0FsUEs7O0FBQUEsb0NBbVBMQSwwREFBQSxDQUFjLElBQWQsQ0FuUEs7O0FBQUEsMkNBb1BHQSwwREFBQSxFQXBQSDs7QUFBQSx1Q0F1UEEsWUFBTTtBQUNsQjtBQUVBO0FBQ0EsUUFBTStNLFVBQVUsR0FBRyxTQUFiQSxVQUFhLENBQUN0UixDQUFELEVBQU87QUFDeEIsVUFBSUEsQ0FBQyxLQUFLLE9BQU4sSUFBaUJBLENBQUMsS0FBSyxPQUEzQixFQUFvQztBQUNsQyxlQUFPQSxDQUFDLEtBQUssSUFBYjtBQUNELE9BRkQsTUFFTztBQUNMLGVBQU9BLENBQVA7QUFDRDtBQUNGLEtBTkQ7O0FBUUEsUUFBTXVSLEdBQUcsR0FBR3JCLHFEQUFBLEVBQVo7O0FBQ0EsUUFBSXFCLEdBQUosRUFBUztBQUNQLFVBQU1FLGVBQWUsR0FBRyxFQUF4Qjs7QUFDQSxXQUFLLElBQU10SixHQUFYLElBQWtCb0osR0FBbEIsRUFBdUI7QUFDckIsZ0JBQVFwSixHQUFSO0FBQ0UsZUFBSyxTQUFMO0FBQ0EsZUFBSyxLQUFMO0FBQ0EsZUFBSyxNQUFMO0FBQ0EsZUFBSyxVQUFMO0FBQ0EsZUFBSyxjQUFMO0FBQ0EsZUFBSyxjQUFMO0FBQ0VzSixZQUFBQSxlQUFlLENBQUN6VyxJQUFoQixDQUFxQjtBQUFFbU4sY0FBQUEsR0FBRyxFQUFIQSxHQUFGO0FBQU95QyxjQUFBQSxHQUFHLEVBQUUwRyxVQUFVLENBQUNDLEdBQUcsQ0FBQ3BKLEdBQUQsQ0FBSjtBQUF0QixhQUFyQjtBQUNBOztBQUNGO0FBQ0UsZ0JBQUksT0FBTyxLQUFJLENBQUNBLEdBQUQsQ0FBWCxLQUFxQixXQUF6QixFQUFzQztBQUNwQyxtQkFBSSxDQUFDQSxHQUFELENBQUosQ0FBVW9KLEdBQUcsQ0FBQ3BKLEdBQUQsQ0FBYjtBQUNEOztBQVpMO0FBY0Q7O0FBQ0QsVUFBSUMsTUFBTSxHQUFHcUosZUFBZSxDQUFDL0ssSUFBaEIsQ0FBcUIsVUFBQTFHLENBQUM7QUFBQSxlQUFJQSxDQUFDLENBQUNtSSxHQUFGLEtBQVUsU0FBZDtBQUFBLE9BQXRCLENBQWI7O0FBQ0EsVUFBSUMsTUFBSixFQUFZO0FBQ1YsYUFBSSxDQUFDQSxNQUFNLENBQUNELEdBQVIsQ0FBSixDQUFpQkMsTUFBTSxDQUFDd0MsR0FBeEI7QUFDRDs7QUFDRHhDLE1BQUFBLE1BQU0sR0FBR3FKLGVBQWUsQ0FBQy9LLElBQWhCLENBQXFCLFVBQUExRyxDQUFDO0FBQUEsZUFBSUEsQ0FBQyxDQUFDbUksR0FBRixLQUFVLFVBQWQ7QUFBQSxPQUF0QixDQUFUOztBQUNBLFVBQUlDLE1BQUosRUFBWTtBQUNWLGFBQUksQ0FBQ0EsTUFBTSxDQUFDRCxHQUFSLENBQUosQ0FBaUJDLE1BQU0sQ0FBQ3dDLEdBQXhCO0FBQ0Q7O0FBQ0Q2RyxNQUFBQSxlQUFlLENBQUNoTCxPQUFoQixDQUF3QixVQUFDekcsQ0FBRCxFQUFPO0FBQzdCLGFBQUksQ0FBQ0EsQ0FBQyxDQUFDbUksR0FBSCxDQUFKLENBQVluSSxDQUFDLENBQUM0SyxHQUFkO0FBQ0QsT0FGRDtBQUdEO0FBQ0YsR0FsU2E7O0FBQUEsOENBc1NPLFVBQUM4RyxJQUFELEVBQXNDO0FBQUEsUUFBL0JDLEdBQStCLHVFQUF6QnpXLE1BQU0sQ0FBQzBXLFFBQVAsQ0FBZ0JDLElBQVM7QUFDekQ7QUFDQUgsSUFBQUEsSUFBSSxHQUFHQSxJQUFJLENBQUM1UixPQUFMLENBQWEsU0FBYixFQUF3QixNQUF4QixDQUFQO0FBQ0EsUUFBTWdTLEtBQUssR0FBRyxJQUFJQyxNQUFKLENBQVcsU0FBU0wsSUFBVCxHQUFnQixtQkFBM0IsQ0FBZDtBQUNBLFFBQU1NLE9BQU8sR0FBR0YsS0FBSyxDQUFDRyxJQUFOLENBQVdOLEdBQVgsQ0FBaEI7QUFDQSxRQUFJLENBQUNLLE9BQUwsRUFBYyxPQUFPLElBQVA7QUFDZCxRQUFJLENBQUNBLE9BQU8sQ0FBQyxDQUFELENBQVosRUFBaUIsT0FBTyxFQUFQO0FBQ2pCLFdBQU9FLGtCQUFrQixDQUFDRixPQUFPLENBQUMsQ0FBRCxDQUFQLENBQVdsUyxPQUFYLENBQW1CLEtBQW5CLEVBQTBCLEdBQTFCLENBQUQsQ0FBekI7QUFDRCxHQTlTYTs7QUFBQSwwQ0FnVEcsWUFBTTtBQUNyQixTQUFJLENBQUNxUyxZQUFMLENBQWtCLENBQWxCO0FBQ0QsR0FsVGE7O0FBQUEsbUNBb1RKLFVBQUMzSCxDQUFELEVBQU87QUFDZixRQUFJLEtBQUksQ0FBQzRILE9BQUwsRUFBSixFQUFvQjtBQUNsQixXQUFJLENBQUNDLFdBQUwsQ0FBaUI3SCxDQUFqQjtBQUNELEtBRkQsTUFFTztBQUNMLFdBQUksQ0FBQzhILE9BQUwsQ0FBYTlILENBQWI7QUFDRDtBQUNGLEdBMVRhOztBQUFBLHFDQTRURmpHLHdEQUFBLENBQVksWUFBTTtBQUM1QixRQUFJLENBQUMsS0FBSSxDQUFDK04sT0FBTCxFQUFMLEVBQXFCO0FBQ25CLGFBQU8sRUFBUDtBQUNEOztBQUVELFdBQU8vSCx5RUFBQSxDQUE4QixLQUFJLENBQUMrSCxPQUFMLEVBQTlCLEVBQThDLENBQUMsS0FBSSxDQUFDRSxnQkFBTCxFQUEvQyxDQUFQO0FBQ0QsR0FOVyxFQU1ULElBTlMsQ0E1VEU7O0FBQUEsdUNBb1VBak8sd0RBQUEsQ0FBWSxZQUFNO0FBQzlCLFdBQU8sS0FBSSxDQUFDa08sU0FBTCxHQUFpQm5XLE1BQWpCLEdBQTBCLENBQWpDO0FBQ0QsR0FGYSxFQUVYLElBRlcsQ0FwVUE7O0FBQUEsaUNBd1VOaUksd0RBQUEsQ0FBWSxZQUFNO0FBQ3hCLFdBQU8sS0FBSSxDQUFDa08sU0FBTCxHQUFpQixLQUFJLENBQUNDLG9CQUFMLEVBQWpCLENBQVA7QUFDRCxHQUZPLEVBRUwsSUFGSyxDQXhVTTs7QUFBQSw2Q0E0VU1uTyx3REFBQSxDQUFZLFlBQU07QUFDcEMsUUFBSSxDQUFDLEtBQUksQ0FBQ29PLFlBQUwsR0FBb0IzUCxJQUFwQixFQUFMLEVBQWlDO0FBQy9CLGFBQU8sQ0FBUDtBQUNEOztBQUNELFdBQU8sS0FBSSxDQUFDMlAsWUFBTCxHQUFvQjNQLElBQXBCLEdBQTJCcUIsS0FBM0IsQ0FBaUMsR0FBakMsRUFBc0MvSCxNQUE3QztBQUNELEdBTG1CLEVBS2pCLElBTGlCLENBNVVOOztBQUFBLHdDQW1WQyxZQUFNO0FBQ25CLFFBQUksQ0FBQyxLQUFJLENBQUNzVyxVQUFMLEVBQUwsRUFBd0I7QUFDdEIsV0FBSSxDQUFDQyxXQUFMLEdBQW1CLEtBQUksQ0FBQ1AsT0FBTCxFQUFuQjs7QUFDQSxXQUFJLENBQUMxTSxPQUFMLENBQWEsS0FBSSxDQUFDME0sT0FBTCxHQUFlak8sS0FBZixDQUFxQixHQUFyQixFQUEwQnlPLElBQTFCLENBQStCLFlBQU07QUFBRSxlQUFPLE1BQU1qWSxJQUFJLENBQUNrWSxNQUFMLEVBQWI7QUFBNEIsT0FBbkUsRUFBcUU5TCxJQUFyRSxDQUEwRSxHQUExRSxDQUFiO0FBQ0QsS0FIRCxNQUdPO0FBQ0wsV0FBSSxDQUFDckIsT0FBTCxDQUFhLEtBQUksQ0FBQ2lOLFdBQWxCO0FBQ0Q7O0FBQ0QsU0FBSSxDQUFDRCxVQUFMLENBQWdCLENBQUMsS0FBSSxDQUFDQSxVQUFMLEVBQWpCO0FBQ0QsR0EzVmE7O0FBQUEsMENBNlZHLFlBQU07QUFDckIsUUFBSSxLQUFJLENBQUNULFlBQUwsS0FBc0IsS0FBSSxDQUFDYSxLQUFMLEdBQWExVyxNQUFiLEdBQXNCLENBQWhELEVBQW1EO0FBQ2pELFdBQUksQ0FBQzZWLFlBQUwsQ0FBa0IsS0FBSSxDQUFDQSxZQUFMLEtBQXNCLENBQXhDO0FBQ0QsS0FGRCxNQUVPO0FBQ0w7QUFDQSxVQUFJLEtBQUksQ0FBQ08sb0JBQUwsS0FBOEIsS0FBSSxDQUFDTyxXQUFMLEVBQWxDLEVBQXNEO0FBQ3BELGFBQUksQ0FBQ1Asb0JBQUwsQ0FBMEJRLE1BQU0sQ0FBQyxLQUFJLENBQUNSLG9CQUFMLEVBQUQsQ0FBTixHQUFzQyxDQUFoRTs7QUFDQSxhQUFJLENBQUNQLFlBQUwsQ0FBa0IsQ0FBbEI7QUFDRDtBQUNGO0FBQ0YsR0F2V2E7O0FBQUEsMENBeVdFLFlBQU07QUFDckIsU0FBSSxDQUFDZ0IsZUFBTCxDQUFxQkMsS0FBckIsQ0FBMkIsWUFBTTtBQUMvQixVQUFJLEtBQUksQ0FBQ2pCLFlBQUwsS0FBc0IsQ0FBdEIsSUFBMkIsS0FBSSxDQUFDYSxLQUFMLEdBQWExVyxNQUFiLEdBQXNCLENBQXJELEVBQXdEO0FBQ3RELGFBQUksQ0FBQzZWLFlBQUwsQ0FBa0IsS0FBSSxDQUFDQSxZQUFMLEtBQXNCLENBQXhDLEVBRHNELENBRXREO0FBQ0E7OztBQUNBa0IsUUFBQUEsVUFBVSxDQUFDLEtBQUksQ0FBQ0MsTUFBTixFQUFjLElBQWQsQ0FBVjtBQUNEO0FBQ0YsS0FQRDtBQVFELEdBbFhjOztBQUFBLHNDQW9YRixZQUFNO0FBQ2pCO0FBQ0EsU0FBSSxDQUFDWixvQkFBTCxDQUEwQixDQUExQjs7QUFDQSxTQUFJLENBQUNQLFlBQUwsQ0FBa0IsQ0FBbEIsRUFIaUIsQ0FJakI7O0FBQ0QsR0F6WGM7O0FBQUEsMENBMlhFLFlBQU07QUFDckI7QUFDQTtBQUNBLFNBQUksQ0FBQ0EsWUFBTCxDQUFrQixDQUFsQixFQUhxQixDQUlyQjs7QUFDRCxHQWhZYzs7QUFBQSx3Q0FrWUEsVUFBQ29CLEtBQUQsRUFBVztBQUN4QixRQUFJLENBQUMsS0FBSSxDQUFDbEYsYUFBTCxFQUFMLEVBQTJCO0FBQ3pCLFdBQUksQ0FBQzhELFlBQUwsQ0FBa0JvQixLQUFsQjtBQUNELEtBRkQsTUFFTztBQUNMLFdBQUksQ0FBQ0MsT0FBTCxDQUFhLEtBQWIsRUFBb0IsS0FBcEI7O0FBQ0EsV0FBSSxDQUFDckIsWUFBTCxDQUFrQm9CLEtBQWxCOztBQUNBLFdBQUksQ0FBQ0QsTUFBTCxDQUFZLEtBQVosRUFBbUIsS0FBbkI7QUFDRDtBQUNGLEdBMVljOztBQUFBLDBDQTRZRSxVQUFDMUosSUFBRCxFQUFVO0FBQ3pCLFFBQUksQ0FBQyxLQUFJLENBQUMrSSxZQUFMLEdBQW9CM1AsSUFBcEIsRUFBTCxFQUFpQztBQUMvQixXQUFJLENBQUMyUCxZQUFMLENBQWtCLEtBQUksQ0FBQ0EsWUFBTCxHQUFvQjNQLElBQXBCLEtBQTZCNEcsSUFBL0M7QUFDRCxLQUZELE1BRU87QUFDTDtBQUNBLFVBQU1vSixLQUFLLEdBQUcsS0FBSSxDQUFDTCxZQUFMLEdBQW9CM1AsSUFBcEIsR0FBMkJxQixLQUEzQixDQUFpQyxHQUFqQyxDQUFkOztBQUNBLFVBQU1vUCxRQUFRLEdBQUdULEtBQUssQ0FBQ0EsS0FBSyxDQUFDMVcsTUFBTixHQUFlLENBQWhCLENBQXRCOztBQUNBLFVBQUltWCxRQUFRLEtBQUs3SixJQUFqQixFQUF1QjtBQUNyQjtBQUNBO0FBQ0FvSixRQUFBQSxLQUFLLENBQUNVLEdBQU47QUFDRCxPQUpELE1BSU87QUFDTFYsUUFBQUEsS0FBSyxDQUFDaFksSUFBTixDQUFXNE8sSUFBWDtBQUNEOztBQUNELFVBQUlvSixLQUFLLENBQUMxVyxNQUFOLEtBQWlCLENBQXJCLEVBQXdCO0FBQ3RCLGFBQUksQ0FBQ3FXLFlBQUwsQ0FBa0IsRUFBbEI7QUFDRCxPQUZELE1BRU87QUFDTCxhQUFJLENBQUNBLFlBQUwsQ0FBa0JLLEtBQUssQ0FBQy9MLElBQU4sQ0FBVyxHQUFYLENBQWxCO0FBQ0Q7QUFDRjtBQUNGLEdBaGFjOztBQUFBLHNDQWthRixZQUFNO0FBQ2pCLFNBQUksQ0FBQ3JCLE9BQUwsQ0FBYSxLQUFJLENBQUMrTSxZQUFMLEVBQWI7O0FBQ0EsU0FBSSxDQUFDZ0IsVUFBTDtBQUNELEdBcmFjOztBQUFBLHlDQXVhQyxZQUFNO0FBQ3BCLFFBQUksS0FBSSxDQUFDQyxXQUFMLEVBQUosRUFBd0I7QUFDdEIsVUFBTTdTLElBQUksR0FBRztBQUFFOFMsUUFBQUEsT0FBTyxFQUFFLEtBQUksQ0FBQ0QsV0FBTCxHQUFtQjVRLElBQW5CLEdBQTBCbEQsT0FBMUIsQ0FBa0MsSUFBbEMsRUFBd0MsRUFBeEM7QUFBWCxPQUFiOztBQUNBLFdBQUksQ0FBQzJILGNBQUwsQ0FBb0IxRyxJQUFwQixFQUEwQixJQUExQjtBQUNEO0FBQ0YsR0E1YWM7O0FBQUEsMENBOGFFLFVBQUNBLElBQUQsRUFBTytTLFFBQVAsRUFBb0I7QUFDbkMsUUFBSUMsR0FBRyxHQUFHLEVBQVY7O0FBQ0EsUUFBTUMsMkJBQTJCLEdBQUcsU0FBOUJBLDJCQUE4QixDQUFDeEosQ0FBRCxFQUFPO0FBQ3pDLFVBQUl5SixPQUFPLEdBQUcsRUFBZDs7QUFDQSxVQUFJLEtBQUksQ0FBQ0MsWUFBTCxNQUF1QixLQUFJLENBQUNDLFVBQUwsR0FBa0JuUixJQUFsQixFQUEzQixFQUFxRDtBQUNuRGlSLFFBQUFBLE9BQU8sR0FBRyxNQUFNLEtBQUksQ0FBQ0UsVUFBTCxHQUFrQjFRLFdBQWxCLEdBQWdDVCxJQUFoQyxHQUF1Q2xELE9BQXZDLENBQStDLE9BQS9DLEVBQXdELEdBQXhELEVBQTZEQSxPQUE3RCxDQUFxRSxJQUFyRSxFQUEyRSxHQUEzRSxDQUFoQjtBQUNEOztBQUVELFVBQU1zVSxNQUFNLGtCQUFXSCxPQUFYLGtCQUFaLENBTnlDLENBT3pDOztBQUNBLFVBQU1JLEVBQUUsR0FBRyxJQUFJdEMsTUFBSixDQUFXcUMsTUFBWCxFQUFtQixHQUFuQixDQUFYO0FBQ0EsVUFBTXRRLEtBQUssR0FBRzBHLENBQUMsQ0FBQy9HLFdBQUYsR0FBZ0JLLEtBQWhCLENBQXNCdVEsRUFBdEIsQ0FBZCxDQVR5QyxDQVV6Qzs7QUFDQSxhQUFPdlEsS0FBUDtBQUNELEtBWkQ7O0FBYUEsUUFBTXdRLEtBQUssR0FBR04sMkJBQTJCLENBQUNqVCxJQUFJLENBQUM4UyxPQUFOLENBQXpDO0FBQ0EsUUFBSVUsT0FBTyxHQUFHLENBQWQ7QUFDQSxRQUFNQyxXQUFXLEdBQUksS0FBSSxDQUFDQyxjQUFMLE1BQXlCWCxRQUExQixHQUF1QyxLQUFJLENBQUNZLFlBQUwsS0FBc0IsRUFBN0QsR0FBbUUzVCxJQUFJLENBQUM0VCxlQUE1RjtBQUNBLFFBQU1DLFdBQVcsR0FBSSxLQUFJLENBQUNDLGdCQUFMLE1BQTJCZixRQUE1QixHQUF3QyxLQUFJLENBQUNnQixXQUFMLEVBQXhDLEdBQTZEL1QsSUFBSSxDQUFDNlQsV0FBdEY7QUFDQSxRQUFNRyxXQUFXLEdBQUksS0FBSSxDQUFDRixnQkFBTCxNQUEyQmYsUUFBNUIsR0FBd0MsS0FBSSxDQUFDa0IsV0FBTCxFQUF4QyxHQUE2RGpVLElBQUksQ0FBQ2dVLFdBQXRGLENBbkJtQyxDQW9CbkM7QUFDQTs7QUFDQSxRQUFNRSxZQUFZLEdBQUcsU0FBZkEsWUFBZSxDQUFDN1QsR0FBRCxFQUFNdEcsR0FBTixFQUFjO0FBQ2pDc0csTUFBQUEsR0FBRyxHQUFHdkcsSUFBSSxDQUFDcWEsSUFBTCxDQUFVOVQsR0FBVixDQUFOO0FBQ0F0RyxNQUFBQSxHQUFHLEdBQUdELElBQUksQ0FBQ3NhLEtBQUwsQ0FBV3JhLEdBQVgsQ0FBTjtBQUNBLGFBQU9ELElBQUksQ0FBQ3NhLEtBQUwsQ0FBV3RhLElBQUksQ0FBQ2tZLE1BQUwsTUFBaUJqWSxHQUFHLEdBQUdzRyxHQUFOLEdBQVksQ0FBN0IsQ0FBWCxJQUE4Q0EsR0FBckQ7QUFDRCxLQUpEOztBQU1BLE9BQUc7QUFDRCxVQUFJd0ksSUFBSSxHQUFHLEVBQVg7O0FBRUEsVUFBSSxLQUFJLENBQUN3TCxnQkFBTCxFQUFKLEVBQTZCO0FBQzNCO0FBQ0EsWUFBTUMsVUFBVSxHQUFHVCxXQUFXLEtBQUtHLFdBQWhCLEdBQThCSCxXQUE5QixHQUE0Q0ssWUFBWSxDQUFDTCxXQUFELEVBQWNHLFdBQWQsQ0FBM0U7O0FBRUEsYUFBSyxJQUFJOVQsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsSUFBSW9VLFVBQXJCLEVBQWlDcFUsQ0FBQyxFQUFsQyxFQUFzQztBQUFFO0FBQ3RDO0FBQ0EySSxVQUFBQSxJQUFJLElBQUkwSyxLQUFLLENBQUNXLFlBQVksQ0FBQyxDQUFELEVBQUlYLEtBQUssQ0FBQ2hZLE1BQVYsQ0FBWixHQUFnQyxDQUFqQyxDQUFiO0FBQ0Q7QUFDRixPQVJELE1BUU87QUFDTHNOLFFBQUFBLElBQUksR0FBRzdJLElBQUksQ0FBQzhTLE9BQVo7QUFDRDs7QUFFREUsTUFBQUEsR0FBRyxJQUFJUSxPQUFPLEdBQUcsQ0FBVixHQUFlLE1BQU0zSyxJQUFJLENBQUNuRyxXQUFMLEVBQXJCLEdBQTJDbUcsSUFBSSxDQUFDbkcsV0FBTCxFQUFsRDs7QUFFQSxVQUFNMkYsTUFBTSxHQUFHLEtBQUksQ0FBQ2tNLCtCQUFMLENBQXFDdkIsR0FBckMsQ0FBZjs7QUFDQSxVQUFNd0IsR0FBRyxHQUFHLEtBQUksQ0FBQ3BDLGVBQUwsQ0FBcUJxQyxlQUFyQixDQUFxQ3BNLE1BQXJDLENBQVo7O0FBQ0FtTCxNQUFBQSxPQUFPLEdBQUdnQixHQUFHLENBQUNqTCxTQUFKLENBQWN1QyxTQUFkLEdBQTBCLElBQXBDO0FBQ0QsS0FwQkQsUUFvQlMwSCxPQUFPLEdBQUdDLFdBcEJuQjs7QUFzQkEsU0FBSSxDQUFDNU8sT0FBTCxDQUFhbU8sR0FBYjtBQUNELEdBamVjOztBQUFBLDJEQW1lbUIsVUFBQ3pRLElBQUQsRUFBVTtBQUMxQyxRQUFNOEYsTUFBTSxHQUFHLElBQUlGLG9GQUFKLEVBQWY7QUFDQUUsSUFBQUEsTUFBTSxDQUFDUSxJQUFQLEdBQWN0RyxJQUFkO0FBQ0E4RixJQUFBQSxNQUFNLENBQUNqUCxHQUFQLEdBQWF3VyxRQUFRLENBQUMsS0FBSSxDQUFDeFcsR0FBTCxFQUFELENBQXJCO0FBQ0FpUCxJQUFBQSxNQUFNLENBQUNoUCxJQUFQLEdBQWN1VyxRQUFRLENBQUMsS0FBSSxDQUFDdlcsSUFBTCxFQUFELENBQXRCO0FBQ0FnUCxJQUFBQSxNQUFNLENBQUN4TCxZQUFQLEdBQXNCK1MsUUFBUSxDQUFDLEtBQUksQ0FBQy9TLFlBQUwsRUFBRCxDQUE5QjtBQUNBd0wsSUFBQUEsTUFBTSxDQUFDdkwsWUFBUCxHQUFzQjhTLFFBQVEsQ0FBQyxLQUFJLENBQUM5UyxZQUFMLEVBQUQsQ0FBOUI7QUFDQXVMLElBQUFBLE1BQU0sQ0FBQ2UsWUFBUCxHQUFzQixLQUFJLENBQUNzTCxZQUFMLEtBQXNCLENBQXRCLEdBQTBCLEtBQUksQ0FBQ0MsUUFBTCxLQUFrQixJQUFsRTtBQUNBdE0sSUFBQUEsTUFBTSxDQUFDSyxpQkFBUCxHQUEyQmtILFFBQVEsQ0FBQyxLQUFJLENBQUNsSCxpQkFBTCxFQUFELENBQW5DO0FBQ0FMLElBQUFBLE1BQU0sQ0FBQ3NHLE1BQVAsR0FBZ0JpQixRQUFRLENBQUMsS0FBSSxDQUFDakIsTUFBTCxFQUFELENBQXhCO0FBQ0F0RyxJQUFBQSxNQUFNLENBQUNtRSxLQUFQLEdBQWU7QUFDYnhSLE1BQUFBLElBQUksRUFBRSxLQUFJLENBQUM0WixZQUFMLEtBQXNCLEtBQUksQ0FBQ0MsU0FBTCxFQUF0QixHQUF5QyxLQURsQztBQUVibEcsTUFBQUEsTUFBTSxFQUFFaUIsUUFBUSxDQUFDLEtBQUksQ0FBQ2tGLFdBQUwsRUFBRDtBQUZILEtBQWY7QUFJQXpNLElBQUFBLE1BQU0sQ0FBQ2lGLGFBQVAsR0FBdUIsS0FBSSxDQUFDQSxhQUFMLEVBQXZCO0FBQ0EsV0FBT2pGLE1BQVA7QUFDRCxHQW5mYzs7QUFBQSxrQ0FxZk4sVUFBQzBNLGFBQUQsRUFBZ0JDLGNBQWhCLEVBQW1DO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFNQyxnQkFBZ0IsR0FBRyxLQUFJLENBQUMzSCxhQUFMLEVBQXpCOztBQUNBLFFBQU00SCxVQUFVLEdBQUdGLGNBQWMsSUFBSSxDQUFDQyxnQkFBdEM7O0FBQ0EsUUFBSSxDQUFDLEtBQUksQ0FBQ0UsaUJBQU4sSUFBNEIsS0FBSSxDQUFDQyxnQkFBTCxLQUEwQixLQUFJLENBQUNELGlCQUEvRCxFQUFtRjtBQUNqRixXQUFJLENBQUNBLGlCQUFMLEdBQXlCakYsSUFBSSxDQUFDbUYsR0FBTCxFQUF6QjtBQUNEOztBQUNELFNBQUksQ0FBQ0MsUUFBTCxDQUFjLEtBQWQ7O0FBQ0EsU0FBSSxDQUFDaEksYUFBTCxDQUFtQixJQUFuQjs7QUFDQSxRQUFJLENBQUN5SCxhQUFMLEVBQW9CO0FBQ2xCLFdBQUksQ0FBQ0wsWUFBTCxDQUFrQixLQUFsQjtBQUNEOztBQUVELFFBQUlRLFVBQUosRUFBZ0I7QUFDZCxXQUFJLENBQUNLLGFBQUwsQ0FBbUIsQ0FBbkI7QUFDRCxLQXRCeUMsQ0F1QjFDO0FBQ0E7QUFDQTs7O0FBQ0EsUUFBSSxLQUFJLENBQUNDLGFBQVQsRUFBd0I7QUFDdEJDLE1BQUFBLFlBQVksQ0FBQyxLQUFJLENBQUNELGFBQU4sQ0FBWjtBQUNEOztBQUNELFNBQUksQ0FBQ0EsYUFBTCxHQUFxQmxELFVBQVUsQ0FBQztBQUFBLGFBQU0sS0FBSSxDQUFDRixlQUFMLENBQXFCQyxLQUFyQixDQUEyQixZQUFNO0FBQ3JFLFlBQU1oSyxNQUFNLEdBQUcsS0FBSSxDQUFDa00sK0JBQUwsQ0FBcUMsS0FBSSxDQUFDdEMsS0FBTCxHQUFhLEtBQUksQ0FBQ2IsWUFBTCxFQUFiLENBQXJDLENBQWY7O0FBQ0EsYUFBSSxDQUFDZ0IsZUFBTCxDQUFxQnZELElBQXJCLENBQTBCeEcsTUFBMUIsRUFBa0MsS0FBSSxDQUFDcU4sU0FBdkM7O0FBQ0EsYUFBSSxDQUFDQyxvQkFBTCxDQUEwQnpGLElBQUksQ0FBQ21GLEdBQUwsRUFBMUI7O0FBQ0EsYUFBSSxDQUFDWCxZQUFMLENBQWtCLElBQWxCO0FBQ0QsT0FMcUMsQ0FBTjtBQUFBLEtBQUQsRUFNL0JLLGFBQWEsSUFBSUMsY0FBakIsR0FBa0MsQ0FBbEMsR0FBc0MsSUFOUCxDQUEvQjtBQU9ELEdBemhCYzs7QUFBQSxxQ0EyaEJILFlBQU07QUFDaEIsU0FBSSxDQUFDTyxhQUFMLENBQW1CLEtBQUksQ0FBQ0EsYUFBTCxNQUF3QnJGLElBQUksQ0FBQ21GLEdBQUwsS0FBYSxLQUFJLENBQUNNLG9CQUFMLEVBQXJDLENBQW5COztBQUNBLFFBQUksS0FBSSxDQUFDdkUsWUFBTCxLQUFzQixLQUFJLENBQUNhLEtBQUwsR0FBYTFXLE1BQWIsR0FBc0IsQ0FBaEQsRUFBbUQ7QUFDakQsV0FBSSxDQUFDcWEsY0FBTDs7QUFDQSxXQUFJLENBQUNyRCxNQUFMLENBQVksSUFBWjtBQUNELEtBSEQsTUFHTyxJQUFJLEtBQUksQ0FBQ1osb0JBQUwsS0FBOEIsS0FBSSxDQUFDTyxXQUFMLEVBQWxDLEVBQXNEO0FBQzNEO0FBQ0EsV0FBSSxDQUFDUCxvQkFBTCxDQUEwQlEsTUFBTSxDQUFDLEtBQUksQ0FBQ1Isb0JBQUwsRUFBRCxDQUFOLEdBQXNDLENBQWhFOztBQUNBLFdBQUksQ0FBQ1AsWUFBTCxDQUFrQixDQUFsQjs7QUFDQSxXQUFJLENBQUNtQixNQUFMLENBQVksSUFBWjtBQUNELEtBTE0sTUFLQTtBQUNMO0FBQ0EsV0FBSSxDQUFDRSxPQUFMLENBQWEsSUFBYjtBQUNEO0FBQ0YsR0F6aUJjOztBQUFBLG1DQTJpQkwsVUFBQ0csVUFBRCxFQUFhaUQsZUFBYixFQUFpQztBQUN6QyxRQUFJQSxlQUFKLEVBQXFCO0FBQ25CLFdBQUksQ0FBQ04sYUFBTCxDQUFtQixLQUFJLENBQUNBLGFBQUwsTUFBd0JyRixJQUFJLENBQUNtRixHQUFMLEtBQWEsS0FBSSxDQUFDTSxvQkFBTCxFQUFyQyxDQUFuQjs7QUFDQSxXQUFJLENBQUNMLFFBQUwsQ0FBYyxDQUFDLEtBQUksQ0FBQ0EsUUFBTCxFQUFmO0FBQ0Q7O0FBQ0QsU0FBSSxDQUFDaEksYUFBTCxDQUFtQixLQUFuQjs7QUFDQSxTQUFJLENBQUM4RSxlQUFMLENBQXFCQyxLQUFyQixDQUEyQixZQUFNO0FBQy9CO0FBQ0F0TyxNQUFBQSxPQUFPLENBQUNDLEdBQVIsQ0FBWSx5QkFBWjs7QUFDQSxXQUFJLENBQUNvUixnQkFBTCxDQUFzQmxGLElBQUksQ0FBQ21GLEdBQUwsRUFBdEI7O0FBQ0F0UixNQUFBQSxPQUFPLENBQUNDLEdBQVIsb0JBQXdCLEtBQUksQ0FBQ29SLGdCQUFMLEtBQTBCLEtBQUksQ0FBQ0QsaUJBQXZELEdBSitCLENBSy9COztBQUNBLFVBQUksS0FBSSxDQUFDVyxlQUFULEVBQTBCO0FBQ3hCLGFBQUksQ0FBQ0EsZUFBTDtBQUNEOztBQUVELFdBQUksQ0FBQ3BCLFlBQUwsQ0FBa0IsS0FBbEI7QUFDRCxLQVhELEVBV0csSUFYSDs7QUFZQSxRQUFJOUIsVUFBSixFQUFnQjtBQUNkLFdBQUksQ0FBQ0EsVUFBTDtBQUNEO0FBQ0YsR0Foa0JjOztBQUFBLDJDQWtrQkcsVUFBQ21ELElBQUQsRUFBVTtBQUMxQjtBQUNBLFFBQU1DLEVBQUUsR0FBRyxJQUFJQyxVQUFKLEVBQVg7O0FBQ0FELElBQUFBLEVBQUUsQ0FBQ0UsTUFBSCxHQUFZLFVBQUNsVyxJQUFELEVBQVU7QUFDcEIsV0FBSSxDQUFDNkUsT0FBTCxDQUFhN0UsSUFBSSxDQUFDcUgsTUFBTCxDQUFZOE8sTUFBekI7QUFDRCxLQUZEOztBQUdBSCxJQUFBQSxFQUFFLENBQUNJLFVBQUgsQ0FBY0wsSUFBZDtBQUNELEdBemtCYzs7QUFBQSxzQ0Eya0JGLFlBQU07QUFDakIsUUFBSU0sUUFBUSxHQUFHLEVBQWY7O0FBQ0EsUUFBTTNFLFNBQVMsR0FBRyxLQUFJLENBQUNBLFNBQUwsRUFBbEI7O0FBQ0FBLElBQUFBLFNBQVMsQ0FBQ2hNLE9BQVYsQ0FBa0IsVUFBQ3lFLFFBQUQsRUFBYztBQUM5QkEsTUFBQUEsUUFBUSxDQUFDekUsT0FBVCxDQUFpQixVQUFDbUQsSUFBRCxFQUFVO0FBQ3pCd04sUUFBQUEsUUFBUSxJQUFJQSxRQUFRLENBQUM5YSxNQUFULEdBQWtCLENBQWxCLEdBQXNCLE1BQU1zTixJQUE1QixHQUFtQ0EsSUFBL0M7QUFDRCxPQUZEO0FBR0QsS0FKRDs7QUFLQSxRQUFNUixNQUFNLEdBQUcsS0FBSSxDQUFDa00sK0JBQUwsQ0FBcUM4QixRQUFyQyxDQUFmOztBQUNBLFFBQU1oTixHQUFHLEdBQUcsS0FBSSxDQUFDK0ksZUFBTCxDQUFxQmtFLGVBQXJCLENBQXFDak8sTUFBckMsQ0FBWjs7QUFDQSxRQUFNeUIsR0FBRyxHQUFHLElBQUl5TSxVQUFKLENBQWVsTixHQUFHLENBQUNBLEdBQW5CLENBQVo7QUFDQSxRQUFNbU4sSUFBSSxHQUFHL08sUUFBUSxDQUFDQyxjQUFULENBQXdCLGNBQXhCLENBQWI7QUFDQSxRQUFNK08sSUFBSSxHQUFHLElBQUlDLElBQUosQ0FBUyxDQUFDNU0sR0FBRCxDQUFULEVBQWdCO0FBQUU5TyxNQUFBQSxJQUFJLEVBQUU7QUFBUixLQUFoQixDQUFiO0FBQ0F3YixJQUFBQSxJQUFJLENBQUMxRixJQUFMLEdBQVk2RixHQUFHLENBQUNDLGVBQUosQ0FBb0JILElBQXBCLENBQVo7QUFDQUQsSUFBQUEsSUFBSSxDQUFDSyxRQUFMLEdBQWdCLFdBQWhCO0FBQ0FMLElBQUFBLElBQUksQ0FBQ00sYUFBTCxDQUFtQixJQUFJQyxVQUFKLENBQWUsT0FBZixDQUFuQjtBQUNELEdBM2xCYzs7QUFBQSxpQ0E2bEJQLFlBQU07QUFDWmhULElBQUFBLE9BQU8sQ0FBQ0MsR0FBUixDQUFZLE9BQVo7QUFDRCxHQS9sQmM7O0FBQUEsd0NBaW1CQVIsd0RBQUEsQ0FBWSxZQUFNO0FBQy9CO0FBQ0E7QUFDQSxRQUFJLENBQUMsS0FBSSxDQUFDK04sT0FBTCxFQUFMLEVBQXFCO0FBQ25CLGFBQU8sQ0FBUDtBQUNEOztBQUNELFFBQU1sSixNQUFNLEdBQUcsS0FBSSxDQUFDa00sK0JBQUwsQ0FBcUMsS0FBSSxDQUFDaEQsT0FBTCxFQUFyQyxDQUFmOztBQUNBLFFBQU1pRCxHQUFHLEdBQUcsS0FBSSxDQUFDcEMsZUFBTCxDQUFxQnFDLGVBQXJCLENBQXFDcE0sTUFBckMsQ0FBWjs7QUFDQSxRQUFNMk8sT0FBTyxHQUFHbGQsSUFBSSxDQUFDc2EsS0FBTCxDQUFXSSxHQUFHLENBQUNqTCxTQUFKLENBQWN1QyxTQUFkLEdBQTBCLEtBQXJDLENBQWhCO0FBQ0EsUUFBTTBILE9BQU8sR0FBRyxDQUFFZ0IsR0FBRyxDQUFDakwsU0FBSixDQUFjdUMsU0FBZCxHQUEwQixLQUEzQixHQUFvQyxJQUFyQyxFQUEyQ21MLE9BQTNDLENBQW1ELENBQW5ELENBQWhCO0FBQ0EsUUFBTUMsYUFBYSxHQUFHLENBQUMxRCxPQUFPLEdBQUcsRUFBVixHQUFlLEdBQWYsR0FBcUIsRUFBdEIsSUFBNEJBLE9BQWxEO0FBQ0EsUUFBTTJELFdBQVcsR0FBRztBQUFFSCxNQUFBQSxPQUFPLEVBQVBBLE9BQUY7QUFBV3hELE1BQUFBLE9BQU8sRUFBUEEsT0FBWDtBQUFvQjBELE1BQUFBLGFBQWEsRUFBYkE7QUFBcEIsS0FBcEI7QUFDQW5ULElBQUFBLE9BQU8sQ0FBQ0MsR0FBUixDQUFZbVQsV0FBWjtBQUNBcFQsSUFBQUEsT0FBTyxDQUFDQyxHQUFSLENBQVl3USxHQUFaO0FBQ0EsV0FBTzJDLFdBQVA7QUFDRCxHQWZjLEVBZVosSUFmWSxDQWptQkE7O0FBQUEsdUNBa25CRDNULHdEQUFBLENBQVksWUFBTTtBQUM5QixRQUFNd1QsT0FBTyxHQUFHbGQsSUFBSSxDQUFDc2EsS0FBTCxDQUFXLEtBQUksQ0FBQ21CLGFBQUwsS0FBdUIsS0FBbEMsQ0FBaEI7QUFDQSxRQUFNL0IsT0FBTyxHQUFHLENBQUUsS0FBSSxDQUFDK0IsYUFBTCxLQUF1QixLQUF4QixHQUFpQyxJQUFsQyxFQUF3QzBCLE9BQXhDLENBQWdELENBQWhELENBQWhCO0FBQ0EsUUFBTUMsYUFBYSxHQUFHLENBQUMxRCxPQUFPLEdBQUcsRUFBVixHQUFlLEdBQWYsR0FBcUIsRUFBdEIsSUFBNEJBLE9BQWxEO0FBQ0EsUUFBTTJELFdBQVcsR0FBRztBQUFFSCxNQUFBQSxPQUFPLEVBQVBBLE9BQUY7QUFBV3hELE1BQUFBLE9BQU8sRUFBUEEsT0FBWDtBQUFvQjBELE1BQUFBLGFBQWEsRUFBYkE7QUFBcEIsS0FBcEIsQ0FKOEIsQ0FLOUI7QUFDQTs7QUFDQSxXQUFPQyxXQUFQO0FBQ0QsR0FSYSxFQVFYLElBUlcsQ0FsbkJDOztBQUNiLE9BQUtDLGVBQUwsQ0FBcUIsSUFBSWpRLGdFQUFKLEVBQXJCLEVBRGEsQ0FHYjs7QUFDQTNELEVBQUFBLHNFQUFBLEdBQTBCLFVBQUM2RCxNQUFELEVBQVNrUSxNQUFULEVBQW9CO0FBQzVDbFEsSUFBQUEsTUFBTSxDQUFDbVEsU0FBUCxDQUFpQixVQUFDQyxRQUFELEVBQWM7QUFDN0J0SSxNQUFBQSxxREFBQSxDQUFZb0ksTUFBWixFQUFvQkUsUUFBcEIsRUFBOEI7QUFBRUUsUUFBQUEsT0FBTyxFQUFFO0FBQVgsT0FBOUI7QUFDRCxLQUZEO0FBR0EsV0FBT3RRLE1BQVA7QUFDRCxHQUxEOztBQU9BN0QsRUFBQUEseUVBQUEsR0FBNkIsVUFBQzZELE1BQUQsRUFBU2tRLE1BQVQsRUFBb0I7QUFDL0NsUSxJQUFBQSxNQUFNLENBQUNtUSxTQUFQLENBQWlCLFVBQUNDLFFBQUQsRUFBYztBQUM3QixVQUFJLEtBQUksQ0FBQ3BHLE9BQUwsRUFBSixFQUFvQjtBQUNsQixhQUFJLENBQUNFLE9BQUwsQ0FBYWtHLFFBQWI7QUFDRDtBQUNGLEtBSkQ7QUFLQSxXQUFPcFEsTUFBUDtBQUNELEdBUEQ7O0FBUUE3RCxFQUFBQSx5RUFBQSxHQUE2QixVQUFDNkQsTUFBRCxFQUFTa1EsTUFBVCxFQUFvQjtBQUMvQ2xRLElBQUFBLE1BQU0sQ0FBQ21RLFNBQVAsQ0FBaUIsVUFBQ0MsUUFBRCxFQUFjO0FBQzdCO0FBQ0EsVUFBSUEsUUFBSixFQUFjO0FBQ1osYUFBSSxDQUFDbkcsV0FBTCxDQUFpQixLQUFJLENBQUNDLE9BQUwsRUFBakI7QUFDRCxPQUZELE1BRU87QUFDTCxhQUFJLENBQUNELFdBQUwsQ0FBaUIsRUFBakI7QUFDRDtBQUNGLEtBUEQ7QUFRQSxXQUFPakssTUFBUDtBQUNELEdBVkQ7O0FBWUE3RCxFQUFBQSxxRUFBQSxHQUF5QixVQUFDNkQsTUFBRCxFQUFTa1EsTUFBVCxFQUFvQjtBQUMzQ2xRLElBQUFBLE1BQU0sQ0FBQ21RLFNBQVAsQ0FBaUIsVUFBQ0MsUUFBRCxFQUFjO0FBQzdCLFdBQUksQ0FBQ3JGLGVBQUwsQ0FBcUJoRSxTQUFyQixDQUErQnFKLFFBQS9CO0FBQ0QsS0FGRDtBQUdBLFdBQU9wUSxNQUFQO0FBQ0QsR0FMRDs7QUFPQTdELEVBQUFBLDBFQUFBLEdBQThCLFVBQUM2RCxNQUFELEVBQVNrUSxNQUFULEVBQW9CO0FBQ2hEbFEsSUFBQUEsTUFBTSxDQUFDbVEsU0FBUCxDQUFpQixVQUFDQyxRQUFELEVBQWM7QUFDN0IsV0FBSSxDQUFDckYsZUFBTCxDQUFxQjdGLGNBQXJCLENBQW9Da0wsUUFBcEM7QUFDRCxLQUZEO0FBR0EsV0FBT3BRLE1BQVA7QUFDRCxHQUxEOztBQU9BN0QsRUFBQUEsd0VBQUEsR0FBNEIsVUFBQzZELE1BQUQsRUFBU2tRLE1BQVQsRUFBb0I7QUFDOUNsUSxJQUFBQSxNQUFNLENBQUNtUSxTQUFQLENBQWlCLFVBQUNDLFFBQUQsRUFBYztBQUM3QixVQUFNcFAsTUFBTSxHQUFHLEtBQUksQ0FBQ2tNLCtCQUFMLENBQXFDLEVBQXJDLENBQWY7O0FBQ0FsTSxNQUFBQSxNQUFNLENBQUNtRSxLQUFQLENBQWF4UixJQUFiLEdBQW9CLEtBQUksQ0FBQzRaLFlBQUwsS0FBc0I2QyxRQUF0QixHQUFpQyxLQUFyRDs7QUFDQSxXQUFJLENBQUNyRixlQUFMLENBQXFCMEYsWUFBckIsQ0FBa0N6UCxNQUFsQztBQUNELEtBSkQ7QUFLQSxXQUFPaEIsTUFBUDtBQUNELEdBUEQsQ0E3Q2EsQ0FzRGI7OztBQUNBLE9BQUtqTyxHQUFMLENBQVMyZSxNQUFULENBQWdCO0FBQUVULElBQUFBLFVBQVUsRUFBRTtBQUFkLEdBQWhCO0FBQ0EsT0FBS2plLElBQUwsQ0FBVTBlLE1BQVYsQ0FBaUI7QUFBRVQsSUFBQUEsVUFBVSxFQUFFO0FBQWQsR0FBakI7QUFDQSxPQUFLemEsWUFBTCxDQUFrQmtiLE1BQWxCLENBQXlCO0FBQUVULElBQUFBLFVBQVUsRUFBRTtBQUFkLEdBQXpCO0FBQ0EsT0FBS3hhLFlBQUwsQ0FBa0JpYixNQUFsQixDQUF5QjtBQUFFVCxJQUFBQSxVQUFVLEVBQUU7QUFBZCxHQUF6QjtBQUNBLE9BQUtVLFFBQUwsQ0FBY0QsTUFBZCxDQUFxQjtBQUFFVCxJQUFBQSxVQUFVLEVBQUU7QUFBZCxHQUFyQjtBQUNBLE9BQUtoRyxXQUFMLENBQWlCeUcsTUFBakIsQ0FBd0I7QUFBRUgsSUFBQUEsYUFBYSxFQUFFO0FBQWpCLEdBQXhCO0FBQ0EsT0FBS3ZHLE9BQUwsQ0FBYTBHLE1BQWIsQ0FBb0I7QUFBRUYsSUFBQUEsYUFBYSxFQUFFO0FBQWpCLEdBQXBCO0FBQ0EsT0FBS2xELFFBQUwsQ0FBY29ELE1BQWQsQ0FBcUI7QUFBRVQsSUFBQUEsVUFBVSxFQUFFO0FBQWQsR0FBckI7QUFDQSxPQUFLNU8saUJBQUwsQ0FBdUJxUCxNQUF2QixDQUE4QjtBQUFFVCxJQUFBQSxVQUFVLEVBQUU7QUFBZCxHQUE5QjtBQUNBLE9BQUszSSxNQUFMLENBQVlvSixNQUFaLENBQW1CO0FBQUVULElBQUFBLFVBQVUsRUFBRTtBQUFkLEdBQW5CLEVBQTZDUyxNQUE3QyxDQUFvRDtBQUFFM0osSUFBQUEsU0FBUyxFQUFFO0FBQWIsR0FBcEQ7QUFDQSxPQUFLMEcsV0FBTCxDQUFpQmlELE1BQWpCLENBQXdCO0FBQUVULElBQUFBLFVBQVUsRUFBRTtBQUFkLEdBQXhCLEVBQXVEUyxNQUF2RCxDQUE4RDtBQUFFeEwsSUFBQUEsY0FBYyxFQUFFO0FBQWxCLEdBQTlEO0FBQ0EsT0FBS3NJLFNBQUwsQ0FBZWtELE1BQWYsQ0FBc0I7QUFBRVQsSUFBQUEsVUFBVSxFQUFFO0FBQWQsR0FBdEIsRUFBbURTLE1BQW5ELENBQTBEO0FBQUVELElBQUFBLFlBQVksRUFBRTtBQUFoQixHQUExRDtBQUNBLE9BQUtuSSxPQUFMLENBQWFvSSxNQUFiLENBQW9CO0FBQUVULElBQUFBLFVBQVUsRUFBRTtBQUFkLEdBQXBCO0FBQ0EsT0FBS3RILFFBQUwsQ0FBYytILE1BQWQsQ0FBcUI7QUFBRVQsSUFBQUEsVUFBVSxFQUFFO0FBQWQsR0FBckIsRUFwRWEsQ0FzRWI7O0FBQ0EsT0FBSy9GLE9BQUwsQ0FBYSxLQUFLRCxXQUFMLEVBQWI7QUFFQS9OLEVBQUFBLCtFQUFBLENBQW9DQyxpREFBcEMsRUFBd0MsSUFBeEMsRUF6RWEsQ0EyRWI7O0FBQ0EsTUFBSSxLQUFLMFUsa0JBQUwsQ0FBd0IsWUFBeEIsQ0FBSixFQUEyQztBQUN6Qyw2S0FBOEJyYyxJQUE5QixDQUFtQyxnQkFBaUM7QUFBQSxVQUFyQnNjLGNBQXFCO0FBQ2xFQSxNQUFBQSxjQUFjLENBQUNDLGNBQWYsQ0FBOEI1VSxpREFBOUIsRUFBa0MsS0FBbEMsRUFEa0UsQ0FFbEU7O0FBQ0EsV0FBSSxDQUFDNlUsVUFBTCxDQUFnQixJQUFoQixFQUhrRSxDQUlsRTtBQUNBO0FBQ0E7OztBQUNBLFdBQUksQ0FBQ0MsV0FBTDtBQUNELEtBUkQ7QUFTRCxHQXRGWSxDQXdGYjs7O0FBQ0EsTUFBSSxLQUFLSixrQkFBTCxDQUF3QixjQUF4QixDQUFKLEVBQTZDO0FBQzNDLFNBQUt0RCxZQUFMLENBQWtCLElBQWxCO0FBQ0Q7O0FBRUQsT0FBSzBELFdBQUwsR0E3RmEsQ0ErRmI7O0FBQ0EsT0FBS3RULGtCQUFMO0FBQ0QsSUE0aEJIOzs7QUFDQXhCLDZEQUFBLENBQWlCLElBQUk0TCxjQUFKLEVBQWpCLEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2NyZWF0ZVBvcHBlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9jb250YWlucy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q2xpcHBpbmdSZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldENvbXBvc2l0ZVJlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q29tcHV0ZWRTdHlsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXREb2N1bWVudEVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRSZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldEhUTUxFbGVtZW50U2Nyb2xsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldExheW91dFJlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Tm9kZU5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Tm9kZVNjcm9sbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0UGFyZW50Tm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRTY3JvbGxQYXJlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Vmlld3BvcnRSZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFdpbmRvdy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3dTY3JvbGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93U2Nyb2xsQmFyWC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2lzU2Nyb2xsUGFyZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2lzVGFibGVFbGVtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2xpc3RTY3JvbGxQYXJlbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZW51bXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9hcHBseVN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9hcnJvdy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9jb21wdXRlU3R5bGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2V2ZW50TGlzdGVuZXJzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2ZsaXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvaGlkZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9vZmZzZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9wcmV2ZW50T3ZlcmZsb3cuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9wb3BwZXItbGl0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3BvcHBlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2NvbXB1dGVBdXRvUGxhY2VtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvY29tcHV0ZU9mZnNldHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9kZWJvdW5jZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZXhwYW5kVG9IYXNoTWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZm9ybWF0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0QWx0QXhpcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRGcmVzaFNpZGVPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRPcHBvc2l0ZVBsYWNlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0VmFyaWF0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWF0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21lcmdlQnlOYW1lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWVyZ2VQYWRkaW5nT2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvb3JkZXJNb2RpZmllcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9yZWN0VG9DbGllbnRSZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvdW5pcXVlQnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy92YWxpZGF0ZU1vZGlmaWVycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3dpdGhpbi5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9yc2UtcHJvL21vcnNlLXByby1jdy13YXZlLmpzIiwid2VicGFjazovLy8uL3NyYy9tb3JzZS1wcm8vbW9yc2UtcHJvLWN3LmpzIiwid2VicGFjazovLy8uL3NyYy9tb3JzZS1wcm8vbW9yc2UtcHJvLW1lc3NhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vcnNlLXByby9tb3JzZS1wcm8tdXRpbC1yaWZmd2F2ZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9yc2UtcHJvL21vcnNlLXByby13cG0uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vcnNlLXByby9tb3JzZS1wcm8uanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vcnNlTGVzc29uUGx1Z2luLmpzIiwid2VicGFjazovLy8uL3NyYy9tb3JzZUxvYWRJbWFnZXMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vcnNlU3RyaW5nVG9XYXZCdWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vcnNlU3RyaW5nVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vcnNlVGltaW5nQ2FsY3VsYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9yc2VXYXZCdWZmZXJQbGF5ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vcnNlV29yZFBsYXllci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL2Rpc3QvanMvYm9vdHN0cmFwLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMva25vY2tvdXQvYnVpbGQvb3V0cHV0L2tub2Nrb3V0LWxhdGVzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL2Rpc3QvY3NzL2Jvb3RzdHJhcC5taW4uY3NzP2UzZDciLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pzLWNvb2tpZS9kaXN0L2pzLmNvb2tpZS5tanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovLy93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly8vd2VicGFjay9ydW50aW1lL2NyZWF0ZSBmYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly8vd2VicGFjay9ydW50aW1lL2Vuc3VyZSBjaHVuayIsIndlYnBhY2s6Ly8vd2VicGFjay9ydW50aW1lL2dldCBqYXZhc2NyaXB0IGNodW5rIGZpbGVuYW1lIiwid2VicGFjazovLy93ZWJwYWNrL3J1bnRpbWUvZ2V0IG1pbmktY3NzIGNodW5rIGZpbGVuYW1lIiwid2VicGFjazovLy93ZWJwYWNrL3J1bnRpbWUvZ2xvYmFsIiwid2VicGFjazovLy93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovLy93ZWJwYWNrL3J1bnRpbWUvbG9hZCBzY3JpcHQiLCJ3ZWJwYWNrOi8vL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vL3dlYnBhY2svcnVudGltZS9ub2RlIG1vZHVsZSBkZWNvcmF0b3IiLCJ3ZWJwYWNrOi8vL3dlYnBhY2svcnVudGltZS9wdWJsaWNQYXRoIiwid2VicGFjazovLy93ZWJwYWNrL3J1bnRpbWUvanNvbnAgY2h1bmsgbG9hZGluZyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9yc2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGdldENvbXBvc2l0ZVJlY3QgZnJvbSBcIi4vZG9tLXV0aWxzL2dldENvbXBvc2l0ZVJlY3QuanNcIjtcbmltcG9ydCBnZXRMYXlvdXRSZWN0IGZyb20gXCIuL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzXCI7XG5pbXBvcnQgbGlzdFNjcm9sbFBhcmVudHMgZnJvbSBcIi4vZG9tLXV0aWxzL2xpc3RTY3JvbGxQYXJlbnRzLmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuL2RvbS11dGlscy9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgb3JkZXJNb2RpZmllcnMgZnJvbSBcIi4vdXRpbHMvb3JkZXJNb2RpZmllcnMuanNcIjtcbmltcG9ydCBkZWJvdW5jZSBmcm9tIFwiLi91dGlscy9kZWJvdW5jZS5qc1wiO1xuaW1wb3J0IHZhbGlkYXRlTW9kaWZpZXJzIGZyb20gXCIuL3V0aWxzL3ZhbGlkYXRlTW9kaWZpZXJzLmpzXCI7XG5pbXBvcnQgdW5pcXVlQnkgZnJvbSBcIi4vdXRpbHMvdW5pcXVlQnkuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBtZXJnZUJ5TmFtZSBmcm9tIFwiLi91dGlscy9tZXJnZUJ5TmFtZS5qc1wiO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gXCIuL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXCI7XG5pbXBvcnQgeyBpc0VsZW1lbnQgfSBmcm9tIFwiLi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IHsgYXV0byB9IGZyb20gXCIuL2VudW1zLmpzXCI7XG52YXIgSU5WQUxJRF9FTEVNRU5UX0VSUk9SID0gJ1BvcHBlcjogSW52YWxpZCByZWZlcmVuY2Ugb3IgcG9wcGVyIGFyZ3VtZW50IHByb3ZpZGVkLiBUaGV5IG11c3QgYmUgZWl0aGVyIGEgRE9NIGVsZW1lbnQgb3IgdmlydHVhbCBlbGVtZW50Lic7XG52YXIgSU5GSU5JVEVfTE9PUF9FUlJPUiA9ICdQb3BwZXI6IEFuIGluZmluaXRlIGxvb3AgaW4gdGhlIG1vZGlmaWVycyBjeWNsZSBoYXMgYmVlbiBkZXRlY3RlZCEgVGhlIGN5Y2xlIGhhcyBiZWVuIGludGVycnVwdGVkIHRvIHByZXZlbnQgYSBicm93c2VyIGNyYXNoLic7XG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuICBtb2RpZmllcnM6IFtdLFxuICBzdHJhdGVneTogJ2Fic29sdXRlJ1xufTtcblxuZnVuY3Rpb24gYXJlVmFsaWRFbGVtZW50cygpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiAhYXJncy5zb21lKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgcmV0dXJuICEoZWxlbWVudCAmJiB0eXBlb2YgZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgPT09ICdmdW5jdGlvbicpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvcHBlckdlbmVyYXRvcihnZW5lcmF0b3JPcHRpb25zKSB7XG4gIGlmIChnZW5lcmF0b3JPcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBnZW5lcmF0b3JPcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgX2dlbmVyYXRvck9wdGlvbnMgPSBnZW5lcmF0b3JPcHRpb25zLFxuICAgICAgX2dlbmVyYXRvck9wdGlvbnMkZGVmID0gX2dlbmVyYXRvck9wdGlvbnMuZGVmYXVsdE1vZGlmaWVycyxcbiAgICAgIGRlZmF1bHRNb2RpZmllcnMgPSBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYgPT09IHZvaWQgMCA/IFtdIDogX2dlbmVyYXRvck9wdGlvbnMkZGVmLFxuICAgICAgX2dlbmVyYXRvck9wdGlvbnMkZGVmMiA9IF9nZW5lcmF0b3JPcHRpb25zLmRlZmF1bHRPcHRpb25zLFxuICAgICAgZGVmYXVsdE9wdGlvbnMgPSBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyID09PSB2b2lkIDAgPyBERUZBVUxUX09QVElPTlMgOiBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyO1xuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlUG9wcGVyKHJlZmVyZW5jZSwgcG9wcGVyLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xuICAgIH1cblxuICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgIHBsYWNlbWVudDogJ2JvdHRvbScsXG4gICAgICBvcmRlcmVkTW9kaWZpZXJzOiBbXSxcbiAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgZGVmYXVsdE9wdGlvbnMpLFxuICAgICAgbW9kaWZpZXJzRGF0YToge30sXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICByZWZlcmVuY2U6IHJlZmVyZW5jZSxcbiAgICAgICAgcG9wcGVyOiBwb3BwZXJcbiAgICAgIH0sXG4gICAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICAgIHN0eWxlczoge31cbiAgICB9O1xuICAgIHZhciBlZmZlY3RDbGVhbnVwRm5zID0gW107XG4gICAgdmFyIGlzRGVzdHJveWVkID0gZmFsc2U7XG4gICAgdmFyIGluc3RhbmNlID0ge1xuICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgc2V0T3B0aW9uczogZnVuY3Rpb24gc2V0T3B0aW9ucyhzZXRPcHRpb25zQWN0aW9uKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdHlwZW9mIHNldE9wdGlvbnNBY3Rpb24gPT09ICdmdW5jdGlvbicgPyBzZXRPcHRpb25zQWN0aW9uKHN0YXRlLm9wdGlvbnMpIDogc2V0T3B0aW9uc0FjdGlvbjtcbiAgICAgICAgY2xlYW51cE1vZGlmaWVyRWZmZWN0cygpO1xuICAgICAgICBzdGF0ZS5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIHN0YXRlLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICBzdGF0ZS5zY3JvbGxQYXJlbnRzID0ge1xuICAgICAgICAgIHJlZmVyZW5jZTogaXNFbGVtZW50KHJlZmVyZW5jZSkgPyBsaXN0U2Nyb2xsUGFyZW50cyhyZWZlcmVuY2UpIDogcmVmZXJlbmNlLmNvbnRleHRFbGVtZW50ID8gbGlzdFNjcm9sbFBhcmVudHMocmVmZXJlbmNlLmNvbnRleHRFbGVtZW50KSA6IFtdLFxuICAgICAgICAgIHBvcHBlcjogbGlzdFNjcm9sbFBhcmVudHMocG9wcGVyKVxuICAgICAgICB9OyAvLyBPcmRlcnMgdGhlIG1vZGlmaWVycyBiYXNlZCBvbiB0aGVpciBkZXBlbmRlbmNpZXMgYW5kIGBwaGFzZWBcbiAgICAgICAgLy8gcHJvcGVydGllc1xuXG4gICAgICAgIHZhciBvcmRlcmVkTW9kaWZpZXJzID0gb3JkZXJNb2RpZmllcnMobWVyZ2VCeU5hbWUoW10uY29uY2F0KGRlZmF1bHRNb2RpZmllcnMsIHN0YXRlLm9wdGlvbnMubW9kaWZpZXJzKSkpOyAvLyBTdHJpcCBvdXQgZGlzYWJsZWQgbW9kaWZpZXJzXG5cbiAgICAgICAgc3RhdGUub3JkZXJlZE1vZGlmaWVycyA9IG9yZGVyZWRNb2RpZmllcnMuZmlsdGVyKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgcmV0dXJuIG0uZW5hYmxlZDtcbiAgICAgICAgfSk7IC8vIFZhbGlkYXRlIHRoZSBwcm92aWRlZCBtb2RpZmllcnMgc28gdGhhdCB0aGUgY29uc3VtZXIgd2lsbCBnZXQgd2FybmVkXG4gICAgICAgIC8vIGlmIG9uZSBvZiB0aGUgbW9kaWZpZXJzIGlzIGludmFsaWQgZm9yIGFueSByZWFzb25cblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgdmFyIG1vZGlmaWVycyA9IHVuaXF1ZUJ5KFtdLmNvbmNhdChvcmRlcmVkTW9kaWZpZXJzLCBzdGF0ZS5vcHRpb25zLm1vZGlmaWVycyksIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IF9yZWYubmFtZTtcbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhbGlkYXRlTW9kaWZpZXJzKG1vZGlmaWVycyk7XG5cbiAgICAgICAgICBpZiAoZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5vcHRpb25zLnBsYWNlbWVudCkgPT09IGF1dG8pIHtcbiAgICAgICAgICAgIHZhciBmbGlwTW9kaWZpZXIgPSBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmZpbmQoZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICAgICAgICAgIHZhciBuYW1lID0gX3JlZjIubmFtZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5hbWUgPT09ICdmbGlwJztcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIWZsaXBNb2RpZmllcikge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFsnUG9wcGVyOiBcImF1dG9cIiBwbGFjZW1lbnRzIHJlcXVpcmUgdGhlIFwiZmxpcFwiIG1vZGlmaWVyIGJlJywgJ3ByZXNlbnQgYW5kIGVuYWJsZWQgdG8gd29yay4nXS5qb2luKCcgJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfZ2V0Q29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUocG9wcGVyKSxcbiAgICAgICAgICAgICAgbWFyZ2luVG9wID0gX2dldENvbXB1dGVkU3R5bGUubWFyZ2luVG9wLFxuICAgICAgICAgICAgICBtYXJnaW5SaWdodCA9IF9nZXRDb21wdXRlZFN0eWxlLm1hcmdpblJpZ2h0LFxuICAgICAgICAgICAgICBtYXJnaW5Cb3R0b20gPSBfZ2V0Q29tcHV0ZWRTdHlsZS5tYXJnaW5Cb3R0b20sXG4gICAgICAgICAgICAgIG1hcmdpbkxlZnQgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5tYXJnaW5MZWZ0OyAvLyBXZSBubyBsb25nZXIgdGFrZSBpbnRvIGFjY291bnQgYG1hcmdpbnNgIG9uIHRoZSBwb3BwZXIsIGFuZCBpdCBjYW5cbiAgICAgICAgICAvLyBjYXVzZSBidWdzIHdpdGggcG9zaXRpb25pbmcsIHNvIHdlJ2xsIHdhcm4gdGhlIGNvbnN1bWVyXG5cblxuICAgICAgICAgIGlmIChbbWFyZ2luVG9wLCBtYXJnaW5SaWdodCwgbWFyZ2luQm90dG9tLCBtYXJnaW5MZWZ0XS5zb21lKGZ1bmN0aW9uIChtYXJnaW4pIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KG1hcmdpbik7XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihbJ1BvcHBlcjogQ1NTIFwibWFyZ2luXCIgc3R5bGVzIGNhbm5vdCBiZSB1c2VkIHRvIGFwcGx5IHBhZGRpbmcnLCAnYmV0d2VlbiB0aGUgcG9wcGVyIGFuZCBpdHMgcmVmZXJlbmNlIGVsZW1lbnQgb3IgYm91bmRhcnkuJywgJ1RvIHJlcGxpY2F0ZSBtYXJnaW4sIHVzZSB0aGUgYG9mZnNldGAgbW9kaWZpZXIsIGFzIHdlbGwgYXMnLCAndGhlIGBwYWRkaW5nYCBvcHRpb24gaW4gdGhlIGBwcmV2ZW50T3ZlcmZsb3dgIGFuZCBgZmxpcGAnLCAnbW9kaWZpZXJzLiddLmpvaW4oJyAnKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcnVuTW9kaWZpZXJFZmZlY3RzKCk7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZS51cGRhdGUoKTtcbiAgICAgIH0sXG4gICAgICAvLyBTeW5jIHVwZGF0ZSDigJMgaXQgd2lsbCBhbHdheXMgYmUgZXhlY3V0ZWQsIGV2ZW4gaWYgbm90IG5lY2Vzc2FyeS4gVGhpc1xuICAgICAgLy8gaXMgdXNlZnVsIGZvciBsb3cgZnJlcXVlbmN5IHVwZGF0ZXMgd2hlcmUgc3luYyBiZWhhdmlvciBzaW1wbGlmaWVzIHRoZVxuICAgICAgLy8gbG9naWMuXG4gICAgICAvLyBGb3IgaGlnaCBmcmVxdWVuY3kgdXBkYXRlcyAoZS5nLiBgcmVzaXplYCBhbmQgYHNjcm9sbGAgZXZlbnRzKSwgYWx3YXlzXG4gICAgICAvLyBwcmVmZXIgdGhlIGFzeW5jIFBvcHBlciN1cGRhdGUgbWV0aG9kXG4gICAgICBmb3JjZVVwZGF0ZTogZnVuY3Rpb24gZm9yY2VVcGRhdGUoKSB7XG4gICAgICAgIGlmIChpc0Rlc3Ryb3llZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfc3RhdGUkZWxlbWVudHMgPSBzdGF0ZS5lbGVtZW50cyxcbiAgICAgICAgICAgIHJlZmVyZW5jZSA9IF9zdGF0ZSRlbGVtZW50cy5yZWZlcmVuY2UsXG4gICAgICAgICAgICBwb3BwZXIgPSBfc3RhdGUkZWxlbWVudHMucG9wcGVyOyAvLyBEb24ndCBwcm9jZWVkIGlmIGByZWZlcmVuY2VgIG9yIGBwb3BwZXJgIGFyZSBub3QgdmFsaWQgZWxlbWVudHNcbiAgICAgICAgLy8gYW55bW9yZVxuXG4gICAgICAgIGlmICghYXJlVmFsaWRFbGVtZW50cyhyZWZlcmVuY2UsIHBvcHBlcikpIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKElOVkFMSURfRUxFTUVOVF9FUlJPUik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIFN0b3JlIHRoZSByZWZlcmVuY2UgYW5kIHBvcHBlciByZWN0cyB0byBiZSByZWFkIGJ5IG1vZGlmaWVyc1xuXG5cbiAgICAgICAgc3RhdGUucmVjdHMgPSB7XG4gICAgICAgICAgcmVmZXJlbmNlOiBnZXRDb21wb3NpdGVSZWN0KHJlZmVyZW5jZSwgZ2V0T2Zmc2V0UGFyZW50KHBvcHBlciksIHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3kgPT09ICdmaXhlZCcpLFxuICAgICAgICAgIHBvcHBlcjogZ2V0TGF5b3V0UmVjdChwb3BwZXIpXG4gICAgICAgIH07IC8vIE1vZGlmaWVycyBoYXZlIHRoZSBhYmlsaXR5IHRvIHJlc2V0IHRoZSBjdXJyZW50IHVwZGF0ZSBjeWNsZS4gVGhlXG4gICAgICAgIC8vIG1vc3QgY29tbW9uIHVzZSBjYXNlIGZvciB0aGlzIGlzIHRoZSBgZmxpcGAgbW9kaWZpZXIgY2hhbmdpbmcgdGhlXG4gICAgICAgIC8vIHBsYWNlbWVudCwgd2hpY2ggdGhlbiBuZWVkcyB0byByZS1ydW4gYWxsIHRoZSBtb2RpZmllcnMsIGJlY2F1c2UgdGhlXG4gICAgICAgIC8vIGxvZ2ljIHdhcyBwcmV2aW91c2x5IHJhbiBmb3IgdGhlIHByZXZpb3VzIHBsYWNlbWVudCBhbmQgaXMgdGhlcmVmb3JlXG4gICAgICAgIC8vIHN0YWxlL2luY29ycmVjdFxuXG4gICAgICAgIHN0YXRlLnJlc2V0ID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLnBsYWNlbWVudCA9IHN0YXRlLm9wdGlvbnMucGxhY2VtZW50OyAvLyBPbiBlYWNoIHVwZGF0ZSBjeWNsZSwgdGhlIGBtb2RpZmllcnNEYXRhYCBwcm9wZXJ0eSBmb3IgZWFjaCBtb2RpZmllclxuICAgICAgICAvLyBpcyBmaWxsZWQgd2l0aCB0aGUgaW5pdGlhbCBkYXRhIHNwZWNpZmllZCBieSB0aGUgbW9kaWZpZXIuIFRoaXMgbWVhbnNcbiAgICAgICAgLy8gaXQgZG9lc24ndCBwZXJzaXN0IGFuZCBpcyBmcmVzaCBvbiBlYWNoIHVwZGF0ZS5cbiAgICAgICAgLy8gVG8gZW5zdXJlIHBlcnNpc3RlbnQgZGF0YSwgdXNlIGAke25hbWV9I3BlcnNpc3RlbnRgXG5cbiAgICAgICAgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgICAgICAgIHJldHVybiBzdGF0ZS5tb2RpZmllcnNEYXRhW21vZGlmaWVyLm5hbWVdID0gT2JqZWN0LmFzc2lnbih7fSwgbW9kaWZpZXIuZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgX19kZWJ1Z19sb29wc19fID0gMDtcblxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBfX2RlYnVnX2xvb3BzX18gKz0gMTtcblxuICAgICAgICAgICAgaWYgKF9fZGVidWdfbG9vcHNfXyA+IDEwMCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKElORklOSVRFX0xPT1BfRVJST1IpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3RhdGUucmVzZXQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHN0YXRlLnJlc2V0ID0gZmFsc2U7XG4gICAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9zdGF0ZSRvcmRlcmVkTW9kaWZpZSA9IHN0YXRlLm9yZGVyZWRNb2RpZmllcnNbaW5kZXhdLFxuICAgICAgICAgICAgICBmbiA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZS5mbixcbiAgICAgICAgICAgICAgX3N0YXRlJG9yZGVyZWRNb2RpZmllMiA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZS5vcHRpb25zLFxuICAgICAgICAgICAgICBfb3B0aW9ucyA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIgPT09IHZvaWQgMCA/IHt9IDogX3N0YXRlJG9yZGVyZWRNb2RpZmllMixcbiAgICAgICAgICAgICAgbmFtZSA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZS5uYW1lO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc3RhdGUgPSBmbih7XG4gICAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgICAgb3B0aW9uczogX29wdGlvbnMsXG4gICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgIGluc3RhbmNlOiBpbnN0YW5jZVxuICAgICAgICAgICAgfSkgfHwgc3RhdGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gQXN5bmMgYW5kIG9wdGltaXN0aWNhbGx5IG9wdGltaXplZCB1cGRhdGUg4oCTIGl0IHdpbGwgbm90IGJlIGV4ZWN1dGVkIGlmXG4gICAgICAvLyBub3QgbmVjZXNzYXJ5IChkZWJvdW5jZWQgdG8gcnVuIGF0IG1vc3Qgb25jZS1wZXItdGljaylcbiAgICAgIHVwZGF0ZTogZGVib3VuY2UoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICBpbnN0YW5jZS5mb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgIHJlc29sdmUoc3RhdGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pLFxuICAgICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgY2xlYW51cE1vZGlmaWVyRWZmZWN0cygpO1xuICAgICAgICBpc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmICghYXJlVmFsaWRFbGVtZW50cyhyZWZlcmVuY2UsIHBvcHBlcikpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihJTlZBTElEX0VMRU1FTlRfRVJST1IpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgaWYgKCFpc0Rlc3Ryb3llZCAmJiBvcHRpb25zLm9uRmlyc3RVcGRhdGUpIHtcbiAgICAgICAgb3B0aW9ucy5vbkZpcnN0VXBkYXRlKHN0YXRlKTtcbiAgICAgIH1cbiAgICB9KTsgLy8gTW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gZXhlY3V0ZSBhcmJpdHJhcnkgY29kZSBiZWZvcmUgdGhlIGZpcnN0XG4gICAgLy8gdXBkYXRlIGN5Y2xlIHJ1bnMuIFRoZXkgd2lsbCBiZSBleGVjdXRlZCBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGUgdXBkYXRlXG4gICAgLy8gY3ljbGUuIFRoaXMgaXMgdXNlZnVsIHdoZW4gYSBtb2RpZmllciBhZGRzIHNvbWUgcGVyc2lzdGVudCBkYXRhIHRoYXRcbiAgICAvLyBvdGhlciBtb2RpZmllcnMgbmVlZCB0byB1c2UsIGJ1dCB0aGUgbW9kaWZpZXIgaXMgcnVuIGFmdGVyIHRoZSBkZXBlbmRlbnRcbiAgICAvLyBvbmUuXG5cbiAgICBmdW5jdGlvbiBydW5Nb2RpZmllckVmZmVjdHMoKSB7XG4gICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgICAgIHZhciBuYW1lID0gX3JlZjMubmFtZSxcbiAgICAgICAgICAgIF9yZWYzJG9wdGlvbnMgPSBfcmVmMy5vcHRpb25zLFxuICAgICAgICAgICAgb3B0aW9ucyA9IF9yZWYzJG9wdGlvbnMgPT09IHZvaWQgMCA/IHt9IDogX3JlZjMkb3B0aW9ucyxcbiAgICAgICAgICAgIGVmZmVjdCA9IF9yZWYzLmVmZmVjdDtcblxuICAgICAgICBpZiAodHlwZW9mIGVmZmVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciBjbGVhbnVwRm4gPSBlZmZlY3Qoe1xuICAgICAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIGluc3RhbmNlOiBpbnN0YW5jZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBub29wRm4gPSBmdW5jdGlvbiBub29wRm4oKSB7fTtcblxuICAgICAgICAgIGVmZmVjdENsZWFudXBGbnMucHVzaChjbGVhbnVwRm4gfHwgbm9vcEZuKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYW51cE1vZGlmaWVyRWZmZWN0cygpIHtcbiAgICAgIGVmZmVjdENsZWFudXBGbnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICB9KTtcbiAgICAgIGVmZmVjdENsZWFudXBGbnMgPSBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH07XG59XG5leHBvcnQgdmFyIGNyZWF0ZVBvcHBlciA9IC8qI19fUFVSRV9fKi9wb3BwZXJHZW5lcmF0b3IoKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgeyBkZXRlY3RPdmVyZmxvdyB9OyIsImltcG9ydCB7IGlzU2hhZG93Um9vdCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbnRhaW5zKHBhcmVudCwgY2hpbGQpIHtcbiAgdmFyIHJvb3ROb2RlID0gY2hpbGQuZ2V0Um9vdE5vZGUgJiYgY2hpbGQuZ2V0Um9vdE5vZGUoKTsgLy8gRmlyc3QsIGF0dGVtcHQgd2l0aCBmYXN0ZXIgbmF0aXZlIG1ldGhvZFxuXG4gIGlmIChwYXJlbnQuY29udGFpbnMoY2hpbGQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gdGhlbiBmYWxsYmFjayB0byBjdXN0b20gaW1wbGVtZW50YXRpb24gd2l0aCBTaGFkb3cgRE9NIHN1cHBvcnRcbiAgZWxzZSBpZiAocm9vdE5vZGUgJiYgaXNTaGFkb3dSb290KHJvb3ROb2RlKSkge1xuICAgICAgdmFyIG5leHQgPSBjaGlsZDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAobmV4dCAmJiBwYXJlbnQuaXNTYW1lTm9kZShuZXh0KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXTogbmVlZCBhIGJldHRlciB3YXkgdG8gaGFuZGxlIHRoaXMuLi5cblxuXG4gICAgICAgIG5leHQgPSBuZXh0LnBhcmVudE5vZGUgfHwgbmV4dC5ob3N0O1xuICAgICAgfSB3aGlsZSAobmV4dCk7XG4gICAgfSAvLyBHaXZlIHVwLCB0aGUgcmVzdWx0IGlzIGZhbHNlXG5cblxuICByZXR1cm4gZmFsc2U7XG59IiwiaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCB7IHJvdW5kIH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBpbmNsdWRlU2NhbGUpIHtcbiAgaWYgKGluY2x1ZGVTY2FsZSA9PT0gdm9pZCAwKSB7XG4gICAgaW5jbHVkZVNjYWxlID0gZmFsc2U7XG4gIH1cblxuICB2YXIgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciBzY2FsZVggPSAxO1xuICB2YXIgc2NhbGVZID0gMTtcblxuICBpZiAoaXNIVE1MRWxlbWVudChlbGVtZW50KSAmJiBpbmNsdWRlU2NhbGUpIHtcbiAgICB2YXIgb2Zmc2V0SGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgdmFyIG9mZnNldFdpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aDsgLy8gRG8gbm90IGF0dGVtcHQgdG8gZGl2aWRlIGJ5IDAsIG90aGVyd2lzZSB3ZSBnZXQgYEluZmluaXR5YCBhcyBzY2FsZVxuICAgIC8vIEZhbGxiYWNrIHRvIDEgaW4gY2FzZSBib3RoIHZhbHVlcyBhcmUgYDBgXG5cbiAgICBpZiAob2Zmc2V0V2lkdGggPiAwKSB7XG4gICAgICBzY2FsZVggPSByb3VuZChyZWN0LndpZHRoKSAvIG9mZnNldFdpZHRoIHx8IDE7XG4gICAgfVxuXG4gICAgaWYgKG9mZnNldEhlaWdodCA+IDApIHtcbiAgICAgIHNjYWxlWSA9IHJvdW5kKHJlY3QuaGVpZ2h0KSAvIG9mZnNldEhlaWdodCB8fCAxO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHJlY3Qud2lkdGggLyBzY2FsZVgsXG4gICAgaGVpZ2h0OiByZWN0LmhlaWdodCAvIHNjYWxlWSxcbiAgICB0b3A6IHJlY3QudG9wIC8gc2NhbGVZLFxuICAgIHJpZ2h0OiByZWN0LnJpZ2h0IC8gc2NhbGVYLFxuICAgIGJvdHRvbTogcmVjdC5ib3R0b20gLyBzY2FsZVksXG4gICAgbGVmdDogcmVjdC5sZWZ0IC8gc2NhbGVYLFxuICAgIHg6IHJlY3QubGVmdCAvIHNjYWxlWCxcbiAgICB5OiByZWN0LnRvcCAvIHNjYWxlWVxuICB9O1xufSIsImltcG9ydCB7IHZpZXdwb3J0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0Vmlld3BvcnRSZWN0IGZyb20gXCIuL2dldFZpZXdwb3J0UmVjdC5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50UmVjdCBmcm9tIFwiLi9nZXREb2N1bWVudFJlY3QuanNcIjtcbmltcG9ydCBsaXN0U2Nyb2xsUGFyZW50cyBmcm9tIFwiLi9saXN0U2Nyb2xsUGFyZW50cy5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgeyBpc0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSBcIi4vZ2V0UGFyZW50Tm9kZS5qc1wiO1xuaW1wb3J0IGNvbnRhaW5zIGZyb20gXCIuL2NvbnRhaW5zLmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCByZWN0VG9DbGllbnRSZWN0IGZyb20gXCIuLi91dGlscy9yZWN0VG9DbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgeyBtYXgsIG1pbiB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7XG5cbmZ1bmN0aW9uIGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCk7XG4gIHJlY3QudG9wID0gcmVjdC50b3AgKyBlbGVtZW50LmNsaWVudFRvcDtcbiAgcmVjdC5sZWZ0ID0gcmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRMZWZ0O1xuICByZWN0LmJvdHRvbSA9IHJlY3QudG9wICsgZWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gIHJlY3QucmlnaHQgPSByZWN0LmxlZnQgKyBlbGVtZW50LmNsaWVudFdpZHRoO1xuICByZWN0LndpZHRoID0gZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgcmVjdC5oZWlnaHQgPSBlbGVtZW50LmNsaWVudEhlaWdodDtcbiAgcmVjdC54ID0gcmVjdC5sZWZ0O1xuICByZWN0LnkgPSByZWN0LnRvcDtcbiAgcmV0dXJuIHJlY3Q7XG59XG5cbmZ1bmN0aW9uIGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGNsaXBwaW5nUGFyZW50KSB7XG4gIHJldHVybiBjbGlwcGluZ1BhcmVudCA9PT0gdmlld3BvcnQgPyByZWN0VG9DbGllbnRSZWN0KGdldFZpZXdwb3J0UmVjdChlbGVtZW50KSkgOiBpc0VsZW1lbnQoY2xpcHBpbmdQYXJlbnQpID8gZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QoY2xpcHBpbmdQYXJlbnQpIDogcmVjdFRvQ2xpZW50UmVjdChnZXREb2N1bWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKSk7XG59IC8vIEEgXCJjbGlwcGluZyBwYXJlbnRcIiBpcyBhbiBvdmVyZmxvd2FibGUgY29udGFpbmVyIHdpdGggdGhlIGNoYXJhY3RlcmlzdGljIG9mXG4vLyBjbGlwcGluZyAob3IgaGlkaW5nKSBvdmVyZmxvd2luZyBlbGVtZW50cyB3aXRoIGEgcG9zaXRpb24gZGlmZmVyZW50IGZyb21cbi8vIGBpbml0aWFsYFxuXG5cbmZ1bmN0aW9uIGdldENsaXBwaW5nUGFyZW50cyhlbGVtZW50KSB7XG4gIHZhciBjbGlwcGluZ1BhcmVudHMgPSBsaXN0U2Nyb2xsUGFyZW50cyhnZXRQYXJlbnROb2RlKGVsZW1lbnQpKTtcbiAgdmFyIGNhbkVzY2FwZUNsaXBwaW5nID0gWydhYnNvbHV0ZScsICdmaXhlZCddLmluZGV4T2YoZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbikgPj0gMDtcbiAgdmFyIGNsaXBwZXJFbGVtZW50ID0gY2FuRXNjYXBlQ2xpcHBpbmcgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSA/IGdldE9mZnNldFBhcmVudChlbGVtZW50KSA6IGVsZW1lbnQ7XG5cbiAgaWYgKCFpc0VsZW1lbnQoY2xpcHBlckVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8xNDE0XG5cblxuICByZXR1cm4gY2xpcHBpbmdQYXJlbnRzLmZpbHRlcihmdW5jdGlvbiAoY2xpcHBpbmdQYXJlbnQpIHtcbiAgICByZXR1cm4gaXNFbGVtZW50KGNsaXBwaW5nUGFyZW50KSAmJiBjb250YWlucyhjbGlwcGluZ1BhcmVudCwgY2xpcHBlckVsZW1lbnQpICYmIGdldE5vZGVOYW1lKGNsaXBwaW5nUGFyZW50KSAhPT0gJ2JvZHknO1xuICB9KTtcbn0gLy8gR2V0cyB0aGUgbWF4aW11bSBhcmVhIHRoYXQgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBpbiBkdWUgdG8gYW55IG51bWJlciBvZlxuLy8gY2xpcHBpbmcgcGFyZW50c1xuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENsaXBwaW5nUmVjdChlbGVtZW50LCBib3VuZGFyeSwgcm9vdEJvdW5kYXJ5KSB7XG4gIHZhciBtYWluQ2xpcHBpbmdQYXJlbnRzID0gYm91bmRhcnkgPT09ICdjbGlwcGluZ1BhcmVudHMnID8gZ2V0Q2xpcHBpbmdQYXJlbnRzKGVsZW1lbnQpIDogW10uY29uY2F0KGJvdW5kYXJ5KTtcbiAgdmFyIGNsaXBwaW5nUGFyZW50cyA9IFtdLmNvbmNhdChtYWluQ2xpcHBpbmdQYXJlbnRzLCBbcm9vdEJvdW5kYXJ5XSk7XG4gIHZhciBmaXJzdENsaXBwaW5nUGFyZW50ID0gY2xpcHBpbmdQYXJlbnRzWzBdO1xuICB2YXIgY2xpcHBpbmdSZWN0ID0gY2xpcHBpbmdQYXJlbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjUmVjdCwgY2xpcHBpbmdQYXJlbnQpIHtcbiAgICB2YXIgcmVjdCA9IGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGNsaXBwaW5nUGFyZW50KTtcbiAgICBhY2NSZWN0LnRvcCA9IG1heChyZWN0LnRvcCwgYWNjUmVjdC50b3ApO1xuICAgIGFjY1JlY3QucmlnaHQgPSBtaW4ocmVjdC5yaWdodCwgYWNjUmVjdC5yaWdodCk7XG4gICAgYWNjUmVjdC5ib3R0b20gPSBtaW4ocmVjdC5ib3R0b20sIGFjY1JlY3QuYm90dG9tKTtcbiAgICBhY2NSZWN0LmxlZnQgPSBtYXgocmVjdC5sZWZ0LCBhY2NSZWN0LmxlZnQpO1xuICAgIHJldHVybiBhY2NSZWN0O1xuICB9LCBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBmaXJzdENsaXBwaW5nUGFyZW50KSk7XG4gIGNsaXBwaW5nUmVjdC53aWR0aCA9IGNsaXBwaW5nUmVjdC5yaWdodCAtIGNsaXBwaW5nUmVjdC5sZWZ0O1xuICBjbGlwcGluZ1JlY3QuaGVpZ2h0ID0gY2xpcHBpbmdSZWN0LmJvdHRvbSAtIGNsaXBwaW5nUmVjdC50b3A7XG4gIGNsaXBwaW5nUmVjdC54ID0gY2xpcHBpbmdSZWN0LmxlZnQ7XG4gIGNsaXBwaW5nUmVjdC55ID0gY2xpcHBpbmdSZWN0LnRvcDtcbiAgcmV0dXJuIGNsaXBwaW5nUmVjdDtcbn0iLCJpbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IGdldE5vZGVTY3JvbGwgZnJvbSBcIi4vZ2V0Tm9kZVNjcm9sbC5qc1wiO1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbEJhclggZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsQmFyWC5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBpc1Njcm9sbFBhcmVudCBmcm9tIFwiLi9pc1Njcm9sbFBhcmVudC5qc1wiO1xuaW1wb3J0IHsgcm91bmQgfSBmcm9tIFwiLi4vdXRpbHMvbWF0aC5qc1wiO1xuXG5mdW5jdGlvbiBpc0VsZW1lbnRTY2FsZWQoZWxlbWVudCkge1xuICB2YXIgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciBzY2FsZVggPSByb3VuZChyZWN0LndpZHRoKSAvIGVsZW1lbnQub2Zmc2V0V2lkdGggfHwgMTtcbiAgdmFyIHNjYWxlWSA9IHJvdW5kKHJlY3QuaGVpZ2h0KSAvIGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IDE7XG4gIHJldHVybiBzY2FsZVggIT09IDEgfHwgc2NhbGVZICE9PSAxO1xufSAvLyBSZXR1cm5zIHRoZSBjb21wb3NpdGUgcmVjdCBvZiBhbiBlbGVtZW50IHJlbGF0aXZlIHRvIGl0cyBvZmZzZXRQYXJlbnQuXG4vLyBDb21wb3NpdGUgbWVhbnMgaXQgdGFrZXMgaW50byBhY2NvdW50IHRyYW5zZm9ybXMgYXMgd2VsbCBhcyBsYXlvdXQuXG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Q29tcG9zaXRlUmVjdChlbGVtZW50T3JWaXJ0dWFsRWxlbWVudCwgb2Zmc2V0UGFyZW50LCBpc0ZpeGVkKSB7XG4gIGlmIChpc0ZpeGVkID09PSB2b2lkIDApIHtcbiAgICBpc0ZpeGVkID0gZmFsc2U7XG4gIH1cblxuICB2YXIgaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgPSBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIHZhciBvZmZzZXRQYXJlbnRJc1NjYWxlZCA9IGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KSAmJiBpc0VsZW1lbnRTY2FsZWQob2Zmc2V0UGFyZW50KTtcbiAgdmFyIGRvY3VtZW50RWxlbWVudCA9IGdldERvY3VtZW50RWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICB2YXIgcmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50T3JWaXJ0dWFsRWxlbWVudCwgb2Zmc2V0UGFyZW50SXNTY2FsZWQpO1xuICB2YXIgc2Nyb2xsID0ge1xuICAgIHNjcm9sbExlZnQ6IDAsXG4gICAgc2Nyb2xsVG9wOiAwXG4gIH07XG4gIHZhciBvZmZzZXRzID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuXG4gIGlmIChpc09mZnNldFBhcmVudEFuRWxlbWVudCB8fCAhaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgJiYgIWlzRml4ZWQpIHtcbiAgICBpZiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSAhPT0gJ2JvZHknIHx8IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvMTA3OFxuICAgIGlzU2Nyb2xsUGFyZW50KGRvY3VtZW50RWxlbWVudCkpIHtcbiAgICAgIHNjcm9sbCA9IGdldE5vZGVTY3JvbGwob2Zmc2V0UGFyZW50KTtcbiAgICB9XG5cbiAgICBpZiAoaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICBvZmZzZXRzID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCwgdHJ1ZSk7XG4gICAgICBvZmZzZXRzLnggKz0gb2Zmc2V0UGFyZW50LmNsaWVudExlZnQ7XG4gICAgICBvZmZzZXRzLnkgKz0gb2Zmc2V0UGFyZW50LmNsaWVudFRvcDtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50RWxlbWVudCkge1xuICAgICAgb2Zmc2V0cy54ID0gZ2V0V2luZG93U2Nyb2xsQmFyWChkb2N1bWVudEVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogcmVjdC5sZWZ0ICsgc2Nyb2xsLnNjcm9sbExlZnQgLSBvZmZzZXRzLngsXG4gICAgeTogcmVjdC50b3AgKyBzY3JvbGwuc2Nyb2xsVG9wIC0gb2Zmc2V0cy55LFxuICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHRcbiAgfTtcbn0iLCJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSB7XG4gIHJldHVybiBnZXRXaW5kb3coZWxlbWVudCkuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbn0iLCJpbXBvcnQgeyBpc0VsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkge1xuICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBhc3N1bWUgYm9keSBpcyBhbHdheXMgYXZhaWxhYmxlXG4gIHJldHVybiAoKGlzRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQub3duZXJEb2N1bWVudCA6IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICBlbGVtZW50LmRvY3VtZW50KSB8fCB3aW5kb3cuZG9jdW1lbnQpLmRvY3VtZW50RWxlbWVudDtcbn0iLCJpbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbEJhclggZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsQmFyWC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGwuanNcIjtcbmltcG9ydCB7IG1heCB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7IC8vIEdldHMgdGhlIGVudGlyZSBzaXplIG9mIHRoZSBzY3JvbGxhYmxlIGRvY3VtZW50IGFyZWEsIGV2ZW4gZXh0ZW5kaW5nIG91dHNpZGVcbi8vIG9mIHRoZSBgPGh0bWw+YCBhbmQgYDxib2R5PmAgcmVjdCBib3VuZHMgaWYgaG9yaXpvbnRhbGx5IHNjcm9sbGFibGVcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RG9jdW1lbnRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIF9lbGVtZW50JG93bmVyRG9jdW1lbjtcblxuICB2YXIgaHRtbCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgdmFyIHdpblNjcm9sbCA9IGdldFdpbmRvd1Njcm9sbChlbGVtZW50KTtcbiAgdmFyIGJvZHkgPSAoX2VsZW1lbnQkb3duZXJEb2N1bWVuID0gZWxlbWVudC5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2VsZW1lbnQkb3duZXJEb2N1bWVuLmJvZHk7XG4gIHZhciB3aWR0aCA9IG1heChodG1sLnNjcm9sbFdpZHRoLCBodG1sLmNsaWVudFdpZHRoLCBib2R5ID8gYm9keS5zY3JvbGxXaWR0aCA6IDAsIGJvZHkgPyBib2R5LmNsaWVudFdpZHRoIDogMCk7XG4gIHZhciBoZWlnaHQgPSBtYXgoaHRtbC5zY3JvbGxIZWlnaHQsIGh0bWwuY2xpZW50SGVpZ2h0LCBib2R5ID8gYm9keS5zY3JvbGxIZWlnaHQgOiAwLCBib2R5ID8gYm9keS5jbGllbnRIZWlnaHQgOiAwKTtcbiAgdmFyIHggPSAtd2luU2Nyb2xsLnNjcm9sbExlZnQgKyBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpO1xuICB2YXIgeSA9IC13aW5TY3JvbGwuc2Nyb2xsVG9wO1xuXG4gIGlmIChnZXRDb21wdXRlZFN0eWxlKGJvZHkgfHwgaHRtbCkuZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgIHggKz0gbWF4KGh0bWwuY2xpZW50V2lkdGgsIGJvZHkgPyBib2R5LmNsaWVudFdpZHRoIDogMCkgLSB3aWR0aDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEhUTUxFbGVtZW50U2Nyb2xsKGVsZW1lbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBlbGVtZW50LnNjcm9sbExlZnQsXG4gICAgc2Nyb2xsVG9wOiBlbGVtZW50LnNjcm9sbFRvcFxuICB9O1xufSIsImltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7IC8vIFJldHVybnMgdGhlIGxheW91dCByZWN0IG9mIGFuIGVsZW1lbnQgcmVsYXRpdmUgdG8gaXRzIG9mZnNldFBhcmVudC4gTGF5b3V0XG4vLyBtZWFucyBpdCBkb2Vzbid0IHRha2UgaW50byBhY2NvdW50IHRyYW5zZm9ybXMuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldExheW91dFJlY3QoZWxlbWVudCkge1xuICB2YXIgY2xpZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KTsgLy8gVXNlIHRoZSBjbGllbnRSZWN0IHNpemVzIGlmIGl0J3Mgbm90IGJlZW4gdHJhbnNmb3JtZWQuXG4gIC8vIEZpeGVzIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvMTIyM1xuXG4gIHZhciB3aWR0aCA9IGVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gIHZhciBoZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcblxuICBpZiAoTWF0aC5hYnMoY2xpZW50UmVjdC53aWR0aCAtIHdpZHRoKSA8PSAxKSB7XG4gICAgd2lkdGggPSBjbGllbnRSZWN0LndpZHRoO1xuICB9XG5cbiAgaWYgKE1hdGguYWJzKGNsaWVudFJlY3QuaGVpZ2h0IC0gaGVpZ2h0KSA8PSAxKSB7XG4gICAgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IGVsZW1lbnQub2Zmc2V0TGVmdCxcbiAgICB5OiBlbGVtZW50Lm9mZnNldFRvcCxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgfTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXROb2RlTmFtZShlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50ID8gKGVsZW1lbnQubm9kZU5hbWUgfHwgJycpLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xufSIsImltcG9ydCBnZXRXaW5kb3dTY3JvbGwgZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBnZXRIVE1MRWxlbWVudFNjcm9sbCBmcm9tIFwiLi9nZXRIVE1MRWxlbWVudFNjcm9sbC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Tm9kZVNjcm9sbChub2RlKSB7XG4gIGlmIChub2RlID09PSBnZXRXaW5kb3cobm9kZSkgfHwgIWlzSFRNTEVsZW1lbnQobm9kZSkpIHtcbiAgICByZXR1cm4gZ2V0V2luZG93U2Nyb2xsKG5vZGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZXRIVE1MRWxlbWVudFNjcm9sbChub2RlKTtcbiAgfVxufSIsImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQsIGlzU2hhZG93Um9vdCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBpc1RhYmxlRWxlbWVudCBmcm9tIFwiLi9pc1RhYmxlRWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSBcIi4vZ2V0UGFyZW50Tm9kZS5qc1wiO1xuXG5mdW5jdGlvbiBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvODM3XG4gIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50Lm9mZnNldFBhcmVudDtcbn0gLy8gYC5vZmZzZXRQYXJlbnRgIHJlcG9ydHMgYG51bGxgIGZvciBmaXhlZCBlbGVtZW50cywgd2hpbGUgYWJzb2x1dGUgZWxlbWVudHNcbi8vIHJldHVybiB0aGUgY29udGFpbmluZyBibG9ja1xuXG5cbmZ1bmN0aW9uIGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB7XG4gIHZhciBpc0ZpcmVmb3ggPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignZmlyZWZveCcpICE9PSAtMTtcbiAgdmFyIGlzSUUgPSBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ1RyaWRlbnQnKSAhPT0gLTE7XG5cbiAgaWYgKGlzSUUgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xuICAgIC8vIEluIElFIDksIDEwIGFuZCAxMSBmaXhlZCBlbGVtZW50cyBjb250YWluaW5nIGJsb2NrIGlzIGFsd2F5cyBlc3RhYmxpc2hlZCBieSB0aGUgdmlld3BvcnRcbiAgICB2YXIgZWxlbWVudENzcyA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG5cbiAgICBpZiAoZWxlbWVudENzcy5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgdmFyIGN1cnJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcblxuICBpZiAoaXNTaGFkb3dSb290KGN1cnJlbnROb2RlKSkge1xuICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUuaG9zdDtcbiAgfVxuXG4gIHdoaWxlIChpc0hUTUxFbGVtZW50KGN1cnJlbnROb2RlKSAmJiBbJ2h0bWwnLCAnYm9keSddLmluZGV4T2YoZ2V0Tm9kZU5hbWUoY3VycmVudE5vZGUpKSA8IDApIHtcbiAgICB2YXIgY3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShjdXJyZW50Tm9kZSk7IC8vIFRoaXMgaXMgbm9uLWV4aGF1c3RpdmUgYnV0IGNvdmVycyB0aGUgbW9zdCBjb21tb24gQ1NTIHByb3BlcnRpZXMgdGhhdFxuICAgIC8vIGNyZWF0ZSBhIGNvbnRhaW5pbmcgYmxvY2suXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0NvbnRhaW5pbmdfYmxvY2sjaWRlbnRpZnlpbmdfdGhlX2NvbnRhaW5pbmdfYmxvY2tcblxuICAgIGlmIChjc3MudHJhbnNmb3JtICE9PSAnbm9uZScgfHwgY3NzLnBlcnNwZWN0aXZlICE9PSAnbm9uZScgfHwgY3NzLmNvbnRhaW4gPT09ICdwYWludCcgfHwgWyd0cmFuc2Zvcm0nLCAncGVyc3BlY3RpdmUnXS5pbmRleE9mKGNzcy53aWxsQ2hhbmdlKSAhPT0gLTEgfHwgaXNGaXJlZm94ICYmIGNzcy53aWxsQ2hhbmdlID09PSAnZmlsdGVyJyB8fCBpc0ZpcmVmb3ggJiYgY3NzLmZpbHRlciAmJiBjc3MuZmlsdGVyICE9PSAnbm9uZScpIHtcbiAgICAgIHJldHVybiBjdXJyZW50Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufSAvLyBHZXRzIHRoZSBjbG9zZXN0IGFuY2VzdG9yIHBvc2l0aW9uZWQgZWxlbWVudC4gSGFuZGxlcyBzb21lIGVkZ2UgY2FzZXMsXG4vLyBzdWNoIGFzIHRhYmxlIGFuY2VzdG9ycyBhbmQgY3Jvc3MgYnJvd3NlciBidWdzLlxuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIHZhciB3aW5kb3cgPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIHZhciBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQpO1xuXG4gIHdoaWxlIChvZmZzZXRQYXJlbnQgJiYgaXNUYWJsZUVsZW1lbnQob2Zmc2V0UGFyZW50KSAmJiBnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnKSB7XG4gICAgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChvZmZzZXRQYXJlbnQpO1xuICB9XG5cbiAgaWYgKG9mZnNldFBhcmVudCAmJiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSA9PT0gJ2h0bWwnIHx8IGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgPT09ICdib2R5JyAmJiBnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnKSkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB8fCB3aW5kb3c7XG59IiwiaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IHsgaXNTaGFkb3dSb290IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0UGFyZW50Tm9kZShlbGVtZW50KSB7XG4gIGlmIChnZXROb2RlTmFtZShlbGVtZW50KSA9PT0gJ2h0bWwnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICByZXR1cm4gKC8vIHRoaXMgaXMgYSBxdWlja2VyIChidXQgbGVzcyB0eXBlIHNhZmUpIHdheSB0byBzYXZlIHF1aXRlIHNvbWUgYnl0ZXMgZnJvbSB0aGUgYnVuZGxlXG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgIGVsZW1lbnQuYXNzaWduZWRTbG90IHx8IC8vIHN0ZXAgaW50byB0aGUgc2hhZG93IERPTSBvZiB0aGUgcGFyZW50IG9mIGEgc2xvdHRlZCBub2RlXG4gICAgZWxlbWVudC5wYXJlbnROb2RlIHx8ICggLy8gRE9NIEVsZW1lbnQgZGV0ZWN0ZWRcbiAgICBpc1NoYWRvd1Jvb3QoZWxlbWVudCkgPyBlbGVtZW50Lmhvc3QgOiBudWxsKSB8fCAvLyBTaGFkb3dSb290IGRldGVjdGVkXG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF06IEhUTUxFbGVtZW50IGlzIGEgTm9kZVxuICAgIGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSAvLyBmYWxsYmFja1xuXG4gICk7XG59IiwiaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSBcIi4vZ2V0UGFyZW50Tm9kZS5qc1wiO1xuaW1wb3J0IGlzU2Nyb2xsUGFyZW50IGZyb20gXCIuL2lzU2Nyb2xsUGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRTY3JvbGxQYXJlbnQobm9kZSkge1xuICBpZiAoWydodG1sJywgJ2JvZHknLCAnI2RvY3VtZW50J10uaW5kZXhPZihnZXROb2RlTmFtZShub2RlKSkgPj0gMCkge1xuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGFzc3VtZSBib2R5IGlzIGFsd2F5cyBhdmFpbGFibGVcbiAgICByZXR1cm4gbm9kZS5vd25lckRvY3VtZW50LmJvZHk7XG4gIH1cblxuICBpZiAoaXNIVE1MRWxlbWVudChub2RlKSAmJiBpc1Njcm9sbFBhcmVudChub2RlKSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgcmV0dXJuIGdldFNjcm9sbFBhcmVudChnZXRQYXJlbnROb2RlKG5vZGUpKTtcbn0iLCJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGxCYXJYIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbEJhclguanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFZpZXdwb3J0UmVjdChlbGVtZW50KSB7XG4gIHZhciB3aW4gPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIHZhciBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICB2YXIgdmlzdWFsVmlld3BvcnQgPSB3aW4udmlzdWFsVmlld3BvcnQ7XG4gIHZhciB3aWR0aCA9IGh0bWwuY2xpZW50V2lkdGg7XG4gIHZhciBoZWlnaHQgPSBodG1sLmNsaWVudEhlaWdodDtcbiAgdmFyIHggPSAwO1xuICB2YXIgeSA9IDA7IC8vIE5COiBUaGlzIGlzbid0IHN1cHBvcnRlZCBvbiBpT1MgPD0gMTIuIElmIHRoZSBrZXlib2FyZCBpcyBvcGVuLCB0aGUgcG9wcGVyXG4gIC8vIGNhbiBiZSBvYnNjdXJlZCB1bmRlcm5lYXRoIGl0LlxuICAvLyBBbHNvLCBgaHRtbC5jbGllbnRIZWlnaHRgIGFkZHMgdGhlIGJvdHRvbSBiYXIgaGVpZ2h0IGluIFNhZmFyaSBpT1MsIGV2ZW5cbiAgLy8gaWYgaXQgaXNuJ3Qgb3Blbiwgc28gaWYgdGhpcyBpc24ndCBhdmFpbGFibGUsIHRoZSBwb3BwZXIgd2lsbCBiZSBkZXRlY3RlZFxuICAvLyB0byBvdmVyZmxvdyB0aGUgYm90dG9tIG9mIHRoZSBzY3JlZW4gdG9vIGVhcmx5LlxuXG4gIGlmICh2aXN1YWxWaWV3cG9ydCkge1xuICAgIHdpZHRoID0gdmlzdWFsVmlld3BvcnQud2lkdGg7XG4gICAgaGVpZ2h0ID0gdmlzdWFsVmlld3BvcnQuaGVpZ2h0OyAvLyBVc2VzIExheW91dCBWaWV3cG9ydCAobGlrZSBDaHJvbWU7IFNhZmFyaSBkb2VzIG5vdCBjdXJyZW50bHkpXG4gICAgLy8gSW4gQ2hyb21lLCBpdCByZXR1cm5zIGEgdmFsdWUgdmVyeSBjbG9zZSB0byAwICgrLy0pIGJ1dCBjb250YWlucyByb3VuZGluZ1xuICAgIC8vIGVycm9ycyBkdWUgdG8gZmxvYXRpbmcgcG9pbnQgbnVtYmVycywgc28gd2UgbmVlZCB0byBjaGVjayBwcmVjaXNpb24uXG4gICAgLy8gU2FmYXJpIHJldHVybnMgYSBudW1iZXIgPD0gMCwgdXN1YWxseSA8IC0xIHdoZW4gcGluY2gtem9vbWVkXG4gICAgLy8gRmVhdHVyZSBkZXRlY3Rpb24gZmFpbHMgaW4gbW9iaWxlIGVtdWxhdGlvbiBtb2RlIGluIENocm9tZS5cbiAgICAvLyBNYXRoLmFicyh3aW4uaW5uZXJXaWR0aCAvIHZpc3VhbFZpZXdwb3J0LnNjYWxlIC0gdmlzdWFsVmlld3BvcnQud2lkdGgpIDxcbiAgICAvLyAwLjAwMVxuICAgIC8vIEZhbGxiYWNrIGhlcmU6IFwiTm90IFNhZmFyaVwiIHVzZXJBZ2VudFxuXG4gICAgaWYgKCEvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICB4ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdDtcbiAgICAgIHkgPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3A7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgeDogeCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCksXG4gICAgeTogeVxuICB9O1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFdpbmRvdyhub2RlKSB7XG4gIGlmIChub2RlID09IG51bGwpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG5cbiAgaWYgKG5vZGUudG9TdHJpbmcoKSAhPT0gJ1tvYmplY3QgV2luZG93XScpIHtcbiAgICB2YXIgb3duZXJEb2N1bWVudCA9IG5vZGUub3duZXJEb2N1bWVudDtcbiAgICByZXR1cm4gb3duZXJEb2N1bWVudCA/IG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93IDogd2luZG93O1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59IiwiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbChub2RlKSB7XG4gIHZhciB3aW4gPSBnZXRXaW5kb3cobm9kZSk7XG4gIHZhciBzY3JvbGxMZWZ0ID0gd2luLnBhZ2VYT2Zmc2V0O1xuICB2YXIgc2Nyb2xsVG9wID0gd2luLnBhZ2VZT2Zmc2V0O1xuICByZXR1cm4ge1xuICAgIHNjcm9sbExlZnQ6IHNjcm9sbExlZnQsXG4gICAgc2Nyb2xsVG9wOiBzY3JvbGxUb3BcbiAgfTtcbn0iLCJpbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGwgZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpIHtcbiAgLy8gSWYgPGh0bWw+IGhhcyBhIENTUyB3aWR0aCBncmVhdGVyIHRoYW4gdGhlIHZpZXdwb3J0LCB0aGVuIHRoaXMgd2lsbCBiZVxuICAvLyBpbmNvcnJlY3QgZm9yIFJUTC5cbiAgLy8gUG9wcGVyIDEgaXMgYnJva2VuIGluIHRoaXMgY2FzZSBhbmQgbmV2ZXIgaGFkIGEgYnVnIHJlcG9ydCBzbyBsZXQncyBhc3N1bWVcbiAgLy8gaXQncyBub3QgYW4gaXNzdWUuIEkgZG9uJ3QgdGhpbmsgYW55b25lIGV2ZXIgc3BlY2lmaWVzIHdpZHRoIG9uIDxodG1sPlxuICAvLyBhbnl3YXkuXG4gIC8vIEJyb3dzZXJzIHdoZXJlIHRoZSBsZWZ0IHNjcm9sbGJhciBkb2Vzbid0IGNhdXNlIGFuIGlzc3VlIHJlcG9ydCBgMGAgZm9yXG4gIC8vIHRoaXMgKGUuZy4gRWRnZSAyMDE5LCBJRTExLCBTYWZhcmkpXG4gIHJldHVybiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKS5sZWZ0ICsgZ2V0V2luZG93U2Nyb2xsKGVsZW1lbnQpLnNjcm9sbExlZnQ7XG59IiwiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcblxuZnVuY3Rpb24gaXNFbGVtZW50KG5vZGUpIHtcbiAgdmFyIE93bkVsZW1lbnQgPSBnZXRXaW5kb3cobm9kZSkuRWxlbWVudDtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBpc0hUTUxFbGVtZW50KG5vZGUpIHtcbiAgdmFyIE93bkVsZW1lbnQgPSBnZXRXaW5kb3cobm9kZSkuSFRNTEVsZW1lbnQ7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGlzU2hhZG93Um9vdChub2RlKSB7XG4gIC8vIElFIDExIGhhcyBubyBTaGFkb3dSb290XG4gIGlmICh0eXBlb2YgU2hhZG93Um9vdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5TaGFkb3dSb290O1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3Q7XG59XG5cbmV4cG9ydCB7IGlzRWxlbWVudCwgaXNIVE1MRWxlbWVudCwgaXNTaGFkb3dSb290IH07IiwiaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNTY3JvbGxQYXJlbnQoZWxlbWVudCkge1xuICAvLyBGaXJlZm94IHdhbnRzIHVzIHRvIGNoZWNrIGAteGAgYW5kIGAteWAgdmFyaWF0aW9ucyBhcyB3ZWxsXG4gIHZhciBfZ2V0Q29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCksXG4gICAgICBvdmVyZmxvdyA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93LFxuICAgICAgb3ZlcmZsb3dYID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3dYLFxuICAgICAgb3ZlcmZsb3dZID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3dZO1xuXG4gIHJldHVybiAvYXV0b3xzY3JvbGx8b3ZlcmxheXxoaWRkZW4vLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpO1xufSIsImltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNUYWJsZUVsZW1lbnQoZWxlbWVudCkge1xuICByZXR1cm4gWyd0YWJsZScsICd0ZCcsICd0aCddLmluZGV4T2YoZ2V0Tm9kZU5hbWUoZWxlbWVudCkpID49IDA7XG59IiwiaW1wb3J0IGdldFNjcm9sbFBhcmVudCBmcm9tIFwiLi9nZXRTY3JvbGxQYXJlbnQuanNcIjtcbmltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gXCIuL2dldFBhcmVudE5vZGUuanNcIjtcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgaXNTY3JvbGxQYXJlbnQgZnJvbSBcIi4vaXNTY3JvbGxQYXJlbnQuanNcIjtcbi8qXG5naXZlbiBhIERPTSBlbGVtZW50LCByZXR1cm4gdGhlIGxpc3Qgb2YgYWxsIHNjcm9sbCBwYXJlbnRzLCB1cCB0aGUgbGlzdCBvZiBhbmNlc29yc1xudW50aWwgd2UgZ2V0IHRvIHRoZSB0b3Agd2luZG93IG9iamVjdC4gVGhpcyBsaXN0IGlzIHdoYXQgd2UgYXR0YWNoIHNjcm9sbCBsaXN0ZW5lcnNcbnRvLCBiZWNhdXNlIGlmIGFueSBvZiB0aGVzZSBwYXJlbnQgZWxlbWVudHMgc2Nyb2xsLCB3ZSdsbCBuZWVkIHRvIHJlLWNhbGN1bGF0ZSB0aGVcbnJlZmVyZW5jZSBlbGVtZW50J3MgcG9zaXRpb24uXG4qL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsaXN0U2Nyb2xsUGFyZW50cyhlbGVtZW50LCBsaXN0KSB7XG4gIHZhciBfZWxlbWVudCRvd25lckRvY3VtZW47XG5cbiAgaWYgKGxpc3QgPT09IHZvaWQgMCkge1xuICAgIGxpc3QgPSBbXTtcbiAgfVxuXG4gIHZhciBzY3JvbGxQYXJlbnQgPSBnZXRTY3JvbGxQYXJlbnQoZWxlbWVudCk7XG4gIHZhciBpc0JvZHkgPSBzY3JvbGxQYXJlbnQgPT09ICgoX2VsZW1lbnQkb3duZXJEb2N1bWVuID0gZWxlbWVudC5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2VsZW1lbnQkb3duZXJEb2N1bWVuLmJvZHkpO1xuICB2YXIgd2luID0gZ2V0V2luZG93KHNjcm9sbFBhcmVudCk7XG4gIHZhciB0YXJnZXQgPSBpc0JvZHkgPyBbd2luXS5jb25jYXQod2luLnZpc3VhbFZpZXdwb3J0IHx8IFtdLCBpc1Njcm9sbFBhcmVudChzY3JvbGxQYXJlbnQpID8gc2Nyb2xsUGFyZW50IDogW10pIDogc2Nyb2xsUGFyZW50O1xuICB2YXIgdXBkYXRlZExpc3QgPSBsaXN0LmNvbmNhdCh0YXJnZXQpO1xuICByZXR1cm4gaXNCb2R5ID8gdXBkYXRlZExpc3QgOiAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogaXNCb2R5IHRlbGxzIHVzIHRhcmdldCB3aWxsIGJlIGFuIEhUTUxFbGVtZW50IGhlcmVcbiAgdXBkYXRlZExpc3QuY29uY2F0KGxpc3RTY3JvbGxQYXJlbnRzKGdldFBhcmVudE5vZGUodGFyZ2V0KSkpO1xufSIsImV4cG9ydCB2YXIgdG9wID0gJ3RvcCc7XG5leHBvcnQgdmFyIGJvdHRvbSA9ICdib3R0b20nO1xuZXhwb3J0IHZhciByaWdodCA9ICdyaWdodCc7XG5leHBvcnQgdmFyIGxlZnQgPSAnbGVmdCc7XG5leHBvcnQgdmFyIGF1dG8gPSAnYXV0byc7XG5leHBvcnQgdmFyIGJhc2VQbGFjZW1lbnRzID0gW3RvcCwgYm90dG9tLCByaWdodCwgbGVmdF07XG5leHBvcnQgdmFyIHN0YXJ0ID0gJ3N0YXJ0JztcbmV4cG9ydCB2YXIgZW5kID0gJ2VuZCc7XG5leHBvcnQgdmFyIGNsaXBwaW5nUGFyZW50cyA9ICdjbGlwcGluZ1BhcmVudHMnO1xuZXhwb3J0IHZhciB2aWV3cG9ydCA9ICd2aWV3cG9ydCc7XG5leHBvcnQgdmFyIHBvcHBlciA9ICdwb3BwZXInO1xuZXhwb3J0IHZhciByZWZlcmVuY2UgPSAncmVmZXJlbmNlJztcbmV4cG9ydCB2YXIgdmFyaWF0aW9uUGxhY2VtZW50cyA9IC8qI19fUFVSRV9fKi9iYXNlUGxhY2VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gIHJldHVybiBhY2MuY29uY2F0KFtwbGFjZW1lbnQgKyBcIi1cIiArIHN0YXJ0LCBwbGFjZW1lbnQgKyBcIi1cIiArIGVuZF0pO1xufSwgW10pO1xuZXhwb3J0IHZhciBwbGFjZW1lbnRzID0gLyojX19QVVJFX18qL1tdLmNvbmNhdChiYXNlUGxhY2VtZW50cywgW2F1dG9dKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gIHJldHVybiBhY2MuY29uY2F0KFtwbGFjZW1lbnQsIHBsYWNlbWVudCArIFwiLVwiICsgc3RhcnQsIHBsYWNlbWVudCArIFwiLVwiICsgZW5kXSk7XG59LCBbXSk7IC8vIG1vZGlmaWVycyB0aGF0IG5lZWQgdG8gcmVhZCB0aGUgRE9NXG5cbmV4cG9ydCB2YXIgYmVmb3JlUmVhZCA9ICdiZWZvcmVSZWFkJztcbmV4cG9ydCB2YXIgcmVhZCA9ICdyZWFkJztcbmV4cG9ydCB2YXIgYWZ0ZXJSZWFkID0gJ2FmdGVyUmVhZCc7IC8vIHB1cmUtbG9naWMgbW9kaWZpZXJzXG5cbmV4cG9ydCB2YXIgYmVmb3JlTWFpbiA9ICdiZWZvcmVNYWluJztcbmV4cG9ydCB2YXIgbWFpbiA9ICdtYWluJztcbmV4cG9ydCB2YXIgYWZ0ZXJNYWluID0gJ2FmdGVyTWFpbic7IC8vIG1vZGlmaWVyIHdpdGggdGhlIHB1cnBvc2UgdG8gd3JpdGUgdG8gdGhlIERPTSAob3Igd3JpdGUgaW50byBhIGZyYW1ld29yayBzdGF0ZSlcblxuZXhwb3J0IHZhciBiZWZvcmVXcml0ZSA9ICdiZWZvcmVXcml0ZSc7XG5leHBvcnQgdmFyIHdyaXRlID0gJ3dyaXRlJztcbmV4cG9ydCB2YXIgYWZ0ZXJXcml0ZSA9ICdhZnRlcldyaXRlJztcbmV4cG9ydCB2YXIgbW9kaWZpZXJQaGFzZXMgPSBbYmVmb3JlUmVhZCwgcmVhZCwgYWZ0ZXJSZWFkLCBiZWZvcmVNYWluLCBtYWluLCBhZnRlck1haW4sIGJlZm9yZVdyaXRlLCB3cml0ZSwgYWZ0ZXJXcml0ZV07IiwiZXhwb3J0ICogZnJvbSBcIi4vZW51bXMuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL21vZGlmaWVycy9pbmRleC5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCB7IHBvcHBlckdlbmVyYXRvciwgZGV0ZWN0T3ZlcmZsb3csIGNyZWF0ZVBvcHBlciBhcyBjcmVhdGVQb3BwZXJCYXNlIH0gZnJvbSBcIi4vY3JlYXRlUG9wcGVyLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IHsgY3JlYXRlUG9wcGVyIH0gZnJvbSBcIi4vcG9wcGVyLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IHsgY3JlYXRlUG9wcGVyIGFzIGNyZWF0ZVBvcHBlckxpdGUgfSBmcm9tIFwiLi9wb3BwZXItbGl0ZS5qc1wiOyIsImltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4uL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzXCI7IC8vIFRoaXMgbW9kaWZpZXIgdGFrZXMgdGhlIHN0eWxlcyBwcmVwYXJlZCBieSB0aGUgYGNvbXB1dGVTdHlsZXNgIG1vZGlmaWVyXG4vLyBhbmQgYXBwbGllcyB0aGVtIHRvIHRoZSBIVE1MRWxlbWVudHMgc3VjaCBhcyBwb3BwZXIgYW5kIGFycm93XG5cbmZ1bmN0aW9uIGFwcGx5U3R5bGVzKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZTtcbiAgT2JqZWN0LmtleXMoc3RhdGUuZWxlbWVudHMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgc3R5bGUgPSBzdGF0ZS5zdHlsZXNbbmFtZV0gfHwge307XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBzdGF0ZS5hdHRyaWJ1dGVzW25hbWVdIHx8IHt9O1xuICAgIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbbmFtZV07IC8vIGFycm93IGlzIG9wdGlvbmFsICsgdmlydHVhbCBlbGVtZW50c1xuXG4gICAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8ICFnZXROb2RlTmFtZShlbGVtZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRmxvdyBkb2Vzbid0IHN1cHBvcnQgdG8gZXh0ZW5kIHRoaXMgcHJvcGVydHksIGJ1dCBpdCdzIHRoZSBtb3N0XG4gICAgLy8gZWZmZWN0aXZlIHdheSB0byBhcHBseSBzdHlsZXMgdG8gYW4gSFRNTEVsZW1lbnRcbiAgICAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV1cblxuXG4gICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LnN0eWxlLCBzdHlsZSk7XG4gICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIHZhbHVlID0gYXR0cmlidXRlc1tuYW1lXTtcblxuICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlID09PSB0cnVlID8gJycgOiB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBlZmZlY3QoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGU7XG4gIHZhciBpbml0aWFsU3R5bGVzID0ge1xuICAgIHBvcHBlcjoge1xuICAgICAgcG9zaXRpb246IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICBsZWZ0OiAnMCcsXG4gICAgICB0b3A6ICcwJyxcbiAgICAgIG1hcmdpbjogJzAnXG4gICAgfSxcbiAgICBhcnJvdzoge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbiAgICB9LFxuICAgIHJlZmVyZW5jZToge31cbiAgfTtcbiAgT2JqZWN0LmFzc2lnbihzdGF0ZS5lbGVtZW50cy5wb3BwZXIuc3R5bGUsIGluaXRpYWxTdHlsZXMucG9wcGVyKTtcbiAgc3RhdGUuc3R5bGVzID0gaW5pdGlhbFN0eWxlcztcblxuICBpZiAoc3RhdGUuZWxlbWVudHMuYXJyb3cpIHtcbiAgICBPYmplY3QuYXNzaWduKHN0YXRlLmVsZW1lbnRzLmFycm93LnN0eWxlLCBpbml0aWFsU3R5bGVzLmFycm93KTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgT2JqZWN0LmtleXMoc3RhdGUuZWxlbWVudHMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbbmFtZV07XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IHN0YXRlLmF0dHJpYnV0ZXNbbmFtZV0gfHwge307XG4gICAgICB2YXIgc3R5bGVQcm9wZXJ0aWVzID0gT2JqZWN0LmtleXMoc3RhdGUuc3R5bGVzLmhhc093blByb3BlcnR5KG5hbWUpID8gc3RhdGUuc3R5bGVzW25hbWVdIDogaW5pdGlhbFN0eWxlc1tuYW1lXSk7IC8vIFNldCBhbGwgdmFsdWVzIHRvIGFuIGVtcHR5IHN0cmluZyB0byB1bnNldCB0aGVtXG5cbiAgICAgIHZhciBzdHlsZSA9IHN0eWxlUHJvcGVydGllcy5yZWR1Y2UoZnVuY3Rpb24gKHN0eWxlLCBwcm9wZXJ0eSkge1xuICAgICAgICBzdHlsZVtwcm9wZXJ0eV0gPSAnJztcbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgfSwge30pOyAvLyBhcnJvdyBpcyBvcHRpb25hbCArIHZpcnR1YWwgZWxlbWVudHNcblxuICAgICAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8ICFnZXROb2RlTmFtZShlbGVtZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuICAgICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2FwcGx5U3R5bGVzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICd3cml0ZScsXG4gIGZuOiBhcHBseVN0eWxlcyxcbiAgZWZmZWN0OiBlZmZlY3QsXG4gIHJlcXVpcmVzOiBbJ2NvbXB1dGVTdHlsZXMnXVxufTsiLCJpbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldExheW91dFJlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzXCI7XG5pbXBvcnQgY29udGFpbnMgZnJvbSBcIi4uL2RvbS11dGlscy9jb250YWlucy5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgeyB3aXRoaW4gfSBmcm9tIFwiLi4vdXRpbHMvd2l0aGluLmpzXCI7XG5pbXBvcnQgbWVyZ2VQYWRkaW5nT2JqZWN0IGZyb20gXCIuLi91dGlscy9tZXJnZVBhZGRpbmdPYmplY3QuanNcIjtcbmltcG9ydCBleHBhbmRUb0hhc2hNYXAgZnJvbSBcIi4uL3V0aWxzL2V4cGFuZFRvSGFzaE1hcC5qc1wiO1xuaW1wb3J0IHsgbGVmdCwgcmlnaHQsIGJhc2VQbGFjZW1lbnRzLCB0b3AsIGJvdHRvbSB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuLi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbnZhciB0b1BhZGRpbmdPYmplY3QgPSBmdW5jdGlvbiB0b1BhZGRpbmdPYmplY3QocGFkZGluZywgc3RhdGUpIHtcbiAgcGFkZGluZyA9IHR5cGVvZiBwYWRkaW5nID09PSAnZnVuY3Rpb24nID8gcGFkZGluZyhPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5yZWN0cywge1xuICAgIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50XG4gIH0pKSA6IHBhZGRpbmc7XG4gIHJldHVybiBtZXJnZVBhZGRpbmdPYmplY3QodHlwZW9mIHBhZGRpbmcgIT09ICdudW1iZXInID8gcGFkZGluZyA6IGV4cGFuZFRvSGFzaE1hcChwYWRkaW5nLCBiYXNlUGxhY2VtZW50cykpO1xufTtcblxuZnVuY3Rpb24gYXJyb3coX3JlZikge1xuICB2YXIgX3N0YXRlJG1vZGlmaWVyc0RhdGEkO1xuXG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucztcbiAgdmFyIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93O1xuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cztcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHN0YXRlLnBsYWNlbWVudCk7XG4gIHZhciBheGlzID0gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpO1xuICB2YXIgaXNWZXJ0aWNhbCA9IFtsZWZ0LCByaWdodF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwO1xuICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICBpZiAoIWFycm93RWxlbWVudCB8fCAhcG9wcGVyT2Zmc2V0cykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwYWRkaW5nT2JqZWN0ID0gdG9QYWRkaW5nT2JqZWN0KG9wdGlvbnMucGFkZGluZywgc3RhdGUpO1xuICB2YXIgYXJyb3dSZWN0ID0gZ2V0TGF5b3V0UmVjdChhcnJvd0VsZW1lbnQpO1xuICB2YXIgbWluUHJvcCA9IGF4aXMgPT09ICd5JyA/IHRvcCA6IGxlZnQ7XG4gIHZhciBtYXhQcm9wID0gYXhpcyA9PT0gJ3knID8gYm90dG9tIDogcmlnaHQ7XG4gIHZhciBlbmREaWZmID0gc3RhdGUucmVjdHMucmVmZXJlbmNlW2xlbl0gKyBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbYXhpc10gLSBwb3BwZXJPZmZzZXRzW2F4aXNdIC0gc3RhdGUucmVjdHMucG9wcGVyW2xlbl07XG4gIHZhciBzdGFydERpZmYgPSBwb3BwZXJPZmZzZXRzW2F4aXNdIC0gc3RhdGUucmVjdHMucmVmZXJlbmNlW2F4aXNdO1xuICB2YXIgYXJyb3dPZmZzZXRQYXJlbnQgPSBnZXRPZmZzZXRQYXJlbnQoYXJyb3dFbGVtZW50KTtcbiAgdmFyIGNsaWVudFNpemUgPSBhcnJvd09mZnNldFBhcmVudCA/IGF4aXMgPT09ICd5JyA/IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudEhlaWdodCB8fCAwIDogYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50V2lkdGggfHwgMCA6IDA7XG4gIHZhciBjZW50ZXJUb1JlZmVyZW5jZSA9IGVuZERpZmYgLyAyIC0gc3RhcnREaWZmIC8gMjsgLy8gTWFrZSBzdXJlIHRoZSBhcnJvdyBkb2Vzbid0IG92ZXJmbG93IHRoZSBwb3BwZXIgaWYgdGhlIGNlbnRlciBwb2ludCBpc1xuICAvLyBvdXRzaWRlIG9mIHRoZSBwb3BwZXIgYm91bmRzXG5cbiAgdmFyIG1pbiA9IHBhZGRpbmdPYmplY3RbbWluUHJvcF07XG4gIHZhciBtYXggPSBjbGllbnRTaXplIC0gYXJyb3dSZWN0W2xlbl0gLSBwYWRkaW5nT2JqZWN0W21heFByb3BdO1xuICB2YXIgY2VudGVyID0gY2xpZW50U2l6ZSAvIDIgLSBhcnJvd1JlY3RbbGVuXSAvIDIgKyBjZW50ZXJUb1JlZmVyZW5jZTtcbiAgdmFyIG9mZnNldCA9IHdpdGhpbihtaW4sIGNlbnRlciwgbWF4KTsgLy8gUHJldmVudHMgYnJlYWtpbmcgc3ludGF4IGhpZ2hsaWdodGluZy4uLlxuXG4gIHZhciBheGlzUHJvcCA9IGF4aXM7XG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSAoX3N0YXRlJG1vZGlmaWVyc0RhdGEkID0ge30sIF9zdGF0ZSRtb2RpZmllcnNEYXRhJFtheGlzUHJvcF0gPSBvZmZzZXQsIF9zdGF0ZSRtb2RpZmllcnNEYXRhJC5jZW50ZXJPZmZzZXQgPSBvZmZzZXQgLSBjZW50ZXIsIF9zdGF0ZSRtb2RpZmllcnNEYXRhJCk7XG59XG5cbmZ1bmN0aW9uIGVmZmVjdChfcmVmMikge1xuICB2YXIgc3RhdGUgPSBfcmVmMi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmMi5vcHRpb25zO1xuICB2YXIgX29wdGlvbnMkZWxlbWVudCA9IG9wdGlvbnMuZWxlbWVudCxcbiAgICAgIGFycm93RWxlbWVudCA9IF9vcHRpb25zJGVsZW1lbnQgPT09IHZvaWQgMCA/ICdbZGF0YS1wb3BwZXItYXJyb3ddJyA6IF9vcHRpb25zJGVsZW1lbnQ7XG5cbiAgaWYgKGFycm93RWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIENTUyBzZWxlY3RvclxuXG5cbiAgaWYgKHR5cGVvZiBhcnJvd0VsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMucG9wcGVyLnF1ZXJ5U2VsZWN0b3IoYXJyb3dFbGVtZW50KTtcblxuICAgIGlmICghYXJyb3dFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmICghaXNIVE1MRWxlbWVudChhcnJvd0VsZW1lbnQpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFsnUG9wcGVyOiBcImFycm93XCIgZWxlbWVudCBtdXN0IGJlIGFuIEhUTUxFbGVtZW50IChub3QgYW4gU1ZHRWxlbWVudCkuJywgJ1RvIHVzZSBhbiBTVkcgYXJyb3csIHdyYXAgaXQgaW4gYW4gSFRNTEVsZW1lbnQgdGhhdCB3aWxsIGJlIHVzZWQgYXMnLCAndGhlIGFycm93LiddLmpvaW4oJyAnKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb250YWlucyhzdGF0ZS5lbGVtZW50cy5wb3BwZXIsIGFycm93RWxlbWVudCkpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFsnUG9wcGVyOiBcImFycm93XCIgbW9kaWZpZXJcXCdzIGBlbGVtZW50YCBtdXN0IGJlIGEgY2hpbGQgb2YgdGhlIHBvcHBlcicsICdlbGVtZW50LiddLmpvaW4oJyAnKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3RhdGUuZWxlbWVudHMuYXJyb3cgPSBhcnJvd0VsZW1lbnQ7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdhcnJvdycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIGZuOiBhcnJvdyxcbiAgZWZmZWN0OiBlZmZlY3QsXG4gIHJlcXVpcmVzOiBbJ3BvcHBlck9mZnNldHMnXSxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydwcmV2ZW50T3ZlcmZsb3cnXVxufTsiLCJpbXBvcnQgeyB0b3AsIGxlZnQsIHJpZ2h0LCBib3R0b20sIGVuZCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi4vdXRpbHMvZ2V0VmFyaWF0aW9uLmpzXCI7XG5pbXBvcnQgeyByb3VuZCB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxudmFyIHVuc2V0U2lkZXMgPSB7XG4gIHRvcDogJ2F1dG8nLFxuICByaWdodDogJ2F1dG8nLFxuICBib3R0b206ICdhdXRvJyxcbiAgbGVmdDogJ2F1dG8nXG59OyAvLyBSb3VuZCB0aGUgb2Zmc2V0cyB0byB0aGUgbmVhcmVzdCBzdWl0YWJsZSBzdWJwaXhlbCBiYXNlZCBvbiB0aGUgRFBSLlxuLy8gWm9vbWluZyBjYW4gY2hhbmdlIHRoZSBEUFIsIGJ1dCBpdCBzZWVtcyB0byByZXBvcnQgYSB2YWx1ZSB0aGF0IHdpbGxcbi8vIGNsZWFubHkgZGl2aWRlIHRoZSB2YWx1ZXMgaW50byB0aGUgYXBwcm9wcmlhdGUgc3VicGl4ZWxzLlxuXG5mdW5jdGlvbiByb3VuZE9mZnNldHNCeURQUihfcmVmKSB7XG4gIHZhciB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueTtcbiAgdmFyIHdpbiA9IHdpbmRvdztcbiAgdmFyIGRwciA9IHdpbi5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gIHJldHVybiB7XG4gICAgeDogcm91bmQoeCAqIGRwcikgLyBkcHIgfHwgMCxcbiAgICB5OiByb3VuZCh5ICogZHByKSAvIGRwciB8fCAwXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXBUb1N0eWxlcyhfcmVmMikge1xuICB2YXIgX09iamVjdCRhc3NpZ24yO1xuXG4gIHZhciBwb3BwZXIgPSBfcmVmMi5wb3BwZXIsXG4gICAgICBwb3BwZXJSZWN0ID0gX3JlZjIucG9wcGVyUmVjdCxcbiAgICAgIHBsYWNlbWVudCA9IF9yZWYyLnBsYWNlbWVudCxcbiAgICAgIHZhcmlhdGlvbiA9IF9yZWYyLnZhcmlhdGlvbixcbiAgICAgIG9mZnNldHMgPSBfcmVmMi5vZmZzZXRzLFxuICAgICAgcG9zaXRpb24gPSBfcmVmMi5wb3NpdGlvbixcbiAgICAgIGdwdUFjY2VsZXJhdGlvbiA9IF9yZWYyLmdwdUFjY2VsZXJhdGlvbixcbiAgICAgIGFkYXB0aXZlID0gX3JlZjIuYWRhcHRpdmUsXG4gICAgICByb3VuZE9mZnNldHMgPSBfcmVmMi5yb3VuZE9mZnNldHMsXG4gICAgICBpc0ZpeGVkID0gX3JlZjIuaXNGaXhlZDtcbiAgdmFyIF9vZmZzZXRzJHggPSBvZmZzZXRzLngsXG4gICAgICB4ID0gX29mZnNldHMkeCA9PT0gdm9pZCAwID8gMCA6IF9vZmZzZXRzJHgsXG4gICAgICBfb2Zmc2V0cyR5ID0gb2Zmc2V0cy55LFxuICAgICAgeSA9IF9vZmZzZXRzJHkgPT09IHZvaWQgMCA/IDAgOiBfb2Zmc2V0cyR5O1xuXG4gIHZhciBfcmVmMyA9IHR5cGVvZiByb3VuZE9mZnNldHMgPT09ICdmdW5jdGlvbicgPyByb3VuZE9mZnNldHMoe1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9KSA6IHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfTtcblxuICB4ID0gX3JlZjMueDtcbiAgeSA9IF9yZWYzLnk7XG4gIHZhciBoYXNYID0gb2Zmc2V0cy5oYXNPd25Qcm9wZXJ0eSgneCcpO1xuICB2YXIgaGFzWSA9IG9mZnNldHMuaGFzT3duUHJvcGVydHkoJ3knKTtcbiAgdmFyIHNpZGVYID0gbGVmdDtcbiAgdmFyIHNpZGVZID0gdG9wO1xuICB2YXIgd2luID0gd2luZG93O1xuXG4gIGlmIChhZGFwdGl2ZSkge1xuICAgIHZhciBvZmZzZXRQYXJlbnQgPSBnZXRPZmZzZXRQYXJlbnQocG9wcGVyKTtcbiAgICB2YXIgaGVpZ2h0UHJvcCA9ICdjbGllbnRIZWlnaHQnO1xuICAgIHZhciB3aWR0aFByb3AgPSAnY2xpZW50V2lkdGgnO1xuXG4gICAgaWYgKG9mZnNldFBhcmVudCA9PT0gZ2V0V2luZG93KHBvcHBlcikpIHtcbiAgICAgIG9mZnNldFBhcmVudCA9IGdldERvY3VtZW50RWxlbWVudChwb3BwZXIpO1xuXG4gICAgICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uICE9PSAnc3RhdGljJyAmJiBwb3NpdGlvbiA9PT0gJ2Fic29sdXRlJykge1xuICAgICAgICBoZWlnaHRQcm9wID0gJ3Njcm9sbEhlaWdodCc7XG4gICAgICAgIHdpZHRoUHJvcCA9ICdzY3JvbGxXaWR0aCc7XG4gICAgICB9XG4gICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYXN0XTogZm9yY2UgdHlwZSByZWZpbmVtZW50LCB3ZSBjb21wYXJlIG9mZnNldFBhcmVudCB3aXRoIHdpbmRvdyBhYm92ZSwgYnV0IEZsb3cgZG9lc24ndCBkZXRlY3QgaXRcblxuXG4gICAgb2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50O1xuXG4gICAgaWYgKHBsYWNlbWVudCA9PT0gdG9wIHx8IChwbGFjZW1lbnQgPT09IGxlZnQgfHwgcGxhY2VtZW50ID09PSByaWdodCkgJiYgdmFyaWF0aW9uID09PSBlbmQpIHtcbiAgICAgIHNpZGVZID0gYm90dG9tO1xuICAgICAgdmFyIG9mZnNldFkgPSBpc0ZpeGVkICYmIG9mZnNldFBhcmVudCA9PT0gd2luICYmIHdpbi52aXN1YWxWaWV3cG9ydCA/IHdpbi52aXN1YWxWaWV3cG9ydC5oZWlnaHQgOiAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICAgIG9mZnNldFBhcmVudFtoZWlnaHRQcm9wXTtcbiAgICAgIHkgLT0gb2Zmc2V0WSAtIHBvcHBlclJlY3QuaGVpZ2h0O1xuICAgICAgeSAqPSBncHVBY2NlbGVyYXRpb24gPyAxIDogLTE7XG4gICAgfVxuXG4gICAgaWYgKHBsYWNlbWVudCA9PT0gbGVmdCB8fCAocGxhY2VtZW50ID09PSB0b3AgfHwgcGxhY2VtZW50ID09PSBib3R0b20pICYmIHZhcmlhdGlvbiA9PT0gZW5kKSB7XG4gICAgICBzaWRlWCA9IHJpZ2h0O1xuICAgICAgdmFyIG9mZnNldFggPSBpc0ZpeGVkICYmIG9mZnNldFBhcmVudCA9PT0gd2luICYmIHdpbi52aXN1YWxWaWV3cG9ydCA/IHdpbi52aXN1YWxWaWV3cG9ydC53aWR0aCA6IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgICAgb2Zmc2V0UGFyZW50W3dpZHRoUHJvcF07XG4gICAgICB4IC09IG9mZnNldFggLSBwb3BwZXJSZWN0LndpZHRoO1xuICAgICAgeCAqPSBncHVBY2NlbGVyYXRpb24gPyAxIDogLTE7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbW1vblN0eWxlcyA9IE9iamVjdC5hc3NpZ24oe1xuICAgIHBvc2l0aW9uOiBwb3NpdGlvblxuICB9LCBhZGFwdGl2ZSAmJiB1bnNldFNpZGVzKTtcblxuICB2YXIgX3JlZjQgPSByb3VuZE9mZnNldHMgPT09IHRydWUgPyByb3VuZE9mZnNldHNCeURQUih7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH0pIDoge1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xuXG4gIHggPSBfcmVmNC54O1xuICB5ID0gX3JlZjQueTtcblxuICBpZiAoZ3B1QWNjZWxlcmF0aW9uKSB7XG4gICAgdmFyIF9PYmplY3QkYXNzaWduO1xuXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywgKF9PYmplY3QkYXNzaWduID0ge30sIF9PYmplY3QkYXNzaWduW3NpZGVZXSA9IGhhc1kgPyAnMCcgOiAnJywgX09iamVjdCRhc3NpZ25bc2lkZVhdID0gaGFzWCA/ICcwJyA6ICcnLCBfT2JqZWN0JGFzc2lnbi50cmFuc2Zvcm0gPSAod2luLmRldmljZVBpeGVsUmF0aW8gfHwgMSkgPD0gMSA/IFwidHJhbnNsYXRlKFwiICsgeCArIFwicHgsIFwiICsgeSArIFwicHgpXCIgOiBcInRyYW5zbGF0ZTNkKFwiICsgeCArIFwicHgsIFwiICsgeSArIFwicHgsIDApXCIsIF9PYmplY3QkYXNzaWduKSk7XG4gIH1cblxuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCAoX09iamVjdCRhc3NpZ24yID0ge30sIF9PYmplY3QkYXNzaWduMltzaWRlWV0gPSBoYXNZID8geSArIFwicHhcIiA6ICcnLCBfT2JqZWN0JGFzc2lnbjJbc2lkZVhdID0gaGFzWCA/IHggKyBcInB4XCIgOiAnJywgX09iamVjdCRhc3NpZ24yLnRyYW5zZm9ybSA9ICcnLCBfT2JqZWN0JGFzc2lnbjIpKTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZVN0eWxlcyhfcmVmNSkge1xuICB2YXIgc3RhdGUgPSBfcmVmNS5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmNS5vcHRpb25zO1xuICB2YXIgX29wdGlvbnMkZ3B1QWNjZWxlcmF0ID0gb3B0aW9ucy5ncHVBY2NlbGVyYXRpb24sXG4gICAgICBncHVBY2NlbGVyYXRpb24gPSBfb3B0aW9ucyRncHVBY2NlbGVyYXQgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRncHVBY2NlbGVyYXQsXG4gICAgICBfb3B0aW9ucyRhZGFwdGl2ZSA9IG9wdGlvbnMuYWRhcHRpdmUsXG4gICAgICBhZGFwdGl2ZSA9IF9vcHRpb25zJGFkYXB0aXZlID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkYWRhcHRpdmUsXG4gICAgICBfb3B0aW9ucyRyb3VuZE9mZnNldHMgPSBvcHRpb25zLnJvdW5kT2Zmc2V0cyxcbiAgICAgIHJvdW5kT2Zmc2V0cyA9IF9vcHRpb25zJHJvdW5kT2Zmc2V0cyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHJvdW5kT2Zmc2V0cztcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgdmFyIHRyYW5zaXRpb25Qcm9wZXJ0eSA9IGdldENvbXB1dGVkU3R5bGUoc3RhdGUuZWxlbWVudHMucG9wcGVyKS50cmFuc2l0aW9uUHJvcGVydHkgfHwgJyc7XG5cbiAgICBpZiAoYWRhcHRpdmUgJiYgWyd0cmFuc2Zvcm0nLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J10uc29tZShmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgIHJldHVybiB0cmFuc2l0aW9uUHJvcGVydHkuaW5kZXhPZihwcm9wZXJ0eSkgPj0gMDtcbiAgICB9KSkge1xuICAgICAgY29uc29sZS53YXJuKFsnUG9wcGVyOiBEZXRlY3RlZCBDU1MgdHJhbnNpdGlvbnMgb24gYXQgbGVhc3Qgb25lIG9mIHRoZSBmb2xsb3dpbmcnLCAnQ1NTIHByb3BlcnRpZXM6IFwidHJhbnNmb3JtXCIsIFwidG9wXCIsIFwicmlnaHRcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCIuJywgJ1xcblxcbicsICdEaXNhYmxlIHRoZSBcImNvbXB1dGVTdHlsZXNcIiBtb2RpZmllclxcJ3MgYGFkYXB0aXZlYCBvcHRpb24gdG8gYWxsb3cnLCAnZm9yIHNtb290aCB0cmFuc2l0aW9ucywgb3IgcmVtb3ZlIHRoZXNlIHByb3BlcnRpZXMgZnJvbSB0aGUgQ1NTJywgJ3RyYW5zaXRpb24gZGVjbGFyYXRpb24gb24gdGhlIHBvcHBlciBlbGVtZW50IGlmIG9ubHkgdHJhbnNpdGlvbmluZycsICdvcGFjaXR5IG9yIGJhY2tncm91bmQtY29sb3IgZm9yIGV4YW1wbGUuJywgJ1xcblxcbicsICdXZSByZWNvbW1lbmQgdXNpbmcgdGhlIHBvcHBlciBlbGVtZW50IGFzIGEgd3JhcHBlciBhcm91bmQgYW4gaW5uZXInLCAnZWxlbWVudCB0aGF0IGNhbiBoYXZlIGFueSBDU1MgcHJvcGVydHkgdHJhbnNpdGlvbmVkIGZvciBhbmltYXRpb25zLiddLmpvaW4oJyAnKSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbW1vblN0eWxlcyA9IHtcbiAgICBwbGFjZW1lbnQ6IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KSxcbiAgICB2YXJpYXRpb246IGdldFZhcmlhdGlvbihzdGF0ZS5wbGFjZW1lbnQpLFxuICAgIHBvcHBlcjogc3RhdGUuZWxlbWVudHMucG9wcGVyLFxuICAgIHBvcHBlclJlY3Q6IHN0YXRlLnJlY3RzLnBvcHBlcixcbiAgICBncHVBY2NlbGVyYXRpb246IGdwdUFjY2VsZXJhdGlvbixcbiAgICBpc0ZpeGVkOiBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5ID09PSAnZml4ZWQnXG4gIH07XG5cbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyAhPSBudWxsKSB7XG4gICAgc3RhdGUuc3R5bGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnN0eWxlcy5wb3BwZXIsIG1hcFRvU3R5bGVzKE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywge1xuICAgICAgb2Zmc2V0czogc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLFxuICAgICAgcG9zaXRpb246IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICBhZGFwdGl2ZTogYWRhcHRpdmUsXG4gICAgICByb3VuZE9mZnNldHM6IHJvdW5kT2Zmc2V0c1xuICAgIH0pKSk7XG4gIH1cblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5hcnJvdyAhPSBudWxsKSB7XG4gICAgc3RhdGUuc3R5bGVzLmFycm93ID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuc3R5bGVzLmFycm93LCBtYXBUb1N0eWxlcyhPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIHtcbiAgICAgIG9mZnNldHM6IHN0YXRlLm1vZGlmaWVyc0RhdGEuYXJyb3csXG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIGFkYXB0aXZlOiBmYWxzZSxcbiAgICAgIHJvdW5kT2Zmc2V0czogcm91bmRPZmZzZXRzXG4gICAgfSkpKTtcbiAgfVxuXG4gIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIsIHtcbiAgICAnZGF0YS1wb3BwZXItcGxhY2VtZW50Jzogc3RhdGUucGxhY2VtZW50XG4gIH0pO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnY29tcHV0ZVN0eWxlcycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnYmVmb3JlV3JpdGUnLFxuICBmbjogY29tcHV0ZVN0eWxlcyxcbiAgZGF0YToge31cbn07IiwiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldFdpbmRvdy5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbnZhciBwYXNzaXZlID0ge1xuICBwYXNzaXZlOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBlZmZlY3QoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgaW5zdGFuY2UgPSBfcmVmLmluc3RhbmNlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucztcbiAgdmFyIF9vcHRpb25zJHNjcm9sbCA9IG9wdGlvbnMuc2Nyb2xsLFxuICAgICAgc2Nyb2xsID0gX29wdGlvbnMkc2Nyb2xsID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkc2Nyb2xsLFxuICAgICAgX29wdGlvbnMkcmVzaXplID0gb3B0aW9ucy5yZXNpemUsXG4gICAgICByZXNpemUgPSBfb3B0aW9ucyRyZXNpemUgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRyZXNpemU7XG4gIHZhciB3aW5kb3cgPSBnZXRXaW5kb3coc3RhdGUuZWxlbWVudHMucG9wcGVyKTtcbiAgdmFyIHNjcm9sbFBhcmVudHMgPSBbXS5jb25jYXQoc3RhdGUuc2Nyb2xsUGFyZW50cy5yZWZlcmVuY2UsIHN0YXRlLnNjcm9sbFBhcmVudHMucG9wcGVyKTtcblxuICBpZiAoc2Nyb2xsKSB7XG4gICAgc2Nyb2xsUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzY3JvbGxQYXJlbnQpIHtcbiAgICAgIHNjcm9sbFBhcmVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKHJlc2l6ZSkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2Nyb2xsKSB7XG4gICAgICBzY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHNjcm9sbFBhcmVudCkge1xuICAgICAgICBzY3JvbGxQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChyZXNpemUpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgIH1cbiAgfTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2V2ZW50TGlzdGVuZXJzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICd3cml0ZScsXG4gIGZuOiBmdW5jdGlvbiBmbigpIHt9LFxuICBlZmZlY3Q6IGVmZmVjdCxcbiAgZGF0YToge31cbn07IiwiaW1wb3J0IGdldE9wcG9zaXRlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRPcHBvc2l0ZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi4vdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanNcIjtcbmltcG9ydCBjb21wdXRlQXV0b1BsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvY29tcHV0ZUF1dG9QbGFjZW1lbnQuanNcIjtcbmltcG9ydCB7IGJvdHRvbSwgdG9wLCBzdGFydCwgcmlnaHQsIGxlZnQsIGF1dG8gfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4uL3V0aWxzL2dldFZhcmlhdGlvbi5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmZ1bmN0aW9uIGdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzKHBsYWNlbWVudCkge1xuICBpZiAoZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpID09PSBhdXRvKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIG9wcG9zaXRlUGxhY2VtZW50ID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgcmV0dXJuIFtnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChwbGFjZW1lbnQpLCBvcHBvc2l0ZVBsYWNlbWVudCwgZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQob3Bwb3NpdGVQbGFjZW1lbnQpXTtcbn1cblxuZnVuY3Rpb24gZmxpcChfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXS5fc2tpcCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyRtYWluQXhpcyA9IG9wdGlvbnMubWFpbkF4aXMsXG4gICAgICBjaGVja01haW5BeGlzID0gX29wdGlvbnMkbWFpbkF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRtYWluQXhpcyxcbiAgICAgIF9vcHRpb25zJGFsdEF4aXMgPSBvcHRpb25zLmFsdEF4aXMsXG4gICAgICBjaGVja0FsdEF4aXMgPSBfb3B0aW9ucyRhbHRBeGlzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkYWx0QXhpcyxcbiAgICAgIHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyA9IG9wdGlvbnMuZmFsbGJhY2tQbGFjZW1lbnRzLFxuICAgICAgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyxcbiAgICAgIGJvdW5kYXJ5ID0gb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IG9wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnkgPSBvcHRpb25zLmFsdEJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkZmxpcFZhcmlhdGlvID0gb3B0aW9ucy5mbGlwVmFyaWF0aW9ucyxcbiAgICAgIGZsaXBWYXJpYXRpb25zID0gX29wdGlvbnMkZmxpcFZhcmlhdGlvID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkZmxpcFZhcmlhdGlvLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzID0gb3B0aW9ucy5hbGxvd2VkQXV0b1BsYWNlbWVudHM7XG4gIHZhciBwcmVmZXJyZWRQbGFjZW1lbnQgPSBzdGF0ZS5vcHRpb25zLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHByZWZlcnJlZFBsYWNlbWVudCk7XG4gIHZhciBpc0Jhc2VQbGFjZW1lbnQgPSBiYXNlUGxhY2VtZW50ID09PSBwcmVmZXJyZWRQbGFjZW1lbnQ7XG4gIHZhciBmYWxsYmFja1BsYWNlbWVudHMgPSBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgfHwgKGlzQmFzZVBsYWNlbWVudCB8fCAhZmxpcFZhcmlhdGlvbnMgPyBbZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocHJlZmVycmVkUGxhY2VtZW50KV0gOiBnZXRFeHBhbmRlZEZhbGxiYWNrUGxhY2VtZW50cyhwcmVmZXJyZWRQbGFjZW1lbnQpKTtcbiAgdmFyIHBsYWNlbWVudHMgPSBbcHJlZmVycmVkUGxhY2VtZW50XS5jb25jYXQoZmFsbGJhY2tQbGFjZW1lbnRzKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIGFjYy5jb25jYXQoZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpID09PSBhdXRvID8gY29tcHV0ZUF1dG9QbGFjZW1lbnQoc3RhdGUsIHtcbiAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgICBwYWRkaW5nOiBwYWRkaW5nLFxuICAgICAgZmxpcFZhcmlhdGlvbnM6IGZsaXBWYXJpYXRpb25zLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzOiBhbGxvd2VkQXV0b1BsYWNlbWVudHNcbiAgICB9KSA6IHBsYWNlbWVudCk7XG4gIH0sIFtdKTtcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgY2hlY2tzTWFwID0gbmV3IE1hcCgpO1xuICB2YXIgbWFrZUZhbGxiYWNrQ2hlY2tzID0gdHJ1ZTtcbiAgdmFyIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudHNbMF07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbGFjZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBsYWNlbWVudCA9IHBsYWNlbWVudHNbaV07XG5cbiAgICB2YXIgX2Jhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCk7XG5cbiAgICB2YXIgaXNTdGFydFZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpID09PSBzdGFydDtcbiAgICB2YXIgaXNWZXJ0aWNhbCA9IFt0b3AsIGJvdHRvbV0uaW5kZXhPZihfYmFzZVBsYWNlbWVudCkgPj0gMDtcbiAgICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcbiAgICB2YXIgb3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5OiBhbHRCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmc6IHBhZGRpbmdcbiAgICB9KTtcbiAgICB2YXIgbWFpblZhcmlhdGlvblNpZGUgPSBpc1ZlcnRpY2FsID8gaXNTdGFydFZhcmlhdGlvbiA/IHJpZ2h0IDogbGVmdCA6IGlzU3RhcnRWYXJpYXRpb24gPyBib3R0b20gOiB0b3A7XG5cbiAgICBpZiAocmVmZXJlbmNlUmVjdFtsZW5dID4gcG9wcGVyUmVjdFtsZW5dKSB7XG4gICAgICBtYWluVmFyaWF0aW9uU2lkZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5WYXJpYXRpb25TaWRlKTtcbiAgICB9XG5cbiAgICB2YXIgYWx0VmFyaWF0aW9uU2lkZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5WYXJpYXRpb25TaWRlKTtcbiAgICB2YXIgY2hlY2tzID0gW107XG5cbiAgICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgICAgY2hlY2tzLnB1c2gob3ZlcmZsb3dbX2Jhc2VQbGFjZW1lbnRdIDw9IDApO1xuICAgIH1cblxuICAgIGlmIChjaGVja0FsdEF4aXMpIHtcbiAgICAgIGNoZWNrcy5wdXNoKG92ZXJmbG93W21haW5WYXJpYXRpb25TaWRlXSA8PSAwLCBvdmVyZmxvd1thbHRWYXJpYXRpb25TaWRlXSA8PSAwKTtcbiAgICB9XG5cbiAgICBpZiAoY2hlY2tzLmV2ZXJ5KGZ1bmN0aW9uIChjaGVjaykge1xuICAgICAgcmV0dXJuIGNoZWNrO1xuICAgIH0pKSB7XG4gICAgICBmaXJzdEZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnQ7XG4gICAgICBtYWtlRmFsbGJhY2tDaGVja3MgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNoZWNrc01hcC5zZXQocGxhY2VtZW50LCBjaGVja3MpO1xuICB9XG5cbiAgaWYgKG1ha2VGYWxsYmFja0NoZWNrcykge1xuICAgIC8vIGAyYCBtYXkgYmUgZGVzaXJlZCBpbiBzb21lIGNhc2VzIOKAkyByZXNlYXJjaCBsYXRlclxuICAgIHZhciBudW1iZXJPZkNoZWNrcyA9IGZsaXBWYXJpYXRpb25zID8gMyA6IDE7XG5cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChfaSkge1xuICAgICAgdmFyIGZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnRzLmZpbmQoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgICAgICB2YXIgY2hlY2tzID0gY2hlY2tzTWFwLmdldChwbGFjZW1lbnQpO1xuXG4gICAgICAgIGlmIChjaGVja3MpIHtcbiAgICAgICAgICByZXR1cm4gY2hlY2tzLnNsaWNlKDAsIF9pKS5ldmVyeShmdW5jdGlvbiAoY2hlY2spIHtcbiAgICAgICAgICAgIHJldHVybiBjaGVjaztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChmaXR0aW5nUGxhY2VtZW50KSB7XG4gICAgICAgIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IGZpdHRpbmdQbGFjZW1lbnQ7XG4gICAgICAgIHJldHVybiBcImJyZWFrXCI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAodmFyIF9pID0gbnVtYmVyT2ZDaGVja3M7IF9pID4gMDsgX2ktLSkge1xuICAgICAgdmFyIF9yZXQgPSBfbG9vcChfaSk7XG5cbiAgICAgIGlmIChfcmV0ID09PSBcImJyZWFrXCIpIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdGF0ZS5wbGFjZW1lbnQgIT09IGZpcnN0Rml0dGluZ1BsYWNlbWVudCkge1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0uX3NraXAgPSB0cnVlO1xuICAgIHN0YXRlLnBsYWNlbWVudCA9IGZpcnN0Rml0dGluZ1BsYWNlbWVudDtcbiAgICBzdGF0ZS5yZXNldCA9IHRydWU7XG4gIH1cbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2ZsaXAnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICBmbjogZmxpcCxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydvZmZzZXQnXSxcbiAgZGF0YToge1xuICAgIF9za2lwOiBmYWxzZVxuICB9XG59OyIsImltcG9ydCB7IHRvcCwgYm90dG9tLCBsZWZ0LCByaWdodCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gXCIuLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuXG5mdW5jdGlvbiBnZXRTaWRlT2Zmc2V0cyhvdmVyZmxvdywgcmVjdCwgcHJldmVudGVkT2Zmc2V0cykge1xuICBpZiAocHJldmVudGVkT2Zmc2V0cyA9PT0gdm9pZCAwKSB7XG4gICAgcHJldmVudGVkT2Zmc2V0cyA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdG9wOiBvdmVyZmxvdy50b3AgLSByZWN0LmhlaWdodCAtIHByZXZlbnRlZE9mZnNldHMueSxcbiAgICByaWdodDogb3ZlcmZsb3cucmlnaHQgLSByZWN0LndpZHRoICsgcHJldmVudGVkT2Zmc2V0cy54LFxuICAgIGJvdHRvbTogb3ZlcmZsb3cuYm90dG9tIC0gcmVjdC5oZWlnaHQgKyBwcmV2ZW50ZWRPZmZzZXRzLnksXG4gICAgbGVmdDogb3ZlcmZsb3cubGVmdCAtIHJlY3Qud2lkdGggLSBwcmV2ZW50ZWRPZmZzZXRzLnhcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKG92ZXJmbG93KSB7XG4gIHJldHVybiBbdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0XS5zb21lKGZ1bmN0aW9uIChzaWRlKSB7XG4gICAgcmV0dXJuIG92ZXJmbG93W3NpZGVdID49IDA7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBoaWRlKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG4gIHZhciByZWZlcmVuY2VSZWN0ID0gc3RhdGUucmVjdHMucmVmZXJlbmNlO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIHByZXZlbnRlZE9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnByZXZlbnRPdmVyZmxvdztcbiAgdmFyIHJlZmVyZW5jZU92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICBlbGVtZW50Q29udGV4dDogJ3JlZmVyZW5jZSdcbiAgfSk7XG4gIHZhciBwb3BwZXJBbHRPdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgYWx0Qm91bmRhcnk6IHRydWVcbiAgfSk7XG4gIHZhciByZWZlcmVuY2VDbGlwcGluZ09mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhyZWZlcmVuY2VPdmVyZmxvdywgcmVmZXJlbmNlUmVjdCk7XG4gIHZhciBwb3BwZXJFc2NhcGVPZmZzZXRzID0gZ2V0U2lkZU9mZnNldHMocG9wcGVyQWx0T3ZlcmZsb3csIHBvcHBlclJlY3QsIHByZXZlbnRlZE9mZnNldHMpO1xuICB2YXIgaXNSZWZlcmVuY2VIaWRkZW4gPSBpc0FueVNpZGVGdWxseUNsaXBwZWQocmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzKTtcbiAgdmFyIGhhc1BvcHBlckVzY2FwZWQgPSBpc0FueVNpZGVGdWxseUNsaXBwZWQocG9wcGVyRXNjYXBlT2Zmc2V0cyk7XG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSB7XG4gICAgcmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzOiByZWZlcmVuY2VDbGlwcGluZ09mZnNldHMsXG4gICAgcG9wcGVyRXNjYXBlT2Zmc2V0czogcG9wcGVyRXNjYXBlT2Zmc2V0cyxcbiAgICBpc1JlZmVyZW5jZUhpZGRlbjogaXNSZWZlcmVuY2VIaWRkZW4sXG4gICAgaGFzUG9wcGVyRXNjYXBlZDogaGFzUG9wcGVyRXNjYXBlZFxuICB9O1xuICBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyLCB7XG4gICAgJ2RhdGEtcG9wcGVyLXJlZmVyZW5jZS1oaWRkZW4nOiBpc1JlZmVyZW5jZUhpZGRlbixcbiAgICAnZGF0YS1wb3BwZXItZXNjYXBlZCc6IGhhc1BvcHBlckVzY2FwZWRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdoaWRlJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydwcmV2ZW50T3ZlcmZsb3cnXSxcbiAgZm46IGhpZGVcbn07IiwiZXhwb3J0IHsgZGVmYXVsdCBhcyBhcHBseVN0eWxlcyB9IGZyb20gXCIuL2FwcGx5U3R5bGVzLmpzXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGFycm93IH0gZnJvbSBcIi4vYXJyb3cuanNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgY29tcHV0ZVN0eWxlcyB9IGZyb20gXCIuL2NvbXB1dGVTdHlsZXMuanNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgZXZlbnRMaXN0ZW5lcnMgfSBmcm9tIFwiLi9ldmVudExpc3RlbmVycy5qc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBmbGlwIH0gZnJvbSBcIi4vZmxpcC5qc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBoaWRlIH0gZnJvbSBcIi4vaGlkZS5qc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBvZmZzZXQgfSBmcm9tIFwiLi9vZmZzZXQuanNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcG9wcGVyT2Zmc2V0cyB9IGZyb20gXCIuL3BvcHBlck9mZnNldHMuanNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcHJldmVudE92ZXJmbG93IH0gZnJvbSBcIi4vcHJldmVudE92ZXJmbG93LmpzXCI7IiwiaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCB7IHRvcCwgbGVmdCwgcmlnaHQsIHBsYWNlbWVudHMgfSBmcm9tIFwiLi4vZW51bXMuanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgZnVuY3Rpb24gZGlzdGFuY2VBbmRTa2lkZGluZ1RvWFkocGxhY2VtZW50LCByZWN0cywgb2Zmc2V0KSB7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICB2YXIgaW52ZXJ0RGlzdGFuY2UgPSBbbGVmdCwgdG9wXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDAgPyAtMSA6IDE7XG5cbiAgdmFyIF9yZWYgPSB0eXBlb2Ygb2Zmc2V0ID09PSAnZnVuY3Rpb24nID8gb2Zmc2V0KE9iamVjdC5hc3NpZ24oe30sIHJlY3RzLCB7XG4gICAgcGxhY2VtZW50OiBwbGFjZW1lbnRcbiAgfSkpIDogb2Zmc2V0LFxuICAgICAgc2tpZGRpbmcgPSBfcmVmWzBdLFxuICAgICAgZGlzdGFuY2UgPSBfcmVmWzFdO1xuXG4gIHNraWRkaW5nID0gc2tpZGRpbmcgfHwgMDtcbiAgZGlzdGFuY2UgPSAoZGlzdGFuY2UgfHwgMCkgKiBpbnZlcnREaXN0YW5jZTtcbiAgcmV0dXJuIFtsZWZ0LCByaWdodF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwID8ge1xuICAgIHg6IGRpc3RhbmNlLFxuICAgIHk6IHNraWRkaW5nXG4gIH0gOiB7XG4gICAgeDogc2tpZGRpbmcsXG4gICAgeTogZGlzdGFuY2VcbiAgfTtcbn1cblxuZnVuY3Rpb24gb2Zmc2V0KF9yZWYyKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYyLm9wdGlvbnMsXG4gICAgICBuYW1lID0gX3JlZjIubmFtZTtcbiAgdmFyIF9vcHRpb25zJG9mZnNldCA9IG9wdGlvbnMub2Zmc2V0LFxuICAgICAgb2Zmc2V0ID0gX29wdGlvbnMkb2Zmc2V0ID09PSB2b2lkIDAgPyBbMCwgMF0gOiBfb3B0aW9ucyRvZmZzZXQ7XG4gIHZhciBkYXRhID0gcGxhY2VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gICAgYWNjW3BsYWNlbWVudF0gPSBkaXN0YW5jZUFuZFNraWRkaW5nVG9YWShwbGFjZW1lbnQsIHN0YXRlLnJlY3RzLCBvZmZzZXQpO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbiAgdmFyIF9kYXRhJHN0YXRlJHBsYWNlbWVudCA9IGRhdGFbc3RhdGUucGxhY2VtZW50XSxcbiAgICAgIHggPSBfZGF0YSRzdGF0ZSRwbGFjZW1lbnQueCxcbiAgICAgIHkgPSBfZGF0YSRzdGF0ZSRwbGFjZW1lbnQueTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzICE9IG51bGwpIHtcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMueCArPSB4O1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cy55ICs9IHk7XG4gIH1cblxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gZGF0YTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ29mZnNldCcsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIHJlcXVpcmVzOiBbJ3BvcHBlck9mZnNldHMnXSxcbiAgZm46IG9mZnNldFxufTsiLCJpbXBvcnQgY29tcHV0ZU9mZnNldHMgZnJvbSBcIi4uL3V0aWxzL2NvbXB1dGVPZmZzZXRzLmpzXCI7XG5cbmZ1bmN0aW9uIHBvcHBlck9mZnNldHMoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgLy8gT2Zmc2V0cyBhcmUgdGhlIGFjdHVhbCBwb3NpdGlvbiB0aGUgcG9wcGVyIG5lZWRzIHRvIGhhdmUgdG8gYmVcbiAgLy8gcHJvcGVybHkgcG9zaXRpb25lZCBuZWFyIGl0cyByZWZlcmVuY2UgZWxlbWVudFxuICAvLyBUaGlzIGlzIHRoZSBtb3N0IGJhc2ljIHBsYWNlbWVudCwgYW5kIHdpbGwgYmUgYWRqdXN0ZWQgYnlcbiAgLy8gdGhlIG1vZGlmaWVycyBpbiB0aGUgbmV4dCBzdGVwXG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBjb21wdXRlT2Zmc2V0cyh7XG4gICAgcmVmZXJlbmNlOiBzdGF0ZS5yZWN0cy5yZWZlcmVuY2UsXG4gICAgZWxlbWVudDogc3RhdGUucmVjdHMucG9wcGVyLFxuICAgIHN0cmF0ZWd5OiAnYWJzb2x1dGUnLFxuICAgIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50XG4gIH0pO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAncG9wcGVyT2Zmc2V0cycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAncmVhZCcsXG4gIGZuOiBwb3BwZXJPZmZzZXRzLFxuICBkYXRhOiB7fVxufTsiLCJpbXBvcnQgeyB0b3AsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHN0YXJ0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0QWx0QXhpcyBmcm9tIFwiLi4vdXRpbHMvZ2V0QWx0QXhpcy5qc1wiO1xuaW1wb3J0IHsgd2l0aGluLCB3aXRoaW5NYXhDbGFtcCB9IGZyb20gXCIuLi91dGlscy93aXRoaW4uanNcIjtcbmltcG9ydCBnZXRMYXlvdXRSZWN0IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gXCIuLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi4vdXRpbHMvZ2V0VmFyaWF0aW9uLmpzXCI7XG5pbXBvcnQgZ2V0RnJlc2hTaWRlT2JqZWN0IGZyb20gXCIuLi91dGlscy9nZXRGcmVzaFNpZGVPYmplY3QuanNcIjtcbmltcG9ydCB7IG1pbiBhcyBtYXRoTWluLCBtYXggYXMgbWF0aE1heCB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7XG5cbmZ1bmN0aW9uIHByZXZlbnRPdmVyZmxvdyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgdmFyIF9vcHRpb25zJG1haW5BeGlzID0gb3B0aW9ucy5tYWluQXhpcyxcbiAgICAgIGNoZWNrTWFpbkF4aXMgPSBfb3B0aW9ucyRtYWluQXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJG1haW5BeGlzLFxuICAgICAgX29wdGlvbnMkYWx0QXhpcyA9IG9wdGlvbnMuYWx0QXhpcyxcbiAgICAgIGNoZWNrQWx0QXhpcyA9IF9vcHRpb25zJGFsdEF4aXMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkYWx0QXhpcyxcbiAgICAgIGJvdW5kYXJ5ID0gb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IG9wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnkgPSBvcHRpb25zLmFsdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyxcbiAgICAgIF9vcHRpb25zJHRldGhlciA9IG9wdGlvbnMudGV0aGVyLFxuICAgICAgdGV0aGVyID0gX29wdGlvbnMkdGV0aGVyID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkdGV0aGVyLFxuICAgICAgX29wdGlvbnMkdGV0aGVyT2Zmc2V0ID0gb3B0aW9ucy50ZXRoZXJPZmZzZXQsXG4gICAgICB0ZXRoZXJPZmZzZXQgPSBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQgPT09IHZvaWQgMCA/IDAgOiBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQ7XG4gIHZhciBvdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgIHBhZGRpbmc6IHBhZGRpbmcsXG4gICAgYWx0Qm91bmRhcnk6IGFsdEJvdW5kYXJ5XG4gIH0pO1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KTtcbiAgdmFyIHZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihzdGF0ZS5wbGFjZW1lbnQpO1xuICB2YXIgaXNCYXNlUGxhY2VtZW50ID0gIXZhcmlhdGlvbjtcbiAgdmFyIG1haW5BeGlzID0gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpO1xuICB2YXIgYWx0QXhpcyA9IGdldEFsdEF4aXMobWFpbkF4aXMpO1xuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cztcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgdGV0aGVyT2Zmc2V0VmFsdWUgPSB0eXBlb2YgdGV0aGVyT2Zmc2V0ID09PSAnZnVuY3Rpb24nID8gdGV0aGVyT2Zmc2V0KE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnJlY3RzLCB7XG4gICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSkpIDogdGV0aGVyT2Zmc2V0O1xuICB2YXIgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlID0gdHlwZW9mIHRldGhlck9mZnNldFZhbHVlID09PSAnbnVtYmVyJyA/IHtcbiAgICBtYWluQXhpczogdGV0aGVyT2Zmc2V0VmFsdWUsXG4gICAgYWx0QXhpczogdGV0aGVyT2Zmc2V0VmFsdWVcbiAgfSA6IE9iamVjdC5hc3NpZ24oe1xuICAgIG1haW5BeGlzOiAwLFxuICAgIGFsdEF4aXM6IDBcbiAgfSwgdGV0aGVyT2Zmc2V0VmFsdWUpO1xuICB2YXIgb2Zmc2V0TW9kaWZpZXJTdGF0ZSA9IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0ID8gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXRbc3RhdGUucGxhY2VtZW50XSA6IG51bGw7XG4gIHZhciBkYXRhID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuXG4gIGlmICghcG9wcGVyT2Zmc2V0cykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgdmFyIF9vZmZzZXRNb2RpZmllclN0YXRlJDtcblxuICAgIHZhciBtYWluU2lkZSA9IG1haW5BeGlzID09PSAneScgPyB0b3AgOiBsZWZ0O1xuICAgIHZhciBhbHRTaWRlID0gbWFpbkF4aXMgPT09ICd5JyA/IGJvdHRvbSA6IHJpZ2h0O1xuICAgIHZhciBsZW4gPSBtYWluQXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgIHZhciBvZmZzZXQgPSBwb3BwZXJPZmZzZXRzW21haW5BeGlzXTtcbiAgICB2YXIgbWluID0gb2Zmc2V0ICsgb3ZlcmZsb3dbbWFpblNpZGVdO1xuICAgIHZhciBtYXggPSBvZmZzZXQgLSBvdmVyZmxvd1thbHRTaWRlXTtcbiAgICB2YXIgYWRkaXRpdmUgPSB0ZXRoZXIgPyAtcG9wcGVyUmVjdFtsZW5dIC8gMiA6IDA7XG4gICAgdmFyIG1pbkxlbiA9IHZhcmlhdGlvbiA9PT0gc3RhcnQgPyByZWZlcmVuY2VSZWN0W2xlbl0gOiBwb3BwZXJSZWN0W2xlbl07XG4gICAgdmFyIG1heExlbiA9IHZhcmlhdGlvbiA9PT0gc3RhcnQgPyAtcG9wcGVyUmVjdFtsZW5dIDogLXJlZmVyZW5jZVJlY3RbbGVuXTsgLy8gV2UgbmVlZCB0byBpbmNsdWRlIHRoZSBhcnJvdyBpbiB0aGUgY2FsY3VsYXRpb24gc28gdGhlIGFycm93IGRvZXNuJ3QgZ29cbiAgICAvLyBvdXRzaWRlIHRoZSByZWZlcmVuY2UgYm91bmRzXG5cbiAgICB2YXIgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3c7XG4gICAgdmFyIGFycm93UmVjdCA9IHRldGhlciAmJiBhcnJvd0VsZW1lbnQgPyBnZXRMYXlvdXRSZWN0KGFycm93RWxlbWVudCkgOiB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMFxuICAgIH07XG4gICAgdmFyIGFycm93UGFkZGluZ09iamVjdCA9IHN0YXRlLm1vZGlmaWVyc0RhdGFbJ2Fycm93I3BlcnNpc3RlbnQnXSA/IHN0YXRlLm1vZGlmaWVyc0RhdGFbJ2Fycm93I3BlcnNpc3RlbnQnXS5wYWRkaW5nIDogZ2V0RnJlc2hTaWRlT2JqZWN0KCk7XG4gICAgdmFyIGFycm93UGFkZGluZ01pbiA9IGFycm93UGFkZGluZ09iamVjdFttYWluU2lkZV07XG4gICAgdmFyIGFycm93UGFkZGluZ01heCA9IGFycm93UGFkZGluZ09iamVjdFthbHRTaWRlXTsgLy8gSWYgdGhlIHJlZmVyZW5jZSBsZW5ndGggaXMgc21hbGxlciB0aGFuIHRoZSBhcnJvdyBsZW5ndGgsIHdlIGRvbid0IHdhbnRcbiAgICAvLyB0byBpbmNsdWRlIGl0cyBmdWxsIHNpemUgaW4gdGhlIGNhbGN1bGF0aW9uLiBJZiB0aGUgcmVmZXJlbmNlIGlzIHNtYWxsXG4gICAgLy8gYW5kIG5lYXIgdGhlIGVkZ2Ugb2YgYSBib3VuZGFyeSwgdGhlIHBvcHBlciBjYW4gb3ZlcmZsb3cgZXZlbiBpZiB0aGVcbiAgICAvLyByZWZlcmVuY2UgaXMgbm90IG92ZXJmbG93aW5nIGFzIHdlbGwgKGUuZy4gdmlydHVhbCBlbGVtZW50cyB3aXRoIG5vXG4gICAgLy8gd2lkdGggb3IgaGVpZ2h0KVxuXG4gICAgdmFyIGFycm93TGVuID0gd2l0aGluKDAsIHJlZmVyZW5jZVJlY3RbbGVuXSwgYXJyb3dSZWN0W2xlbl0pO1xuICAgIHZhciBtaW5PZmZzZXQgPSBpc0Jhc2VQbGFjZW1lbnQgPyByZWZlcmVuY2VSZWN0W2xlbl0gLyAyIC0gYWRkaXRpdmUgLSBhcnJvd0xlbiAtIGFycm93UGFkZGluZ01pbiAtIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcyA6IG1pbkxlbiAtIGFycm93TGVuIC0gYXJyb3dQYWRkaW5nTWluIC0gbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzO1xuICAgIHZhciBtYXhPZmZzZXQgPSBpc0Jhc2VQbGFjZW1lbnQgPyAtcmVmZXJlbmNlUmVjdFtsZW5dIC8gMiArIGFkZGl0aXZlICsgYXJyb3dMZW4gKyBhcnJvd1BhZGRpbmdNYXggKyBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXMgOiBtYXhMZW4gKyBhcnJvd0xlbiArIGFycm93UGFkZGluZ01heCArIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcztcbiAgICB2YXIgYXJyb3dPZmZzZXRQYXJlbnQgPSBzdGF0ZS5lbGVtZW50cy5hcnJvdyAmJiBnZXRPZmZzZXRQYXJlbnQoc3RhdGUuZWxlbWVudHMuYXJyb3cpO1xuICAgIHZhciBjbGllbnRPZmZzZXQgPSBhcnJvd09mZnNldFBhcmVudCA/IG1haW5BeGlzID09PSAneScgPyBhcnJvd09mZnNldFBhcmVudC5jbGllbnRUb3AgfHwgMCA6IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudExlZnQgfHwgMCA6IDA7XG4gICAgdmFyIG9mZnNldE1vZGlmaWVyVmFsdWUgPSAoX29mZnNldE1vZGlmaWVyU3RhdGUkID0gb2Zmc2V0TW9kaWZpZXJTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogb2Zmc2V0TW9kaWZpZXJTdGF0ZVttYWluQXhpc10pICE9IG51bGwgPyBfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQgOiAwO1xuICAgIHZhciB0ZXRoZXJNaW4gPSBvZmZzZXQgKyBtaW5PZmZzZXQgLSBvZmZzZXRNb2RpZmllclZhbHVlIC0gY2xpZW50T2Zmc2V0O1xuICAgIHZhciB0ZXRoZXJNYXggPSBvZmZzZXQgKyBtYXhPZmZzZXQgLSBvZmZzZXRNb2RpZmllclZhbHVlO1xuICAgIHZhciBwcmV2ZW50ZWRPZmZzZXQgPSB3aXRoaW4odGV0aGVyID8gbWF0aE1pbihtaW4sIHRldGhlck1pbikgOiBtaW4sIG9mZnNldCwgdGV0aGVyID8gbWF0aE1heChtYXgsIHRldGhlck1heCkgOiBtYXgpO1xuICAgIHBvcHBlck9mZnNldHNbbWFpbkF4aXNdID0gcHJldmVudGVkT2Zmc2V0O1xuICAgIGRhdGFbbWFpbkF4aXNdID0gcHJldmVudGVkT2Zmc2V0IC0gb2Zmc2V0O1xuICB9XG5cbiAgaWYgKGNoZWNrQWx0QXhpcykge1xuICAgIHZhciBfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQyO1xuXG4gICAgdmFyIF9tYWluU2lkZSA9IG1haW5BeGlzID09PSAneCcgPyB0b3AgOiBsZWZ0O1xuXG4gICAgdmFyIF9hbHRTaWRlID0gbWFpbkF4aXMgPT09ICd4JyA/IGJvdHRvbSA6IHJpZ2h0O1xuXG4gICAgdmFyIF9vZmZzZXQgPSBwb3BwZXJPZmZzZXRzW2FsdEF4aXNdO1xuXG4gICAgdmFyIF9sZW4gPSBhbHRBeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgICB2YXIgX21pbiA9IF9vZmZzZXQgKyBvdmVyZmxvd1tfbWFpblNpZGVdO1xuXG4gICAgdmFyIF9tYXggPSBfb2Zmc2V0IC0gb3ZlcmZsb3dbX2FsdFNpZGVdO1xuXG4gICAgdmFyIGlzT3JpZ2luU2lkZSA9IFt0b3AsIGxlZnRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuXG4gICAgdmFyIF9vZmZzZXRNb2RpZmllclZhbHVlID0gKF9vZmZzZXRNb2RpZmllclN0YXRlJDIgPSBvZmZzZXRNb2RpZmllclN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBvZmZzZXRNb2RpZmllclN0YXRlW2FsdEF4aXNdKSAhPSBudWxsID8gX29mZnNldE1vZGlmaWVyU3RhdGUkMiA6IDA7XG5cbiAgICB2YXIgX3RldGhlck1pbiA9IGlzT3JpZ2luU2lkZSA/IF9taW4gOiBfb2Zmc2V0IC0gcmVmZXJlbmNlUmVjdFtfbGVuXSAtIHBvcHBlclJlY3RbX2xlbl0gLSBfb2Zmc2V0TW9kaWZpZXJWYWx1ZSArIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5hbHRBeGlzO1xuXG4gICAgdmFyIF90ZXRoZXJNYXggPSBpc09yaWdpblNpZGUgPyBfb2Zmc2V0ICsgcmVmZXJlbmNlUmVjdFtfbGVuXSArIHBvcHBlclJlY3RbX2xlbl0gLSBfb2Zmc2V0TW9kaWZpZXJWYWx1ZSAtIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5hbHRBeGlzIDogX21heDtcblxuICAgIHZhciBfcHJldmVudGVkT2Zmc2V0ID0gdGV0aGVyICYmIGlzT3JpZ2luU2lkZSA/IHdpdGhpbk1heENsYW1wKF90ZXRoZXJNaW4sIF9vZmZzZXQsIF90ZXRoZXJNYXgpIDogd2l0aGluKHRldGhlciA/IF90ZXRoZXJNaW4gOiBfbWluLCBfb2Zmc2V0LCB0ZXRoZXIgPyBfdGV0aGVyTWF4IDogX21heCk7XG5cbiAgICBwb3BwZXJPZmZzZXRzW2FsdEF4aXNdID0gX3ByZXZlbnRlZE9mZnNldDtcbiAgICBkYXRhW2FsdEF4aXNdID0gX3ByZXZlbnRlZE9mZnNldCAtIF9vZmZzZXQ7XG4gIH1cblxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gZGF0YTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ3ByZXZlbnRPdmVyZmxvdycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIGZuOiBwcmV2ZW50T3ZlcmZsb3csXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsnb2Zmc2V0J11cbn07IiwiaW1wb3J0IHsgcG9wcGVyR2VuZXJhdG9yLCBkZXRlY3RPdmVyZmxvdyB9IGZyb20gXCIuL2NyZWF0ZVBvcHBlci5qc1wiO1xuaW1wb3J0IGV2ZW50TGlzdGVuZXJzIGZyb20gXCIuL21vZGlmaWVycy9ldmVudExpc3RlbmVycy5qc1wiO1xuaW1wb3J0IHBvcHBlck9mZnNldHMgZnJvbSBcIi4vbW9kaWZpZXJzL3BvcHBlck9mZnNldHMuanNcIjtcbmltcG9ydCBjb21wdXRlU3R5bGVzIGZyb20gXCIuL21vZGlmaWVycy9jb21wdXRlU3R5bGVzLmpzXCI7XG5pbXBvcnQgYXBwbHlTdHlsZXMgZnJvbSBcIi4vbW9kaWZpZXJzL2FwcGx5U3R5bGVzLmpzXCI7XG52YXIgZGVmYXVsdE1vZGlmaWVycyA9IFtldmVudExpc3RlbmVycywgcG9wcGVyT2Zmc2V0cywgY29tcHV0ZVN0eWxlcywgYXBwbHlTdHlsZXNdO1xudmFyIGNyZWF0ZVBvcHBlciA9IC8qI19fUFVSRV9fKi9wb3BwZXJHZW5lcmF0b3Ioe1xuICBkZWZhdWx0TW9kaWZpZXJzOiBkZWZhdWx0TW9kaWZpZXJzXG59KTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgeyBjcmVhdGVQb3BwZXIsIHBvcHBlckdlbmVyYXRvciwgZGVmYXVsdE1vZGlmaWVycywgZGV0ZWN0T3ZlcmZsb3cgfTsiLCJpbXBvcnQgeyBwb3BwZXJHZW5lcmF0b3IsIGRldGVjdE92ZXJmbG93IH0gZnJvbSBcIi4vY3JlYXRlUG9wcGVyLmpzXCI7XG5pbXBvcnQgZXZlbnRMaXN0ZW5lcnMgZnJvbSBcIi4vbW9kaWZpZXJzL2V2ZW50TGlzdGVuZXJzLmpzXCI7XG5pbXBvcnQgcG9wcGVyT2Zmc2V0cyBmcm9tIFwiLi9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cy5qc1wiO1xuaW1wb3J0IGNvbXB1dGVTdHlsZXMgZnJvbSBcIi4vbW9kaWZpZXJzL2NvbXB1dGVTdHlsZXMuanNcIjtcbmltcG9ydCBhcHBseVN0eWxlcyBmcm9tIFwiLi9tb2RpZmllcnMvYXBwbHlTdHlsZXMuanNcIjtcbmltcG9ydCBvZmZzZXQgZnJvbSBcIi4vbW9kaWZpZXJzL29mZnNldC5qc1wiO1xuaW1wb3J0IGZsaXAgZnJvbSBcIi4vbW9kaWZpZXJzL2ZsaXAuanNcIjtcbmltcG9ydCBwcmV2ZW50T3ZlcmZsb3cgZnJvbSBcIi4vbW9kaWZpZXJzL3ByZXZlbnRPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGFycm93IGZyb20gXCIuL21vZGlmaWVycy9hcnJvdy5qc1wiO1xuaW1wb3J0IGhpZGUgZnJvbSBcIi4vbW9kaWZpZXJzL2hpZGUuanNcIjtcbnZhciBkZWZhdWx0TW9kaWZpZXJzID0gW2V2ZW50TGlzdGVuZXJzLCBwb3BwZXJPZmZzZXRzLCBjb21wdXRlU3R5bGVzLCBhcHBseVN0eWxlcywgb2Zmc2V0LCBmbGlwLCBwcmV2ZW50T3ZlcmZsb3csIGFycm93LCBoaWRlXTtcbnZhciBjcmVhdGVQb3BwZXIgPSAvKiNfX1BVUkVfXyovcG9wcGVyR2VuZXJhdG9yKHtcbiAgZGVmYXVsdE1vZGlmaWVyczogZGVmYXVsdE1vZGlmaWVyc1xufSk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IHsgY3JlYXRlUG9wcGVyLCBwb3BwZXJHZW5lcmF0b3IsIGRlZmF1bHRNb2RpZmllcnMsIGRldGVjdE92ZXJmbG93IH07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IHsgY3JlYXRlUG9wcGVyIGFzIGNyZWF0ZVBvcHBlckxpdGUgfSBmcm9tIFwiLi9wb3BwZXItbGl0ZS5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCAqIGZyb20gXCIuL21vZGlmaWVycy9pbmRleC5qc1wiOyIsImltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4vZ2V0VmFyaWF0aW9uLmpzXCI7XG5pbXBvcnQgeyB2YXJpYXRpb25QbGFjZW1lbnRzLCBiYXNlUGxhY2VtZW50cywgcGxhY2VtZW50cyBhcyBhbGxQbGFjZW1lbnRzIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4vZGV0ZWN0T3ZlcmZsb3cuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNvbXB1dGVBdXRvUGxhY2VtZW50KHN0YXRlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgcGxhY2VtZW50ID0gX29wdGlvbnMucGxhY2VtZW50LFxuICAgICAgYm91bmRhcnkgPSBfb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IF9vcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmcgPSBfb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgZmxpcFZhcmlhdGlvbnMgPSBfb3B0aW9ucy5mbGlwVmFyaWF0aW9ucyxcbiAgICAgIF9vcHRpb25zJGFsbG93ZWRBdXRvUCA9IF9vcHRpb25zLmFsbG93ZWRBdXRvUGxhY2VtZW50cyxcbiAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50cyA9IF9vcHRpb25zJGFsbG93ZWRBdXRvUCA9PT0gdm9pZCAwID8gYWxsUGxhY2VtZW50cyA6IF9vcHRpb25zJGFsbG93ZWRBdXRvUDtcbiAgdmFyIHZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpO1xuICB2YXIgcGxhY2VtZW50cyA9IHZhcmlhdGlvbiA/IGZsaXBWYXJpYXRpb25zID8gdmFyaWF0aW9uUGxhY2VtZW50cyA6IHZhcmlhdGlvblBsYWNlbWVudHMuZmlsdGVyKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgPT09IHZhcmlhdGlvbjtcbiAgfSkgOiBiYXNlUGxhY2VtZW50cztcbiAgdmFyIGFsbG93ZWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cy5maWx0ZXIoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgIHJldHVybiBhbGxvd2VkQXV0b1BsYWNlbWVudHMuaW5kZXhPZihwbGFjZW1lbnQpID49IDA7XG4gIH0pO1xuXG4gIGlmIChhbGxvd2VkUGxhY2VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBhbGxvd2VkUGxhY2VtZW50cyA9IHBsYWNlbWVudHM7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFsnUG9wcGVyOiBUaGUgYGFsbG93ZWRBdXRvUGxhY2VtZW50c2Agb3B0aW9uIGRpZCBub3QgYWxsb3cgYW55JywgJ3BsYWNlbWVudHMuIEVuc3VyZSB0aGUgYHBsYWNlbWVudGAgb3B0aW9uIG1hdGNoZXMgdGhlIHZhcmlhdGlvbicsICdvZiB0aGUgYWxsb3dlZCBwbGFjZW1lbnRzLicsICdGb3IgZXhhbXBsZSwgXCJhdXRvXCIgY2Fubm90IGJlIHVzZWQgdG8gYWxsb3cgXCJib3R0b20tc3RhcnRcIi4nLCAnVXNlIFwiYXV0by1zdGFydFwiIGluc3RlYWQuJ10uam9pbignICcpKTtcbiAgICB9XG4gIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV06IEZsb3cgc2VlbXMgdG8gaGF2ZSBwcm9ibGVtcyB3aXRoIHR3byBhcnJheSB1bmlvbnMuLi5cblxuXG4gIHZhciBvdmVyZmxvd3MgPSBhbGxvd2VkUGxhY2VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gICAgYWNjW3BsYWNlbWVudF0gPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmc6IHBhZGRpbmdcbiAgICB9KVtnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCldO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG92ZXJmbG93cykuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBvdmVyZmxvd3NbYV0gLSBvdmVyZmxvd3NbYl07XG4gIH0pO1xufSIsImltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4vZ2V0VmFyaWF0aW9uLmpzXCI7XG5pbXBvcnQgZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50IGZyb20gXCIuL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IHsgdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0LCBzdGFydCwgZW5kIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wdXRlT2Zmc2V0cyhfcmVmKSB7XG4gIHZhciByZWZlcmVuY2UgPSBfcmVmLnJlZmVyZW5jZSxcbiAgICAgIGVsZW1lbnQgPSBfcmVmLmVsZW1lbnQsXG4gICAgICBwbGFjZW1lbnQgPSBfcmVmLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQgPyBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgOiBudWxsO1xuICB2YXIgdmFyaWF0aW9uID0gcGxhY2VtZW50ID8gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgOiBudWxsO1xuICB2YXIgY29tbW9uWCA9IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoIC8gMiAtIGVsZW1lbnQud2lkdGggLyAyO1xuICB2YXIgY29tbW9uWSA9IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodCAvIDIgLSBlbGVtZW50LmhlaWdodCAvIDI7XG4gIHZhciBvZmZzZXRzO1xuXG4gIHN3aXRjaCAoYmFzZVBsYWNlbWVudCkge1xuICAgIGNhc2UgdG9wOlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgLSBlbGVtZW50LmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBib3R0b206XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcmlnaHQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCxcbiAgICAgICAgeTogY29tbW9uWVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBsZWZ0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLnggLSBlbGVtZW50LndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLngsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55XG4gICAgICB9O1xuICB9XG5cbiAgdmFyIG1haW5BeGlzID0gYmFzZVBsYWNlbWVudCA/IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KSA6IG51bGw7XG5cbiAgaWYgKG1haW5BeGlzICE9IG51bGwpIHtcbiAgICB2YXIgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICAgIHN3aXRjaCAodmFyaWF0aW9uKSB7XG4gICAgICBjYXNlIHN0YXJ0OlxuICAgICAgICBvZmZzZXRzW21haW5BeGlzXSA9IG9mZnNldHNbbWFpbkF4aXNdIC0gKHJlZmVyZW5jZVtsZW5dIC8gMiAtIGVsZW1lbnRbbGVuXSAvIDIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBlbmQ6XG4gICAgICAgIG9mZnNldHNbbWFpbkF4aXNdID0gb2Zmc2V0c1ttYWluQXhpc10gKyAocmVmZXJlbmNlW2xlbl0gLyAyIC0gZWxlbWVudFtsZW5dIC8gMik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvZmZzZXRzO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRlYm91bmNlKGZuKSB7XG4gIHZhciBwZW5kaW5nO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghcGVuZGluZykge1xuICAgICAgcGVuZGluZyA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHBlbmRpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgcmVzb2x2ZShmbigpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGVuZGluZztcbiAgfTtcbn0iLCJpbXBvcnQgZ2V0Q2xpcHBpbmdSZWN0IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0Q2xpcHBpbmdSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgY29tcHV0ZU9mZnNldHMgZnJvbSBcIi4vY29tcHV0ZU9mZnNldHMuanNcIjtcbmltcG9ydCByZWN0VG9DbGllbnRSZWN0IGZyb20gXCIuL3JlY3RUb0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCB7IGNsaXBwaW5nUGFyZW50cywgcmVmZXJlbmNlLCBwb3BwZXIsIGJvdHRvbSwgdG9wLCByaWdodCwgYmFzZVBsYWNlbWVudHMsIHZpZXdwb3J0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgeyBpc0VsZW1lbnQgfSBmcm9tIFwiLi4vZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBtZXJnZVBhZGRpbmdPYmplY3QgZnJvbSBcIi4vbWVyZ2VQYWRkaW5nT2JqZWN0LmpzXCI7XG5pbXBvcnQgZXhwYW5kVG9IYXNoTWFwIGZyb20gXCIuL2V4cGFuZFRvSGFzaE1hcC5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRldGVjdE92ZXJmbG93KHN0YXRlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgX29wdGlvbnMkcGxhY2VtZW50ID0gX29wdGlvbnMucGxhY2VtZW50LFxuICAgICAgcGxhY2VtZW50ID0gX29wdGlvbnMkcGxhY2VtZW50ID09PSB2b2lkIDAgPyBzdGF0ZS5wbGFjZW1lbnQgOiBfb3B0aW9ucyRwbGFjZW1lbnQsXG4gICAgICBfb3B0aW9ucyRib3VuZGFyeSA9IF9vcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgYm91bmRhcnkgPSBfb3B0aW9ucyRib3VuZGFyeSA9PT0gdm9pZCAwID8gY2xpcHBpbmdQYXJlbnRzIDogX29wdGlvbnMkYm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRyb290Qm91bmRhcnkgPSBfb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnkgPSBfb3B0aW9ucyRyb290Qm91bmRhcnkgPT09IHZvaWQgMCA/IHZpZXdwb3J0IDogX29wdGlvbnMkcm9vdEJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkZWxlbWVudENvbnRlID0gX29wdGlvbnMuZWxlbWVudENvbnRleHQsXG4gICAgICBlbGVtZW50Q29udGV4dCA9IF9vcHRpb25zJGVsZW1lbnRDb250ZSA9PT0gdm9pZCAwID8gcG9wcGVyIDogX29wdGlvbnMkZWxlbWVudENvbnRlLFxuICAgICAgX29wdGlvbnMkYWx0Qm91bmRhcnkgPSBfb3B0aW9ucy5hbHRCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5ID0gX29wdGlvbnMkYWx0Qm91bmRhcnkgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkYWx0Qm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRwYWRkaW5nID0gX29wdGlvbnMucGFkZGluZyxcbiAgICAgIHBhZGRpbmcgPSBfb3B0aW9ucyRwYWRkaW5nID09PSB2b2lkIDAgPyAwIDogX29wdGlvbnMkcGFkZGluZztcbiAgdmFyIHBhZGRpbmdPYmplY3QgPSBtZXJnZVBhZGRpbmdPYmplY3QodHlwZW9mIHBhZGRpbmcgIT09ICdudW1iZXInID8gcGFkZGluZyA6IGV4cGFuZFRvSGFzaE1hcChwYWRkaW5nLCBiYXNlUGxhY2VtZW50cykpO1xuICB2YXIgYWx0Q29udGV4dCA9IGVsZW1lbnRDb250ZXh0ID09PSBwb3BwZXIgPyByZWZlcmVuY2UgOiBwb3BwZXI7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW2FsdEJvdW5kYXJ5ID8gYWx0Q29udGV4dCA6IGVsZW1lbnRDb250ZXh0XTtcbiAgdmFyIGNsaXBwaW5nQ2xpZW50UmVjdCA9IGdldENsaXBwaW5nUmVjdChpc0VsZW1lbnQoZWxlbWVudCkgPyBlbGVtZW50IDogZWxlbWVudC5jb250ZXh0RWxlbWVudCB8fCBnZXREb2N1bWVudEVsZW1lbnQoc3RhdGUuZWxlbWVudHMucG9wcGVyKSwgYm91bmRhcnksIHJvb3RCb3VuZGFyeSk7XG4gIHZhciByZWZlcmVuY2VDbGllbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHN0YXRlLmVsZW1lbnRzLnJlZmVyZW5jZSk7XG4gIHZhciBwb3BwZXJPZmZzZXRzID0gY29tcHV0ZU9mZnNldHMoe1xuICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlQ2xpZW50UmVjdCxcbiAgICBlbGVtZW50OiBwb3BwZXJSZWN0LFxuICAgIHN0cmF0ZWd5OiAnYWJzb2x1dGUnLFxuICAgIHBsYWNlbWVudDogcGxhY2VtZW50XG4gIH0pO1xuICB2YXIgcG9wcGVyQ2xpZW50UmVjdCA9IHJlY3RUb0NsaWVudFJlY3QoT2JqZWN0LmFzc2lnbih7fSwgcG9wcGVyUmVjdCwgcG9wcGVyT2Zmc2V0cykpO1xuICB2YXIgZWxlbWVudENsaWVudFJlY3QgPSBlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyID8gcG9wcGVyQ2xpZW50UmVjdCA6IHJlZmVyZW5jZUNsaWVudFJlY3Q7IC8vIHBvc2l0aXZlID0gb3ZlcmZsb3dpbmcgdGhlIGNsaXBwaW5nIHJlY3RcbiAgLy8gMCBvciBuZWdhdGl2ZSA9IHdpdGhpbiB0aGUgY2xpcHBpbmcgcmVjdFxuXG4gIHZhciBvdmVyZmxvd09mZnNldHMgPSB7XG4gICAgdG9wOiBjbGlwcGluZ0NsaWVudFJlY3QudG9wIC0gZWxlbWVudENsaWVudFJlY3QudG9wICsgcGFkZGluZ09iamVjdC50b3AsXG4gICAgYm90dG9tOiBlbGVtZW50Q2xpZW50UmVjdC5ib3R0b20gLSBjbGlwcGluZ0NsaWVudFJlY3QuYm90dG9tICsgcGFkZGluZ09iamVjdC5ib3R0b20sXG4gICAgbGVmdDogY2xpcHBpbmdDbGllbnRSZWN0LmxlZnQgLSBlbGVtZW50Q2xpZW50UmVjdC5sZWZ0ICsgcGFkZGluZ09iamVjdC5sZWZ0LFxuICAgIHJpZ2h0OiBlbGVtZW50Q2xpZW50UmVjdC5yaWdodCAtIGNsaXBwaW5nQ2xpZW50UmVjdC5yaWdodCArIHBhZGRpbmdPYmplY3QucmlnaHRcbiAgfTtcbiAgdmFyIG9mZnNldERhdGEgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldDsgLy8gT2Zmc2V0cyBjYW4gYmUgYXBwbGllZCBvbmx5IHRvIHRoZSBwb3BwZXIgZWxlbWVudFxuXG4gIGlmIChlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyICYmIG9mZnNldERhdGEpIHtcbiAgICB2YXIgb2Zmc2V0ID0gb2Zmc2V0RGF0YVtwbGFjZW1lbnRdO1xuICAgIE9iamVjdC5rZXlzKG92ZXJmbG93T2Zmc2V0cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgbXVsdGlwbHkgPSBbcmlnaHQsIGJvdHRvbV0uaW5kZXhPZihrZXkpID49IDAgPyAxIDogLTE7XG4gICAgICB2YXIgYXhpcyA9IFt0b3AsIGJvdHRvbV0uaW5kZXhPZihrZXkpID49IDAgPyAneScgOiAneCc7XG4gICAgICBvdmVyZmxvd09mZnNldHNba2V5XSArPSBvZmZzZXRbYXhpc10gKiBtdWx0aXBseTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBvdmVyZmxvd09mZnNldHM7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZXhwYW5kVG9IYXNoTWFwKHZhbHVlLCBrZXlzKSB7XG4gIHJldHVybiBrZXlzLnJlZHVjZShmdW5jdGlvbiAoaGFzaE1hcCwga2V5KSB7XG4gICAgaGFzaE1hcFtrZXldID0gdmFsdWU7XG4gICAgcmV0dXJuIGhhc2hNYXA7XG4gIH0sIHt9KTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmb3JtYXQoc3RyKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiBbXS5jb25jYXQoYXJncykucmVkdWNlKGZ1bmN0aW9uIChwLCBjKSB7XG4gICAgcmV0dXJuIHAucmVwbGFjZSgvJXMvLCBjKTtcbiAgfSwgc3RyKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRBbHRBeGlzKGF4aXMpIHtcbiAgcmV0dXJuIGF4aXMgPT09ICd4JyA/ICd5JyA6ICd4Jztcbn0iLCJpbXBvcnQgeyBhdXRvIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RnJlc2hTaWRlT2JqZWN0KCkge1xuICByZXR1cm4ge1xuICAgIHRvcDogMCxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMFxuICB9O1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSA+PSAwID8gJ3gnIDogJ3knO1xufSIsInZhciBoYXNoID0ge1xuICBsZWZ0OiAncmlnaHQnLFxuICByaWdodDogJ2xlZnQnLFxuICBib3R0b206ICd0b3AnLFxuICB0b3A6ICdib3R0b20nXG59O1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIGZ1bmN0aW9uIChtYXRjaGVkKSB7XG4gICAgcmV0dXJuIGhhc2hbbWF0Y2hlZF07XG4gIH0pO1xufSIsInZhciBoYXNoID0ge1xuICBzdGFydDogJ2VuZCcsXG4gIGVuZDogJ3N0YXJ0J1xufTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL3N0YXJ0fGVuZC9nLCBmdW5jdGlvbiAobWF0Y2hlZCkge1xuICAgIHJldHVybiBoYXNoW21hdGNoZWRdO1xuICB9KTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcbn0iLCJleHBvcnQgdmFyIG1heCA9IE1hdGgubWF4O1xuZXhwb3J0IHZhciBtaW4gPSBNYXRoLm1pbjtcbmV4cG9ydCB2YXIgcm91bmQgPSBNYXRoLnJvdW5kOyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lcmdlQnlOYW1lKG1vZGlmaWVycykge1xuICB2YXIgbWVyZ2VkID0gbW9kaWZpZXJzLnJlZHVjZShmdW5jdGlvbiAobWVyZ2VkLCBjdXJyZW50KSB7XG4gICAgdmFyIGV4aXN0aW5nID0gbWVyZ2VkW2N1cnJlbnQubmFtZV07XG4gICAgbWVyZ2VkW2N1cnJlbnQubmFtZV0gPSBleGlzdGluZyA/IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLCBjdXJyZW50LCB7XG4gICAgICBvcHRpb25zOiBPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZy5vcHRpb25zLCBjdXJyZW50Lm9wdGlvbnMpLFxuICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7fSwgZXhpc3RpbmcuZGF0YSwgY3VycmVudC5kYXRhKVxuICAgIH0pIDogY3VycmVudDtcbiAgICByZXR1cm4gbWVyZ2VkO1xuICB9LCB7fSk7IC8vIElFMTEgZG9lcyBub3Qgc3VwcG9ydCBPYmplY3QudmFsdWVzXG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKG1lcmdlZCkubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gbWVyZ2VkW2tleV07XG4gIH0pO1xufSIsImltcG9ydCBnZXRGcmVzaFNpZGVPYmplY3QgZnJvbSBcIi4vZ2V0RnJlc2hTaWRlT2JqZWN0LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtZXJnZVBhZGRpbmdPYmplY3QocGFkZGluZ09iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZ2V0RnJlc2hTaWRlT2JqZWN0KCksIHBhZGRpbmdPYmplY3QpO1xufSIsImltcG9ydCB7IG1vZGlmaWVyUGhhc2VzIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7IC8vIHNvdXJjZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDk4NzUyNTVcblxuZnVuY3Rpb24gb3JkZXIobW9kaWZpZXJzKSB7XG4gIHZhciBtYXAgPSBuZXcgTWFwKCk7XG4gIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIG1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIG1hcC5zZXQobW9kaWZpZXIubmFtZSwgbW9kaWZpZXIpO1xuICB9KTsgLy8gT24gdmlzaXRpbmcgb2JqZWN0LCBjaGVjayBmb3IgaXRzIGRlcGVuZGVuY2llcyBhbmQgdmlzaXQgdGhlbSByZWN1cnNpdmVseVxuXG4gIGZ1bmN0aW9uIHNvcnQobW9kaWZpZXIpIHtcbiAgICB2aXNpdGVkLmFkZChtb2RpZmllci5uYW1lKTtcbiAgICB2YXIgcmVxdWlyZXMgPSBbXS5jb25jYXQobW9kaWZpZXIucmVxdWlyZXMgfHwgW10sIG1vZGlmaWVyLnJlcXVpcmVzSWZFeGlzdHMgfHwgW10pO1xuICAgIHJlcXVpcmVzLmZvckVhY2goZnVuY3Rpb24gKGRlcCkge1xuICAgICAgaWYgKCF2aXNpdGVkLmhhcyhkZXApKSB7XG4gICAgICAgIHZhciBkZXBNb2RpZmllciA9IG1hcC5nZXQoZGVwKTtcblxuICAgICAgICBpZiAoZGVwTW9kaWZpZXIpIHtcbiAgICAgICAgICBzb3J0KGRlcE1vZGlmaWVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJlc3VsdC5wdXNoKG1vZGlmaWVyKTtcbiAgfVxuXG4gIG1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIGlmICghdmlzaXRlZC5oYXMobW9kaWZpZXIubmFtZSkpIHtcbiAgICAgIC8vIGNoZWNrIGZvciB2aXNpdGVkIG9iamVjdFxuICAgICAgc29ydChtb2RpZmllcik7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gb3JkZXJNb2RpZmllcnMobW9kaWZpZXJzKSB7XG4gIC8vIG9yZGVyIGJhc2VkIG9uIGRlcGVuZGVuY2llc1xuICB2YXIgb3JkZXJlZE1vZGlmaWVycyA9IG9yZGVyKG1vZGlmaWVycyk7IC8vIG9yZGVyIGJhc2VkIG9uIHBoYXNlXG5cbiAgcmV0dXJuIG1vZGlmaWVyUGhhc2VzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwaGFzZSkge1xuICAgIHJldHVybiBhY2MuY29uY2F0KG9yZGVyZWRNb2RpZmllcnMuZmlsdGVyKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgICAgcmV0dXJuIG1vZGlmaWVyLnBoYXNlID09PSBwaGFzZTtcbiAgICB9KSk7XG4gIH0sIFtdKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZWN0VG9DbGllbnRSZWN0KHJlY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHJlY3QsIHtcbiAgICBsZWZ0OiByZWN0LngsXG4gICAgdG9wOiByZWN0LnksXG4gICAgcmlnaHQ6IHJlY3QueCArIHJlY3Qud2lkdGgsXG4gICAgYm90dG9tOiByZWN0LnkgKyByZWN0LmhlaWdodFxuICB9KTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1bmlxdWVCeShhcnIsIGZuKSB7XG4gIHZhciBpZGVudGlmaWVycyA9IG5ldyBTZXQoKTtcbiAgcmV0dXJuIGFyci5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICB2YXIgaWRlbnRpZmllciA9IGZuKGl0ZW0pO1xuXG4gICAgaWYgKCFpZGVudGlmaWVycy5oYXMoaWRlbnRpZmllcikpIHtcbiAgICAgIGlkZW50aWZpZXJzLmFkZChpZGVudGlmaWVyKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG59IiwiaW1wb3J0IGZvcm1hdCBmcm9tIFwiLi9mb3JtYXQuanNcIjtcbmltcG9ydCB7IG1vZGlmaWVyUGhhc2VzIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG52YXIgSU5WQUxJRF9NT0RJRklFUl9FUlJPUiA9ICdQb3BwZXI6IG1vZGlmaWVyIFwiJXNcIiBwcm92aWRlZCBhbiBpbnZhbGlkICVzIHByb3BlcnR5LCBleHBlY3RlZCAlcyBidXQgZ290ICVzJztcbnZhciBNSVNTSU5HX0RFUEVOREVOQ1lfRVJST1IgPSAnUG9wcGVyOiBtb2RpZmllciBcIiVzXCIgcmVxdWlyZXMgXCIlc1wiLCBidXQgXCIlc1wiIG1vZGlmaWVyIGlzIG5vdCBhdmFpbGFibGUnO1xudmFyIFZBTElEX1BST1BFUlRJRVMgPSBbJ25hbWUnLCAnZW5hYmxlZCcsICdwaGFzZScsICdmbicsICdlZmZlY3QnLCAncmVxdWlyZXMnLCAnb3B0aW9ucyddO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdmFsaWRhdGVNb2RpZmllcnMobW9kaWZpZXJzKSB7XG4gIG1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIFtdLmNvbmNhdChPYmplY3Qua2V5cyhtb2RpZmllciksIFZBTElEX1BST1BFUlRJRVMpIC8vIElFMTEtY29tcGF0aWJsZSByZXBsYWNlbWVudCBmb3IgYG5ldyBTZXQoaXRlcmFibGUpYFxuICAgIC5maWx0ZXIoZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgc2VsZikge1xuICAgICAgcmV0dXJuIHNlbGYuaW5kZXhPZih2YWx1ZSkgPT09IGluZGV4O1xuICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgY2FzZSAnbmFtZSc6XG4gICAgICAgICAgaWYgKHR5cGVvZiBtb2RpZmllci5uYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihmb3JtYXQoSU5WQUxJRF9NT0RJRklFUl9FUlJPUiwgU3RyaW5nKG1vZGlmaWVyLm5hbWUpLCAnXCJuYW1lXCInLCAnXCJzdHJpbmdcIicsIFwiXFxcIlwiICsgU3RyaW5nKG1vZGlmaWVyLm5hbWUpICsgXCJcXFwiXCIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdlbmFibGVkJzpcbiAgICAgICAgICBpZiAodHlwZW9mIG1vZGlmaWVyLmVuYWJsZWQgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihmb3JtYXQoSU5WQUxJRF9NT0RJRklFUl9FUlJPUiwgbW9kaWZpZXIubmFtZSwgJ1wiZW5hYmxlZFwiJywgJ1wiYm9vbGVhblwiJywgXCJcXFwiXCIgKyBTdHJpbmcobW9kaWZpZXIuZW5hYmxlZCkgKyBcIlxcXCJcIikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3BoYXNlJzpcbiAgICAgICAgICBpZiAobW9kaWZpZXJQaGFzZXMuaW5kZXhPZihtb2RpZmllci5waGFzZSkgPCAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGZvcm1hdChJTlZBTElEX01PRElGSUVSX0VSUk9SLCBtb2RpZmllci5uYW1lLCAnXCJwaGFzZVwiJywgXCJlaXRoZXIgXCIgKyBtb2RpZmllclBoYXNlcy5qb2luKCcsICcpLCBcIlxcXCJcIiArIFN0cmluZyhtb2RpZmllci5waGFzZSkgKyBcIlxcXCJcIikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2ZuJzpcbiAgICAgICAgICBpZiAodHlwZW9mIG1vZGlmaWVyLmZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGZvcm1hdChJTlZBTElEX01PRElGSUVSX0VSUk9SLCBtb2RpZmllci5uYW1lLCAnXCJmblwiJywgJ1wiZnVuY3Rpb25cIicsIFwiXFxcIlwiICsgU3RyaW5nKG1vZGlmaWVyLmZuKSArIFwiXFxcIlwiKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZWZmZWN0JzpcbiAgICAgICAgICBpZiAobW9kaWZpZXIuZWZmZWN0ICE9IG51bGwgJiYgdHlwZW9mIG1vZGlmaWVyLmVmZmVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihmb3JtYXQoSU5WQUxJRF9NT0RJRklFUl9FUlJPUiwgbW9kaWZpZXIubmFtZSwgJ1wiZWZmZWN0XCInLCAnXCJmdW5jdGlvblwiJywgXCJcXFwiXCIgKyBTdHJpbmcobW9kaWZpZXIuZm4pICsgXCJcXFwiXCIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdyZXF1aXJlcyc6XG4gICAgICAgICAgaWYgKG1vZGlmaWVyLnJlcXVpcmVzICE9IG51bGwgJiYgIUFycmF5LmlzQXJyYXkobW9kaWZpZXIucmVxdWlyZXMpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGZvcm1hdChJTlZBTElEX01PRElGSUVSX0VSUk9SLCBtb2RpZmllci5uYW1lLCAnXCJyZXF1aXJlc1wiJywgJ1wiYXJyYXlcIicsIFwiXFxcIlwiICsgU3RyaW5nKG1vZGlmaWVyLnJlcXVpcmVzKSArIFwiXFxcIlwiKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncmVxdWlyZXNJZkV4aXN0cyc6XG4gICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1vZGlmaWVyLnJlcXVpcmVzSWZFeGlzdHMpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGZvcm1hdChJTlZBTElEX01PRElGSUVSX0VSUk9SLCBtb2RpZmllci5uYW1lLCAnXCJyZXF1aXJlc0lmRXhpc3RzXCInLCAnXCJhcnJheVwiJywgXCJcXFwiXCIgKyBTdHJpbmcobW9kaWZpZXIucmVxdWlyZXNJZkV4aXN0cykgKyBcIlxcXCJcIikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ29wdGlvbnMnOlxuICAgICAgICBjYXNlICdkYXRhJzpcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJQb3BwZXJKUzogYW4gaW52YWxpZCBwcm9wZXJ0eSBoYXMgYmVlbiBwcm92aWRlZCB0byB0aGUgXFxcIlwiICsgbW9kaWZpZXIubmFtZSArIFwiXFxcIiBtb2RpZmllciwgdmFsaWQgcHJvcGVydGllcyBhcmUgXCIgKyBWQUxJRF9QUk9QRVJUSUVTLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgcmV0dXJuIFwiXFxcIlwiICsgcyArIFwiXFxcIlwiO1xuICAgICAgICAgIH0pLmpvaW4oJywgJykgKyBcIjsgYnV0IFxcXCJcIiArIGtleSArIFwiXFxcIiB3YXMgcHJvdmlkZWQuXCIpO1xuICAgICAgfVxuXG4gICAgICBtb2RpZmllci5yZXF1aXJlcyAmJiBtb2RpZmllci5yZXF1aXJlcy5mb3JFYWNoKGZ1bmN0aW9uIChyZXF1aXJlbWVudCkge1xuICAgICAgICBpZiAobW9kaWZpZXJzLmZpbmQoZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICAgIHJldHVybiBtb2QubmFtZSA9PT0gcmVxdWlyZW1lbnQ7XG4gICAgICAgIH0pID09IG51bGwpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGZvcm1hdChNSVNTSU5HX0RFUEVOREVOQ1lfRVJST1IsIFN0cmluZyhtb2RpZmllci5uYW1lKSwgcmVxdWlyZW1lbnQsIHJlcXVpcmVtZW50KSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn0iLCJpbXBvcnQgeyBtYXggYXMgbWF0aE1heCwgbWluIGFzIG1hdGhNaW4gfSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gd2l0aGluKG1pbiwgdmFsdWUsIG1heCkge1xuICByZXR1cm4gbWF0aE1heChtaW4sIG1hdGhNaW4odmFsdWUsIG1heCkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdpdGhpbk1heENsYW1wKG1pbiwgdmFsdWUsIG1heCkge1xuICB2YXIgdiA9IHdpdGhpbihtaW4sIHZhbHVlLCBtYXgpO1xuICByZXR1cm4gdiA+IG1heCA/IG1heCA6IHY7XG59IiwiLyohXG5UaGlzIGNvZGUgaXMgwqkgQ29weXJpZ2h0IFN0ZXBoZW4gQy4gUGhpbGxpcHMsIDIwMTguXG5FbWFpbDogc3RldmVAc2NwaGlsbGlwcy5jb21cbiovXG4vKlxuTGljZW5zZWQgdW5kZXIgdGhlIEVVUEwsIFZlcnNpb24gMS4yIG9yIOKAkyBhcyBzb29uIHRoZXkgd2lsbCBiZSBhcHByb3ZlZCBieSB0aGUgRXVyb3BlYW4gQ29tbWlzc2lvbiAtIHN1YnNlcXVlbnQgdmVyc2lvbnMgb2YgdGhlIEVVUEwgKHRoZSBcIkxpY2VuY2VcIik7XG5Zb3UgbWF5IG5vdCB1c2UgdGhpcyB3b3JrIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2VuY2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2VuY2UgYXQ6IGh0dHBzOi8vam9pbnVwLmVjLmV1cm9wYS5ldS9jb21tdW5pdHkvZXVwbC9cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2VuY2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIGJhc2lzLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5jZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2VuY2UuXG4qL1xuXG5pbXBvcnQgTW9yc2VDVyBmcm9tICcuL21vcnNlLXByby1jdyc7XG5cbi8qKlxuICogQ2xhc3MgdG8gY3JlYXRlIHNpbmUtd2F2ZSBzYW1wbGVzIG9mIHN0YW5kYXJkIENXIE1vcnNlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW9yc2VDV1dhdmUgZnJvbSAnbW9yc2UtcHJvLWN3LXdhdmUnO1xuICogdmFyIG1vcnNlQ1dXYXZlID0gbmV3IE1vcnNlQ1dXYXZlKCk7XG4gKiBtb3JzZUNXV2F2ZS50cmFuc2xhdGUoXCJhYmNcIik7XG4gKiB2YXIgc2FtcGxlID0gbW9yc2VDV1dhdmUuZ2V0U2FtcGxlKCk7XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vcnNlQ1dXYXZlIGV4dGVuZHMgTW9yc2VDVyB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcmVxdWVuY3k9NTUwXSAtIGZyZXF1ZW5jeSBvZiB3YXZlIGluIEh6XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzYW1wbGVSYXRlPTgwMDBdIC0gc2FtcGxlIHJhdGUgZm9yIHRoZSB3YXZlZm9ybSBpbiBIelxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHVzZVByb3NpZ25zLCB3cG0sIGZ3cG0sIGZyZXF1ZW5jeSA9IDU1MCwgc2FtcGxlUmF0ZSA9IDgwMDApIHtcbiAgICAgICAgc3VwZXIodXNlUHJvc2lnbnMsIHdwbSwgZndwbSk7XG4gICAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLnNpbmdsZUZyZXF1ZW5jeSA9IHR5cGVvZihmcmVxdWVuY3kuZGl0KT09XCJ1bmRlZmluZWRcIjtcbiAgICAgICAgdGhpcy5mcmVxdWVuY3kgPSBmcmVxdWVuY3k7ICAvLyBmcmVxdWVuY3kgb2Ygd2F2ZSBpbiBIelxuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5zYW1wbGVSYXRlID0gc2FtcGxlUmF0ZTsgIC8vIHNhbXBsZSByYXRlIGZvciB0aGUgd2F2ZWZvcm0gaW4gSHpcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBzYW1wbGUgd2F2ZWZvcm0sIG5vdCB1c2luZyBXZWIgQXVkaW8gQVBJIChzeW5jaHJvbm91cykuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmRQYWRkaW5nPTBdIC0gaG93IG11Y2ggc2lsZW5jZSBpbiBtcyB0byBhZGQgdG8gdGhlIGVuZCBvZiB0aGUgd2F2ZWZvcm0uXG4gICAgICogQHJldHVybiB7bnVtYmVyW119IGFuIGFycmF5IG9mIGZsb2F0cyBpbiByYW5nZSBbLTEsIDFdIHJlcHJlc2VudGluZyB0aGUgd2F2ZS1mb3JtLlxuICAgICAqL1xuICAgIGdldFNhbXBsZShlbmRQYWRkaW5nID0gMCwgcHJlUGFkZGluZz0wKSB7XG4gICAgICAgIHJldHVybiBNb3JzZUNXV2F2ZS5nZXRTYW1wbGVHZW5lcmFsKHRoaXMuZ2V0VGltaW5ncyh0cnVlKSwgdGhpcy5mcmVxdWVuY3ksIHRoaXMuc2FtcGxlUmF0ZSwgZW5kUGFkZGluZywgcHJlUGFkZGluZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGEgc2FtcGxlIHdhdmVmb3JtLCBub3QgdXNpbmcgV2ViIEF1ZGlvIEFQSSAoc3luY2hyb25vdXMpLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHRpbWluZ3MgLSBtaWxsaXNlY29uZCB0aW1pbmdzLCArdmUgbnVtYmVycyByZXByZXNlbnRpbmcgc291bmQsIC12ZSBmb3Igbm8gc291bmQgKCt2ZS8tdmUgY2FuIGJlIGluIGFueSBvcmRlcilcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZnJlcXVlbmN5IC0gZnJlcXVlbmN5IG9mIHNvdW5kIGluIEh6LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzYW1wbGVSYXRlIC0gc2FtcGxlIHJhdGUgaW4gSHouXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmRQYWRkaW5nPTBdIC0gaG93IG11Y2ggc2lsZW5jZSBpbiBtcyB0byBhZGQgdG8gdGhlIGVuZCBvZiB0aGUgd2F2ZWZvcm0uXG4gICAgICogQHJldHVybiB7bnVtYmVyW119IGFuIGFycmF5IG9mIGZsb2F0cyBpbiByYW5nZSBbLTEsIDFdIHJlcHJlc2VudGluZyB0aGUgd2F2ZS1mb3JtLlxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTYW1wbGVHZW5lcmFsKHRpbWluZ3MsIGZyZXF1ZW5jeSwgc2FtcGxlUmF0ZSwgZW5kUGFkZGluZyA9IDAscHJlUGFkZGluZz0wKSB7XG4gICAgICAgIHZhciBzYW1wbGUgPSBbXTtcbiAgICAgICAgaWYgKHRpbWluZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZVBhZGRpbmc+MCkge1xuICAgICAgICAgICAgdGltaW5ncy51bnNoaWZ0KHtcInRpbWVcIjooLTEgKiBwcmVQYWRkaW5nKSwgXCJ0eXBlXCI6XCJcIn0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub0RldGFpbHMgPSB0eXBlb2YodGltaW5nc1swXS50aW1lKT09XCJ1bmRlZmluZWRcIjtcblxuICAgICAgICAvLyBhZGQgbWluaW11bSBvZiA1bXMgc2lsZW5jZSB0byB0aGUgZW5kIHRvIGVuc3VyZSB0aGUgZmlsdGVyZWQgc2lnbmFsIGNhbiBmaW5pc2ggY2xlYW5seVxuICAgICAgICB2YXIgc2lsZW5jZUxlbmd0aCA9IC1NYXRoLm1heCg1LCBlbmRQYWRkaW5nKTtcbiAgICAgICAgdGltaW5ncy5wdXNoKG5vRGV0YWlscyA/IHNpbGVuY2VMZW5ndGggOiB7XCJ0aW1lXCI6IHNpbGVuY2VMZW5ndGgsIFwidHlwZVwiOlwiXCJ9KTtcblxuICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgICAgIENvbXB1dGUgZmlsdGVyZWQgc2lnbmFsXG4gICAgICAgICovXG5cbiAgICAgICAgXG4gICAgICAgIHZhciBmaXJzdExlbmd0aCA9IG5vRGV0YWlscyA/IHRpbWluZ3NbMF0gOiB0aW1pbmdzWzBdLnRpbWU7XG4gICAgICAgIHZhciBvbiA9IGZpcnN0TGVuZ3RoID4gMCA/IDEgOiAwO1xuICAgICAgICB2YXIgeDAsIHgxID0gMCwgeDIgPSAwO1xuICAgICAgICB2YXIgeTAsIHkxID0gMCwgeTIgPSAwO1xuICAgICAgICB2YXIgZ2FpbiA9IDAuODEzOyAgLy8gZW1waXJpY2FsbHksIHRoZSBsb3dwYXNzIGZpbHRlciBvdXRwdXRzIHdhdmVmb3JtIG9mIG1hZ25pdHVkZSAxLjIzLCBzbyBuZWVkIHRvIHNjYWxlIGl0IGRvd24gdG8gYXZvaWQgY2xpcHBpbmdcbiAgICAgICAgZm9yICh2YXIgdCA9IDA7IHQgPCB0aW1pbmdzLmxlbmd0aDsgdCArPSAxKSB7XG4gICAgICAgICAgICB2YXIgZHVyYXRpb24gPSBzYW1wbGVSYXRlICogTWF0aC5hYnMobm9EZXRhaWxzID8gdGltaW5nc1t0XSA6IHRpbWluZ3NbdF0udGltZSkgLyAxMDAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkdXJhdGlvbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpdEZyZXF1ZW5jeSA9IHR5cGVvZihmcmVxdWVuY3kuZGl0KSA9PSBcInVuZGVmaW5lZFwiID8gZnJlcXVlbmN5IDogZnJlcXVlbmN5LmRpdDtcbiAgICAgICAgICAgICAgICB2YXIgZGFoRnJlcXVlbmN5ID0gdHlwZW9mKGZyZXF1ZW5jeS5kYWgpID09IFwidW5kZWZpbmVkXCIgPyBmcmVxdWVuY3kgOiBmcmVxdWVuY3kuZGFoO1xuICAgICAgICAgICAgICAgIHZhciBkaXRTdGVwID0gTWF0aC5QSSAqIDIgKiBkaXRGcmVxdWVuY3kgLyBzYW1wbGVSYXRlO1xuICAgICAgICAgICAgICAgIHZhciBkYWhTdGVwID0gTWF0aC5QSSAqIDIgKiBkYWhGcmVxdWVuY3kgLyBzYW1wbGVSYXRlO1xuICAgICAgICAgICAgICAgIHZhciBzdGVwVG9Vc2UgPSBkaXRTdGVwO1xuICAgICAgICAgICAgICAgIHZhciBmcmVxVG9Vc2UgPSBkaXRGcmVxdWVuY3k7XG4gICAgICAgICAgICAgICAgaWYgKCFub0RldGFpbHMgJiYgdGltaW5nc1t0XS50eXBlPT1cImRhaFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0ZXBUb1VzZSA9IGRhaFN0ZXA7XG4gICAgICAgICAgICAgICAgICAgIGZyZXFUb1VzZSA9IGRhaEZyZXF1ZW5jeTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeDAgPSBvbiAqIE1hdGguc2luKGkgKiBzdGVwVG9Vc2UpOyAgLy8gdGhlIGlucHV0IHNpZ25hbFxuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICBDb21wdXRlIGxvd3Bhc3MgYmlxdWFkIGZpbHRlciBjb2VmZmljaWVudHMgdXNpbmcgbWV0aG9kIGZyb20gQ2hyb21pdW1cbiAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgLy8gc2V0IGxvd3Bhc3MgZnJlcXVlbmN5IGN1dG9mZiB0byAxLjUgeCB3YXZlIGZyZXF1ZW5jeVxuICAgICAgICAgICAgICAgIHZhciBsb3dwYXNzRnJlcSA9IChmcmVxVG9Vc2UgKiAxLjUpIC8gc2FtcGxlUmF0ZTtcbiAgICAgICAgICAgICAgICB2YXIgcSA9IE1hdGguU1FSVDFfMjtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBzaW4gPSBNYXRoLnNpbigyICogTWF0aC5QSSAqIGxvd3Bhc3NGcmVxKTtcbiAgICAgICAgICAgICAgICB2YXIgY29zID0gTWF0aC5jb3MoMiAqIE1hdGguUEkgKiBsb3dwYXNzRnJlcSk7XG4gICAgICAgICAgICAgICAgdmFyIGFscGhhID0gc2luIC8gKDIgKiBNYXRoLnBvdygxMCwgcSAvIDIwKSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXIgYTAgPSAgMSArIGFscGhhO1xuXG4gICAgICAgICAgICAgICAgdmFyIGIwID0gKCgxIC0gY29zKSAqIDAuNSkgLyBhMDtcbiAgICAgICAgICAgICAgICB2YXIgYjEgPSAoMSAtIGNvcykgLyBhMDtcbiAgICAgICAgICAgICAgICB2YXIgYjIgPSAoKDEgLSBjb3MpICogMC41KSAvIGEwO1xuICAgICAgICAgICAgICAgIHZhciBhMSA9ICgtMiAqIGNvcykgLyBhMDtcbiAgICAgICAgICAgICAgICB2YXIgYTIgPSAoMSAtIGFscGhhKSAvIGEwO1xuXG5cblxuXG4gICAgICAgICAgICAgICAgeTAgPSBiMCAqIHgwICsgYjEgKiB4MSArIGIyICogeDIgLSBhMSAqIHkxIC0gYTIgKiB5MjtcbiAgICAgICAgICAgICAgICBzYW1wbGUucHVzaCh5MCAqIGdhaW4pO1xuICAgICAgICAgICAgICAgIHgyID0geDE7XG4gICAgICAgICAgICAgICAgeDEgPSB4MDtcbiAgICAgICAgICAgICAgICB5MiA9IHkxO1xuICAgICAgICAgICAgICAgIHkxID0geTA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbiA9IDEgLSBvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2FtcGxlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBhIHNhbXBsZSB3YXZlZm9ybSB1c2luZyBXZWIgQXVkaW8gQVBJIChhc3luY2hyb25vdXMpLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kUGFkZGluZz0wXSAtIGhvdyBtdWNoIHNpbGVuY2UgaW4gbXMgdG8gYWRkIHRvIHRoZSBlbmQgb2YgdGhlIHdhdmVmb3JtLlxuICAgICAqIEByZXR1cm4ge1Byb21pc2UobnVtYmVyW10pfSBhIFByb21pc2UgcmVzb2x2aW5nIHRvIGFuIGFycmF5IG9mIGZsb2F0cyBpbiByYW5nZSBbLTEsIDFdIHJlcHJlc2VudGluZyB0aGUgd2F2ZS1mb3JtLlxuICAgICAqL1xuICAgIGdldFdBQVNhbXBsZShlbmRQYWRkaW5nID0gMCkge1xuICAgICAgICAvLyBhZGQgbWluaW11bSBvZiA1bXMgc2lsZW5jZSB0byB0aGUgZW5kIHRvIGVuc3VyZSB0aGUgZmlsdGVyZWQgc2lnbmFsIGNhbiBmaW5pc2ggY2xlYW5seVxuICAgICAgICBlbmRQYWRkaW5nID0gTWF0aC5tYXgoNSwgZW5kUGFkZGluZyk7XG4gICAgICAgIHZhciB0aW1pbmdzID0gdGhpcy5nZXRUaW1pbmdzKCk7XG4gICAgICAgIHRpbWluZ3MucHVzaCgtZW5kUGFkZGluZyk7XG4gICAgICAgIHZhciBvZmZsaW5lQXVkaW9Db250ZXh0Q2xhc3MgPSB3aW5kb3cuT2ZmbGluZUF1ZGlvQ29udGV4dCB8fCB3aW5kb3cud2Via2l0T2ZmbGluZUF1ZGlvQ29udGV4dDtcbiAgICAgICAgaWYgKG9mZmxpbmVBdWRpb0NvbnRleHRDbGFzcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBPZmZsaW5lQXVkaW9Db250ZXh0IGNsYXNzIGRlZmluZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYnVmZmVyIGxlbmd0aCBpcyB0aGUgTW9yc2UgZHVyYXRpb24gKyA1bXMgdG8gbGV0IHRoZSBsb3dwYXNzIGZpbHRlciBlbmQgY2xlYW5seVxuICAgICAgICB2YXIgb2ZmbGluZUN0eCA9IG5ldyBvZmZsaW5lQXVkaW9Db250ZXh0Q2xhc3MoMSwgdGhpcy5zYW1wbGVSYXRlICogKHRoaXMuZ2V0RHVyYXRpb24oKSArIGVuZFBhZGRpbmcpIC8gMTAwMCwgdGhpcy5zYW1wbGVSYXRlKTtcbiAgICAgICAgdmFyIGdhaW5Ob2RlID0gb2ZmbGluZUN0eC5jcmVhdGVHYWluKCk7XG4gICAgICAgIC8vIGVtcGlyaWNhbGx5LCB0aGUgbG93cGFzcyBmaWx0ZXIgb3V0cHV0cyB3YXZlZm9ybSBvZiBtYWduaXR1ZGUgMS4yMywgc28gbmVlZCB0byBzY2FsZSBpdCBkb3duIHRvIGF2b2lkIGNsaXBwaW5nXG4gICAgICAgIGdhaW5Ob2RlLmdhaW4uc2V0VmFsdWVBdFRpbWUoMC44MTMsIDApO1xuICAgICAgICB2YXIgbG93UGFzc05vZGUgPSBvZmZsaW5lQ3R4LmNyZWF0ZUJpcXVhZEZpbHRlcigpO1xuICAgICAgICBsb3dQYXNzTm9kZS50eXBlID0gXCJsb3dwYXNzXCI7XG4gICAgICAgIGxvd1Bhc3NOb2RlLmZyZXF1ZW5jeS5zZXRWYWx1ZUF0VGltZSh0aGlzLmZyZXF1ZW5jeSAqIDEuMSwgMCk7ICAvLyBUT0RPOiByZW1vdmUgdGhpcyBtYWdpYyBudW1iZXIgYW5kIG1ha2UgdGhlIGZpbHRlciBjb25maWd1cmFibGU/XG4gICAgICAgIGdhaW5Ob2RlLmNvbm5lY3QobG93UGFzc05vZGUpO1xuICAgICAgICBsb3dQYXNzTm9kZS5jb25uZWN0KG9mZmxpbmVDdHguZGVzdGluYXRpb24pO1xuICAgICAgICB2YXIgdCA9IDA7XG4gICAgICAgIHZhciBvc2NpbGxhdG9yO1xuICAgICAgICB2YXIgZHVyYXRpb247XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGltaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZHVyYXRpb24gPSBNYXRoLmFicyh0aW1pbmdzW2ldKSAvIDEwMDA7XG4gICAgICAgICAgICBpZiAodGltaW5nc1tpXSA+IDApIHsgIC8vIC12ZSB0aW1pbmdzIGFyZSBzaWxlbmNlXG4gICAgICAgICAgICAgICAgb3NjaWxsYXRvciA9IG9mZmxpbmVDdHguY3JlYXRlT3NjaWxsYXRvcigpO1xuICAgICAgICAgICAgICAgIG9zY2lsbGF0b3IudHlwZSA9ICdzaW5lJztcbiAgICAgICAgICAgICAgICBvc2NpbGxhdG9yLmZyZXF1ZW5jeS5zZXRWYWx1ZUF0VGltZSh0aGlzLmZyZXF1ZW5jeSwgdCk7XG4gICAgICAgICAgICAgICAgb3NjaWxsYXRvci5zdGFydCh0KTtcbiAgICAgICAgICAgICAgICBvc2NpbGxhdG9yLnN0b3AodCArIGR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICBvc2NpbGxhdG9yLmNvbm5lY3QoZ2Fpbk5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdCArPSBkdXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2ZmbGluZUN0eC5zdGFydFJlbmRlcmluZygpLnRoZW4oZnVuY3Rpb24ocmVuZGVyZWRCdWZmZXIpIHtcbiAgICAgICAgICAgIHJldHVybiByZW5kZXJlZEJ1ZmZlci5nZXRDaGFubmVsRGF0YSgwKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiLyohXG5UaGlzIGNvZGUgaXMgwqkgQ29weXJpZ2h0IFN0ZXBoZW4gQy4gUGhpbGxpcHMsIDIwMTguXG5FbWFpbDogc3RldmVAc2NwaGlsbGlwcy5jb21cbiovXG4vKlxuTGljZW5zZWQgdW5kZXIgdGhlIEVVUEwsIFZlcnNpb24gMS4yIG9yIOKAkyBhcyBzb29uIHRoZXkgd2lsbCBiZSBhcHByb3ZlZCBieSB0aGUgRXVyb3BlYW4gQ29tbWlzc2lvbiAtIHN1YnNlcXVlbnQgdmVyc2lvbnMgb2YgdGhlIEVVUEwgKHRoZSBcIkxpY2VuY2VcIik7XG5Zb3UgbWF5IG5vdCB1c2UgdGhpcyB3b3JrIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2VuY2UuXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2VuY2UgYXQ6IGh0dHBzOi8vam9pbnVwLmVjLmV1cm9wYS5ldS9jb21tdW5pdHkvZXVwbC9cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2VuY2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIGJhc2lzLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cblNlZSB0aGUgTGljZW5jZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2VuY2UuXG4qL1xuXG5pbXBvcnQgKiBhcyBXUE0gZnJvbSAnLi9tb3JzZS1wcm8td3BtJztcbmltcG9ydCBNb3JzZU1lc3NhZ2UgZnJvbSAnLi9tb3JzZS1wcm8tbWVzc2FnZSc7XG5cbi8qKlxuICogQ2xhc3MgdG8gY3JlYXRlIHRoZSBvbi9vZmYgdGltaW5ncyBuZWVkZWQgYnkgZS5nLiBzb3VuZCBnZW5lcmF0b3JzLiBUaW1pbmdzIGFyZSBpbiBtaWxsaXNlY29uZHM7IFwib2ZmXCIgdGltaW5ncyBhcmUgbmVnYXRpdmUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCBNb3JzZUNXIGZyb20gJ21vcnNlLXByby1jdyc7XG4gKiB2YXIgbW9yc2VDVyA9IG5ldyBNb3JzZUNXKCk7XG4gKiBtb3JzZUNXLnRyYW5zbGF0ZShcImFiY1wiKTtcbiAqIHZhciB0aW1pbmdzID0gbW9yc2VDVy5nZXRUaW1pbmdzKCk7XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vcnNlQ1cgZXh0ZW5kcyBNb3JzZU1lc3NhZ2Uge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3NpZ25zPXRydWVdIC0gd2hldGhlciBvciBub3QgdG8gaW5jbHVkZSBwcm9zaWducyBpbiB0aGUgdHJhbnNsYXRpb25zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3cG09MjBdIC0gdGhlIHNwZWVkIGluIHdvcmRzIHBlciBtaW51dGUgdXNpbmcgUEFSSVMgYXMgdGhlIHN0YW5kYXJkIHdvcmRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Z3cG09d3BtXSAtIHRoZSBGYXJuc3dvcnRoIHNwZWVkIGluIHdvcmRzIHBlciBtaW51dGUgKGRlZmF1bHRzIHRvIHdwbSlcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih1c2VQcm9zaWducyA9IHRydWUsIHdwbSA9IDIwLCBmd3BtID0gd3BtKSB7XG4gICAgICAgIHN1cGVyKHVzZVByb3NpZ25zKTtcbiAgICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAgIHRoaXMud3BtID0gd3BtO1xuICAgICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5md3BtID0gZndwbTtcbiAgICB9XG5cbiAgICAvKiogXG4gICAgICogU2V0IHRoZSBXUE0gc3BlZWQuIEVuc3VyZXMgdGhhdCBGYXJuc3dvcnRoIFdQTSBpcyBubyBmYXN0ZXIgdGhhbiBXUE0uXG4gICAgICogQHR5cGUge251bWJlcn0gKi9cbiAgICBzZXQgd3BtKHdwbSkge1xuICAgICAgICB0aGlzLl93cG0gPSB3cG07XG4gICAgICAgIGlmICh3cG0gPCB0aGlzLl9md3BtKSB7XG4gICAgICAgICAgICB0aGlzLl9md3BtID0gd3BtO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgZ2V0IHdwbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dwbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIEZhcm5zd29ydGggV1BNIHNwZWVkLiBFbnN1cmVzIHRoYXQgV1BNIGlzIG5vIHNsb3dlciB0aGFuIEZhcm5zd29ydGggV1BNLlxuICAgICAqICBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHNldCBmd3BtKGZ3cG0pIHtcbiAgICAgICAgdGhpcy5fZndwbSA9IGZ3cG07XG4gICAgICAgIGlmIChmd3BtID4gdGhpcy5fd3BtKSB7XG4gICAgICAgICAgICB0aGlzLl93cG0gPSBmd3BtO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgZ2V0IGZ3cG0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9md3BtO1xuICAgIH1cblxuICAgIC8qKiBcbiAgICAgKiBHZXQgdGhlIGxlbmd0aCBvZiB0aGUgc3BhY2UgYmV0d2VlbiB3b3JkcyBpbiBtcy5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIGdldCB3b3JkU3BhY2UoKSB7XG4gICAgICAgIHJldHVybiBXUE0ud29yZFNwYWNlKHRoaXMuX3dwbSwgdGhpcy5fZndwbSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGFuIGFycmF5IG9mIG1pbGxpc2Vjb25kIHRpbWluZ3MuXG4gICAgICogV2l0aCB0aGUgRmFybnN3b3J0aCBtZXRob2QsIHRoZSBtb3JzZSBjaGFyYWN0ZXJzIGFyZSBwbGF5ZWQgYXQgb25lXG4gICAgICogc3BlZWQgYW5kIHRoZSBzcGFjZXMgYmV0d2VlbiBjaGFyYWN0ZXJzIGF0IGEgc2xvd2VyIHNwZWVkLlxuICAgICAqIEByZXR1cm4ge251bWJlcltdfVxuICAgICAqL1xuICAgIGdldFRpbWluZ3Mod2l0aERldGFpbHMpIHtcbiAgICAgICAgcmV0dXJuIE1vcnNlQ1cuZ2V0VGltaW5nc0dlbmVyYWwoXG4gICAgICAgICAgICBXUE0uZGl0TGVuZ3RoKHRoaXMuX3dwbSksXG4gICAgICAgICAgICBXUE0uZGFoTGVuZ3RoKHRoaXMuX3dwbSksXG4gICAgICAgICAgICBXUE0uZGl0U3BhY2UodGhpcy5fd3BtKSxcbiAgICAgICAgICAgIFdQTS5jaGFyU3BhY2UodGhpcy5fd3BtLCB0aGlzLl9md3BtKSxcbiAgICAgICAgICAgIFdQTS53b3JkU3BhY2UodGhpcy5fd3BtLCB0aGlzLl9md3BtKSxcbiAgICAgICAgICAgIHRoaXMubW9yc2UsXG4gICAgICAgICAgICB3aXRoRGV0YWlsc1xuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhbiBhcnJheSBvZiBtaWxsaXNlY29uZCB0aW1pbmdzLlxuICAgICAqIEVhY2ggc291bmQgYW5kIHNwYWNlIGhhcyBhIGR1cmF0aW9uLiBUaGUgZHVyYXRpb25zIG9mIHRoZSBzcGFjZXMgYXJlIGRpc3Rpbmd1aXNoZWQgYnkgYmVpbmcgbmVnYXRpdmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRpdCAtIHRoZSBsZW5ndGggb2YgYSBkaXQgaW4gbWlsbGlzZWNvbmRzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRhaCAtIHRoZSBsZW5ndGggb2YgYSBkYWggaW4gbWlsbGlzZWNvbmRzIChub3JtYWxseSAzICogZGl0KVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaXRTcGFjZSAtIHRoZSBsZW5ndGggb2YgYW4gaW50cmEtY2hhcmFjdGVyIHNwYWNlIGluIG1pbGxpc2Vjb25kcyAoMSAqIGRpdClcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY2hhclNwYWNlIC0gdGhlIGxlbmd0aCBvZiBhbiBpbnRlci1jaGFyYWN0ZXIgc3BhY2UgaW4gbWlsbGlzZWNvbmRzIChub3JtYWxseSAzICogZGl0KVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3b3JkU3BhY2UgLSB0aGUgbGVuZ3RoIG9mIGFuIGludGVyLXdvcmQgc3BhY2UgaW4gbWlsbGlzZWNvbmRzIChub3JtYWxseSA3ICogZGl0KVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtb3JzZSAtIHRoZSAoY2Fub25pY2FsKSBtb3JzZSBjb2RlIHN0cmluZyAobWF0Y2hpbmcgWy4tLyBdKilcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJbXX1cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0VGltaW5nc0dlbmVyYWwoZGl0LCBkYWgsIGRpdFNwYWNlLCBjaGFyU3BhY2UsIHdvcmRTcGFjZSwgbW9yc2Usd2l0aERldGFpbHMpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIk1vcnNlOiBcIiArIG1vcnNlKTtcbiAgICAgICAgbW9yc2UgPSBtb3JzZS5yZXBsYWNlKC8gXFwvIC9nLCAnLycpOyAgLy8gdGhpcyBtZWFucyB0aGF0IGEgc3BhY2UgaXMgb25seSB1c2VkIGZvciBpbnRlci1jaGFyYWN0ZXJcbiAgICAgICAgbW9yc2UgPSBtb3JzZS5yZXBsYWNlKC8oW1xcLlxcLV0pKD89W1xcLlxcLV0pL2csIFwiJDErXCIpOyAgLy8gcHV0IGEgKyBpbiBiZXR3ZWVuIGFsbCBkaXRzIGFuZCBkYWhzXG4gICAgICAgIHZhciB0aW1lcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1vcnNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKG1vcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnLic6XG4gICAgICAgICAgICAgICAgICAgIHRpbWVzLnB1c2goZGl0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICAgICAgICAgIHRpbWVzLnB1c2goZGFoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICAgICAgICAgIHRpbWVzLnB1c2goLWRpdFNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIiBcIjpcbiAgICAgICAgICAgICAgICAgICAgdGltZXMucHVzaCgtY2hhclNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIi9cIjpcbiAgICAgICAgICAgICAgICAgICAgdGltZXMucHVzaCgtd29yZFNwYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIlRpbWluZ3M6IFwiICsgdGltZXMpO1xuICAgICAgICByZXR1cm4gIXdpdGhEZXRhaWxzID8gdGltZXM6IHRpbWVzLm1hcCh4PT57XG4gICAgICAgICAgICB2YXIgdHlwZT1cIlwiXG4gICAgICAgICAgICBzd2l0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgICBjYXNlIGRpdDpcbiAgICAgICAgICAgICAgICAgICAgdHlwZT1cImRpdFwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIGRhaDpcbiAgICAgICAgICAgICAgICAgICAgdHlwZT1cImRhaFwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4ge1widGltZVwiOngsIFwidHlwZVwiOnR5cGV9O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHRvdGFsIGR1cmF0aW9uIG9mIHRoZSBtZXNzYWdlIGluIG1zXG4gICAgIDggQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldER1cmF0aW9uKCkge1xuICAgICAgICB2YXIgdGltZXMgPSB0aGlzLmdldFRpbWluZ3MoKTtcbiAgICAgICAgdmFyIHQgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRpbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0ICs9IE1hdGguYWJzKHRpbWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9XG59XG4iLCIvKiFcblRoaXMgY29kZSBpcyDCqSBDb3B5cmlnaHQgU3RlcGhlbiBDLiBQaGlsbGlwcywgMjAxOC5cbkVtYWlsOiBzdGV2ZUBzY3BoaWxsaXBzLmNvbVxuKi9cbi8qXG5MaWNlbnNlZCB1bmRlciB0aGUgRVVQTCwgVmVyc2lvbiAxLjIgb3Ig4oCTIGFzIHNvb24gdGhleSB3aWxsIGJlIGFwcHJvdmVkIGJ5IHRoZSBFdXJvcGVhbiBDb21taXNzaW9uIC0gc3Vic2VxdWVudCB2ZXJzaW9ucyBvZiB0aGUgRVVQTCAodGhlIFwiTGljZW5jZVwiKTtcbllvdSBtYXkgbm90IHVzZSB0aGlzIHdvcmsgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5jZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5jZSBhdDogaHR0cHM6Ly9qb2ludXAuZWMuZXVyb3BhLmV1L2NvbW11bml0eS9ldXBsL1xuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5jZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgYmFzaXMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbmNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5jZS5cbiovXG5cbmltcG9ydCAqIGFzIE1vcnNlIGZyb20gJy4vbW9yc2UtcHJvJztcblxuLyoqXG4gKiBDbGFzcyBmb3IgY29udmVuaWVudGx5IHRyYW5zbGF0aW5nIHRvIGFuZCBmcm9tIE1vcnNlIGNvZGUuXG4gKiBEZWFscyB3aXRoIGVycm9yIGhhbmRsaW5nLlxuICogV29ya3Mgb3V0IGlmIHRoZSBpbnB1dCBpcyBNb3JzZSBjb2RlIG9yIG5vdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IE1vcnNlTWVzc2FnZSBmcm9tICdtb3JzZS1wcm8tbWVzc2FnZSc7XG4gKiB2YXIgbW9yc2VNZXNzYWdlID0gbmV3IE1vcnNlTWVzc2FnZSgpO1xuICogdmFyIGlucHV0O1xuICogdmFyIG91dHB1dDtcbiAqIHRyeSB7XG4gKiAgICAgb3V0cHV0ID0gbW9yc2VNZXNzYWdlLnRyYW5zbGF0ZShcImFiY1wiKTtcbiAqIGNhdGNoIChleCkge1xuICogICAgIC8vIGlucHV0IHdpbGwgaGF2ZSBlcnJvcnMgc3Vycm91bmRlZCBieSBwYWlyZWQgJyMnIHNpZ25zXG4gKiAgICAgLy8gb3V0cHV0IHdpbGwgYmUgYmVzdCBhdHRlbXB0IGF0IHRyYW5zbGF0aW9uLCB3aXRoIHVudHJhbnNsYXRhYmxlcyByZXBsYWNlZCB3aXRoICcjJ1xuICogICAgIG1vcnNlTWVzc2FnZS5jbGVhckVycm9yKCk7ICAvLyByZW1vdmUgYWxsIHRoZSAnIydcbiAqIH1cbiAqIGlmIChtb3JzZU1lc3NhZ2UuaW5wdXRXYXNNb3JzZSkge1xuICogICAgIC8vIGRvIHNvbWV0aGluZ1xuICogfVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb3JzZU1lc3NhZ2Uge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3NpZ25zPXRydWVdIC0gd2hldGhlciBvciBub3QgdG8gaW5jbHVkZSBwcm9zaWducyBpbiB0aGUgdHJhbnNsYXRpb25zXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodXNlUHJvc2lnbnMgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMudXNlUHJvc2lnbnMgPSB1c2VQcm9zaWducztcbiAgICAgICAgdGhpcy5pbnB1dCA9IFwiXCI7XG4gICAgICAgIHRoaXMub3V0cHV0ID0gXCJcIjtcbiAgICAgICAgdGhpcy5tb3JzZSA9IFwiXCI7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IFwiXCI7XG4gICAgICAgIHRoaXMuaW5wdXRXYXNNb3JzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5oYXNFcnJvciA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgLSBhbHBoYW51bWVyaWMgdGV4dCBvciBtb3JzZSBjb2RlIHRvIHRyYW5zbGF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNNb3JzZSAtIHdoZXRoZXIgdGhlIGlucHV0IGlzIE1vcnNlIGNvZGUgb3Igbm90IChpZiBub3Qgc2V0IHRoZW4gdGhlIGxvb2tzTGlrZU1vcnNlIG1ldGhvZCB3aWxsIGJlIHVzZWQpXG4gICAgICovXG4gICAgdHJhbnNsYXRlKGlucHV0LCBpc01vcnNlKSB7XG4gICAgICAgIHZhciB0cmFuc2xhdGlvbjtcblxuICAgICAgICBpZiAodHlwZW9mIGlzTW9yc2UgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIC8vIG1ha2UgYSBndWVzczogY291bGQgYmUgd3JvbmcgaWYgc29tZW9uZSB3YW50cyB0byB0cmFuc2xhdGUgXCIuXCIgaW50byBNb3JzZSBmb3IgaW5zdGFuY2VcbiAgICAgICAgICAgIGlzTW9yc2UgPSBNb3JzZS5sb29rc0xpa2VNb3JzZShpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTW9yc2UpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRXYXNNb3JzZSA9IHRydWU7XG4gICAgICAgICAgICB0cmFuc2xhdGlvbiA9IE1vcnNlLm1vcnNlMnRleHQoaW5wdXQsIHRoaXMudXNlUHJvc2lnbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbnB1dFdhc01vcnNlID0gZmFsc2U7XG4gICAgICAgICAgICB0cmFuc2xhdGlvbiA9IE1vcnNlLnRleHQybW9yc2UoaW5wdXQsIHRoaXMudXNlUHJvc2lnbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tb3JzZSA9IHRyYW5zbGF0aW9uLm1vcnNlO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSB0cmFuc2xhdGlvbi5tZXNzYWdlO1xuXG4gICAgICAgIGlmICh0aGlzLmlucHV0V2FzTW9yc2UpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQgPSB0aGlzLm1vcnNlO1xuICAgICAgICAgICAgdGhpcy5vdXRwdXQgPSB0aGlzLm1lc3NhZ2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0ID0gdGhpcy5tZXNzYWdlO1xuICAgICAgICAgICAgdGhpcy5vdXRwdXQgPSB0aGlzLm1vcnNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5oYXNFcnJvciA9IHRyYW5zbGF0aW9uLmhhc0Vycm9yO1xuICAgICAgICBpZiAodGhpcy5oYXNFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gaW5wdXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMub3V0cHV0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFyIGFsbCB0aGUgZXJyb3JzIGZyb20gdGhlIG1vcnNlIGFuZCBtZXNzYWdlLiBVc2VmdWwgaWYgeW91IHdhbnQgdG8gcGxheSB0aGUgc291bmQgZXZlbiB0aG91Z2ggaXQgZGlkbid0IHRyYW5zbGF0ZS5cbiAgICAgKi9cbiAgICBjbGVhckVycm9yKCkge1xuICAgICAgICBpZiAodGhpcy5pbnB1dFdhc01vcnNlKSB7XG4gICAgICAgICAgICB0aGlzLm1vcnNlID0gdGhpcy5tb3JzZS5yZXBsYWNlKC8jL2csIFwiXCIpOyAgLy8gbGVhdmUgaW4gdGhlIGJhZCBNb3JzZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gdGhpcy5tZXNzYWdlLnJlcGxhY2UoLyNbXiNdKj8jL2csIFwiXCIpO1xuICAgICAgICAgICAgdGhpcy5tb3JzZSA9IHRoaXMubW9yc2UucmVwbGFjZSgvIy9nLCBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhc0Vycm9yID0gZmFsc2U7XG4gICAgfVxufVxuIiwiLypcbiogUklGRldBVkUgYWRhcHRlZCBmcm9tIFJJRkZXQVZFLmpzIHYwLjAzIC0gQXVkaW8gZW5jb2RlciBmb3IgSFRNTDUgPGF1ZGlvPiBlbGVtZW50cy5cbiogQ29weWxlZnQgMjAxMSBieSBQZWRybyBMYWRhcmlhIDxwZWRyby5sYWRhcmlhIGF0IEdtYWlsIGRvdCBjb20+XG4qIFB1YmxpYyBEb21haW5cbiovXG5cbi8qXG4qIEFkYXB0YXRpb24gYnkgU3RlcGhlbiBDLiBQaGlsbGlwcywgMjAxMy0yMDE3LlxuKiBFbWFpbDogc3RldmVAc2NwaGlsbGlwcy5jb21cbiogUHVibGljIERvbWFpblxuKi9cblxuLyoqXG4gKiBVdGlsaXR5IHRvIGNyZWF0ZSBSSUZGIFdBVkUgZmlsZSBkYXRhLlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgTW9yc2VDV1dhdmUgZnJvbSAnbW9yc2UtcHJvLWN3LXdhdmUnO1xuICogaW1wb3J0ICogYXMgUmlmZldhdmUgZnJvbSAnbW9yc2UtcHJvLXV0aWwtcmlmZndhdmUnO1xuICogdmFyIG1vcnNlQ1dXYXZlID0gbmV3IE1vcnNlQ1dXYXZlKCk7XG4gKiBtb3JzZUNXV2F2ZS50cmFuc2xhdGUoXCJhYmNcIik7XG4gKiB2YXIgd2F2ID0gUmlmZldhdmUuZ2V0RGF0YShtb3JzZUNXV2F2ZS5nZXRTYW1wbGUoKSk7ICAvLyByZXR1cm5zIGJ5dGUgYXJyYXkgb2YgV0FWIGZpbGVcbiAgKi9cbnZhciB1MzJUb0FycmF5ID0gZnVuY3Rpb24oaSkge1xuICAgIHJldHVybiBbaSYweEZGLCAoaT4+OCkmMHhGRiwgKGk+PjE2KSYweEZGLCAoaT4+MjQpJjB4RkZdO1xufTtcblxudmFyIHUxNlRvQXJyYXkgPSBmdW5jdGlvbihpKSB7XG4gICAgcmV0dXJuIFtpJjB4RkYsIChpPj44KSYweEZGXTtcbn07XG5cbnZhciBzcGxpdDE2Yml0QXJyYXkgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgdmFyIHIgPSBbXTtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgIGZvciAodmFyIGk9MDsgaTxsZW47IGkrKykge1xuICAgICAgICByW2orK10gPSBkYXRhW2ldICYgMHhGRjtcbiAgICAgICAgcltqKytdID0gKGRhdGFbaV0+PjgpICYgMHhGRjtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG59O1xuXG52YXIgZlRvVTggPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgdmFyIHIgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcltpXSA9IE1hdGgubWF4KE1hdGgubWluKDEyOCArIE1hdGgucm91bmQoMTI3ICogZGF0YVtpXSksIDI1NSksIDApO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IFBDTSBkYXRhIHRvIFdBViBmaWxlIGRhdGEuXG4gKiBAcGFyYW0ge251bWJlcltdfSBkYXRhIC0gd2F2ZWZvcm0gZGF0YSwgZXhwZWN0ZWQgdG8gYmUgaW4gKGFuZCBjbGFtcGVkIHRvKSByYW5nZSBbLTEsMV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc2FtcGxlUmF0ZT04MDAwXSAtIHRoZSBzYW1wbGUgcmF0ZSBvZiB0aGUgd2F2ZWZvcm0gaW4gSHpcbiAqIEBwYXJhbSB7bnVtYmVyfSBbYml0c1BlclNhbXBsZT04XSAtIG51bWJlciBvZiBiaXRzIHRvIHN0b3JlIGVhY2ggZGF0YSBwb2ludCAoOCBvciAxNilcbiAqIEByZXR1cm4ge251bWJlcltdfSAtIGFycmF5IG9mIGJ5dGVzIHJlcHJlc2VudGluZyB0aGUgV0FWIGZpbGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERhdGEoZGF0YSwgc2FtcGxlUmF0ZSA9IDgwMDAsIGJpdHNQZXJTYW1wbGUgPSA4KSB7XG4gICAgZGF0YSA9IGZUb1U4KGRhdGEpO1xuXG4gICAgdmFyIGhlYWRlciA9IHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT0ZGUyBTSVpFIE5PVEVTXG4gICAgICAgIGNodW5rSWQgICAgICA6IFsweDUyLDB4NDksMHg0NiwweDQ2XSwgLy8gMCAgICA0ICAgIFwiUklGRlwiID0gMHg1MjQ5NDY0NlxuICAgICAgICBjaHVua1NpemUgICAgOiAwLCAgICAgICAgICAgICAgICAgICAgIC8vIDQgICAgNCAgICAzNitTdWJDaHVuazJTaXplID0gNCsoOCtTdWJDaHVuazFTaXplKSsoOCtTdWJDaHVuazJTaXplKVxuICAgICAgICBmb3JtYXQgICAgICAgOiBbMHg1NywweDQxLDB4NTYsMHg0NV0sIC8vIDggICAgNCAgICBcIldBVkVcIiA9IDB4NTc0MTU2NDVcbiAgICAgICAgc3ViQ2h1bmsxSWQgIDogWzB4NjYsMHg2ZCwweDc0LDB4MjBdLCAvLyAxMiAgIDQgICAgXCJmbXQgXCIgPSAweDY2NmQ3NDIwXG4gICAgICAgIHN1YkNodW5rMVNpemU6IDE2LCAgICAgICAgICAgICAgICAgICAgLy8gMTYgICA0ICAgIDE2IGZvciBQQ01cbiAgICAgICAgYXVkaW9Gb3JtYXQgIDogMSwgICAgICAgICAgICAgICAgICAgICAvLyAyMCAgIDIgICAgUENNID0gMVxuICAgICAgICBudW1DaGFubmVscyAgOiAxLCAgICAgICAgICAgICAgICAgICAgIC8vIDIyICAgMiAgICBNb25vID0gMSwgU3RlcmVvID0gMi4uLlxuICAgICAgICBzYW1wbGVSYXRlICAgOiBzYW1wbGVSYXRlLCAgICAgICAgICAgIC8vIDI0ICAgNCAgICA4MDAwLCA0NDEwMC4uLlxuICAgICAgICBieXRlUmF0ZSAgICAgOiAwLCAgICAgICAgICAgICAgICAgICAgIC8vIDI4ICAgNCAgICBTYW1wbGVSYXRlKk51bUNoYW5uZWxzKkJpdHNQZXJTYW1wbGUvOFxuICAgICAgICBibG9ja0FsaWduICAgOiAwLCAgICAgICAgICAgICAgICAgICAgIC8vIDMyICAgMiAgICBOdW1DaGFubmVscypCaXRzUGVyU2FtcGxlLzhcbiAgICAgICAgYml0c1BlclNhbXBsZTogYml0c1BlclNhbXBsZSwgICAgICAgICAvLyAzNCAgIDIgICAgOCBiaXRzID0gOCwgMTYgYml0cyA9IDE2XG4gICAgICAgIHN1YkNodW5rMklkICA6IFsweDY0LDB4NjEsMHg3NCwweDYxXSwgLy8gMzYgICA0ICAgIFwiZGF0YVwiID0gMHg2NDYxNzQ2MVxuICAgICAgICBzdWJDaHVuazJTaXplOiAwICAgICAgICAgICAgICAgICAgICAgIC8vIDQwICAgNCAgICBkYXRhIHNpemUgPSBOdW1TYW1wbGVzKk51bUNoYW5uZWxzKkJpdHNQZXJTYW1wbGUvOFxuICAgIH07XG5cbiAgICBoZWFkZXIuYmxvY2tBbGlnbiA9IChoZWFkZXIubnVtQ2hhbm5lbHMgKiBoZWFkZXIuYml0c1BlclNhbXBsZSkgPj4gMztcbiAgICBoZWFkZXIuYnl0ZVJhdGUgPSBoZWFkZXIuYmxvY2tBbGlnbiAqIGhlYWRlci5zYW1wbGVSYXRlO1xuICAgIGhlYWRlci5zdWJDaHVuazJTaXplID0gZGF0YS5sZW5ndGggKiAoaGVhZGVyLmJpdHNQZXJTYW1wbGUgPj4gMyk7XG4gICAgaGVhZGVyLmNodW5rU2l6ZSA9IDM2ICsgaGVhZGVyLnN1YkNodW5rMlNpemU7XG5cbiAgICByZXR1cm4gaGVhZGVyLmNodW5rSWQuY29uY2F0KFxuICAgICAgICB1MzJUb0FycmF5KGhlYWRlci5jaHVua1NpemUpLFxuICAgICAgICBoZWFkZXIuZm9ybWF0LFxuICAgICAgICBoZWFkZXIuc3ViQ2h1bmsxSWQsXG4gICAgICAgIHUzMlRvQXJyYXkoaGVhZGVyLnN1YkNodW5rMVNpemUpLFxuICAgICAgICB1MTZUb0FycmF5KGhlYWRlci5hdWRpb0Zvcm1hdCksXG4gICAgICAgIHUxNlRvQXJyYXkoaGVhZGVyLm51bUNoYW5uZWxzKSxcbiAgICAgICAgdTMyVG9BcnJheShoZWFkZXIuc2FtcGxlUmF0ZSksXG4gICAgICAgIHUzMlRvQXJyYXkoaGVhZGVyLmJ5dGVSYXRlKSxcbiAgICAgICAgdTE2VG9BcnJheShoZWFkZXIuYmxvY2tBbGlnbiksXG4gICAgICAgIHUxNlRvQXJyYXkoaGVhZGVyLmJpdHNQZXJTYW1wbGUpLFxuICAgICAgICBoZWFkZXIuc3ViQ2h1bmsySWQsXG4gICAgICAgIHUzMlRvQXJyYXkoaGVhZGVyLnN1YkNodW5rMlNpemUpLFxuICAgICAgICAoaGVhZGVyLmJpdHNQZXJTYW1wbGUgPT0gMTYpID8gc3BsaXQxNmJpdEFycmF5KGRhdGEpIDogZGF0YVxuICAgICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRNSU1FVHlwZSgpIHtcbiAgICByZXR1cm4gXCJhdWRpby93YXZcIjtcbn1cbiIsIi8qIVxuVGhpcyBjb2RlIGlzIMKpIENvcHlyaWdodCBTdGVwaGVuIEMuIFBoaWxsaXBzLCAyMDE4LlxuRW1haWw6IHN0ZXZlQHNjcGhpbGxpcHMuY29tXG4qL1xuLypcbkxpY2Vuc2VkIHVuZGVyIHRoZSBFVVBMLCBWZXJzaW9uIDEuMiBvciDigJMgYXMgc29vbiB0aGV5IHdpbGwgYmUgYXBwcm92ZWQgYnkgdGhlIEV1cm9wZWFuIENvbW1pc3Npb24gLSBzdWJzZXF1ZW50IHZlcnNpb25zIG9mIHRoZSBFVVBMICh0aGUgXCJMaWNlbmNlXCIpO1xuWW91IG1heSBub3QgdXNlIHRoaXMgd29yayBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbmNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbmNlIGF0OiBodHRwczovL2pvaW51cC5lYy5ldXJvcGEuZXUvY29tbXVuaXR5L2V1cGwvXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbmNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBiYXNpcywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2VuY2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbmNlLlxuKi9cblxuLyoqXG4gKiBVc2VmdWwgY29uc3RhbnRzIGFuZCBmdW5jdGlvbnMgZm9yIGNvbXB1dGluZyB0aGUgc3BlZWQgb2YgTW9yc2UgY29kZS5cbiAqL1xuXG5jb25zdCBESVRTX1BFUl9XT1JEID0gNTA7ICAvKiogZGl0cyBpbiBcIlBBUklTIFwiICovXG5jb25zdCBTUEFDRVNfSU5fUEFSSVMgPSAxOTsgIC8qKiA1eCAzLWRpdCBpbnRlci1jaGFyYWN0ZXIgc3BhY2VzICsgMXggNy1kaXQgc3BhY2UgKi9cbmNvbnN0IE1TX0lOX01JTlVURSA9IDYwMDAwOyAgLyoqIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaW4gMSBtaW51dGUgKi9cblxuLyoqIEdldCB0aGUgZGl0IGxlbmd0aCBpbiBtc1xuICogQHBhcmFtIHtudW1iZXJ9IHdwbSAtIHNwZWVkIGluIHdvcmRzIHBlciBtaW51dGVcbiAqIEByZXR1cm4ge2ludGVnZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXRMZW5ndGgod3BtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoX2RpdExlbmd0aCh3cG0pKTtcbn1cblxuZnVuY3Rpb24gX2RpdExlbmd0aCh3cG0pIHtcbiAgICByZXR1cm4gKE1TX0lOX01JTlVURSAvIERJVFNfUEVSX1dPUkQpIC8gd3BtO1xufVxuXG4vKipcbiAqIEdldCB0aGUgZGFoIGxlbmd0aCBpbiBtc1xuICogQHBhcmFtIHtudW1iZXJ9IHdwbSAtIHNwZWVkIGluIHdvcmRzIHBlciBtaW51dGVcbiAqIEByZXR1cm4ge2ludGVnZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkYWhMZW5ndGgod3BtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoMyAqIF9kaXRMZW5ndGgod3BtKSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBkaXQgc3BhY2UgaW4gbXNcbiAqIEBwYXJhbSB7bnVtYmVyfSB3cG0gLSBzcGVlZCBpbiB3b3JkcyBwZXIgbWludXRlXG4gKiBAcmV0dXJuIHtpbnRlZ2VyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGl0U3BhY2Uod3BtKSB7XG4gICAgcmV0dXJuIGRpdExlbmd0aCh3cG0pXG59XG5cbi8qKlxuICogR2V0IHRoZSBjaGFyYWN0ZXItc3BhY2UgaW4gbXNcbiAqIEBwYXJhbSB7bnVtYmVyfSB3cG0gLSBzcGVlZCBpbiB3b3JkcyBwZXIgbWludXRlXG4gKiBAcGFyYW0ge251bWJlcn0gW2Z3cG0gPSB3cG1dIC0gRmFybnN3b3J0aCBzcGVlZCBpbiB3b3JkcyBwZXIgbWludXRlXG4gKiBAcmV0dXJuIHtpbnRlZ2VyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hhclNwYWNlKHdwbSwgZndwbSA9IHdwbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKDMgKiBfZmRpdExlbmd0aCh3cG0sIGZ3cG0pKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHdvcmQtc3BhY2UgaW4gbXNcbiAqIEBwYXJhbSB7bnVtYmVyfSB3cG0gLSBzcGVlZCBpbiB3b3JkcyBwZXIgbWludXRlXG4gKiBAcGFyYW0ge251bWJlcn0gW2Z3cG0gPSB3cG1dIC0gRmFybnN3b3J0aCBzcGVlZCBpbiB3b3JkcyBwZXIgbWludXRlXG4gKiBAcmV0dXJuIHtpbnRlZ2VyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gd29yZFNwYWNlKHdwbSwgZndwbSA9IHdwbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKDcgKiBfZmRpdExlbmd0aCh3cG0sIGZ3cG0pKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIFdQTSBmb3IgYSBnaXZlbiBkaXQgbGVuZ3RoIGluIG1zXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3cG0oZGl0TGVuKSB7XG4gICAgcmV0dXJuIChNU19JTl9NSU5VVEUgLyBESVRTX1BFUl9XT1JEKSAvIGRpdExlbjtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIEZhcm5zd29ydGggZGl0IGxlbmd0aCBpbiBtcyBmb3IgYSBnaXZlbiBXUE0gYW5kIEZhcm5zd29ydGggV1BNLiBOb3RlLCBhY3R1YWwgZGl0LXNwYWNlcyBzaG91bGQgbm90IGJlIHNsb3dlZCBkb3duXG4gKiBAcmV0dXJuIHtpbnRlZ2VyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmRpdExlbmd0aCh3cG0sIGZ3cG0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChfZmRpdExlbmd0aCh3cG0sIGZ3cG0pKTtcbn1cblxuZnVuY3Rpb24gX2ZkaXRMZW5ndGgod3BtLCBmd3BtKSB7XG4gICAgcmV0dXJuIF9kaXRMZW5ndGgod3BtKSAqIHJhdGlvKHdwbSwgZndwbSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBkaXQgbGVuZ3RoIHJhdGlvIGZvciBhIGdpdmVuIFdQTSBhbmQgRmFybnN3b3J0aCBXUE1cbiAqIEBwYXJhbSB7bnVtYmVyfSB3cG0gLSBzcGVlZCBpbiB3b3JkcyBwZXIgbWludXRlXG4gKiBAcGFyYW0ge251bWJlcn0gZndwbSAtIEZhcm5zd29ydGggc3BlZWQgaW4gd29yZHMgcGVyIG1pbnV0ZVxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmF0aW8od3BtLCBmd3BtKSB7XG4gICAgLy8gXCJQQVJJUyBcIiBpcyAzMSB1bml0cyBmb3IgdGhlIGNoYXJhY3RlcnMgYW5kIDE5IHVuaXRzIGZvciB0aGUgaW50ZXItY2hhcmFjdGVyIHNwYWNlcyBhbmQgaW50ZXItd29yZCBzcGFjZVxuICAgIC8vIE9uZSB1bml0IHRha2VzIDEgKiA2MCAvICg1MCAqIHdwbSlcbiAgICAvLyBUaGUgMzEgdW5pdHMgc2hvdWxkIHRha2UgMzEgKiA2MCAvICg1MCAqIHdwbSkgc2Vjb25kcyBhdCB3cG1cbiAgICAvLyBcIlBBUklTIFwiIHNob3VsZCB0YWtlIDUwICogNjAgLyAoNTAgKiBmd3BtKSB0byB0cmFuc21pdCBhdCBmd3BtLCBvciA2MCAvIGZ3cG0gIHNlY29uZHMgYXQgZndwbVxuICAgIC8vIEtlZXBpbmcgdGhlIHRpbWUgZm9yIHRoZSBjaGFyYWN0ZXJzIGNvbnN0YW50LFxuICAgIC8vIFRoZSBzcGFjZXMgbmVlZCB0byB0YWtlOiAoNjAgLyBmd3BtKSAtIFszMSAqIDYwIC8gKDUwICogd3BtKV0gc2Vjb25kcyBpbiB0b3RhbFxuICAgIC8vIFRoZSBzcGFjZXMgYXJlIDQgaW50ZXItY2hhcmFjdGVyIHNwYWNlcyBvZiAzIHVuaXRzIGFuZCAxIGludGVyLXdvcmQgc3BhY2Ugb2YgNyB1bml0cy4gVGhlaXIgcmF0aW8gbXVzdCBiZSBtYWludGFpbmVkLlxuICAgIC8vIEEgc3BhY2UgdW5pdCBpczogWyg2MCAvIGZ3cG0pIC0gWzMxICogNjAgLyAoNTAgKiB3cG0pXV0gLyAxOSBzZWNvbmRzXG4gICAgLy8gQ29tcGFyaW5nIHRoYXQgdG8gNjAgLyAoNTAgKiB3cG0pIGdpdmVzIGEgcmF0aW8gb2YgKDUwLndwbSAtIDMxLmZ3cG0pIC8gMTkuZndwbVxuICAgIHJldHVybiAoRElUU19QRVJfV09SRCAqIHdwbSAtIChESVRTX1BFUl9XT1JEIC0gU1BBQ0VTX0lOX1BBUklTKSAqIGZ3cG0pIC8gKFNQQUNFU19JTl9QQVJJUyAqIGZ3cG0pO1xufVxuXG4vKiogR2V0IHRoZSBGYXJuc3dvcnRoIFdQTSBmb3IgYSBnaXZlbiBXUE0gYW5kIHJhdGlvICovXG5leHBvcnQgZnVuY3Rpb24gZndwbSh3cG0sIHIpIHtcbiAgICByZXR1cm4gRElUU19QRVJfV09SRCAqIHdwbSAvIChTUEFDRVNfSU5fUEFSSVMgKiByICsgKERJVFNfUEVSX1dPUkQgLSBTUEFDRVNfSU5fUEFSSVMpKTtcbn0iLCIvKiFcblRoaXMgY29kZSBpcyDCqSBDb3B5cmlnaHQgU3RlcGhlbiBDLiBQaGlsbGlwcywgMjAxOC5cbkVtYWlsOiBzdGV2ZUBzY3BoaWxsaXBzLmNvbVxuKi9cbi8qXG5MaWNlbnNlZCB1bmRlciB0aGUgRVVQTCwgVmVyc2lvbiAxLjIgb3Ig4oCTIGFzIHNvb24gdGhleSB3aWxsIGJlIGFwcHJvdmVkIGJ5IHRoZSBFdXJvcGVhbiBDb21taXNzaW9uIC0gc3Vic2VxdWVudCB2ZXJzaW9ucyBvZiB0aGUgRVVQTCAodGhlIFwiTGljZW5jZVwiKTtcbllvdSBtYXkgbm90IHVzZSB0aGlzIHdvcmsgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5jZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5jZSBhdDogaHR0cHM6Ly9qb2ludXAuZWMuZXVyb3BhLmV1L2NvbW11bml0eS9ldXBsL1xuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5jZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgYmFzaXMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbmNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5jZS5cbiovXG5cbi8qKlxuICogQmFzaWMgbWV0aG9kcyB0byB0cmFuc2xhdGUgTW9yc2UgY29kZS5cbiAqL1xuXG5pZiAodHlwZW9mKFN0cmluZy5wcm90b3R5cGUudHJpbSkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBTdHJpbmcucHJvdG90eXBlLnRyaW0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyh0aGlzKS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XG4gICAgfTtcbn1cblxudmFyIHRleHQybW9yc2VIID0ge1xuICAgICdBJzogXCIuLVwiLFxuICAgICdCJzogXCItLi4uXCIsXG4gICAgJ0MnOiBcIi0uLS5cIixcbiAgICAnRCc6IFwiLS4uXCIsXG4gICAgJ0UnOiBcIi5cIixcbiAgICAnRic6IFwiLi4tLlwiLFxuICAgICdHJzogXCItLS5cIixcbiAgICAnSCc6IFwiLi4uLlwiLFxuICAgICdJJzogXCIuLlwiLFxuICAgICdKJzogXCIuLS0tXCIsXG4gICAgJ0snOiBcIi0uLVwiLFxuICAgICdMJzogXCIuLS4uXCIsXG4gICAgJ00nOiBcIi0tXCIsXG4gICAgJ04nOiBcIi0uXCIsXG4gICAgJ08nOiBcIi0tLVwiLFxuICAgICdQJzogXCIuLS0uXCIsXG4gICAgJ1EnOiBcIi0tLi1cIixcbiAgICAnUic6IFwiLi0uXCIsXG4gICAgJ1MnOiBcIi4uLlwiLFxuICAgICdUJzogXCItXCIsXG4gICAgJ1UnOiBcIi4uLVwiLFxuICAgICdWJzogXCIuLi4tXCIsXG4gICAgJ1cnOiBcIi4tLVwiLFxuICAgICdYJzogXCItLi4tXCIsXG4gICAgJ1knOiBcIi0uLS1cIixcbiAgICAnWic6IFwiLS0uLlwiLFxuICAgICcxJzogXCIuLS0tLVwiLFxuICAgICcyJzogXCIuLi0tLVwiLFxuICAgICczJzogXCIuLi4tLVwiLFxuICAgICc0JzogXCIuLi4uLVwiLFxuICAgICc1JzogXCIuLi4uLlwiLFxuICAgICc2JzogXCItLi4uLlwiLFxuICAgICc3JzogXCItLS4uLlwiLFxuICAgICc4JzogXCItLS0uLlwiLFxuICAgICc5JzogXCItLS0tLlwiLFxuICAgICcwJzogXCItLS0tLVwiLFxuICAgICcuJzogXCIuLS4tLi1cIixcbiAgICAnLCc6IFwiLS0uLi0tXCIsXG4gICAgJzonOiBcIi0tLS4uLlwiLFxuICAgICc/JzogXCIuLi0tLi5cIixcbiAgICAnXFwnJzogXCIuLS0tLS5cIixcbiAgICAnLSc6IFwiLS4uLi4tXCIsXG4gICAgJy8nOiBcIi0uLi0uXCIsXG4gICAgJygnOiBcIi0uLS0uXCIsXG4gICAgJyknOiBcIi0uLS0uLVwiLFxuICAgICdcIic6IFwiLi0uLi0uXCIsXG4gICAgJ0AnOiBcIi4tLS4tLlwiLFxuICAgICc9JzogXCItLi4uLVwiLFxuICAgICcmJzogXCIuLS4uLlwiLFxuICAgICcrJzogXCIuLS4tLlwiLFxuICAgICchJzogXCItLi0uLS1cIixcbiAgICAnICc6IFwiL1wiIC8vTm90IG1vcnNlIGJ1dCBoZWxwcyB0cmFuc2xhdGlvblxufTtcbnZhciBtb3JzZTJ0ZXh0SCA9IHt9O1xudmFyIHByb3NpZ24ybW9yc2VIID0ge1xuICAgICc8QUE+JzogJy4tLi0nLFxuICAgICc8QVI+JzogJy4tLi0uJyxcbiAgICAnPEFTPic6ICcuLS4uLicsXG4gICAgJzxCSz4nOiAnLS4uLi0uLScsXG4gICAgJzxCVD4nOiAnLS4uLi0nLCAvLyBhbHNvIDxUVj5cbiAgICAnPENMPic6ICctLi0uLi0uLicsXG4gICAgJzxDVD4nOiAnLS4tLi0nLFxuICAgICc8RE8+JzogJy0uLi0tLScsXG4gICAgJzxLTj4nOiAnLS4tLS4nLFxuICAgICc8U0s+JzogJy4uLi0uLScsIC8vIGFsc28gPFZBPlxuICAgICc8VkE+JzogJy4uLi0uLScsXG4gICAgJzxTTj4nOiAnLi4uLS4nLCAvLyBhbHNvIDxWRT5cbiAgICAnPFZFPic6ICcuLi4tLicsXG4gICAgJzxTT1M+JzogJy4uLi0tLS4uLidcbn07XG52YXIgbW9yc2Vwcm8ydGV4dEggPSB7fTtcbnZhciB0ZXh0Mm1vcnNlcHJvSCA9IHt9O1xuZm9yICh2YXIgdGV4dCBpbiB0ZXh0Mm1vcnNlSCkge1xuICAgIHRleHQybW9yc2Vwcm9IW3RleHRdID0gdGV4dDJtb3JzZUhbdGV4dF07XG4gICAgbW9yc2UydGV4dEhbdGV4dDJtb3JzZUhbdGV4dF1dID0gdGV4dDtcbiAgICBtb3JzZXBybzJ0ZXh0SFt0ZXh0Mm1vcnNlSFt0ZXh0XV0gPSB0ZXh0O1xufVxuZm9yICh2YXIgc2lnbiBpbiBwcm9zaWduMm1vcnNlSCkge1xuICAgIHRleHQybW9yc2Vwcm9IW3NpZ25dID0gcHJvc2lnbjJtb3JzZUhbc2lnbl07XG4gICAgbW9yc2Vwcm8ydGV4dEhbcHJvc2lnbjJtb3JzZUhbc2lnbl1dID0gc2lnbjtcbn1cblxudmFyIHRpZHlUZXh0ID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHRleHQgPSB0ZXh0LnRvVXBwZXJDYXNlKCk7XG4gICAgdGV4dCA9IHRleHQudHJpbSgpO1xuICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xccysvZywgJyAnKTtcbiAgICByZXR1cm4gdGV4dDtcbn07XG5cbi8qKlxuICogVHJhbnNsYXRlIHRleHQgdG8gbW9yc2UgaW4gJy4uLSAuLiAvIC0tJyBmb3JtLlxuICogSWYgc29tZXRoaW5nIGluIHRoZSB0ZXh0IGlzIHVudHJhbnNsYXRhYmxlIHRoZW4gaXQgaXMgc3Vycm91bmRlZCBieSBoYXNoLXNpZ25zICgnIycpIGFuZCBhIGhhc2ggaXMgcGxhY2VkIGluIHRoZSBtb3JzZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gYWxwaGFudW1lcmljIG1lc3NhZ2VcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlUHJvc2lnbnMgLSB0cnVlIGlmIHByb3NpZ25zIGFyZSB0byBiZSB1c2VkIChkZWZhdWx0IGlzIHRydWUpXG4gKiBAcmV0dXJuIHt7bWVzc2FnZTogc3RyaW5nLCBtb3JzZTogc3RyaW5nLCBoYXNFcnJvcjogYm9vbGVhbn19XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0ZXh0Mm1vcnNlKHRleHQsIHVzZVByb3NpZ25zID0gdHJ1ZSkge1xuICAgIHRleHQgPSB0aWR5VGV4dCh0ZXh0KTtcbiAgICB2YXIgcmV0ID0ge1xuICAgICAgICBtb3JzZTogXCJcIixcbiAgICAgICAgbWVzc2FnZTogXCJcIixcbiAgICAgICAgaGFzRXJyb3I6IGZhbHNlXG4gICAgfTtcbiAgICBpZiAodGV4dCA9PT0gXCJcIikge1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIHZhciB0b2tlbnMgPSBbXTtcbiAgICB2YXIgcHJvc2lnbjtcbiAgICB2YXIgdG9rZW5fbGVuZ3RoO1xuICAgIHdoaWxlICh0ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgdG9rZW5fbGVuZ3RoID0gMTtcbiAgICAgICAgaWYgKHVzZVByb3NpZ25zKSB7XG4gICAgICAgICAgICBwcm9zaWduID0gdGV4dC5tYXRjaCgvXjwuLi4/Pi8pOyAvLyBhcnJheSBvZiBtYXRjaGVzXG4gICAgICAgICAgICBpZiAocHJvc2lnbikge1xuICAgICAgICAgICAgICAgIHRva2VuX2xlbmd0aCA9IHByb3NpZ25bMF0ubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRva2Vucy5wdXNoKHRleHQuc2xpY2UoMCwgdG9rZW5fbGVuZ3RoKSk7XG4gICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKHRva2VuX2xlbmd0aCwgdGV4dC5sZW5ndGgpO1xuICAgIH1cbiAgICB2YXIgZGljdDtcbiAgICBpZiAodXNlUHJvc2lnbnMpIHtcbiAgICAgICAgZGljdCA9IHRleHQybW9yc2Vwcm9IO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRpY3QgPSB0ZXh0Mm1vcnNlSDtcbiAgICB9XG4gICAgdmFyIGksIGMsIHQ7XG4gICAgZm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0ID0gdG9rZW5zW2ldO1xuICAgICAgICBjID0gZGljdFt0XTtcbiAgICAgICAgaWYgKGMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0Lm1lc3NhZ2UgKz0gXCIjXCIgKyB0ICsgXCIjXCI7XG4gICAgICAgICAgICByZXQubW9yc2UgKz0gXCIjIFwiO1xuICAgICAgICAgICAgcmV0Lmhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldC5tZXNzYWdlICs9IHQ7XG4gICAgICAgICAgICByZXQubW9yc2UgKz0gYyArIFwiIFwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldC5tb3JzZSA9IHJldC5tb3JzZS5zbGljZSgwLCByZXQubW9yc2UubGVuZ3RoIC0gMSk7XG4gICAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBUcmFuc2xhdGUgdGV4dCB0byBtb3JzZSBpbiAnRGktZGktZGFoIGRhaCcgZm9ybS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gYWxwaGFudW1lcmljIG1lc3NhZ2VcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlUHJvc2lnbnMgLSB0cnVlIGlmIHByb3NpZ25zIGFyZSB0byBiZSB1c2VkIChkZWZhdWx0IGlzIHRydWUpXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0ZXh0MmRpdGRhaCh0ZXh0LCB1c2VQcm9zaWducykge1xuICAgIC8vIFRPRE86IGRlYWwgd2l0aCBlcnJvcnMgaW4gdGhlIHRyYW5zbGF0aW9uXG4gICAgdmFyIGRpdGRhaCA9IHRleHQybW9yc2UodGV4dCwgdXNlUHJvc2lnbnMpLm1vcnNlICsgJyAnOyAvLyBnZXQgdGhlIGRvdHMgYW5kIGRhc2hlc1xuICAgIGRpdGRhaCA9IGRpdGRhaC5yZXBsYWNlKC9cXC4vZywgJ2RpficpLnJlcGxhY2UoL1xcLS9nLCAnZGFoficpOyAvLyBkbyB0aGUgYmFzaWMgam9iXG4gICAgZGl0ZGFoID0gZGl0ZGFoLnJlcGxhY2UoL34vZywgJy0nKTsgLy8gcmVwbGFjZSBwbGFjZWhvbGRlciB3aXRoIGRhc2hcbiAgICBkaXRkYWggPSBkaXRkYWgucmVwbGFjZSgvXFwtIC9nLCAnICcpOyAvLyByZW1vdmUgdHJhaWxpbmcgZGFzaGVzXG4gICAgZGl0ZGFoID0gZGl0ZGFoLnJlcGxhY2UoL2RpIC9nLCAnZGl0ICcpOyAvLyB1c2UgJ2RpdCcgYXQgZW5kIG9mIGxldHRlclxuICAgIGRpdGRhaCA9IGRpdGRhaC5yZXBsYWNlKC8gXFwvIC9nLCAnLCAnKTsgLy8gZG8gcHVuY3R1YXRpb25cbiAgICBkaXRkYWggPSBkaXRkYWgucmVwbGFjZSgvXmQvLCAnRCcpOyAvLyBkbyBjYXBpdGFsaXNhdGlvblxuICAgIGRpdGRhaCA9IGRpdGRhaC5yZXBsYWNlKC8gJC8sICcnKTsgLy8gcmVtb3ZlIHRoZSBzcGFjZSB3ZSBhZGRlZFxuICAgIGRpdGRhaCA9IGRpdGRhaC5yZXBsYWNlKC8oW3RoXSkkLywgJyQxLicpOyAvLyBhZGQgZnVsbC1zdG9wIGlmIHRoZXJlIGlzIGFueXRoaW5nIHRoZXJlXG4gICAgcmV0dXJuIGRpdGRhaDtcbn1cblxuLyoqXG4gKiBDYW5vbmljYWxpc2UgbW9yc2UgdGV4dC5cbiAqIENhbm9uaWNhbCBmb3JtIG1hdGNoZXMgWy4tLyBdKiwgaGFzIHNpbmdsZSBzcGFjZXMgYmV0d2VlbiBjaGFyYWN0ZXJzLCBoYXMgd29yZHMgc2VwYXJhdGVkIGJ5ICcgLyAnLCBhbmQgaGFzIG5vIHNwYWNlcyBhdCB0aGUgc3RhcnQgb3IgZW5kLlxuICogQSBzaW5nbGUgJy8nIG1heSBiZSByZXR1cm5lZCBieSB0aGlzIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IG1vcnNlIC0gTW9yc2UgY29kZSBtYXRjaGluZyBbLi1fL3wgXSpcbiAqIEByZXR1cm4ge3N0cmluZ30gTW9yc2UgY29kZSBpbiBjYW5vbmljYWwgZm9ybSBtYXRjaGluZyBbLi0vIF0qXG4gKi9cbnZhciB0aWR5TW9yc2UgPSBmdW5jdGlvbihtb3JzZSkge1xuICAgIG1vcnNlID0gbW9yc2UucmVwbGFjZSgvXFx8L2csIFwiL1wiKTsgLy8gdW5pZnkgdGhlIHdvcmQgc2VwYXJhdG9yXG4gICAgbW9yc2UgPSBtb3JzZS5yZXBsYWNlKC9cXC8vZywgXCIgLyBcIik7IC8vIG1ha2Ugc3VyZSB3b3JkIHNlcGFyYXRvcnMgYXJlIHNwYWNlZCBvdXRcbiAgICBtb3JzZSA9IG1vcnNlLnJlcGxhY2UoL1xccysvZywgXCIgXCIpOyAvLyBzcXVhc2ggbXVsdGlwbGUgc3BhY2VzIGludG8gc2luZ2xlIHNwYWNlc1xuICAgIG1vcnNlID0gbW9yc2UucmVwbGFjZSgvKFxcLyApK1xcLy9nLCBcIi9cIik7IC8vIHNxdWFzaCBtdWx0aXBsZSB3b3JkIHNlcGFyYXRvcnNcbiAgICBtb3JzZSA9IG1vcnNlLnJlcGxhY2UoL18vZywgXCItXCIpOyAvLyB1bmlmeSB0aGUgZGFzaCBjaGFyYWN0ZXJcbiAgICBtb3JzZSA9IG1vcnNlLnJlcGxhY2UoL15cXHMrLywgXCJcIik7ICAvLyByZW1vdmUgaW5pdGlhbCB3aGl0ZXNwYWNlXG4gICAgbW9yc2UgPSBtb3JzZS5yZXBsYWNlKC9cXHMrJC8sIFwiXCIpOyAgLy8gcmVtb3ZlIHRyYWlsaW5nIHdoaXRlc3BhY2VcbiAgICByZXR1cm4gbW9yc2U7XG59O1xuXG4vKipcbiAqIFRyYW5zbGF0ZSBtb3JzZSB0byB0ZXh0LiBDYW5vbmljYWxpc2UgdGhlIG1vcnNlIGZpcnN0LlxuICogSWYgc29tZXRoaW5nIGluIHRoZSBtb3JzZSBpcyB1bnRyYW5zbGF0YWJsZSB0aGVuIGl0IGlzIHN1cnJvdW5kZWQgYnkgaGFzaC1zaWducyAoJyMnKSBhbmQgYSBoYXNoIGlzIHBsYWNlZCBpbiB0aGUgdGV4dC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBtb3JzZSAtIG1vcnNlIG1lc3NhZ2UgdXNpbmcgWy4tXy98IF0gY2hhcmFjdGVyc1xuICogQHBhcmFtIHtib29sZWFufSB1c2VQcm9zaWducyAtIHRydWUgaWYgcHJvc2lnbnMgYXJlIHRvIGJlIHVzZWQgKGRlZmF1bHQgaXMgdHJ1ZSlcbiAqIEByZXR1cm4ge3ttZXNzYWdlOiBzdHJpbmcsIG1vcnNlOiBzdHJpbmcsIGhhc0Vycm9yOiBib29sZWFufX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1vcnNlMnRleHQobW9yc2UsIHVzZVByb3NpZ25zID0gdHJ1ZSkge1xuICAgIG1vcnNlID0gdGlkeU1vcnNlKG1vcnNlKTtcbiAgICB2YXIgcmV0ID0ge1xuICAgICAgICBtb3JzZTogXCJcIixcbiAgICAgICAgbWVzc2FnZTogXCJcIixcbiAgICAgICAgaGFzRXJyb3I6IGZhbHNlXG4gICAgfTtcbiAgICBpZiAobW9yc2UgPT09IFwiXCIpIHtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICB2YXIgdG9rZW5zID0gbW9yc2Uuc3BsaXQoXCIgXCIpO1xuICAgIHZhciBkaWN0O1xuICAgIGlmICh1c2VQcm9zaWducykge1xuICAgICAgICBkaWN0ID0gbW9yc2Vwcm8ydGV4dEg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZGljdCA9IG1vcnNlMnRleHRIO1xuICAgIH1cbiAgICB2YXIgYywgdDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0ID0gdG9rZW5zW2ldO1xuICAgICAgICBjID0gZGljdFt0XTtcbiAgICAgICAgaWYgKGMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0Lm1vcnNlICs9IFwiI1wiICsgdCArIFwiIyBcIjtcbiAgICAgICAgICAgIHJldC5tZXNzYWdlICs9IFwiI1wiO1xuICAgICAgICAgICAgcmV0Lmhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldC5tb3JzZSArPSB0ICsgXCIgXCI7XG4gICAgICAgICAgICByZXQubWVzc2FnZSArPSBjO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldC5tb3JzZSA9IHJldC5tb3JzZS5zbGljZSgwLCByZXQubW9yc2UubGVuZ3RoIC0gMSk7XG4gICAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciBhIHN0cmluZyBpcyBtb3N0IGxpa2VseSBtb3JzZSBjb2RlLlxuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0IC0gdGhlIHRleHRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IC0gdHJ1ZSBpZiB0aGUgc3RyaW5nIG9ubHkgaGFzIE1vcnNlIGNoYXJhY3RlcnMgaW4gYWZ0ZXIgZXhlY3V0aW5nIHRpZHlNb3JzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gbG9va3NMaWtlTW9yc2UoaW5wdXQpIHtcbiAgICBpbnB1dCA9IHRpZHlNb3JzZShpbnB1dCk7XG4gICAgcmV0dXJuIChpbnB1dC5tYXRjaCgvXlsvLi1dWyAvLi1dKiQvKSAhPT0gbnVsbCk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBNb3JzZUxlc3NvblBsdWdpbiB7XG4gICAgc3RhdGljIGFkZExlc3NvbkZlYXR1cmVzID0gKGtvLCBjdHh0KSA9PiB7XG4gICAgICBjdHh0LnNldFVzZXJUYXJnZXRJbml0aWFsaXplZCA9ICgpID0+IHtcbiAgICAgICAgY3R4dC51c2VyVGFyZ2V0SW5pdGlhbGl6ZWQgPSB0cnVlXG4gICAgICB9XG5cbiAgICAgIGN0eHQuc2V0U2VsZWN0ZWRDbGFzc0luaXRpYWxpemVkID0gKCkgPT4ge1xuICAgICAgICBjdHh0LnNlbGVjdGVkQ2xhc3NJbml0aWFsaXplZCA9IHRydWVcbiAgICAgIH1cblxuICAgICAgY3R4dC5zZXRMZXR0ZXJHcm91cEluaXRpYWxpemVkID0gKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnc2V0bGV0dGVyZ3JvdXBpbml0aWFsaXplZCcpXG4gICAgICAgIGN0eHQubGV0dGVyR3JvdXBJbml0aWFsaXplZCA9IHRydWVcbiAgICAgIH1cblxuICAgICAgY3R4dC5zZXREaXNwbGF5c0luaXRpYWxpemVkID0gKCkgPT4ge1xuICAgICAgICBjdHh0LmRpc3BsYXlzSW5pdGlhbGl6ZWQgPSB0cnVlXG4gICAgICB9XG5cbiAgICAgIGN0eHQuY2hhbmdlVXNlclRhcmdldCA9ICh1c2VyVGFyZ2V0KSA9PiB7XG4gICAgICAgIGlmIChjdHh0LnVzZXJUYXJnZXRJbml0aWFsaXplZCkge1xuICAgICAgICAgIGN0eHQudXNlclRhcmdldCh1c2VyVGFyZ2V0KVxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCd1c2VydGFyZ2V0JylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjdHh0LmNoYW5nZVNlbGVjdGVkQ2xhc3MgPSAoc2VsZWN0ZWRDbGFzcykgPT4ge1xuICAgICAgICBpZiAoY3R4dC5zZWxlY3RlZENsYXNzSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICBjdHh0LnNlbGVjdGVkQ2xhc3Moc2VsZWN0ZWRDbGFzcylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjdHh0LnNldExldHRlckdyb3VwID0gKGxldHRlckdyb3VwKSA9PiB7XG4gICAgICAgIGlmIChjdHh0LmxldHRlckdyb3VwSW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZygnc2V0bGV0dGVyZ3JvdXAnKVxuICAgICAgICAgIGN0eHQubGV0dGVyR3JvdXAobGV0dGVyR3JvdXApXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY3R4dC5zZXREaXNwbGF5U2VsZWN0ZWQgPSAoZGlzcGxheSkgPT4ge1xuICAgICAgICBpZiAoY3R4dC5kaXNwbGF5c0luaXRpYWxpemVkKSB7XG4gICAgICAgICAgY3R4dC5zZWxlY3RlZERpc3BsYXkoZGlzcGxheSlcbiAgICAgICAgICBjdHh0LnNldFRleHQoYHdoZW4gd2UgaGF2ZSBsZXNzb24gZmlsZXMsIGxvYWQgJHtjdHh0LnNlbGVjdGVkRGlzcGxheSgpLmZpbGVOYW1lfWApXG4gICAgICAgICAgY3R4dC5nZXRXb3JkTGlzdChjdHh0LnNlbGVjdGVkRGlzcGxheSgpLmZpbGVOYW1lKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGN0eHQuaW5pdGlhbGl6ZVdvcmRMaXN0ID0gKCkgPT4ge1xuICAgICAgICBmZXRjaCgnd29yZGZpbGVzY29uZmlncy93b3JkbGlzdHMuanNvbicpXG4gICAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpXG4gICAgICAgICAgfSlcbiAgICAgICAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgY3R4dC53b3JkTGlzdHMoZGF0YS5maWxlT3B0aW9ucylcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnZXJyb3I6ICcgKyBlcnIpXG4gICAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgY3R4dC51c2VyVGFyZ2V0cyA9IGtvLmNvbXB1dGVkKCgpID0+IHtcbiAgICAgICAgY29uc3QgdGFyZ3MgPSBbXVxuICAgICAgICBjdHh0LndvcmRMaXN0cygpLmZvckVhY2goKHgpID0+IHtcbiAgICAgICAgICBpZiAoIXRhcmdzLmZpbmQoKHkpID0+IHkgPT09IHgudXNlclRhcmdldCkpIHtcbiAgICAgICAgICAgIHRhcmdzLnB1c2goeC51c2VyVGFyZ2V0KVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIHRhcmdzXG4gICAgICB9LCBjdHh0KVxuXG4gICAgICBjdHh0LmNsYXNzZXMgPSBrby5jb21wdXRlZCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNscyA9IFtdXG4gICAgICAgIGN0eHQud29yZExpc3RzKCkuZm9yRWFjaCgoeCkgPT4ge1xuICAgICAgICAgIGlmICghY2xzLmZpbmQoKHkpID0+IHkgPT09IHguY2xhc3MpKSB7XG4gICAgICAgICAgICBjbHMucHVzaCh4LmNsYXNzKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIGNsc1xuICAgICAgfSwgY3R4dClcblxuICAgICAgY3R4dC5sZXR0ZXJHcm91cHMgPSBrby5jb21wdXRlZCgoKSA9PiB7XG4gICAgICAgIGN0eHQubGV0dGVyR3JvdXBJbml0aWFsaXplZCA9IGZhbHNlXG4gICAgICAgIGN0eHQubGV0dGVyR3JvdXAoJycpXG4gICAgICAgIGNvbnN0IGxncyA9IFtdXG4gICAgICAgIGlmIChjdHh0LnNlbGVjdGVkQ2xhc3MoKSA9PT0gJycgfHwgY3R4dC51c2VyVGFyZ2V0KCkgPT09ICcnKSB7XG4gICAgICAgICAgY29uc3QgbWlzc2luZyA9IFtdXG4gICAgICAgICAgaWYgKGN0eHQuc2VsZWN0ZWRDbGFzcygpID09PSAnJykge1xuICAgICAgICAgICAgbWlzc2luZy5wdXNoKCdjbGFzcycpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjdHh0LnVzZXJUYXJnZXQoKSA9PT0gJycpIHtcbiAgICAgICAgICAgIG1pc3NpbmcucHVzaCgndXNlcicpXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbYFNlbGVjdCAke21pc3Npbmcuam9pbignLCAnKX1gXVxuICAgICAgICB9XG4gICAgICAgIGN0eHQud29yZExpc3RzKCkuZmlsdGVyKChsaXN0KSA9PiBsaXN0LmNsYXNzID09PSBjdHh0LnNlbGVjdGVkQ2xhc3MoKSAmJiBsaXN0LnVzZXJUYXJnZXQgPT09IGN0eHQudXNlclRhcmdldCgpKVxuICAgICAgICAgIC5mb3JFYWNoKCh4KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWxncy5maW5kKCh5KSA9PiB5ID09PSB4LmxldHRlckdyb3VwKSkge1xuICAgICAgICAgICAgICBsZ3MucHVzaCh4LmxldHRlckdyb3VwKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIHJldHVybiBsZ3NcbiAgICAgIH0sIGN0eHQpXG5cbiAgICAgIGN0eHQuZGlzcGxheXMgPSBrby5jb21wdXRlZCgoKSA9PiB7XG4gICAgICAgIGN0eHQuZGlzcGxheXNJbml0aWFsaXplZCA9IGZhbHNlXG4gICAgICAgIGN0eHQuc2VsZWN0ZWREaXNwbGF5KHt9KVxuICAgICAgICBjb25zdCBkcHMgPSBbXVxuICAgICAgICBpZiAoY3R4dC5zZWxlY3RlZENsYXNzKCkgPT09ICcnIHx8IGN0eHQudXNlclRhcmdldCgpID09PSAnJyB8fCBjdHh0LmxldHRlckdyb3VwKCkgPT09ICcnKSB7XG4gICAgICAgICAgcmV0dXJuIFt7IGRpc3BsYXk6ICdTZWxlY3Qgd29yZGxpc3QnLCBmaWxlTmFtZTogJ2R1bW15LnR4dCcgfV1cbiAgICAgICAgfVxuICAgICAgICBjdHh0LndvcmRMaXN0cygpLmZpbHRlcigobGlzdCkgPT4gbGlzdC5jbGFzcyA9PT0gY3R4dC5zZWxlY3RlZENsYXNzKCkgJiZcbiAgICAgICAgICAgbGlzdC51c2VyVGFyZ2V0ID09PSBjdHh0LnVzZXJUYXJnZXQoKSAmJlxuICAgICAgICAgICBsaXN0LmxldHRlckdyb3VwID09PSBjdHh0LmxldHRlckdyb3VwKCkpXG4gICAgICAgICAgLmZvckVhY2goKHgpID0+IHtcbiAgICAgICAgICAgIGlmICghZHBzLmZpbmQoKHkpID0+IHkgPT09IHguZGlzcGxheSkpIHtcbiAgICAgICAgICAgICAgZHBzLnB1c2goeyBkaXNwbGF5OiB4LmRpc3BsYXksIGZpbGVOYW1lOiB4LmZpbGVOYW1lIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIGRwc1xuICAgICAgfSwgY3R4dClcblxuICAgICAgY3R4dC5nZXRXb3JkTGlzdCA9IChmaWxlbmFtZSkgPT4ge1xuICAgICAgICBjb25zdCBpc1RleHQgPSBmaWxlbmFtZS5lbmRzV2l0aCgndHh0JylcbiAgICAgICAgZmV0Y2goJ3dvcmRmaWxlcy8nICsgZmlsZW5hbWUpXG4gICAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNUZXh0KSB7XG4gICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGFzc3VtZSBqc29uXG4gICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNUZXh0KSB7XG4gICAgICAgICAgICAgIGN0eHQuc2V0VGV4dChkYXRhKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY3R4dC5yYW5kb21Xb3JkTGlzdChkYXRhKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdlcnJvcjogJyArIGVycilcbiAgICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCBsaWN3bG9nbyBmcm9tICcuL2Fzc2V0cy9DVy1DbHViLWxvZ28tY2xlYXI0MDAtMzAweDMwMC5wbmcnXG5pbXBvcnQgZG93bkxvYWRQbmcgZnJvbSAnYm9vdHN0cmFwLWljb25zL2ljb25zL2Rvd25sb2FkLnN2ZydcbmltcG9ydCB2b2x1bWVQbmcgZnJvbSAnYm9vdHN0cmFwLWljb25zL2ljb25zL3ZvbHVtZS11cC5zdmcnXG5pbXBvcnQgZ2l0aHViUG5nIGZyb20gJ2Jvb3RzdHJhcC1pY29ucy9pY29ucy9naXRodWIuc3ZnJ1xuaW1wb3J0IGJvb2tQbmcgZnJvbSAnYm9vdHN0cmFwLWljb25zL2ljb25zL2Jvb2suc3ZnJ1xuaW1wb3J0IGZsYWdQbmcgZnJvbSAnYm9vdHN0cmFwLWljb25zL2ljb25zL2ZsYWcuc3ZnJ1xuaW1wb3J0IGxvY2tQbmcgZnJvbSAnYm9vdHN0cmFwLWljb25zL2ljb25zL2xvY2suc3ZnJ1xuaW1wb3J0IHVubG9ja1BuZyBmcm9tICdib290c3RyYXAtaWNvbnMvaWNvbnMvdW5sb2NrLnN2ZydcblxuZXhwb3J0IGNsYXNzIE1vcnNlTG9hZEltYWdlcyB7XG4gIGluZm8gPSBbXVxuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgY29uc3QgbGljd2xvZ29JbWcgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbG9nbycpXG4gICAgbGljd2xvZ29JbWcuc3JjID0gbGljd2xvZ29cblxuICAgIGNvbnN0IGRvd25sb2FkSW1nID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Rvd25sb2FkSW1hZ2UnKVxuICAgIGRvd25sb2FkSW1nLnNyYyA9IGRvd25Mb2FkUG5nXG5cbiAgICBjb25zdCB2b2x1bWVJbWcgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndm9sdW1lSW1hZ2UnKVxuICAgIHZvbHVtZUltZy5zcmMgPSB2b2x1bWVQbmdcblxuICAgIGNvbnN0IGdpdGh1YkltZyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdnaXRodWJJbWFnZScpXG4gICAgZ2l0aHViSW1nLnNyYyA9IGdpdGh1YlBuZ1xuXG4gICAgY29uc3QgYm9va0ltZyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdib29rSW1hZ2UnKVxuICAgIGJvb2tJbWcuc3JjID0gYm9va1BuZ1xuXG4gICAgY29uc3QgZmxhZ0ltZyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmbGFnSW1hZ2UnKVxuICAgIGZsYWdJbWcuc3JjID0gZmxhZ1BuZ1xuXG4gICAgdGhpcy5pbmZvLnB1c2goeyBrZXk6ICdsb2NrSW1hZ2UnLCBzcmM6IGxvY2tQbmcgfSlcbiAgICB0aGlzLmluZm8ucHVzaCh7IGtleTogJ3VubG9ja0ltYWdlJywgc3JjOiB1bmxvY2tQbmcgfSlcbiAgfVxuXG4gIGdldFNyYyA9IChrZXkpID0+IHtcbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzLmluZm8uZmluZCh4ID0+IHgua2V5ID09PSBrZXkpXG4gICAgcmV0dXJuIHRhcmdldC5zcmNcbiAgfVxufVxuIiwiaW1wb3J0IE1vcnNlQ1dXYXZlIGZyb20gJy4vbW9yc2UtcHJvL21vcnNlLXByby1jdy13YXZlLmpzJ1xuaW1wb3J0ICogYXMgUmlmZldhdmUgZnJvbSAnLi9tb3JzZS1wcm8vbW9yc2UtcHJvLXV0aWwtcmlmZndhdmUuanMnXG5pbXBvcnQgeyBNb3JzZUNvdW50VW5pdHMsIE1vcnNlVGltaW5nQ2FsY3VsYXRvciB9IGZyb20gJy4vbW9yc2VUaW1pbmdDYWxjdWxhdG9yLmpzJ1xuZXhwb3J0IGNsYXNzIE1vcnNlU3RyaW5nVG9XYXZCdWZmZXJDb25maWcge1xuICAgIHdvcmQ7XG4gICAgd3BtO1xuICAgIGZ3cG07XG4gICAgZGl0RnJlcXVlbmN5O1xuICAgIGRhaEZyZXF1ZW5jeTtcbiAgICBwcmVQYWRkaW5nTXM7XG4gICAgeHRyYVdvcmRTcGFjZURpdHM7XG4gICAgdm9sdW1lO1xuICAgIGdldCBmcmVxdWVuY3kgKCkgeyByZXR1cm4gdGhpcy5kaXRGcmVxdWVuY3kgfVxufVxuXG5leHBvcnQgY2xhc3MgTW9yc2VTdHJpbmdUb1dhdkJ1ZmZlciB7XG4gICAgc3RhdGljIGdldEluaXQgPSAoY29uZmlnKSA9PiB7XG4gICAgICBjb25zdCB1c2VQcm9zaWducyA9IHRydWVcbiAgICAgIGNvbnN0IHNhbXBsZVJhdGUgPSA4MDAwXG4gICAgICBjb25zdCB0aW1pbmdVbml0cyA9IE1vcnNlVGltaW5nQ2FsY3VsYXRvci5nZXRUaW1pbmdVbml0cyhjb25maWcud3BtLCBjb25maWcuZndwbSlcbiAgICAgIGNvbnN0IGNvdW50VW5pdHMgPSBuZXcgTW9yc2VDb3VudFVuaXRzKClcbiAgICAgIGNvdW50VW5pdHMuZXh0cmFXb3JkU3BhY2luZ0RpdHNDb3VudCA9IGNvbmZpZy54dHJhV29yZFNwYWNlRGl0c1xuICAgICAgLy8gY29uc3QgdW5pdCA9IDEyMDAgLyBjb25maWcuZndwbVxuICAgICAgLy8gY29uc3Qgd29yZFNwYWNlID0gKHVuaXQgKiA3KSArICh1bml0ICogY29uZmlnLnh0cmFXb3JkU3BhY2VEaXRzKVxuICAgICAgY29uc3QgbW9yc2VDV1dhdmUgPSBuZXcgTW9yc2VDV1dhdmUodXNlUHJvc2lnbnMsIGNvbmZpZy53cG0sIGNvbmZpZy5md3BtLCB7IGRpdDogY29uZmlnLmRpdEZyZXF1ZW5jeSwgZGFoOiBjb25maWcuZGFoRnJlcXVlbmN5IH0sIHNhbXBsZVJhdGUpXG4gICAgICBtb3JzZUNXV2F2ZS50cmFuc2xhdGUoY29uZmlnLndvcmQsIGZhbHNlKVxuICAgICAgcmV0dXJuIHsgbW9yc2VDV1dhdmUsIHRpbWluZ1VuaXRzLCBjb3VudFVuaXRzIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlV2F2ID0gKGNvbmZpZykgPT4ge1xuICAgICAgY29uc3QgaW5pdCA9IHRoaXMuZ2V0SW5pdChjb25maWcpXG4gICAgICBjb25zdCByZXQgPSB7fVxuICAgICAgLy8gZ2V0IHdvcmRzcGFjZVxuICAgICAgY29uc3QgY2FsY3MgPSBNb3JzZVRpbWluZ0NhbGN1bGF0b3IuZ2V0VGltZXMoaW5pdC50aW1pbmdVbml0cywgaW5pdC5jb3VudFVuaXRzKVxuXG4gICAgICByZXQuc2FtcGxlID0gaW5pdC5tb3JzZUNXV2F2ZS5nZXRTYW1wbGUoY2FsY3Muc2luZ2xlV29yZFNwYWNlVGltZSwgY29uZmlnLnByZVBhZGRpbmdNcylcbiAgICAgIGNvbnN0IHdhdiA9IFJpZmZXYXZlLmdldERhdGEocmV0LnNhbXBsZSlcbiAgICAgIHJldC53YXYgPSB3YXZcbiAgICAgIHJldHVybiByZXRcbiAgICB9XG5cbiAgICBzdGF0aWMgZXN0aW1hdGVQbGF5VGltZSA9IChjb25maWcpID0+IHtcbiAgICAgIGNvbnN0IGluaXQgPSB0aGlzLmdldEluaXQoY29uZmlnKVxuICAgICAgY29uc3QgdGltaW5nVW5pdHMgPSBpbml0LnRpbWluZ1VuaXRzXG4gICAgICBjb25zdCB1bml0Q291bnRzID0gTW9yc2VUaW1pbmdDYWxjdWxhdG9yLmNvdW50VW5pdHMoaW5pdC5tb3JzZUNXV2F2ZSwgaW5pdC5jb3VudFVuaXRzKVxuICAgICAgY29uc3QgdGltZUNhbGNzID0gTW9yc2VUaW1pbmdDYWxjdWxhdG9yLmdldFRpbWVzKHRpbWluZ1VuaXRzLCB1bml0Q291bnRzKVxuXG4gICAgICByZXR1cm4geyBtb3JzZTogaW5pdC5tb3JzZUNXV2F2ZS5tb3JzZSwgd29yZDogY29uZmlnLndvcmQsIHRpbWluZ1VuaXRzLCB1bml0Q291bnRzLCB0aW1lQ2FsY3MgfVxuICAgIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vcnNlU3RyaW5nVXRpbHMge1xuICAgIHN0YXRpYyBkb1JlcGxhY2VtZW50cyA9IChzKSA9PiB7XG4gICAgICByZXR1cm4gc1xuICAgICAgICAvLyBhIGZldyBhZC1ob2MgYXR0ZW1wdHMgdG8gZml4IHVuaWNvZGUgb3Igb3RoZXIgcHJvYmxlbXNcbiAgICAgICAgLy8gc2VlbXMgbGlrZSBhcG9zdHJhcGhlIGlzIG5vdCBtb3JzZS1hYmxlXG4gICAgICAgIC5yZXBsYWNlKC/igJkvZywgJycpXG4gICAgICAgIC5yZXBsYWNlKC/igJgvZywgJycpXG4gICAgICAgIC5yZXBsYWNlKC8nL2csICcnKVxuICAgICAgICAvLyB0dXJuIHBlcmNlbnQgc2lnbiBpbnRvIHBjdCBhYmJyZXZpYXRpb25cbiAgICAgICAgLnJlcGxhY2UoLyUvZywgJ3BjdCcpXG4gICAgICAgIC8vIGluIHRoZSBzcXVhcmUgYnJhY2tldHMgd2UgYWRkIGFsbCBzeW1ib2xzIHN1cHBvcnRlZCBieSBtb3JzZS1wcm8gKHNlZSBtb3JlLXByby5qcyksIG90aGVyd2lzZSByZXBsYWNlIHdpdGggc3BhY2VcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG4gICAgICAgIC5yZXBsYWNlKC8oPyFbXFwuXFwsXFw6XFw/XFxcXFxcLVxcL1xcKFxcKVxcXCJcXEBcXD1cXCZcXCtcXCFcXDxcXD5dKVxcVy9nLCAnICcpXG4gICAgfVxuXG4gICAgc3RhdGljIHNwbGl0SW50b1NlbnRlbmNlcyA9IChyZXBsYWNlZCkgPT4ge1xuICAgICAgLy8gc3BsaXQgb24gcGVyaW9kIG9yIHF1ZXN0aW9uIG1hcmsgb3IgZXhjbGFtYXRpb24gbWFya1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG4gICAgICBjb25zdCBzcGxpdFNlbnRzID0gcmVwbGFjZWQuc3BsaXQoLyhbXFwuXFw/XFwhXSkvKVxuICAgICAgLy8gZXhhbXBsZVxuICAgICAgLy8gIFwiaGVsbG8gdGhlcmUuIGhvdyBhcmUgeW91PyBJIGFtIGZpbmVcIi5zcGxpdCgvKFtcXC5cXD9dKS8pXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taXJyZWd1bGFyLXdoaXRlc3BhY2VcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1pcnJlZ3VsYXItd2hpdGVzcGFjZVxuICAgICAgLy8gKDUpwqBbJ2hlbGxvIHRoZXJlJywgJy4nLCAnIGhvdyBhcmUgeW91JywgJz8nLCAnIEkgYW0gZmluZSddXG4gICAgICAvLyBub3cgcHV0IHRoZSBwdW5jdHVhdGlvbiBiYWNrIG9uIHRoZSBlbmQgb2Ygc2VudGVuY2VzXG4gICAgICBjb25zdCBzcGxpdHNHbHVlZCA9IHNwbGl0U2VudHMubWFwKCh2YWwsIGksIGFyeSkgPT4ge1xuICAgICAgICBpZiAoaSA9PT0gMCB8fCBpICUgMiA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiB2YWwgKyAoKChpICsgMSkgPCBhcnkubGVuZ3RoKSA/IGFyeVtpICsgMV0gOiAnJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gJydcbiAgICAgICAgfVxuICAgICAgfSkuZmlsdGVyKHkgPT4geSAhPT0gJycpXG4gICAgICByZXR1cm4gc3BsaXRzR2x1ZWRcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0U2VudGVuY2VzID0gKHMsIGRvbnRTcGxpdCkgPT4ge1xuICAgICAgY29uc3QgcmVwbGFjZWQgPSB0aGlzLmRvUmVwbGFjZW1lbnRzKHMpXG4gICAgICBjb25zdCBzcGxpdHNHbHVlZCA9IGRvbnRTcGxpdCA/IFtyZXBsYWNlZF0gOiB0aGlzLnNwbGl0SW50b1NlbnRlbmNlcyhyZXBsYWNlZClcbiAgICAgIGNvbnN0IHNlbnRzID0gc3BsaXRzR2x1ZWRcbiAgICAgICAgLm1hcCgoc2VudGVuY2UpID0+IHtcbiAgICAgICAgICByZXR1cm4gc2VudGVuY2VcbiAgICAgICAgICAgIC50cmltKClcbiAgICAgICAgICAgIC8vIHJlbW92ZSBkb3VibGUgc3BhY2VzXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVnZXgtc3BhY2VzXG4gICAgICAgICAgICAucmVwbGFjZSgvICAvZywgJyAnKVxuICAgICAgICAgICAgLy8gc3BsaXQgdXAgaW50byB3b3Jkc1xuICAgICAgICAgICAgLnNwbGl0KCcgJylcbiAgICAgICAgICAgIC8vIGdldCByaWQgZm8gc3RyYXkgZW1wdGllc1xuICAgICAgICAgICAgLmZpbHRlcih4ID0+IHgudHJpbSgpLmxlbmd0aCA+IDApXG4gICAgICAgIH0pXG4gICAgICAgIC5maWx0ZXIoeCA9PiB4Lmxlbmd0aCA+IDEgfHwgeFswXSAhPT0gJy4nKVxuXG4gICAgICByZXR1cm4gc2VudHNcbiAgICB9XG59XG4iLCJleHBvcnQgY2xhc3MgTW9yc2VDb3VudFVuaXRzIHtcbiAgICBpbnRlckNoYXJhY3RlclNwYWNlQ291bnQgPSAwXG4gICAgaW50cmFDaGFyYWN0ZXJTcGFjZUNvdW50ID0gMFxuICAgIGRpdENvdW50ID0gMFxuICAgIGRhaENvdW50ID0gMFxuICAgIHdvcmRTcGFjZXNDb3VudCA9IDBcbiAgICBleHRyYVdvcmRTcGFjaW5nRGl0c0NvdW50ID0gMFxufVxuXG5leHBvcnQgY2xhc3MgTW9yc2VUaW1pbmdDYWxjdWxhdG9yIHtcbiAgICAvLyBiYXNlZCBvbiBodHRwczovL21vcnNlY29kZS53b3JsZC9pbnRlcm5hdGlvbmFsL3RpbWluZy5odG1sXG4gICAgc3RhdGljIGdldFRpbWluZ1VuaXRzID0gKHdwbSwgZndwbSkgPT4ge1xuICAgICAgY29uc3QgY2FsY3VsYXRlZFNlY29uZHNQZXJEaXQgPSA2MCAvICg1MCAqIHdwbSlcbiAgICAgIGNvbnN0IGNhbGN1bGF0ZWRVbml0c01zID0gY2FsY3VsYXRlZFNlY29uZHNQZXJEaXQgKiAxMDAwXG4gICAgICBjb25zdCBjYWxjdWxhdGVkRldVbml0U2Vjb25kcyA9ICgoNjAgLyBmd3BtKSAtIDMxICogY2FsY3VsYXRlZFNlY29uZHNQZXJEaXQpIC8gMTlcbiAgICAgIGNvbnN0IGNhbGN1bGF0ZWRGV1VuaXRzTXMgPSBjYWxjdWxhdGVkRldVbml0U2Vjb25kcyAqIDEwMDBcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2FsY3VsYXRlZFVuaXRzTXMsXG4gICAgICAgIGNhbGN1bGF0ZWRGV1VuaXRzTXMsXG4gICAgICAgIGRpdFVuaXRNdWx0aVBsaWVyOiAxLFxuICAgICAgICBkYWhVbml0TXVsdGlwbGllcjogMyxcbiAgICAgICAgaW50cmFDaGFyYWN0ZXJTcGFjZU11bHRpcGxpZXI6IDEsXG4gICAgICAgIGludGVyQ2hhcmFjdGVyU3BhY2VNdWx0aXBsaWVyOiAzLFxuICAgICAgICB3b3JkU3BhY2VNdWx0aXBsaWVyOiA3XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGljIGNvdW50VW5pdHMgPSAobW9yc2Vjd3dhdiwgcHJlUG9wdWxhdGVkKSA9PiB7XG4gICAgICBsZXQgY250c1xuICAgICAgaWYgKHByZVBvcHVsYXRlZCkge1xuICAgICAgICBjbnRzID0gcHJlUG9wdWxhdGVkXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbnRzID0gbmV3IE1vcnNlQ291bnRVbml0cygpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1vcnNlV29yZHMgPSBtb3JzZWN3d2F2Lm1vcnNlLnNwbGl0KCcvJylcbiAgICAgIGNudHMud29yZFNwYWNlc0NvdW50ID0gbW9yc2VXb3Jkcy5sZW5ndGggLSAxXG4gICAgICBtb3JzZVdvcmRzLmZvckVhY2goKHdvcmQpID0+IHtcbiAgICAgICAgY29uc3QgY2hhcmFjdGVycyA9IHdvcmQudHJpbSgpLnNwbGl0KCcgJylcbiAgICAgICAgY250cy5pbnRlckNoYXJhY3RlclNwYWNlQ291bnQgKz0gY2hhcmFjdGVycy5sZW5ndGggLSAxXG4gICAgICAgIGNoYXJhY3RlcnMuZm9yRWFjaCgoY2hhcmFjdGVyKSA9PiB7XG4gICAgICAgICAgY250cy5pbnRyYUNoYXJhY3RlclNwYWNlQ291bnQgKz0gY2hhcmFjdGVyLmxlbmd0aCAtIDFcbiAgICAgICAgICBjbnRzLmRpdENvdW50ICs9IGNoYXJhY3Rlci5zcGxpdCgnJykuZmlsdGVyKCh4KSA9PiB4ID09PSAnLicpLmxlbmd0aFxuICAgICAgICAgIGNudHMuZGFoQ291bnQgKz0gY2hhcmFjdGVyLnNwbGl0KCcnKS5maWx0ZXIoKHgpID0+IHggPT09ICctJykubGVuZ3RoXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgICAgcmV0dXJuIGNudHNcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0VGltZXMgPSAodGltaW5nVW5pdHMsIGNvdW50VW5pdHMpID0+IHtcbiAgICAgIGNvbnN0IGRpdFRpbWUgPSBjb3VudFVuaXRzLmRpdENvdW50ICogdGltaW5nVW5pdHMuZGl0VW5pdE11bHRpUGxpZXIgKiB0aW1pbmdVbml0cy5jYWxjdWxhdGVkVW5pdHNNc1xuICAgICAgY29uc3QgZGFoVGltZSA9IGNvdW50VW5pdHMuZGFoQ291bnQgKiB0aW1pbmdVbml0cy5kYWhVbml0TXVsdGlwbGllciAqIHRpbWluZ1VuaXRzLmNhbGN1bGF0ZWRVbml0c01zXG4gICAgICBjb25zdCBpbnRyYUNoYXJhY3RlclNwYWNlVGltZSA9IGNvdW50VW5pdHMuaW50cmFDaGFyYWN0ZXJTcGFjZUNvdW50ICogdGltaW5nVW5pdHMuaW50cmFDaGFyYWN0ZXJTcGFjZU11bHRpcGxpZXIgKiB0aW1pbmdVbml0cy5jYWxjdWxhdGVkVW5pdHNNc1xuICAgICAgLy8gdGhlc2UgYXJlIGZhcm5zd29ydGhlZFxuICAgICAgY29uc3QgaW50ZXJDaGFyYWN0ZXJTcGFjZVRpbWUgPSBjb3VudFVuaXRzLmludGVyQ2hhcmFjdGVyU3BhY2VDb3VudCAqIHRpbWluZ1VuaXRzLmludGVyQ2hhcmFjdGVyU3BhY2VNdWx0aXBsaWVyICogdGltaW5nVW5pdHMuY2FsY3VsYXRlZEZXVW5pdHNNc1xuICAgICAgY29uc3Qgd29yZFNwYWNlVGltZSA9IGNvdW50VW5pdHMud29yZFNwYWNlc0NvdW50ICogdGltaW5nVW5pdHMud29yZFNwYWNlTXVsdGlwbGllciAqIHRpbWluZ1VuaXRzLmNhbGN1bGF0ZWRGV1VuaXRzTXNcbiAgICAgIGNvbnN0IGV4dHJhV29yZFNwYWNpbmdEaXRzVGltZSA9IGNvdW50VW5pdHMud29yZFNwYWNlc0NvdW50ICogY291bnRVbml0cy5leHRyYVdvcmRTcGFjaW5nRGl0c0NvdW50ICogdGltaW5nVW5pdHMuZGl0VW5pdE11bHRpUGxpZXIgKiB0aW1pbmdVbml0cy5jYWxjdWxhdGVkRldVbml0c01zXG5cbiAgICAgIGNvbnN0IHRvdGFsVGltZSA9IGRpdFRpbWUgKyBkYWhUaW1lICsgaW50cmFDaGFyYWN0ZXJTcGFjZVRpbWUgKyBpbnRlckNoYXJhY3RlclNwYWNlVGltZSArIHdvcmRTcGFjZVRpbWUgKyBleHRyYVdvcmRTcGFjaW5nRGl0c1RpbWVcblxuICAgICAgLy8gc2luZ2xlIHdvcmRzcGFjZVxuICAgICAgY29uc3Qgc2luZ2xlV29yZFNwYWNlVGltZSA9IHRpbWluZ1VuaXRzLndvcmRTcGFjZU11bHRpcGxpZXIgKiB0aW1pbmdVbml0cy5jYWxjdWxhdGVkRldVbml0c01zICsgY291bnRVbml0cy5leHRyYVdvcmRTcGFjaW5nRGl0c0NvdW50ICogdGltaW5nVW5pdHMuZGl0VW5pdE11bHRpUGxpZXIgKiB0aW1pbmdVbml0cy5jYWxjdWxhdGVkRldVbml0c01zXG4gICAgICBjb25zdCB0b3RhbFBsdXNUcmFpbCA9IHRvdGFsVGltZSArIHNpbmdsZVdvcmRTcGFjZVRpbWVcbiAgICAgIHJldHVybiB7IHRvdGFsVGltZSwgZGl0VGltZSwgZGFoVGltZSwgaW50cmFDaGFyYWN0ZXJTcGFjZVRpbWUsIGludGVyQ2hhcmFjdGVyU3BhY2VUaW1lLCB3b3JkU3BhY2VUaW1lLCBleHRyYVdvcmRTcGFjaW5nRGl0c1RpbWUsIHNpbmdsZVdvcmRTcGFjZVRpbWUsIHRvdGFsUGx1c1RyYWlsIH1cbiAgICB9XG59XG4iLCIvKiBhYnN0cmFjdCBhd2F5IHRoZSBwbGF5aW5nIG9mIHdhdiBidWZmZXIgaW4gY2FzZSBicm93c2VyIGlzc3VlcyBjb21lIHVwLCBldGNcbmNhbiBjaGFuZ2UgdGhlIGNvZGUgaGVyZSBhbmQgb3RoZXIgY29kZSB3b24ndCBiZSBhZmZlY3RlZC5cbiovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1vcnNlV2F2QnVmZmVyUGxheWVyIHtcbiAgICBteUF1ZGlvQ29udGV4dDtcbiAgICBzb3VyY2U7XG4gICAgc291cmNlRW5kZWQgPSB0cnVlO1xuICAgIHNvdXJjZUVuZGVkQ2FsbEJhY2s7XG4gICAgZ2Fpbk5vZGU7XG4gICAgbm9pc2VOb2RlO1xuICAgIG5vaXNlUGxheWluZyA9IGZhbHNlO1xuICAgIG5vaXNlR2Fpbk5vZGU7XG4gICAgbGFzdE5vaXNlVHlwZSA9ICdvZmYnO1xuXG4gICAgc3RhcnROb2lzZSA9IChjb25maWcpID0+IHtcbiAgICAgIGxldCBub2lzZU5vZGVNYWtlciA9IG51bGxcbiAgICAgIGNvbnN0IGFmdGVySW1wb3J0ID0gKGRlZikgPT4ge1xuICAgICAgICBkZWYuaW5zdGFsbCgpXG4gICAgICAgIG5vaXNlTm9kZU1ha2VyKClcbiAgICAgICAgdGhpcy5ub2lzZUdhaW5Ob2RlID0gdGhpcy5teUF1ZGlvQ29udGV4dC5jcmVhdGVHYWluKClcbiAgICAgICAgdGhpcy5zZXROb2lzZVZvbHVtZShjb25maWcubm9pc2Uuc2NhbGVkTm9pc2VWb2x1bWUpXG4gICAgICAgIHRoaXMubm9pc2VOb2RlLmNvbm5lY3QodGhpcy5ub2lzZUdhaW5Ob2RlKVxuICAgICAgICB0aGlzLm5vaXNlR2Fpbk5vZGUuY29ubmVjdCh0aGlzLm15QXVkaW9Db250ZXh0LmRlc3RpbmF0aW9uKVxuICAgICAgICB0aGlzLm5vaXNlTm9kZS5zdGFydCgpXG4gICAgICAgIGNvbnNvbGUubG9nKCdzdGFydGVkIGEgbm9pc2Ugbm9kZScpXG4gICAgICAgIHRoaXMubm9pc2VQbGF5aW5nID0gdHJ1ZVxuICAgICAgfVxuICAgICAgc3dpdGNoIChjb25maWcubm9pc2UudHlwZSkge1xuICAgICAgICBjYXNlICd3aGl0ZSc6XG4gICAgICAgICAgbm9pc2VOb2RlTWFrZXIgPSAoKSA9PiB7IHRoaXMubm9pc2VOb2RlID0gdGhpcy5teUF1ZGlvQ29udGV4dC5jcmVhdGVXaGl0ZU5vaXNlKCkgfVxuICAgICAgICAgIGltcG9ydCgnd2hpdGUtbm9pc2Utbm9kZScpLnRoZW4oKHsgZGVmYXVsdDogZGVmIH0pID0+IHtcbiAgICAgICAgICAgIGFmdGVySW1wb3J0KGRlZilcbiAgICAgICAgICB9KVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ2Jyb3duJzpcbiAgICAgICAgICBub2lzZU5vZGVNYWtlciA9ICgpID0+IHsgdGhpcy5ub2lzZU5vZGUgPSB0aGlzLm15QXVkaW9Db250ZXh0LmNyZWF0ZUJyb3duTm9pc2UoKSB9XG4gICAgICAgICAgaW1wb3J0KCdicm93bi1ub2lzZS1ub2RlJykudGhlbigoeyBkZWZhdWx0OiBkZWYgfSkgPT4ge1xuICAgICAgICAgICAgYWZ0ZXJJbXBvcnQoZGVmKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAncGluayc6XG4gICAgICAgICAgbm9pc2VOb2RlTWFrZXIgPSAoKSA9PiB7IHRoaXMubm9pc2VOb2RlID0gdGhpcy5teUF1ZGlvQ29udGV4dC5jcmVhdGVQaW5rTm9pc2UoKSB9XG4gICAgICAgICAgaW1wb3J0KCdwaW5rLW5vaXNlLW5vZGUnKS50aGVuKCh7IGRlZmF1bHQ6IGRlZiB9KSA9PiB7XG4gICAgICAgICAgICBhZnRlckltcG9ydChkZWYpXG4gICAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRWb2x1bWUgPSAoc2NhbGVkVm9sdW1lKSA9PiB7XG4gICAgICBpZiAodGhpcy5teUF1ZGlvQ29udGV4dCkge1xuICAgICAgICB0aGlzLmdhaW5Ob2RlLmdhaW4uc2V0VmFsdWVBdFRpbWUoc2NhbGVkVm9sdW1lLCB0aGlzLm15QXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lKVxuICAgICAgfVxuICAgIH1cblxuICAgIHNldE5vaXNlVm9sdW1lID0gKHNjYWxlZFZvbHVtZSkgPT4ge1xuICAgICAgaWYgKHRoaXMubXlBdWRpb0NvbnRleHQpIHtcbiAgICAgICAgdGhpcy5ub2lzZUdhaW5Ob2RlLmdhaW4uc2V0VmFsdWVBdFRpbWUoc2NhbGVkVm9sdW1lLCB0aGlzLm15QXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lKVxuICAgICAgfVxuICAgIH1cblxuICAgIHN0b3BOb2lzZSA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLm5vaXNlTm9kZSAmJiB0aGlzLm5vaXNlUGxheWluZykge1xuICAgICAgICB0aGlzLm5vaXNlTm9kZS5zdG9wKClcbiAgICAgICAgdGhpcy5ub2lzZVBsYXlpbmcgPSBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZU5vaXNlU2V0dGluZ3MgPSAoY29uZmlnKSA9PiB7XG4gICAgICBpZiAodGhpcy5teUF1ZGlvQ29udGV4dCkge1xuICAgICAgICBjb25zdCBub2lzZVdhc1BsYXlpbmcgPSB0aGlzLm5vaXNlUGxheWluZ1xuICAgICAgICBjb25zdCB0eXBlQ2hhbmdlZCA9IGNvbmZpZy5ub2lzZS50eXBlICE9PSB0aGlzLmxhc3ROb2lzZVR5cGVcbiAgICAgICAgY29uc3QgdHlwZUlzT2ZmID0gY29uZmlnLm5vaXNlLnR5cGUgPT09ICdvZmYnXG4gICAgICAgIGlmICgodHlwZUNoYW5nZWQgJiYgdGhpcy5ub2lzZVBsYXlpbmcpIHx8IHR5cGVJc09mZikge1xuICAgICAgICAgIHRoaXMuc3RvcE5vaXNlKClcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXR5cGVJc09mZiAmJiBjb25maWcucGxheWVyUGxheWluZykge1xuICAgICAgICAgIGlmICgobm9pc2VXYXNQbGF5aW5nICYmIHR5cGVDaGFuZ2VkKSB8fCAoIW5vaXNlV2FzUGxheWluZykpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnROb2lzZShjb25maWcpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdE5vaXNlVHlwZSA9IGNvbmZpZy5ub2lzZS50eXBlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcGxheSA9ICh3YXYsIHNjYWxlZFZvbHVtZSwgY29uZmlnLCBvbkVuZGVkKSA9PiB7XG4gICAgICB0aGlzLnNvdXJjZUVuZGVkID0gZmFsc2VcbiAgICAgIHRoaXMuc291cmNlRW5kZWRDYWxsQmFjayA9IG9uRW5kZWRcbiAgICAgIGlmICh0eXBlb2YgKHRoaXMubXlBdWRpb0NvbnRleHQpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLm15QXVkaW9Db250ZXh0ID0gbmV3IEF1ZGlvQ29udGV4dCgpXG4gICAgICB9XG5cbiAgICAgIHRoaXMuZ2Fpbk5vZGUgPSB0aGlzLm15QXVkaW9Db250ZXh0LmNyZWF0ZUdhaW4oKVxuICAgICAgdGhpcy5zb3VyY2UgPSB0aGlzLm15QXVkaW9Db250ZXh0LmNyZWF0ZUJ1ZmZlclNvdXJjZSgpXG4gICAgICB0aGlzLnNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsICgpID0+IHtcbiAgICAgICAgLy8gdGhpcy5ub2lzZU5vZGUuc3RvcCgpXG4gICAgICAgIHRoaXMuc291cmNlRW5kZWQgPSB0cnVlXG4gICAgICAgIHRoaXMuc291cmNlRW5kZWRDYWxsQmFjaygpXG4gICAgICB9KVxuICAgICAgY29uc3QgbXlidWYgPSBuZXcgSW50OEFycmF5KHdhdikuYnVmZmVyXG4gICAgICBsZXQgbXlidWYyXG4gICAgICB0aGlzLm15QXVkaW9Db250ZXh0LmRlY29kZUF1ZGlvRGF0YShteWJ1ZiwgKHgpID0+IHtcbiAgICAgICAgLy8gdGhhbmtzIGh0dHBzOi8vbWlkZGxlZWFybWVkaWEuY29tL3dlYi1hdWRpby1hcGktYXVkaW8tYnVmZmVyL1xuICAgICAgICBteWJ1ZjIgPSB4XG4gICAgICAgIHRoaXMuc291cmNlLmJ1ZmZlciA9IG15YnVmMlxuICAgICAgICB0aGlzLnNldFZvbHVtZShzY2FsZWRWb2x1bWUpXG4gICAgICAgIHRoaXMuc291cmNlLmNvbm5lY3QodGhpcy5nYWluTm9kZSlcbiAgICAgICAgdGhpcy5nYWluTm9kZS5jb25uZWN0KHRoaXMubXlBdWRpb0NvbnRleHQuZGVzdGluYXRpb24pXG4gICAgICAgIHRoaXMuaGFuZGxlTm9pc2VTZXR0aW5ncyhjb25maWcpXG4gICAgICAgIHRoaXMuc291cmNlLnN0YXJ0KDApXG4gICAgICB9LCAoZSkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnZXJyb3InKVxuICAgICAgICBjb25zb2xlLmxvZyhlKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBmb3JjZVN0b3AgPSAocGF1c2VDYWxsQmFjaywga2lsbE5vaXNlKSA9PiB7XG4gICAgICBpZiAodHlwZW9mICh0aGlzLm15QXVkaW9Db250ZXh0KSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcGF1c2VDYWxsQmFjaygpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoa2lsbE5vaXNlKSB7XG4gICAgICAgICAgdGhpcy5zdG9wTm9pc2UoKVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKHRoaXMuc291cmNlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuc291cmNlRW5kZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc291cmNlRW5kZWRDYWxsQmFjayA9IHBhdXNlQ2FsbEJhY2tcbiAgICAgICAgICAgIHRoaXMuc291cmNlLnN0b3AoKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXVzZUNhbGxCYWNrKClcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF1c2VDYWxsQmFjaygpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgTW9yc2VXYXZCdWZmZXJQbGF5ZXIgZnJvbSAnLi9tb3JzZVdhdkJ1ZmZlclBsYXllci5qcydcbmltcG9ydCB7IE1vcnNlU3RyaW5nVG9XYXZCdWZmZXIgfSBmcm9tICcuL21vcnNlU3RyaW5nVG9XYXZCdWZmZXIuanMnXG5leHBvcnQgY2xhc3MgTW9yc2VXb3JkUGxheWVyIHtcbiAgICBteUJ1ZmZlclBsYXllcjtcbiAgICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgICB0aGlzLm15QnVmZmVyUGxheWVyID0gbmV3IE1vcnNlV2F2QnVmZmVyUGxheWVyKClcbiAgICB9XG5cbiAgICBzZXRWb2x1bWUgKHZvbHVtZSkge1xuICAgICAgdGhpcy5teUJ1ZmZlclBsYXllci5zZXRWb2x1bWUodm9sdW1lIC8gMTApXG4gICAgfVxuXG4gICAgc2V0Tm9pc2VWb2x1bWUgKHZvbHVtZSkge1xuICAgICAgdGhpcy5teUJ1ZmZlclBsYXllci5zZXROb2lzZVZvbHVtZSh2b2x1bWUgLyAxMClcbiAgICB9XG5cbiAgICBzZXROb2lzZVR5cGUgKGNvbmZpZykge1xuICAgICAgY29uZmlnLm5vaXNlLnNjYWxlZE5vaXNlVm9sdW1lID0gY29uZmlnLm5vaXNlLnZvbHVtZSAvIDEwXG4gICAgICB0aGlzLm15QnVmZmVyUGxheWVyLmhhbmRsZU5vaXNlU2V0dGluZ3MoY29uZmlnKVxuICAgIH1cblxuICAgIHBsYXkgKGNvbmZpZywgb25FbmRlZCkge1xuICAgICAgY29uc3Qgd2F2ID0gTW9yc2VTdHJpbmdUb1dhdkJ1ZmZlci5jcmVhdGVXYXYoY29uZmlnKVxuICAgICAgY29uZmlnLm5vaXNlLnNjYWxlZE5vaXNlVm9sdW1lID0gY29uZmlnLm5vaXNlLnZvbHVtZSAvIDEwXG4gICAgICB0aGlzLm15QnVmZmVyUGxheWVyLnBsYXkod2F2LndhdiwgY29uZmlnLnZvbHVtZSAvIDEwLCBjb25maWcsIG9uRW5kZWQpXG4gICAgfVxuXG4gICAgcGF1c2UgKHBhdXNlQ2FsbEJhY2ssIGtpbGxOb2lzZSkge1xuICAgICAgdGhpcy5teUJ1ZmZlclBsYXllci5mb3JjZVN0b3AocGF1c2VDYWxsQmFjaywga2lsbE5vaXNlKVxuICAgIH1cblxuICAgIGdldFdhdkFuZFNhbXBsZSAoY29uZmlnKSB7XG4gICAgICBjb25zdCB3YXYgPSBNb3JzZVN0cmluZ1RvV2F2QnVmZmVyLmNyZWF0ZVdhdihjb25maWcpXG4gICAgICByZXR1cm4gd2F2XG4gICAgfVxuXG4gICAgZ2V0VGltZUVzdGltYXRlIChjb25maWcpIHtcbiAgICAgIHJldHVybiBNb3JzZVN0cmluZ1RvV2F2QnVmZmVyLmVzdGltYXRlUGxheVRpbWUoY29uZmlnKVxuICAgIH1cbn1cbiIsIi8qIVxuICAqIEJvb3RzdHJhcCB2NS4xLjMgKGh0dHBzOi8vZ2V0Ym9vdHN0cmFwLmNvbS8pXG4gICogQ29weXJpZ2h0IDIwMTEtMjAyMSBUaGUgQm9vdHN0cmFwIEF1dGhvcnMgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ncmFwaHMvY29udHJpYnV0b3JzKVxuICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICAqL1xuaW1wb3J0ICogYXMgUG9wcGVyIGZyb20gJ0Bwb3BwZXJqcy9jb3JlJztcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NS4xLjMpOiB1dGlsL2luZGV4LmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbmNvbnN0IE1BWF9VSUQgPSAxMDAwMDAwO1xuY29uc3QgTUlMTElTRUNPTkRTX01VTFRJUExJRVIgPSAxMDAwO1xuY29uc3QgVFJBTlNJVElPTl9FTkQgPSAndHJhbnNpdGlvbmVuZCc7IC8vIFNob3V0b3V0IEFuZ3VzQ3JvbGwgKGh0dHBzOi8vZ29vLmdsL3B4d1FHcClcblxuY29uc3QgdG9UeXBlID0gb2JqID0+IHtcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBgJHtvYmp9YDtcbiAgfVxuXG4gIHJldHVybiB7fS50b1N0cmluZy5jYWxsKG9iaikubWF0Y2goL1xccyhbYS16XSspL2kpWzFdLnRvTG93ZXJDYXNlKCk7XG59O1xuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogUHVibGljIFV0aWwgQXBpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cblxuY29uc3QgZ2V0VUlEID0gcHJlZml4ID0+IHtcbiAgZG8ge1xuICAgIHByZWZpeCArPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBNQVhfVUlEKTtcbiAgfSB3aGlsZSAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocHJlZml4KSk7XG5cbiAgcmV0dXJuIHByZWZpeDtcbn07XG5cbmNvbnN0IGdldFNlbGVjdG9yID0gZWxlbWVudCA9PiB7XG4gIGxldCBzZWxlY3RvciA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWJzLXRhcmdldCcpO1xuXG4gIGlmICghc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09ICcjJykge1xuICAgIGxldCBocmVmQXR0ciA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdocmVmJyk7IC8vIFRoZSBvbmx5IHZhbGlkIGNvbnRlbnQgdGhhdCBjb3VsZCBkb3VibGUgYXMgYSBzZWxlY3RvciBhcmUgSURzIG9yIGNsYXNzZXMsXG4gICAgLy8gc28gZXZlcnl0aGluZyBzdGFydGluZyB3aXRoIGAjYCBvciBgLmAuIElmIGEgXCJyZWFsXCIgVVJMIGlzIHVzZWQgYXMgdGhlIHNlbGVjdG9yLFxuICAgIC8vIGBkb2N1bWVudC5xdWVyeVNlbGVjdG9yYCB3aWxsIHJpZ2h0ZnVsbHkgY29tcGxhaW4gaXQgaXMgaW52YWxpZC5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2lzc3Vlcy8zMjI3M1xuXG4gICAgaWYgKCFocmVmQXR0ciB8fCAhaHJlZkF0dHIuaW5jbHVkZXMoJyMnKSAmJiAhaHJlZkF0dHIuc3RhcnRzV2l0aCgnLicpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IC8vIEp1c3QgaW4gY2FzZSBzb21lIENNUyBwdXRzIG91dCBhIGZ1bGwgVVJMIHdpdGggdGhlIGFuY2hvciBhcHBlbmRlZFxuXG5cbiAgICBpZiAoaHJlZkF0dHIuaW5jbHVkZXMoJyMnKSAmJiAhaHJlZkF0dHIuc3RhcnRzV2l0aCgnIycpKSB7XG4gICAgICBocmVmQXR0ciA9IGAjJHtocmVmQXR0ci5zcGxpdCgnIycpWzFdfWA7XG4gICAgfVxuXG4gICAgc2VsZWN0b3IgPSBocmVmQXR0ciAmJiBocmVmQXR0ciAhPT0gJyMnID8gaHJlZkF0dHIudHJpbSgpIDogbnVsbDtcbiAgfVxuXG4gIHJldHVybiBzZWxlY3Rvcjtcbn07XG5cbmNvbnN0IGdldFNlbGVjdG9yRnJvbUVsZW1lbnQgPSBlbGVtZW50ID0+IHtcbiAgY29uc3Qgc2VsZWN0b3IgPSBnZXRTZWxlY3RvcihlbGVtZW50KTtcblxuICBpZiAoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvcikgPyBzZWxlY3RvciA6IG51bGw7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cbmNvbnN0IGdldEVsZW1lbnRGcm9tU2VsZWN0b3IgPSBlbGVtZW50ID0+IHtcbiAgY29uc3Qgc2VsZWN0b3IgPSBnZXRTZWxlY3RvcihlbGVtZW50KTtcbiAgcmV0dXJuIHNlbGVjdG9yID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvcikgOiBudWxsO1xufTtcblxuY29uc3QgZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQgPSBlbGVtZW50ID0+IHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gLy8gR2V0IHRyYW5zaXRpb24tZHVyYXRpb24gb2YgdGhlIGVsZW1lbnRcblxuXG4gIGxldCB7XG4gICAgdHJhbnNpdGlvbkR1cmF0aW9uLFxuICAgIHRyYW5zaXRpb25EZWxheVxuICB9ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIGNvbnN0IGZsb2F0VHJhbnNpdGlvbkR1cmF0aW9uID0gTnVtYmVyLnBhcnNlRmxvYXQodHJhbnNpdGlvbkR1cmF0aW9uKTtcbiAgY29uc3QgZmxvYXRUcmFuc2l0aW9uRGVsYXkgPSBOdW1iZXIucGFyc2VGbG9hdCh0cmFuc2l0aW9uRGVsYXkpOyAvLyBSZXR1cm4gMCBpZiBlbGVtZW50IG9yIHRyYW5zaXRpb24gZHVyYXRpb24gaXMgbm90IGZvdW5kXG5cbiAgaWYgKCFmbG9hdFRyYW5zaXRpb25EdXJhdGlvbiAmJiAhZmxvYXRUcmFuc2l0aW9uRGVsYXkpIHtcbiAgICByZXR1cm4gMDtcbiAgfSAvLyBJZiBtdWx0aXBsZSBkdXJhdGlvbnMgYXJlIGRlZmluZWQsIHRha2UgdGhlIGZpcnN0XG5cblxuICB0cmFuc2l0aW9uRHVyYXRpb24gPSB0cmFuc2l0aW9uRHVyYXRpb24uc3BsaXQoJywnKVswXTtcbiAgdHJhbnNpdGlvbkRlbGF5ID0gdHJhbnNpdGlvbkRlbGF5LnNwbGl0KCcsJylbMF07XG4gIHJldHVybiAoTnVtYmVyLnBhcnNlRmxvYXQodHJhbnNpdGlvbkR1cmF0aW9uKSArIE51bWJlci5wYXJzZUZsb2F0KHRyYW5zaXRpb25EZWxheSkpICogTUlMTElTRUNPTkRTX01VTFRJUExJRVI7XG59O1xuXG5jb25zdCB0cmlnZ2VyVHJhbnNpdGlvbkVuZCA9IGVsZW1lbnQgPT4ge1xuICBlbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFRSQU5TSVRJT05fRU5EKSk7XG59O1xuXG5jb25zdCBpc0VsZW1lbnQgPSBvYmogPT4ge1xuICBpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqLmpxdWVyeSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBvYmogPSBvYmpbMF07XG4gIH1cblxuICByZXR1cm4gdHlwZW9mIG9iai5ub2RlVHlwZSAhPT0gJ3VuZGVmaW5lZCc7XG59O1xuXG5jb25zdCBnZXRFbGVtZW50ID0gb2JqID0+IHtcbiAgaWYgKGlzRWxlbWVudChvYmopKSB7XG4gICAgLy8gaXQncyBhIGpRdWVyeSBvYmplY3Qgb3IgYSBub2RlIGVsZW1lbnRcbiAgICByZXR1cm4gb2JqLmpxdWVyeSA/IG9ialswXSA6IG9iajtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJyAmJiBvYmoubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKG9iaik7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cbmNvbnN0IHR5cGVDaGVja0NvbmZpZyA9IChjb21wb25lbnROYW1lLCBjb25maWcsIGNvbmZpZ1R5cGVzKSA9PiB7XG4gIE9iamVjdC5rZXlzKGNvbmZpZ1R5cGVzKS5mb3JFYWNoKHByb3BlcnR5ID0+IHtcbiAgICBjb25zdCBleHBlY3RlZFR5cGVzID0gY29uZmlnVHlwZXNbcHJvcGVydHldO1xuICAgIGNvbnN0IHZhbHVlID0gY29uZmlnW3Byb3BlcnR5XTtcbiAgICBjb25zdCB2YWx1ZVR5cGUgPSB2YWx1ZSAmJiBpc0VsZW1lbnQodmFsdWUpID8gJ2VsZW1lbnQnIDogdG9UeXBlKHZhbHVlKTtcblxuICAgIGlmICghbmV3IFJlZ0V4cChleHBlY3RlZFR5cGVzKS50ZXN0KHZhbHVlVHlwZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29tcG9uZW50TmFtZS50b1VwcGVyQ2FzZSgpfTogT3B0aW9uIFwiJHtwcm9wZXJ0eX1cIiBwcm92aWRlZCB0eXBlIFwiJHt2YWx1ZVR5cGV9XCIgYnV0IGV4cGVjdGVkIHR5cGUgXCIke2V4cGVjdGVkVHlwZXN9XCIuYCk7XG4gICAgfVxuICB9KTtcbn07XG5cbmNvbnN0IGlzVmlzaWJsZSA9IGVsZW1lbnQgPT4ge1xuICBpZiAoIWlzRWxlbWVudChlbGVtZW50KSB8fCBlbGVtZW50LmdldENsaWVudFJlY3RzKCkubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZSgndmlzaWJpbGl0eScpID09PSAndmlzaWJsZSc7XG59O1xuXG5jb25zdCBpc0Rpc2FibGVkID0gZWxlbWVudCA9PiB7XG4gIGlmICghZWxlbWVudCB8fCBlbGVtZW50Lm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdkaXNhYmxlZCcpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIGVsZW1lbnQuZGlzYWJsZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuZGlzYWJsZWQ7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJykgJiYgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJykgIT09ICdmYWxzZSc7XG59O1xuXG5jb25zdCBmaW5kU2hhZG93Um9vdCA9IGVsZW1lbnQgPT4ge1xuICBpZiAoIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hdHRhY2hTaGFkb3cpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBDYW4gZmluZCB0aGUgc2hhZG93IHJvb3Qgb3RoZXJ3aXNlIGl0J2xsIHJldHVybiB0aGUgZG9jdW1lbnRcblxuXG4gIGlmICh0eXBlb2YgZWxlbWVudC5nZXRSb290Tm9kZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnN0IHJvb3QgPSBlbGVtZW50LmdldFJvb3ROb2RlKCk7XG4gICAgcmV0dXJuIHJvb3QgaW5zdGFuY2VvZiBTaGFkb3dSb290ID8gcm9vdCA6IG51bGw7XG4gIH1cblxuICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfSAvLyB3aGVuIHdlIGRvbid0IGZpbmQgYSBzaGFkb3cgcm9vdFxuXG5cbiAgaWYgKCFlbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBmaW5kU2hhZG93Um9vdChlbGVtZW50LnBhcmVudE5vZGUpO1xufTtcblxuY29uc3Qgbm9vcCA9ICgpID0+IHt9O1xuLyoqXG4gKiBUcmljayB0byByZXN0YXJ0IGFuIGVsZW1lbnQncyBhbmltYXRpb25cbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJuIHZvaWRcbiAqXG4gKiBAc2VlIGh0dHBzOi8vd3d3LmNoYXJpc3RoZW8uaW8vYmxvZy8yMDIxLzAyL3Jlc3RhcnQtYS1jc3MtYW5pbWF0aW9uLXdpdGgtamF2YXNjcmlwdC8jcmVzdGFydGluZy1hLWNzcy1hbmltYXRpb25cbiAqL1xuXG5cbmNvbnN0IHJlZmxvdyA9IGVsZW1lbnQgPT4ge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG4gIGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xufTtcblxuY29uc3QgZ2V0alF1ZXJ5ID0gKCkgPT4ge1xuICBjb25zdCB7XG4gICAgalF1ZXJ5XG4gIH0gPSB3aW5kb3c7XG5cbiAgaWYgKGpRdWVyeSAmJiAhZG9jdW1lbnQuYm9keS5oYXNBdHRyaWJ1dGUoJ2RhdGEtYnMtbm8tanF1ZXJ5JykpIHtcbiAgICByZXR1cm4galF1ZXJ5O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5jb25zdCBET01Db250ZW50TG9hZGVkQ2FsbGJhY2tzID0gW107XG5cbmNvbnN0IG9uRE9NQ29udGVudExvYWRlZCA9IGNhbGxiYWNrID0+IHtcbiAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkaW5nJykge1xuICAgIC8vIGFkZCBsaXN0ZW5lciBvbiB0aGUgZmlyc3QgY2FsbCB3aGVuIHRoZSBkb2N1bWVudCBpcyBpbiBsb2FkaW5nIHN0YXRlXG4gICAgaWYgKCFET01Db250ZW50TG9hZGVkQ2FsbGJhY2tzLmxlbmd0aCkge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsICgpID0+IHtcbiAgICAgICAgRE9NQ29udGVudExvYWRlZENhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKCkpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgRE9NQ29udGVudExvYWRlZENhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgfSBlbHNlIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG59O1xuXG5jb25zdCBpc1JUTCA9ICgpID0+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kaXIgPT09ICdydGwnO1xuXG5jb25zdCBkZWZpbmVKUXVlcnlQbHVnaW4gPSBwbHVnaW4gPT4ge1xuICBvbkRPTUNvbnRlbnRMb2FkZWQoKCkgPT4ge1xuICAgIGNvbnN0ICQgPSBnZXRqUXVlcnkoKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblxuICAgIGlmICgkKSB7XG4gICAgICBjb25zdCBuYW1lID0gcGx1Z2luLk5BTUU7XG4gICAgICBjb25zdCBKUVVFUllfTk9fQ09ORkxJQ1QgPSAkLmZuW25hbWVdO1xuICAgICAgJC5mbltuYW1lXSA9IHBsdWdpbi5qUXVlcnlJbnRlcmZhY2U7XG4gICAgICAkLmZuW25hbWVdLkNvbnN0cnVjdG9yID0gcGx1Z2luO1xuXG4gICAgICAkLmZuW25hbWVdLm5vQ29uZmxpY3QgPSAoKSA9PiB7XG4gICAgICAgICQuZm5bbmFtZV0gPSBKUVVFUllfTk9fQ09ORkxJQ1Q7XG4gICAgICAgIHJldHVybiBwbHVnaW4ualF1ZXJ5SW50ZXJmYWNlO1xuICAgICAgfTtcbiAgICB9XG4gIH0pO1xufTtcblxuY29uc3QgZXhlY3V0ZSA9IGNhbGxiYWNrID0+IHtcbiAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cbn07XG5cbmNvbnN0IGV4ZWN1dGVBZnRlclRyYW5zaXRpb24gPSAoY2FsbGJhY2ssIHRyYW5zaXRpb25FbGVtZW50LCB3YWl0Rm9yVHJhbnNpdGlvbiA9IHRydWUpID0+IHtcbiAgaWYgKCF3YWl0Rm9yVHJhbnNpdGlvbikge1xuICAgIGV4ZWN1dGUoY2FsbGJhY2spO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGR1cmF0aW9uUGFkZGluZyA9IDU7XG4gIGNvbnN0IGVtdWxhdGVkRHVyYXRpb24gPSBnZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudCh0cmFuc2l0aW9uRWxlbWVudCkgKyBkdXJhdGlvblBhZGRpbmc7XG4gIGxldCBjYWxsZWQgPSBmYWxzZTtcblxuICBjb25zdCBoYW5kbGVyID0gKHtcbiAgICB0YXJnZXRcbiAgfSkgPT4ge1xuICAgIGlmICh0YXJnZXQgIT09IHRyYW5zaXRpb25FbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICB0cmFuc2l0aW9uRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFRSQU5TSVRJT05fRU5ELCBoYW5kbGVyKTtcbiAgICBleGVjdXRlKGNhbGxiYWNrKTtcbiAgfTtcblxuICB0cmFuc2l0aW9uRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFRSQU5TSVRJT05fRU5ELCBoYW5kbGVyKTtcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgIHRyaWdnZXJUcmFuc2l0aW9uRW5kKHRyYW5zaXRpb25FbGVtZW50KTtcbiAgICB9XG4gIH0sIGVtdWxhdGVkRHVyYXRpb24pO1xufTtcbi8qKlxuICogUmV0dXJuIHRoZSBwcmV2aW91cy9uZXh0IGVsZW1lbnQgb2YgYSBsaXN0LlxuICpcbiAqIEBwYXJhbSB7YXJyYXl9IGxpc3QgICAgVGhlIGxpc3Qgb2YgZWxlbWVudHNcbiAqIEBwYXJhbSBhY3RpdmVFbGVtZW50ICAgVGhlIGFjdGl2ZSBlbGVtZW50XG4gKiBAcGFyYW0gc2hvdWxkR2V0TmV4dCAgIENob29zZSB0byBnZXQgbmV4dCBvciBwcmV2aW91cyBlbGVtZW50XG4gKiBAcGFyYW0gaXNDeWNsZUFsbG93ZWRcbiAqIEByZXR1cm4ge0VsZW1lbnR8ZWxlbX0gVGhlIHByb3BlciBlbGVtZW50XG4gKi9cblxuXG5jb25zdCBnZXROZXh0QWN0aXZlRWxlbWVudCA9IChsaXN0LCBhY3RpdmVFbGVtZW50LCBzaG91bGRHZXROZXh0LCBpc0N5Y2xlQWxsb3dlZCkgPT4ge1xuICBsZXQgaW5kZXggPSBsaXN0LmluZGV4T2YoYWN0aXZlRWxlbWVudCk7IC8vIGlmIHRoZSBlbGVtZW50IGRvZXMgbm90IGV4aXN0IGluIHRoZSBsaXN0IHJldHVybiBhbiBlbGVtZW50IGRlcGVuZGluZyBvbiB0aGUgZGlyZWN0aW9uIGFuZCBpZiBjeWNsZSBpcyBhbGxvd2VkXG5cbiAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgIHJldHVybiBsaXN0WyFzaG91bGRHZXROZXh0ICYmIGlzQ3ljbGVBbGxvd2VkID8gbGlzdC5sZW5ndGggLSAxIDogMF07XG4gIH1cblxuICBjb25zdCBsaXN0TGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIGluZGV4ICs9IHNob3VsZEdldE5leHQgPyAxIDogLTE7XG5cbiAgaWYgKGlzQ3ljbGVBbGxvd2VkKSB7XG4gICAgaW5kZXggPSAoaW5kZXggKyBsaXN0TGVuZ3RoKSAlIGxpc3RMZW5ndGg7XG4gIH1cblxuICByZXR1cm4gbGlzdFtNYXRoLm1heCgwLCBNYXRoLm1pbihpbmRleCwgbGlzdExlbmd0aCAtIDEpKV07XG59O1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY1LjEuMyk6IGRvbS9ldmVudC1oYW5kbGVyLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb25zdGFudHNcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNvbnN0IG5hbWVzcGFjZVJlZ2V4ID0gL1teLl0qKD89XFwuLiopXFwufC4qLztcbmNvbnN0IHN0cmlwTmFtZVJlZ2V4ID0gL1xcLi4qLztcbmNvbnN0IHN0cmlwVWlkUmVnZXggPSAvOjpcXGQrJC87XG5jb25zdCBldmVudFJlZ2lzdHJ5ID0ge307IC8vIEV2ZW50cyBzdG9yYWdlXG5cbmxldCB1aWRFdmVudCA9IDE7XG5jb25zdCBjdXN0b21FdmVudHMgPSB7XG4gIG1vdXNlZW50ZXI6ICdtb3VzZW92ZXInLFxuICBtb3VzZWxlYXZlOiAnbW91c2VvdXQnXG59O1xuY29uc3QgY3VzdG9tRXZlbnRzUmVnZXggPSAvXihtb3VzZWVudGVyfG1vdXNlbGVhdmUpL2k7XG5jb25zdCBuYXRpdmVFdmVudHMgPSBuZXcgU2V0KFsnY2xpY2snLCAnZGJsY2xpY2snLCAnbW91c2V1cCcsICdtb3VzZWRvd24nLCAnY29udGV4dG1lbnUnLCAnbW91c2V3aGVlbCcsICdET01Nb3VzZVNjcm9sbCcsICdtb3VzZW92ZXInLCAnbW91c2VvdXQnLCAnbW91c2Vtb3ZlJywgJ3NlbGVjdHN0YXJ0JywgJ3NlbGVjdGVuZCcsICdrZXlkb3duJywgJ2tleXByZXNzJywgJ2tleXVwJywgJ29yaWVudGF0aW9uY2hhbmdlJywgJ3RvdWNoc3RhcnQnLCAndG91Y2htb3ZlJywgJ3RvdWNoZW5kJywgJ3RvdWNoY2FuY2VsJywgJ3BvaW50ZXJkb3duJywgJ3BvaW50ZXJtb3ZlJywgJ3BvaW50ZXJ1cCcsICdwb2ludGVybGVhdmUnLCAncG9pbnRlcmNhbmNlbCcsICdnZXN0dXJlc3RhcnQnLCAnZ2VzdHVyZWNoYW5nZScsICdnZXN0dXJlZW5kJywgJ2ZvY3VzJywgJ2JsdXInLCAnY2hhbmdlJywgJ3Jlc2V0JywgJ3NlbGVjdCcsICdzdWJtaXQnLCAnZm9jdXNpbicsICdmb2N1c291dCcsICdsb2FkJywgJ3VubG9hZCcsICdiZWZvcmV1bmxvYWQnLCAncmVzaXplJywgJ21vdmUnLCAnRE9NQ29udGVudExvYWRlZCcsICdyZWFkeXN0YXRlY2hhbmdlJywgJ2Vycm9yJywgJ2Fib3J0JywgJ3Njcm9sbCddKTtcbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBQcml2YXRlIG1ldGhvZHNcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmZ1bmN0aW9uIGdldFVpZEV2ZW50KGVsZW1lbnQsIHVpZCkge1xuICByZXR1cm4gdWlkICYmIGAke3VpZH06OiR7dWlkRXZlbnQrK31gIHx8IGVsZW1lbnQudWlkRXZlbnQgfHwgdWlkRXZlbnQrKztcbn1cblxuZnVuY3Rpb24gZ2V0RXZlbnQoZWxlbWVudCkge1xuICBjb25zdCB1aWQgPSBnZXRVaWRFdmVudChlbGVtZW50KTtcbiAgZWxlbWVudC51aWRFdmVudCA9IHVpZDtcbiAgZXZlbnRSZWdpc3RyeVt1aWRdID0gZXZlbnRSZWdpc3RyeVt1aWRdIHx8IHt9O1xuICByZXR1cm4gZXZlbnRSZWdpc3RyeVt1aWRdO1xufVxuXG5mdW5jdGlvbiBib290c3RyYXBIYW5kbGVyKGVsZW1lbnQsIGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiBoYW5kbGVyKGV2ZW50KSB7XG4gICAgZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSBlbGVtZW50O1xuXG4gICAgaWYgKGhhbmRsZXIub25lT2ZmKSB7XG4gICAgICBFdmVudEhhbmRsZXIub2ZmKGVsZW1lbnQsIGV2ZW50LnR5cGUsIGZuKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm4uYXBwbHkoZWxlbWVudCwgW2V2ZW50XSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGJvb3RzdHJhcERlbGVnYXRpb25IYW5kbGVyKGVsZW1lbnQsIHNlbGVjdG9yLCBmbikge1xuICByZXR1cm4gZnVuY3Rpb24gaGFuZGxlcihldmVudCkge1xuICAgIGNvbnN0IGRvbUVsZW1lbnRzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcblxuICAgIGZvciAobGV0IHtcbiAgICAgIHRhcmdldFxuICAgIH0gPSBldmVudDsgdGFyZ2V0ICYmIHRhcmdldCAhPT0gdGhpczsgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGUpIHtcbiAgICAgIGZvciAobGV0IGkgPSBkb21FbGVtZW50cy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgaWYgKGRvbUVsZW1lbnRzW2ldID09PSB0YXJnZXQpIHtcbiAgICAgICAgICBldmVudC5kZWxlZ2F0ZVRhcmdldCA9IHRhcmdldDtcblxuICAgICAgICAgIGlmIChoYW5kbGVyLm9uZU9mZikge1xuICAgICAgICAgICAgRXZlbnRIYW5kbGVyLm9mZihlbGVtZW50LCBldmVudC50eXBlLCBzZWxlY3RvciwgZm4pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0YXJnZXQsIFtldmVudF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBUbyBwbGVhc2UgRVNMaW50XG5cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xufVxuXG5mdW5jdGlvbiBmaW5kSGFuZGxlcihldmVudHMsIGhhbmRsZXIsIGRlbGVnYXRpb25TZWxlY3RvciA9IG51bGwpIHtcbiAgY29uc3QgdWlkRXZlbnRMaXN0ID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcblxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gdWlkRXZlbnRMaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgZXZlbnQgPSBldmVudHNbdWlkRXZlbnRMaXN0W2ldXTtcblxuICAgIGlmIChldmVudC5vcmlnaW5hbEhhbmRsZXIgPT09IGhhbmRsZXIgJiYgZXZlbnQuZGVsZWdhdGlvblNlbGVjdG9yID09PSBkZWxlZ2F0aW9uU2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiBldmVudDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplUGFyYW1zKG9yaWdpbmFsVHlwZUV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uRm4pIHtcbiAgY29uc3QgZGVsZWdhdGlvbiA9IHR5cGVvZiBoYW5kbGVyID09PSAnc3RyaW5nJztcbiAgY29uc3Qgb3JpZ2luYWxIYW5kbGVyID0gZGVsZWdhdGlvbiA/IGRlbGVnYXRpb25GbiA6IGhhbmRsZXI7XG4gIGxldCB0eXBlRXZlbnQgPSBnZXRUeXBlRXZlbnQob3JpZ2luYWxUeXBlRXZlbnQpO1xuICBjb25zdCBpc05hdGl2ZSA9IG5hdGl2ZUV2ZW50cy5oYXModHlwZUV2ZW50KTtcblxuICBpZiAoIWlzTmF0aXZlKSB7XG4gICAgdHlwZUV2ZW50ID0gb3JpZ2luYWxUeXBlRXZlbnQ7XG4gIH1cblxuICByZXR1cm4gW2RlbGVnYXRpb24sIG9yaWdpbmFsSGFuZGxlciwgdHlwZUV2ZW50XTtcbn1cblxuZnVuY3Rpb24gYWRkSGFuZGxlcihlbGVtZW50LCBvcmlnaW5hbFR5cGVFdmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZuLCBvbmVPZmYpIHtcbiAgaWYgKHR5cGVvZiBvcmlnaW5hbFR5cGVFdmVudCAhPT0gJ3N0cmluZycgfHwgIWVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoIWhhbmRsZXIpIHtcbiAgICBoYW5kbGVyID0gZGVsZWdhdGlvbkZuO1xuICAgIGRlbGVnYXRpb25GbiA9IG51bGw7XG4gIH0gLy8gaW4gY2FzZSBvZiBtb3VzZWVudGVyIG9yIG1vdXNlbGVhdmUgd3JhcCB0aGUgaGFuZGxlciB3aXRoaW4gYSBmdW5jdGlvbiB0aGF0IGNoZWNrcyBmb3IgaXRzIERPTSBwb3NpdGlvblxuICAvLyB0aGlzIHByZXZlbnRzIHRoZSBoYW5kbGVyIGZyb20gYmVpbmcgZGlzcGF0Y2hlZCB0aGUgc2FtZSB3YXkgYXMgbW91c2VvdmVyIG9yIG1vdXNlb3V0IGRvZXNcblxuXG4gIGlmIChjdXN0b21FdmVudHNSZWdleC50ZXN0KG9yaWdpbmFsVHlwZUV2ZW50KSkge1xuICAgIGNvbnN0IHdyYXBGbiA9IGZuID0+IHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKCFldmVudC5yZWxhdGVkVGFyZ2V0IHx8IGV2ZW50LnJlbGF0ZWRUYXJnZXQgIT09IGV2ZW50LmRlbGVnYXRlVGFyZ2V0ICYmICFldmVudC5kZWxlZ2F0ZVRhcmdldC5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KSkge1xuICAgICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgaWYgKGRlbGVnYXRpb25Gbikge1xuICAgICAgZGVsZWdhdGlvbkZuID0gd3JhcEZuKGRlbGVnYXRpb25Gbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhhbmRsZXIgPSB3cmFwRm4oaGFuZGxlcik7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgW2RlbGVnYXRpb24sIG9yaWdpbmFsSGFuZGxlciwgdHlwZUV2ZW50XSA9IG5vcm1hbGl6ZVBhcmFtcyhvcmlnaW5hbFR5cGVFdmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZuKTtcbiAgY29uc3QgZXZlbnRzID0gZ2V0RXZlbnQoZWxlbWVudCk7XG4gIGNvbnN0IGhhbmRsZXJzID0gZXZlbnRzW3R5cGVFdmVudF0gfHwgKGV2ZW50c1t0eXBlRXZlbnRdID0ge30pO1xuICBjb25zdCBwcmV2aW91c0ZuID0gZmluZEhhbmRsZXIoaGFuZGxlcnMsIG9yaWdpbmFsSGFuZGxlciwgZGVsZWdhdGlvbiA/IGhhbmRsZXIgOiBudWxsKTtcblxuICBpZiAocHJldmlvdXNGbikge1xuICAgIHByZXZpb3VzRm4ub25lT2ZmID0gcHJldmlvdXNGbi5vbmVPZmYgJiYgb25lT2ZmO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHVpZCA9IGdldFVpZEV2ZW50KG9yaWdpbmFsSGFuZGxlciwgb3JpZ2luYWxUeXBlRXZlbnQucmVwbGFjZShuYW1lc3BhY2VSZWdleCwgJycpKTtcbiAgY29uc3QgZm4gPSBkZWxlZ2F0aW9uID8gYm9vdHN0cmFwRGVsZWdhdGlvbkhhbmRsZXIoZWxlbWVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZuKSA6IGJvb3RzdHJhcEhhbmRsZXIoZWxlbWVudCwgaGFuZGxlcik7XG4gIGZuLmRlbGVnYXRpb25TZWxlY3RvciA9IGRlbGVnYXRpb24gPyBoYW5kbGVyIDogbnVsbDtcbiAgZm4ub3JpZ2luYWxIYW5kbGVyID0gb3JpZ2luYWxIYW5kbGVyO1xuICBmbi5vbmVPZmYgPSBvbmVPZmY7XG4gIGZuLnVpZEV2ZW50ID0gdWlkO1xuICBoYW5kbGVyc1t1aWRdID0gZm47XG4gIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlRXZlbnQsIGZuLCBkZWxlZ2F0aW9uKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlSGFuZGxlcihlbGVtZW50LCBldmVudHMsIHR5cGVFdmVudCwgaGFuZGxlciwgZGVsZWdhdGlvblNlbGVjdG9yKSB7XG4gIGNvbnN0IGZuID0gZmluZEhhbmRsZXIoZXZlbnRzW3R5cGVFdmVudF0sIGhhbmRsZXIsIGRlbGVnYXRpb25TZWxlY3Rvcik7XG5cbiAgaWYgKCFmbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlRXZlbnQsIGZuLCBCb29sZWFuKGRlbGVnYXRpb25TZWxlY3RvcikpO1xuICBkZWxldGUgZXZlbnRzW3R5cGVFdmVudF1bZm4udWlkRXZlbnRdO1xufVxuXG5mdW5jdGlvbiByZW1vdmVOYW1lc3BhY2VkSGFuZGxlcnMoZWxlbWVudCwgZXZlbnRzLCB0eXBlRXZlbnQsIG5hbWVzcGFjZSkge1xuICBjb25zdCBzdG9yZUVsZW1lbnRFdmVudCA9IGV2ZW50c1t0eXBlRXZlbnRdIHx8IHt9O1xuICBPYmplY3Qua2V5cyhzdG9yZUVsZW1lbnRFdmVudCkuZm9yRWFjaChoYW5kbGVyS2V5ID0+IHtcbiAgICBpZiAoaGFuZGxlcktleS5pbmNsdWRlcyhuYW1lc3BhY2UpKSB7XG4gICAgICBjb25zdCBldmVudCA9IHN0b3JlRWxlbWVudEV2ZW50W2hhbmRsZXJLZXldO1xuICAgICAgcmVtb3ZlSGFuZGxlcihlbGVtZW50LCBldmVudHMsIHR5cGVFdmVudCwgZXZlbnQub3JpZ2luYWxIYW5kbGVyLCBldmVudC5kZWxlZ2F0aW9uU2VsZWN0b3IpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFR5cGVFdmVudChldmVudCkge1xuICAvLyBhbGxvdyB0byBnZXQgdGhlIG5hdGl2ZSBldmVudHMgZnJvbSBuYW1lc3BhY2VkIGV2ZW50cyAoJ2NsaWNrLmJzLmJ1dHRvbicgLS0+ICdjbGljaycpXG4gIGV2ZW50ID0gZXZlbnQucmVwbGFjZShzdHJpcE5hbWVSZWdleCwgJycpO1xuICByZXR1cm4gY3VzdG9tRXZlbnRzW2V2ZW50XSB8fCBldmVudDtcbn1cblxuY29uc3QgRXZlbnRIYW5kbGVyID0ge1xuICBvbihlbGVtZW50LCBldmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZuKSB7XG4gICAgYWRkSGFuZGxlcihlbGVtZW50LCBldmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZuLCBmYWxzZSk7XG4gIH0sXG5cbiAgb25lKGVsZW1lbnQsIGV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uRm4pIHtcbiAgICBhZGRIYW5kbGVyKGVsZW1lbnQsIGV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uRm4sIHRydWUpO1xuICB9LFxuXG4gIG9mZihlbGVtZW50LCBvcmlnaW5hbFR5cGVFdmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZuKSB7XG4gICAgaWYgKHR5cGVvZiBvcmlnaW5hbFR5cGVFdmVudCAhPT0gJ3N0cmluZycgfHwgIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBbZGVsZWdhdGlvbiwgb3JpZ2luYWxIYW5kbGVyLCB0eXBlRXZlbnRdID0gbm9ybWFsaXplUGFyYW1zKG9yaWdpbmFsVHlwZUV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uRm4pO1xuICAgIGNvbnN0IGluTmFtZXNwYWNlID0gdHlwZUV2ZW50ICE9PSBvcmlnaW5hbFR5cGVFdmVudDtcbiAgICBjb25zdCBldmVudHMgPSBnZXRFdmVudChlbGVtZW50KTtcbiAgICBjb25zdCBpc05hbWVzcGFjZSA9IG9yaWdpbmFsVHlwZUV2ZW50LnN0YXJ0c1dpdGgoJy4nKTtcblxuICAgIGlmICh0eXBlb2Ygb3JpZ2luYWxIYW5kbGVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gU2ltcGxlc3QgY2FzZTogaGFuZGxlciBpcyBwYXNzZWQsIHJlbW92ZSB0aGF0IGxpc3RlbmVyIE9OTFkuXG4gICAgICBpZiAoIWV2ZW50cyB8fCAhZXZlbnRzW3R5cGVFdmVudF0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZW1vdmVIYW5kbGVyKGVsZW1lbnQsIGV2ZW50cywgdHlwZUV2ZW50LCBvcmlnaW5hbEhhbmRsZXIsIGRlbGVnYXRpb24gPyBoYW5kbGVyIDogbnVsbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzTmFtZXNwYWNlKSB7XG4gICAgICBPYmplY3Qua2V5cyhldmVudHMpLmZvckVhY2goZWxlbWVudEV2ZW50ID0+IHtcbiAgICAgICAgcmVtb3ZlTmFtZXNwYWNlZEhhbmRsZXJzKGVsZW1lbnQsIGV2ZW50cywgZWxlbWVudEV2ZW50LCBvcmlnaW5hbFR5cGVFdmVudC5zbGljZSgxKSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBzdG9yZUVsZW1lbnRFdmVudCA9IGV2ZW50c1t0eXBlRXZlbnRdIHx8IHt9O1xuICAgIE9iamVjdC5rZXlzKHN0b3JlRWxlbWVudEV2ZW50KS5mb3JFYWNoKGtleUhhbmRsZXJzID0+IHtcbiAgICAgIGNvbnN0IGhhbmRsZXJLZXkgPSBrZXlIYW5kbGVycy5yZXBsYWNlKHN0cmlwVWlkUmVnZXgsICcnKTtcblxuICAgICAgaWYgKCFpbk5hbWVzcGFjZSB8fCBvcmlnaW5hbFR5cGVFdmVudC5pbmNsdWRlcyhoYW5kbGVyS2V5KSkge1xuICAgICAgICBjb25zdCBldmVudCA9IHN0b3JlRWxlbWVudEV2ZW50W2tleUhhbmRsZXJzXTtcbiAgICAgICAgcmVtb3ZlSGFuZGxlcihlbGVtZW50LCBldmVudHMsIHR5cGVFdmVudCwgZXZlbnQub3JpZ2luYWxIYW5kbGVyLCBldmVudC5kZWxlZ2F0aW9uU2VsZWN0b3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIHRyaWdnZXIoZWxlbWVudCwgZXZlbnQsIGFyZ3MpIHtcbiAgICBpZiAodHlwZW9mIGV2ZW50ICE9PSAnc3RyaW5nJyB8fCAhZWxlbWVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgJCA9IGdldGpRdWVyeSgpO1xuICAgIGNvbnN0IHR5cGVFdmVudCA9IGdldFR5cGVFdmVudChldmVudCk7XG4gICAgY29uc3QgaW5OYW1lc3BhY2UgPSBldmVudCAhPT0gdHlwZUV2ZW50O1xuICAgIGNvbnN0IGlzTmF0aXZlID0gbmF0aXZlRXZlbnRzLmhhcyh0eXBlRXZlbnQpO1xuICAgIGxldCBqUXVlcnlFdmVudDtcbiAgICBsZXQgYnViYmxlcyA9IHRydWU7XG4gICAgbGV0IG5hdGl2ZURpc3BhdGNoID0gdHJ1ZTtcbiAgICBsZXQgZGVmYXVsdFByZXZlbnRlZCA9IGZhbHNlO1xuICAgIGxldCBldnQgPSBudWxsO1xuXG4gICAgaWYgKGluTmFtZXNwYWNlICYmICQpIHtcbiAgICAgIGpRdWVyeUV2ZW50ID0gJC5FdmVudChldmVudCwgYXJncyk7XG4gICAgICAkKGVsZW1lbnQpLnRyaWdnZXIoalF1ZXJ5RXZlbnQpO1xuICAgICAgYnViYmxlcyA9ICFqUXVlcnlFdmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpO1xuICAgICAgbmF0aXZlRGlzcGF0Y2ggPSAhalF1ZXJ5RXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKTtcbiAgICAgIGRlZmF1bHRQcmV2ZW50ZWQgPSBqUXVlcnlFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKTtcbiAgICB9XG5cbiAgICBpZiAoaXNOYXRpdmUpIHtcbiAgICAgIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XG4gICAgICBldnQuaW5pdEV2ZW50KHR5cGVFdmVudCwgYnViYmxlcywgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2dCA9IG5ldyBDdXN0b21FdmVudChldmVudCwge1xuICAgICAgICBidWJibGVzLFxuICAgICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IC8vIG1lcmdlIGN1c3RvbSBpbmZvcm1hdGlvbiBpbiBvdXIgZXZlbnRcblxuXG4gICAgaWYgKHR5cGVvZiBhcmdzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgT2JqZWN0LmtleXMoYXJncykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXZ0LCBrZXksIHtcbiAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJnc1trZXldO1xuICAgICAgICAgIH1cblxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChkZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBpZiAobmF0aXZlRGlzcGF0Y2gpIHtcbiAgICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChldnQpO1xuICAgIH1cblxuICAgIGlmIChldnQuZGVmYXVsdFByZXZlbnRlZCAmJiB0eXBlb2YgalF1ZXJ5RXZlbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBqUXVlcnlFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICAgIHJldHVybiBldnQ7XG4gIH1cblxufTtcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NS4xLjMpOiBkb20vZGF0YS5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb25zdGFudHNcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5jb25zdCBlbGVtZW50TWFwID0gbmV3IE1hcCgpO1xuY29uc3QgRGF0YSA9IHtcbiAgc2V0KGVsZW1lbnQsIGtleSwgaW5zdGFuY2UpIHtcbiAgICBpZiAoIWVsZW1lbnRNYXAuaGFzKGVsZW1lbnQpKSB7XG4gICAgICBlbGVtZW50TWFwLnNldChlbGVtZW50LCBuZXcgTWFwKCkpO1xuICAgIH1cblxuICAgIGNvbnN0IGluc3RhbmNlTWFwID0gZWxlbWVudE1hcC5nZXQoZWxlbWVudCk7IC8vIG1ha2UgaXQgY2xlYXIgd2Ugb25seSB3YW50IG9uZSBpbnN0YW5jZSBwZXIgZWxlbWVudFxuICAgIC8vIGNhbiBiZSByZW1vdmVkIGxhdGVyIHdoZW4gbXVsdGlwbGUga2V5L2luc3RhbmNlcyBhcmUgZmluZSB0byBiZSB1c2VkXG5cbiAgICBpZiAoIWluc3RhbmNlTWFwLmhhcyhrZXkpICYmIGluc3RhbmNlTWFwLnNpemUgIT09IDApIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLmVycm9yKGBCb290c3RyYXAgZG9lc24ndCBhbGxvdyBtb3JlIHRoYW4gb25lIGluc3RhbmNlIHBlciBlbGVtZW50LiBCb3VuZCBpbnN0YW5jZTogJHtBcnJheS5mcm9tKGluc3RhbmNlTWFwLmtleXMoKSlbMF19LmApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGluc3RhbmNlTWFwLnNldChrZXksIGluc3RhbmNlKTtcbiAgfSxcblxuICBnZXQoZWxlbWVudCwga2V5KSB7XG4gICAgaWYgKGVsZW1lbnRNYXAuaGFzKGVsZW1lbnQpKSB7XG4gICAgICByZXR1cm4gZWxlbWVudE1hcC5nZXQoZWxlbWVudCkuZ2V0KGtleSkgfHwgbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICByZW1vdmUoZWxlbWVudCwga2V5KSB7XG4gICAgaWYgKCFlbGVtZW50TWFwLmhhcyhlbGVtZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGluc3RhbmNlTWFwID0gZWxlbWVudE1hcC5nZXQoZWxlbWVudCk7XG4gICAgaW5zdGFuY2VNYXAuZGVsZXRlKGtleSk7IC8vIGZyZWUgdXAgZWxlbWVudCByZWZlcmVuY2VzIGlmIHRoZXJlIGFyZSBubyBpbnN0YW5jZXMgbGVmdCBmb3IgYW4gZWxlbWVudFxuXG4gICAgaWYgKGluc3RhbmNlTWFwLnNpemUgPT09IDApIHtcbiAgICAgIGVsZW1lbnRNYXAuZGVsZXRlKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG59O1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY1LjEuMyk6IGJhc2UtY29tcG9uZW50LmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb25zdGFudHNcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNvbnN0IFZFUlNJT04gPSAnNS4xLjMnO1xuXG5jbGFzcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCkge1xuICAgIGVsZW1lbnQgPSBnZXRFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgRGF0YS5zZXQodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWSwgdGhpcyk7XG4gIH1cblxuICBkaXNwb3NlKCkge1xuICAgIERhdGEucmVtb3ZlKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuREFUQV9LRVkpO1xuICAgIEV2ZW50SGFuZGxlci5vZmYodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5FVkVOVF9LRVkpO1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpLmZvckVhY2gocHJvcGVydHlOYW1lID0+IHtcbiAgICAgIHRoaXNbcHJvcGVydHlOYW1lXSA9IG51bGw7XG4gICAgfSk7XG4gIH1cblxuICBfcXVldWVDYWxsYmFjayhjYWxsYmFjaywgZWxlbWVudCwgaXNBbmltYXRlZCA9IHRydWUpIHtcbiAgICBleGVjdXRlQWZ0ZXJUcmFuc2l0aW9uKGNhbGxiYWNrLCBlbGVtZW50LCBpc0FuaW1hdGVkKTtcbiAgfVxuICAvKiogU3RhdGljICovXG5cblxuICBzdGF0aWMgZ2V0SW5zdGFuY2UoZWxlbWVudCkge1xuICAgIHJldHVybiBEYXRhLmdldChnZXRFbGVtZW50KGVsZW1lbnQpLCB0aGlzLkRBVEFfS0VZKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKGVsZW1lbnQsIGNvbmZpZyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UoZWxlbWVudCkgfHwgbmV3IHRoaXMoZWxlbWVudCwgdHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgPyBjb25maWcgOiBudWxsKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgVkVSU0lPTigpIHtcbiAgICByZXR1cm4gVkVSU0lPTjtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBoYXZlIHRvIGltcGxlbWVudCB0aGUgc3RhdGljIG1ldGhvZCBcIk5BTUVcIiwgZm9yIGVhY2ggY29tcG9uZW50IScpO1xuICB9XG5cbiAgc3RhdGljIGdldCBEQVRBX0tFWSgpIHtcbiAgICByZXR1cm4gYGJzLiR7dGhpcy5OQU1FfWA7XG4gIH1cblxuICBzdGF0aWMgZ2V0IEVWRU5UX0tFWSgpIHtcbiAgICByZXR1cm4gYC4ke3RoaXMuREFUQV9LRVl9YDtcbiAgfVxuXG59XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjUuMS4zKTogdXRpbC9jb21wb25lbnQtZnVuY3Rpb25zLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY29uc3QgZW5hYmxlRGlzbWlzc1RyaWdnZXIgPSAoY29tcG9uZW50LCBtZXRob2QgPSAnaGlkZScpID0+IHtcbiAgY29uc3QgY2xpY2tFdmVudCA9IGBjbGljay5kaXNtaXNzJHtjb21wb25lbnQuRVZFTlRfS0VZfWA7XG4gIGNvbnN0IG5hbWUgPSBjb21wb25lbnQuTkFNRTtcbiAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBjbGlja0V2ZW50LCBgW2RhdGEtYnMtZGlzbWlzcz1cIiR7bmFtZX1cIl1gLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoWydBJywgJ0FSRUEnXS5pbmNsdWRlcyh0aGlzLnRhZ05hbWUpKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICAgIGlmIChpc0Rpc2FibGVkKHRoaXMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgdGFyZ2V0ID0gZ2V0RWxlbWVudEZyb21TZWxlY3Rvcih0aGlzKSB8fCB0aGlzLmNsb3Nlc3QoYC4ke25hbWV9YCk7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBjb21wb25lbnQuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0YXJnZXQpOyAvLyBNZXRob2QgYXJndW1lbnQgaXMgbGVmdCwgZm9yIEFsZXJ0IGFuZCBvbmx5LCBhcyBpdCBkb2Vzbid0IGltcGxlbWVudCB0aGUgJ2hpZGUnIG1ldGhvZFxuXG4gICAgaW5zdGFuY2VbbWV0aG9kXSgpO1xuICB9KTtcbn07XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjUuMS4zKTogYWxlcnQuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvbnN0YW50c1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY29uc3QgTkFNRSRkID0gJ2FsZXJ0JztcbmNvbnN0IERBVEFfS0VZJGMgPSAnYnMuYWxlcnQnO1xuY29uc3QgRVZFTlRfS0VZJGMgPSBgLiR7REFUQV9LRVkkY31gO1xuY29uc3QgRVZFTlRfQ0xPU0UgPSBgY2xvc2Uke0VWRU5UX0tFWSRjfWA7XG5jb25zdCBFVkVOVF9DTE9TRUQgPSBgY2xvc2VkJHtFVkVOVF9LRVkkY31gO1xuY29uc3QgQ0xBU1NfTkFNRV9GQURFJDUgPSAnZmFkZSc7XG5jb25zdCBDTEFTU19OQU1FX1NIT1ckOCA9ICdzaG93Jztcbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDbGFzcyBEZWZpbml0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jbGFzcyBBbGVydCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gTkFNRSRkO1xuICB9IC8vIFB1YmxpY1xuXG5cbiAgY2xvc2UoKSB7XG4gICAgY29uc3QgY2xvc2VFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0NMT1NFKTtcblxuICAgIGlmIChjbG9zZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDgpO1xuXG4gICAgY29uc3QgaXNBbmltYXRlZCA9IHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRkFERSQ1KTtcblxuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soKCkgPT4gdGhpcy5fZGVzdHJveUVsZW1lbnQoKSwgdGhpcy5fZWxlbWVudCwgaXNBbmltYXRlZCk7XG4gIH0gLy8gUHJpdmF0ZVxuXG5cbiAgX2Rlc3Ryb3lFbGVtZW50KCkge1xuICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlKCk7XG5cbiAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9DTE9TRUQpO1xuICAgIHRoaXMuZGlzcG9zZSgpO1xuICB9IC8vIFN0YXRpY1xuXG5cbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBBbGVydC5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMpO1xuXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YVtjb25maWddID09PSB1bmRlZmluZWQgfHwgY29uZmlnLnN0YXJ0c1dpdGgoJ18nKSB8fCBjb25maWcgPT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKTtcbiAgICAgIH1cblxuICAgICAgZGF0YVtjb25maWddKHRoaXMpO1xuICAgIH0pO1xuICB9XG5cbn1cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBEYXRhIEFwaSBpbXBsZW1lbnRhdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuXG5lbmFibGVEaXNtaXNzVHJpZ2dlcihBbGVydCwgJ2Nsb3NlJyk7XG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogalF1ZXJ5XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIGFkZCAuQWxlcnQgdG8galF1ZXJ5IG9ubHkgaWYgalF1ZXJ5IGlzIHByZXNlbnRcbiAqL1xuXG5kZWZpbmVKUXVlcnlQbHVnaW4oQWxlcnQpO1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY1LjEuMyk6IGJ1dHRvbi5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29uc3RhbnRzXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jb25zdCBOQU1FJGMgPSAnYnV0dG9uJztcbmNvbnN0IERBVEFfS0VZJGIgPSAnYnMuYnV0dG9uJztcbmNvbnN0IEVWRU5UX0tFWSRiID0gYC4ke0RBVEFfS0VZJGJ9YDtcbmNvbnN0IERBVEFfQVBJX0tFWSQ3ID0gJy5kYXRhLWFwaSc7XG5jb25zdCBDTEFTU19OQU1FX0FDVElWRSQzID0gJ2FjdGl2ZSc7XG5jb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ1ID0gJ1tkYXRhLWJzLXRvZ2dsZT1cImJ1dHRvblwiXSc7XG5jb25zdCBFVkVOVF9DTElDS19EQVRBX0FQSSQ2ID0gYGNsaWNrJHtFVkVOVF9LRVkkYn0ke0RBVEFfQVBJX0tFWSQ3fWA7XG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ2xhc3MgRGVmaW5pdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY2xhc3MgQnV0dG9uIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBOQU1FJGM7XG4gIH0gLy8gUHVibGljXG5cblxuICB0b2dnbGUoKSB7XG4gICAgLy8gVG9nZ2xlIGNsYXNzIGFuZCBzeW5jIHRoZSBgYXJpYS1wcmVzc2VkYCBhdHRyaWJ1dGUgd2l0aCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBgLnRvZ2dsZSgpYCBtZXRob2RcbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1wcmVzc2VkJywgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKENMQVNTX05BTUVfQUNUSVZFJDMpKTtcbiAgfSAvLyBTdGF0aWNcblxuXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCBkYXRhID0gQnV0dG9uLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcyk7XG5cbiAgICAgIGlmIChjb25maWcgPT09ICd0b2dnbGUnKSB7XG4gICAgICAgIGRhdGFbY29uZmlnXSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbn1cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBEYXRhIEFwaSBpbXBsZW1lbnRhdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuXG5FdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJJDYsIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDUsIGV2ZW50ID0+IHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgY29uc3QgYnV0dG9uID0gZXZlbnQudGFyZ2V0LmNsb3Nlc3QoU0VMRUNUT1JfREFUQV9UT0dHTEUkNSk7XG4gIGNvbnN0IGRhdGEgPSBCdXR0b24uZ2V0T3JDcmVhdGVJbnN0YW5jZShidXR0b24pO1xuICBkYXRhLnRvZ2dsZSgpO1xufSk7XG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogalF1ZXJ5XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIGFkZCAuQnV0dG9uIHRvIGpRdWVyeSBvbmx5IGlmIGpRdWVyeSBpcyBwcmVzZW50XG4gKi9cblxuZGVmaW5lSlF1ZXJ5UGx1Z2luKEJ1dHRvbik7XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjUuMS4zKTogZG9tL21hbmlwdWxhdG9yLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZURhdGEodmFsKSB7XG4gIGlmICh2YWwgPT09ICd0cnVlJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHZhbCA9PT0gJ2ZhbHNlJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh2YWwgPT09IE51bWJlcih2YWwpLnRvU3RyaW5nKCkpIHtcbiAgICByZXR1cm4gTnVtYmVyKHZhbCk7XG4gIH1cblxuICBpZiAodmFsID09PSAnJyB8fCB2YWwgPT09ICdudWxsJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHZhbDtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplRGF0YUtleShrZXkpIHtcbiAgcmV0dXJuIGtleS5yZXBsYWNlKC9bQS1aXS9nLCBjaHIgPT4gYC0ke2Noci50b0xvd2VyQ2FzZSgpfWApO1xufVxuXG5jb25zdCBNYW5pcHVsYXRvciA9IHtcbiAgc2V0RGF0YUF0dHJpYnV0ZShlbGVtZW50LCBrZXksIHZhbHVlKSB7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoYGRhdGEtYnMtJHtub3JtYWxpemVEYXRhS2V5KGtleSl9YCwgdmFsdWUpO1xuICB9LFxuXG4gIHJlbW92ZURhdGFBdHRyaWJ1dGUoZWxlbWVudCwga2V5KSB7XG4gICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYGRhdGEtYnMtJHtub3JtYWxpemVEYXRhS2V5KGtleSl9YCk7XG4gIH0sXG5cbiAgZ2V0RGF0YUF0dHJpYnV0ZXMoZWxlbWVudCkge1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhlbGVtZW50LmRhdGFzZXQpLmZpbHRlcihrZXkgPT4ga2V5LnN0YXJ0c1dpdGgoJ2JzJykpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGxldCBwdXJlS2V5ID0ga2V5LnJlcGxhY2UoL15icy8sICcnKTtcbiAgICAgIHB1cmVLZXkgPSBwdXJlS2V5LmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgcHVyZUtleS5zbGljZSgxLCBwdXJlS2V5Lmxlbmd0aCk7XG4gICAgICBhdHRyaWJ1dGVzW3B1cmVLZXldID0gbm9ybWFsaXplRGF0YShlbGVtZW50LmRhdGFzZXRba2V5XSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gIH0sXG5cbiAgZ2V0RGF0YUF0dHJpYnV0ZShlbGVtZW50LCBrZXkpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplRGF0YShlbGVtZW50LmdldEF0dHJpYnV0ZShgZGF0YS1icy0ke25vcm1hbGl6ZURhdGFLZXkoa2V5KX1gKSk7XG4gIH0sXG5cbiAgb2Zmc2V0KGVsZW1lbnQpIHtcbiAgICBjb25zdCByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4ge1xuICAgICAgdG9wOiByZWN0LnRvcCArIHdpbmRvdy5wYWdlWU9mZnNldCxcbiAgICAgIGxlZnQ6IHJlY3QubGVmdCArIHdpbmRvdy5wYWdlWE9mZnNldFxuICAgIH07XG4gIH0sXG5cbiAgcG9zaXRpb24oZWxlbWVudCkge1xuICAgIHJldHVybiB7XG4gICAgICB0b3A6IGVsZW1lbnQub2Zmc2V0VG9wLFxuICAgICAgbGVmdDogZWxlbWVudC5vZmZzZXRMZWZ0XG4gICAgfTtcbiAgfVxuXG59O1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY1LjEuMyk6IGRvbS9zZWxlY3Rvci1lbmdpbmUuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuY29uc3QgTk9ERV9URVhUID0gMztcbmNvbnN0IFNlbGVjdG9yRW5naW5lID0ge1xuICBmaW5kKHNlbGVjdG9yLCBlbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdCguLi5FbGVtZW50LnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yQWxsLmNhbGwoZWxlbWVudCwgc2VsZWN0b3IpKTtcbiAgfSxcblxuICBmaW5kT25lKHNlbGVjdG9yLCBlbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgcmV0dXJuIEVsZW1lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3IuY2FsbChlbGVtZW50LCBzZWxlY3Rvcik7XG4gIH0sXG5cbiAgY2hpbGRyZW4oZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gW10uY29uY2F0KC4uLmVsZW1lbnQuY2hpbGRyZW4pLmZpbHRlcihjaGlsZCA9PiBjaGlsZC5tYXRjaGVzKHNlbGVjdG9yKSk7XG4gIH0sXG5cbiAgcGFyZW50cyhlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgIGNvbnN0IHBhcmVudHMgPSBbXTtcbiAgICBsZXQgYW5jZXN0b3IgPSBlbGVtZW50LnBhcmVudE5vZGU7XG5cbiAgICB3aGlsZSAoYW5jZXN0b3IgJiYgYW5jZXN0b3Iubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFICYmIGFuY2VzdG9yLm5vZGVUeXBlICE9PSBOT0RFX1RFWFQpIHtcbiAgICAgIGlmIChhbmNlc3Rvci5tYXRjaGVzKHNlbGVjdG9yKSkge1xuICAgICAgICBwYXJlbnRzLnB1c2goYW5jZXN0b3IpO1xuICAgICAgfVxuXG4gICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmVudHM7XG4gIH0sXG5cbiAgcHJldihlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgIGxldCBwcmV2aW91cyA9IGVsZW1lbnQucHJldmlvdXNFbGVtZW50U2libGluZztcblxuICAgIHdoaWxlIChwcmV2aW91cykge1xuICAgICAgaWYgKHByZXZpb3VzLm1hdGNoZXMoc2VsZWN0b3IpKSB7XG4gICAgICAgIHJldHVybiBbcHJldmlvdXNdO1xuICAgICAgfVxuXG4gICAgICBwcmV2aW91cyA9IHByZXZpb3VzLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtdO1xuICB9LFxuXG4gIG5leHQoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgICBsZXQgbmV4dCA9IGVsZW1lbnQubmV4dEVsZW1lbnRTaWJsaW5nO1xuXG4gICAgd2hpbGUgKG5leHQpIHtcbiAgICAgIGlmIChuZXh0Lm1hdGNoZXMoc2VsZWN0b3IpKSB7XG4gICAgICAgIHJldHVybiBbbmV4dF07XG4gICAgICB9XG5cbiAgICAgIG5leHQgPSBuZXh0Lm5leHRFbGVtZW50U2libGluZztcbiAgICB9XG5cbiAgICByZXR1cm4gW107XG4gIH0sXG5cbiAgZm9jdXNhYmxlQ2hpbGRyZW4oZWxlbWVudCkge1xuICAgIGNvbnN0IGZvY3VzYWJsZXMgPSBbJ2EnLCAnYnV0dG9uJywgJ2lucHV0JywgJ3RleHRhcmVhJywgJ3NlbGVjdCcsICdkZXRhaWxzJywgJ1t0YWJpbmRleF0nLCAnW2NvbnRlbnRlZGl0YWJsZT1cInRydWVcIl0nXS5tYXAoc2VsZWN0b3IgPT4gYCR7c2VsZWN0b3J9Om5vdChbdGFiaW5kZXhePVwiLVwiXSlgKS5qb2luKCcsICcpO1xuICAgIHJldHVybiB0aGlzLmZpbmQoZm9jdXNhYmxlcywgZWxlbWVudCkuZmlsdGVyKGVsID0+ICFpc0Rpc2FibGVkKGVsKSAmJiBpc1Zpc2libGUoZWwpKTtcbiAgfVxuXG59O1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY1LjEuMyk6IGNhcm91c2VsLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb25zdGFudHNcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNvbnN0IE5BTUUkYiA9ICdjYXJvdXNlbCc7XG5jb25zdCBEQVRBX0tFWSRhID0gJ2JzLmNhcm91c2VsJztcbmNvbnN0IEVWRU5UX0tFWSRhID0gYC4ke0RBVEFfS0VZJGF9YDtcbmNvbnN0IERBVEFfQVBJX0tFWSQ2ID0gJy5kYXRhLWFwaSc7XG5jb25zdCBBUlJPV19MRUZUX0tFWSA9ICdBcnJvd0xlZnQnO1xuY29uc3QgQVJST1dfUklHSFRfS0VZID0gJ0Fycm93UmlnaHQnO1xuY29uc3QgVE9VQ0hFVkVOVF9DT01QQVRfV0FJVCA9IDUwMDsgLy8gVGltZSBmb3IgbW91c2UgY29tcGF0IGV2ZW50cyB0byBmaXJlIGFmdGVyIHRvdWNoXG5cbmNvbnN0IFNXSVBFX1RIUkVTSE9MRCA9IDQwO1xuY29uc3QgRGVmYXVsdCRhID0ge1xuICBpbnRlcnZhbDogNTAwMCxcbiAga2V5Ym9hcmQ6IHRydWUsXG4gIHNsaWRlOiBmYWxzZSxcbiAgcGF1c2U6ICdob3ZlcicsXG4gIHdyYXA6IHRydWUsXG4gIHRvdWNoOiB0cnVlXG59O1xuY29uc3QgRGVmYXVsdFR5cGUkYSA9IHtcbiAgaW50ZXJ2YWw6ICcobnVtYmVyfGJvb2xlYW4pJyxcbiAga2V5Ym9hcmQ6ICdib29sZWFuJyxcbiAgc2xpZGU6ICcoYm9vbGVhbnxzdHJpbmcpJyxcbiAgcGF1c2U6ICcoc3RyaW5nfGJvb2xlYW4pJyxcbiAgd3JhcDogJ2Jvb2xlYW4nLFxuICB0b3VjaDogJ2Jvb2xlYW4nXG59O1xuY29uc3QgT1JERVJfTkVYVCA9ICduZXh0JztcbmNvbnN0IE9SREVSX1BSRVYgPSAncHJldic7XG5jb25zdCBESVJFQ1RJT05fTEVGVCA9ICdsZWZ0JztcbmNvbnN0IERJUkVDVElPTl9SSUdIVCA9ICdyaWdodCc7XG5jb25zdCBLRVlfVE9fRElSRUNUSU9OID0ge1xuICBbQVJST1dfTEVGVF9LRVldOiBESVJFQ1RJT05fUklHSFQsXG4gIFtBUlJPV19SSUdIVF9LRVldOiBESVJFQ1RJT05fTEVGVFxufTtcbmNvbnN0IEVWRU5UX1NMSURFID0gYHNsaWRlJHtFVkVOVF9LRVkkYX1gO1xuY29uc3QgRVZFTlRfU0xJRCA9IGBzbGlkJHtFVkVOVF9LRVkkYX1gO1xuY29uc3QgRVZFTlRfS0VZRE9XTiA9IGBrZXlkb3duJHtFVkVOVF9LRVkkYX1gO1xuY29uc3QgRVZFTlRfTU9VU0VFTlRFUiA9IGBtb3VzZWVudGVyJHtFVkVOVF9LRVkkYX1gO1xuY29uc3QgRVZFTlRfTU9VU0VMRUFWRSA9IGBtb3VzZWxlYXZlJHtFVkVOVF9LRVkkYX1gO1xuY29uc3QgRVZFTlRfVE9VQ0hTVEFSVCA9IGB0b3VjaHN0YXJ0JHtFVkVOVF9LRVkkYX1gO1xuY29uc3QgRVZFTlRfVE9VQ0hNT1ZFID0gYHRvdWNobW92ZSR7RVZFTlRfS0VZJGF9YDtcbmNvbnN0IEVWRU5UX1RPVUNIRU5EID0gYHRvdWNoZW5kJHtFVkVOVF9LRVkkYX1gO1xuY29uc3QgRVZFTlRfUE9JTlRFUkRPV04gPSBgcG9pbnRlcmRvd24ke0VWRU5UX0tFWSRhfWA7XG5jb25zdCBFVkVOVF9QT0lOVEVSVVAgPSBgcG9pbnRlcnVwJHtFVkVOVF9LRVkkYX1gO1xuY29uc3QgRVZFTlRfRFJBR19TVEFSVCA9IGBkcmFnc3RhcnQke0VWRU5UX0tFWSRhfWA7XG5jb25zdCBFVkVOVF9MT0FEX0RBVEFfQVBJJDIgPSBgbG9hZCR7RVZFTlRfS0VZJGF9JHtEQVRBX0FQSV9LRVkkNn1gO1xuY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNSA9IGBjbGljayR7RVZFTlRfS0VZJGF9JHtEQVRBX0FQSV9LRVkkNn1gO1xuY29uc3QgQ0xBU1NfTkFNRV9DQVJPVVNFTCA9ICdjYXJvdXNlbCc7XG5jb25zdCBDTEFTU19OQU1FX0FDVElWRSQyID0gJ2FjdGl2ZSc7XG5jb25zdCBDTEFTU19OQU1FX1NMSURFID0gJ3NsaWRlJztcbmNvbnN0IENMQVNTX05BTUVfRU5EID0gJ2Nhcm91c2VsLWl0ZW0tZW5kJztcbmNvbnN0IENMQVNTX05BTUVfU1RBUlQgPSAnY2Fyb3VzZWwtaXRlbS1zdGFydCc7XG5jb25zdCBDTEFTU19OQU1FX05FWFQgPSAnY2Fyb3VzZWwtaXRlbS1uZXh0JztcbmNvbnN0IENMQVNTX05BTUVfUFJFViA9ICdjYXJvdXNlbC1pdGVtLXByZXYnO1xuY29uc3QgQ0xBU1NfTkFNRV9QT0lOVEVSX0VWRU5UID0gJ3BvaW50ZXItZXZlbnQnO1xuY29uc3QgU0VMRUNUT1JfQUNUSVZFJDEgPSAnLmFjdGl2ZSc7XG5jb25zdCBTRUxFQ1RPUl9BQ1RJVkVfSVRFTSA9ICcuYWN0aXZlLmNhcm91c2VsLWl0ZW0nO1xuY29uc3QgU0VMRUNUT1JfSVRFTSA9ICcuY2Fyb3VzZWwtaXRlbSc7XG5jb25zdCBTRUxFQ1RPUl9JVEVNX0lNRyA9ICcuY2Fyb3VzZWwtaXRlbSBpbWcnO1xuY29uc3QgU0VMRUNUT1JfTkVYVF9QUkVWID0gJy5jYXJvdXNlbC1pdGVtLW5leHQsIC5jYXJvdXNlbC1pdGVtLXByZXYnO1xuY29uc3QgU0VMRUNUT1JfSU5ESUNBVE9SUyA9ICcuY2Fyb3VzZWwtaW5kaWNhdG9ycyc7XG5jb25zdCBTRUxFQ1RPUl9JTkRJQ0FUT1IgPSAnW2RhdGEtYnMtdGFyZ2V0XSc7XG5jb25zdCBTRUxFQ1RPUl9EQVRBX1NMSURFID0gJ1tkYXRhLWJzLXNsaWRlXSwgW2RhdGEtYnMtc2xpZGUtdG9dJztcbmNvbnN0IFNFTEVDVE9SX0RBVEFfUklERSA9ICdbZGF0YS1icy1yaWRlPVwiY2Fyb3VzZWxcIl0nO1xuY29uc3QgUE9JTlRFUl9UWVBFX1RPVUNIID0gJ3RvdWNoJztcbmNvbnN0IFBPSU5URVJfVFlQRV9QRU4gPSAncGVuJztcbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDbGFzcyBEZWZpbml0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jbGFzcyBDYXJvdXNlbCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICBzdXBlcihlbGVtZW50KTtcbiAgICB0aGlzLl9pdGVtcyA9IG51bGw7XG4gICAgdGhpcy5faW50ZXJ2YWwgPSBudWxsO1xuICAgIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XG4gICAgdGhpcy5faXNTbGlkaW5nID0gZmFsc2U7XG4gICAgdGhpcy50b3VjaFRpbWVvdXQgPSBudWxsO1xuICAgIHRoaXMudG91Y2hTdGFydFggPSAwO1xuICAgIHRoaXMudG91Y2hEZWx0YVggPSAwO1xuICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpO1xuICAgIHRoaXMuX2luZGljYXRvcnNFbGVtZW50ID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9JTkRJQ0FUT1JTLCB0aGlzLl9lbGVtZW50KTtcbiAgICB0aGlzLl90b3VjaFN1cHBvcnRlZCA9ICdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAwO1xuICAgIHRoaXMuX3BvaW50ZXJFdmVudCA9IEJvb2xlYW4od2luZG93LlBvaW50ZXJFdmVudCk7XG5cbiAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xuICB9IC8vIEdldHRlcnNcblxuXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gRGVmYXVsdCRhO1xuICB9XG5cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBOQU1FJGI7XG4gIH0gLy8gUHVibGljXG5cblxuICBuZXh0KCkge1xuICAgIHRoaXMuX3NsaWRlKE9SREVSX05FWFQpO1xuICB9XG5cbiAgbmV4dFdoZW5WaXNpYmxlKCkge1xuICAgIC8vIERvbid0IGNhbGwgbmV4dCB3aGVuIHRoZSBwYWdlIGlzbid0IHZpc2libGVcbiAgICAvLyBvciB0aGUgY2Fyb3VzZWwgb3IgaXRzIHBhcmVudCBpc24ndCB2aXNpYmxlXG4gICAgaWYgKCFkb2N1bWVudC5oaWRkZW4gJiYgaXNWaXNpYmxlKHRoaXMuX2VsZW1lbnQpKSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG4gIH1cblxuICBwcmV2KCkge1xuICAgIHRoaXMuX3NsaWRlKE9SREVSX1BSRVYpO1xuICB9XG5cbiAgcGF1c2UoZXZlbnQpIHtcbiAgICBpZiAoIWV2ZW50KSB7XG4gICAgICB0aGlzLl9pc1BhdXNlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfTkVYVF9QUkVWLCB0aGlzLl9lbGVtZW50KSkge1xuICAgICAgdHJpZ2dlclRyYW5zaXRpb25FbmQodGhpcy5fZWxlbWVudCk7XG4gICAgICB0aGlzLmN5Y2xlKHRydWUpO1xuICAgIH1cblxuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpO1xuICAgIHRoaXMuX2ludGVydmFsID0gbnVsbDtcbiAgfVxuXG4gIGN5Y2xlKGV2ZW50KSB7XG4gICAgaWYgKCFldmVudCkge1xuICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faW50ZXJ2YWwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpO1xuICAgICAgdGhpcy5faW50ZXJ2YWwgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9jb25maWcgJiYgdGhpcy5fY29uZmlnLmludGVydmFsICYmICF0aGlzLl9pc1BhdXNlZCkge1xuICAgICAgdGhpcy5fdXBkYXRlSW50ZXJ2YWwoKTtcblxuICAgICAgdGhpcy5faW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID8gdGhpcy5uZXh0V2hlblZpc2libGUgOiB0aGlzLm5leHQpLmJpbmQodGhpcyksIHRoaXMuX2NvbmZpZy5pbnRlcnZhbCk7XG4gICAgfVxuICB9XG5cbiAgdG8oaW5kZXgpIHtcbiAgICB0aGlzLl9hY3RpdmVFbGVtZW50ID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9BQ1RJVkVfSVRFTSwgdGhpcy5fZWxlbWVudCk7XG5cbiAgICBjb25zdCBhY3RpdmVJbmRleCA9IHRoaXMuX2dldEl0ZW1JbmRleCh0aGlzLl9hY3RpdmVFbGVtZW50KTtcblxuICAgIGlmIChpbmRleCA+IHRoaXMuX2l0ZW1zLmxlbmd0aCAtIDEgfHwgaW5kZXggPCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2lzU2xpZGluZykge1xuICAgICAgRXZlbnRIYW5kbGVyLm9uZSh0aGlzLl9lbGVtZW50LCBFVkVOVF9TTElELCAoKSA9PiB0aGlzLnRvKGluZGV4KSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGFjdGl2ZUluZGV4ID09PSBpbmRleCkge1xuICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgdGhpcy5jeWNsZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG9yZGVyID0gaW5kZXggPiBhY3RpdmVJbmRleCA/IE9SREVSX05FWFQgOiBPUkRFUl9QUkVWO1xuXG4gICAgdGhpcy5fc2xpZGUob3JkZXIsIHRoaXMuX2l0ZW1zW2luZGV4XSk7XG4gIH0gLy8gUHJpdmF0ZVxuXG5cbiAgX2dldENvbmZpZyhjb25maWcpIHtcbiAgICBjb25maWcgPSB7IC4uLkRlZmF1bHQkYSxcbiAgICAgIC4uLk1hbmlwdWxhdG9yLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4uKHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnID8gY29uZmlnIDoge30pXG4gICAgfTtcbiAgICB0eXBlQ2hlY2tDb25maWcoTkFNRSRiLCBjb25maWcsIERlZmF1bHRUeXBlJGEpO1xuICAgIHJldHVybiBjb25maWc7XG4gIH1cblxuICBfaGFuZGxlU3dpcGUoKSB7XG4gICAgY29uc3QgYWJzRGVsdGF4ID0gTWF0aC5hYnModGhpcy50b3VjaERlbHRhWCk7XG5cbiAgICBpZiAoYWJzRGVsdGF4IDw9IFNXSVBFX1RIUkVTSE9MRCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGRpcmVjdGlvbiA9IGFic0RlbHRheCAvIHRoaXMudG91Y2hEZWx0YVg7XG4gICAgdGhpcy50b3VjaERlbHRhWCA9IDA7XG5cbiAgICBpZiAoIWRpcmVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3NsaWRlKGRpcmVjdGlvbiA+IDAgPyBESVJFQ1RJT05fUklHSFQgOiBESVJFQ1RJT05fTEVGVCk7XG4gIH1cblxuICBfYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKHRoaXMuX2NvbmZpZy5rZXlib2FyZCkge1xuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0tFWURPV04sIGV2ZW50ID0+IHRoaXMuX2tleWRvd24oZXZlbnQpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fY29uZmlnLnBhdXNlID09PSAnaG92ZXInKSB7XG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfTU9VU0VFTlRFUiwgZXZlbnQgPT4gdGhpcy5wYXVzZShldmVudCkpO1xuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX01PVVNFTEVBVkUsIGV2ZW50ID0+IHRoaXMuY3ljbGUoZXZlbnQpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fY29uZmlnLnRvdWNoICYmIHRoaXMuX3RvdWNoU3VwcG9ydGVkKSB7XG4gICAgICB0aGlzLl9hZGRUb3VjaEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuICB9XG5cbiAgX2FkZFRvdWNoRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgaGFzUG9pbnRlclBlblRvdWNoID0gZXZlbnQgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuX3BvaW50ZXJFdmVudCAmJiAoZXZlbnQucG9pbnRlclR5cGUgPT09IFBPSU5URVJfVFlQRV9QRU4gfHwgZXZlbnQucG9pbnRlclR5cGUgPT09IFBPSU5URVJfVFlQRV9UT1VDSCk7XG4gICAgfTtcblxuICAgIGNvbnN0IHN0YXJ0ID0gZXZlbnQgPT4ge1xuICAgICAgaWYgKGhhc1BvaW50ZXJQZW5Ub3VjaChldmVudCkpIHtcbiAgICAgICAgdGhpcy50b3VjaFN0YXJ0WCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLl9wb2ludGVyRXZlbnQpIHtcbiAgICAgICAgdGhpcy50b3VjaFN0YXJ0WCA9IGV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgbW92ZSA9IGV2ZW50ID0+IHtcbiAgICAgIC8vIGVuc3VyZSBzd2lwaW5nIHdpdGggb25lIHRvdWNoIGFuZCBub3QgcGluY2hpbmdcbiAgICAgIHRoaXMudG91Y2hEZWx0YVggPSBldmVudC50b3VjaGVzICYmIGV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMSA/IDAgOiBldmVudC50b3VjaGVzWzBdLmNsaWVudFggLSB0aGlzLnRvdWNoU3RhcnRYO1xuICAgIH07XG5cbiAgICBjb25zdCBlbmQgPSBldmVudCA9PiB7XG4gICAgICBpZiAoaGFzUG9pbnRlclBlblRvdWNoKGV2ZW50KSkge1xuICAgICAgICB0aGlzLnRvdWNoRGVsdGFYID0gZXZlbnQuY2xpZW50WCAtIHRoaXMudG91Y2hTdGFydFg7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2hhbmRsZVN3aXBlKCk7XG5cbiAgICAgIGlmICh0aGlzLl9jb25maWcucGF1c2UgPT09ICdob3ZlcicpIHtcbiAgICAgICAgLy8gSWYgaXQncyBhIHRvdWNoLWVuYWJsZWQgZGV2aWNlLCBtb3VzZWVudGVyL2xlYXZlIGFyZSBmaXJlZCBhc1xuICAgICAgICAvLyBwYXJ0IG9mIHRoZSBtb3VzZSBjb21wYXRpYmlsaXR5IGV2ZW50cyBvbiBmaXJzdCB0YXAgLSB0aGUgY2Fyb3VzZWxcbiAgICAgICAgLy8gd291bGQgc3RvcCBjeWNsaW5nIHVudGlsIHVzZXIgdGFwcGVkIG91dCBvZiBpdDtcbiAgICAgICAgLy8gaGVyZSwgd2UgbGlzdGVuIGZvciB0b3VjaGVuZCwgZXhwbGljaXRseSBwYXVzZSB0aGUgY2Fyb3VzZWxcbiAgICAgICAgLy8gKGFzIGlmIGl0J3MgdGhlIHNlY29uZCB0aW1lIHdlIHRhcCBvbiBpdCwgbW91c2VlbnRlciBjb21wYXQgZXZlbnRcbiAgICAgICAgLy8gaXMgTk9UIGZpcmVkKSBhbmQgYWZ0ZXIgYSB0aW1lb3V0ICh0byBhbGxvdyBmb3IgbW91c2UgY29tcGF0aWJpbGl0eVxuICAgICAgICAvLyBldmVudHMgdG8gZmlyZSkgd2UgZXhwbGljaXRseSByZXN0YXJ0IGN5Y2xpbmdcbiAgICAgICAgdGhpcy5wYXVzZSgpO1xuXG4gICAgICAgIGlmICh0aGlzLnRvdWNoVGltZW91dCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRvdWNoVGltZW91dCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRvdWNoVGltZW91dCA9IHNldFRpbWVvdXQoZXZlbnQgPT4gdGhpcy5jeWNsZShldmVudCksIFRPVUNIRVZFTlRfQ09NUEFUX1dBSVQgKyB0aGlzLl9jb25maWcuaW50ZXJ2YWwpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0lURU1fSU1HLCB0aGlzLl9lbGVtZW50KS5mb3JFYWNoKGl0ZW1JbWcgPT4ge1xuICAgICAgRXZlbnRIYW5kbGVyLm9uKGl0ZW1JbWcsIEVWRU5UX0RSQUdfU1RBUlQsIGV2ZW50ID0+IGV2ZW50LnByZXZlbnREZWZhdWx0KCkpO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuX3BvaW50ZXJFdmVudCkge1xuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1BPSU5URVJET1dOLCBldmVudCA9PiBzdGFydChldmVudCkpO1xuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1BPSU5URVJVUCwgZXZlbnQgPT4gZW5kKGV2ZW50KSk7XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1BPSU5URVJfRVZFTlQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfVE9VQ0hTVEFSVCwgZXZlbnQgPT4gc3RhcnQoZXZlbnQpKTtcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9UT1VDSE1PVkUsIGV2ZW50ID0+IG1vdmUoZXZlbnQpKTtcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9UT1VDSEVORCwgZXZlbnQgPT4gZW5kKGV2ZW50KSk7XG4gICAgfVxuICB9XG5cbiAgX2tleWRvd24oZXZlbnQpIHtcbiAgICBpZiAoL2lucHV0fHRleHRhcmVhL2kudGVzdChldmVudC50YXJnZXQudGFnTmFtZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBkaXJlY3Rpb24gPSBLRVlfVE9fRElSRUNUSU9OW2V2ZW50LmtleV07XG5cbiAgICBpZiAoZGlyZWN0aW9uKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB0aGlzLl9zbGlkZShkaXJlY3Rpb24pO1xuICAgIH1cbiAgfVxuXG4gIF9nZXRJdGVtSW5kZXgoZWxlbWVudCkge1xuICAgIHRoaXMuX2l0ZW1zID0gZWxlbWVudCAmJiBlbGVtZW50LnBhcmVudE5vZGUgPyBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0lURU0sIGVsZW1lbnQucGFyZW50Tm9kZSkgOiBbXTtcbiAgICByZXR1cm4gdGhpcy5faXRlbXMuaW5kZXhPZihlbGVtZW50KTtcbiAgfVxuXG4gIF9nZXRJdGVtQnlPcmRlcihvcmRlciwgYWN0aXZlRWxlbWVudCkge1xuICAgIGNvbnN0IGlzTmV4dCA9IG9yZGVyID09PSBPUkRFUl9ORVhUO1xuICAgIHJldHVybiBnZXROZXh0QWN0aXZlRWxlbWVudCh0aGlzLl9pdGVtcywgYWN0aXZlRWxlbWVudCwgaXNOZXh0LCB0aGlzLl9jb25maWcud3JhcCk7XG4gIH1cblxuICBfdHJpZ2dlclNsaWRlRXZlbnQocmVsYXRlZFRhcmdldCwgZXZlbnREaXJlY3Rpb25OYW1lKSB7XG4gICAgY29uc3QgdGFyZ2V0SW5kZXggPSB0aGlzLl9nZXRJdGVtSW5kZXgocmVsYXRlZFRhcmdldCk7XG5cbiAgICBjb25zdCBmcm9tSW5kZXggPSB0aGlzLl9nZXRJdGVtSW5kZXgoU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9BQ1RJVkVfSVRFTSwgdGhpcy5fZWxlbWVudCkpO1xuXG4gICAgcmV0dXJuIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NMSURFLCB7XG4gICAgICByZWxhdGVkVGFyZ2V0LFxuICAgICAgZGlyZWN0aW9uOiBldmVudERpcmVjdGlvbk5hbWUsXG4gICAgICBmcm9tOiBmcm9tSW5kZXgsXG4gICAgICB0bzogdGFyZ2V0SW5kZXhcbiAgICB9KTtcbiAgfVxuXG4gIF9zZXRBY3RpdmVJbmRpY2F0b3JFbGVtZW50KGVsZW1lbnQpIHtcbiAgICBpZiAodGhpcy5faW5kaWNhdG9yc0VsZW1lbnQpIHtcbiAgICAgIGNvbnN0IGFjdGl2ZUluZGljYXRvciA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfQUNUSVZFJDEsIHRoaXMuX2luZGljYXRvcnNFbGVtZW50KTtcbiAgICAgIGFjdGl2ZUluZGljYXRvci5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQUNUSVZFJDIpO1xuICAgICAgYWN0aXZlSW5kaWNhdG9yLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1jdXJyZW50Jyk7XG4gICAgICBjb25zdCBpbmRpY2F0b3JzID0gU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9JTkRJQ0FUT1IsIHRoaXMuX2luZGljYXRvcnNFbGVtZW50KTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRpY2F0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChOdW1iZXIucGFyc2VJbnQoaW5kaWNhdG9yc1tpXS5nZXRBdHRyaWJ1dGUoJ2RhdGEtYnMtc2xpZGUtdG8nKSwgMTApID09PSB0aGlzLl9nZXRJdGVtSW5kZXgoZWxlbWVudCkpIHtcbiAgICAgICAgICBpbmRpY2F0b3JzW2ldLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUkMik7XG4gICAgICAgICAgaW5kaWNhdG9yc1tpXS5zZXRBdHRyaWJ1dGUoJ2FyaWEtY3VycmVudCcsICd0cnVlJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfdXBkYXRlSW50ZXJ2YWwoKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2FjdGl2ZUVsZW1lbnQgfHwgU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9BQ1RJVkVfSVRFTSwgdGhpcy5fZWxlbWVudCk7XG5cbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBlbGVtZW50SW50ZXJ2YWwgPSBOdW1iZXIucGFyc2VJbnQoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYnMtaW50ZXJ2YWwnKSwgMTApO1xuXG4gICAgaWYgKGVsZW1lbnRJbnRlcnZhbCkge1xuICAgICAgdGhpcy5fY29uZmlnLmRlZmF1bHRJbnRlcnZhbCA9IHRoaXMuX2NvbmZpZy5kZWZhdWx0SW50ZXJ2YWwgfHwgdGhpcy5fY29uZmlnLmludGVydmFsO1xuICAgICAgdGhpcy5fY29uZmlnLmludGVydmFsID0gZWxlbWVudEludGVydmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9jb25maWcuaW50ZXJ2YWwgPSB0aGlzLl9jb25maWcuZGVmYXVsdEludGVydmFsIHx8IHRoaXMuX2NvbmZpZy5pbnRlcnZhbDtcbiAgICB9XG4gIH1cblxuICBfc2xpZGUoZGlyZWN0aW9uT3JPcmRlciwgZWxlbWVudCkge1xuICAgIGNvbnN0IG9yZGVyID0gdGhpcy5fZGlyZWN0aW9uVG9PcmRlcihkaXJlY3Rpb25Pck9yZGVyKTtcblxuICAgIGNvbnN0IGFjdGl2ZUVsZW1lbnQgPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0FDVElWRV9JVEVNLCB0aGlzLl9lbGVtZW50KTtcblxuICAgIGNvbnN0IGFjdGl2ZUVsZW1lbnRJbmRleCA9IHRoaXMuX2dldEl0ZW1JbmRleChhY3RpdmVFbGVtZW50KTtcblxuICAgIGNvbnN0IG5leHRFbGVtZW50ID0gZWxlbWVudCB8fCB0aGlzLl9nZXRJdGVtQnlPcmRlcihvcmRlciwgYWN0aXZlRWxlbWVudCk7XG5cbiAgICBjb25zdCBuZXh0RWxlbWVudEluZGV4ID0gdGhpcy5fZ2V0SXRlbUluZGV4KG5leHRFbGVtZW50KTtcblxuICAgIGNvbnN0IGlzQ3ljbGluZyA9IEJvb2xlYW4odGhpcy5faW50ZXJ2YWwpO1xuICAgIGNvbnN0IGlzTmV4dCA9IG9yZGVyID09PSBPUkRFUl9ORVhUO1xuICAgIGNvbnN0IGRpcmVjdGlvbmFsQ2xhc3NOYW1lID0gaXNOZXh0ID8gQ0xBU1NfTkFNRV9TVEFSVCA6IENMQVNTX05BTUVfRU5EO1xuICAgIGNvbnN0IG9yZGVyQ2xhc3NOYW1lID0gaXNOZXh0ID8gQ0xBU1NfTkFNRV9ORVhUIDogQ0xBU1NfTkFNRV9QUkVWO1xuXG4gICAgY29uc3QgZXZlbnREaXJlY3Rpb25OYW1lID0gdGhpcy5fb3JkZXJUb0RpcmVjdGlvbihvcmRlcik7XG5cbiAgICBpZiAobmV4dEVsZW1lbnQgJiYgbmV4dEVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfQUNUSVZFJDIpKSB7XG4gICAgICB0aGlzLl9pc1NsaWRpbmcgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faXNTbGlkaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc2xpZGVFdmVudCA9IHRoaXMuX3RyaWdnZXJTbGlkZUV2ZW50KG5leHRFbGVtZW50LCBldmVudERpcmVjdGlvbk5hbWUpO1xuXG4gICAgaWYgKHNsaWRlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghYWN0aXZlRWxlbWVudCB8fCAhbmV4dEVsZW1lbnQpIHtcbiAgICAgIC8vIFNvbWUgd2VpcmRuZXNzIGlzIGhhcHBlbmluZywgc28gd2UgYmFpbFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2lzU2xpZGluZyA9IHRydWU7XG5cbiAgICBpZiAoaXNDeWNsaW5nKSB7XG4gICAgICB0aGlzLnBhdXNlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fc2V0QWN0aXZlSW5kaWNhdG9yRWxlbWVudChuZXh0RWxlbWVudCk7XG5cbiAgICB0aGlzLl9hY3RpdmVFbGVtZW50ID0gbmV4dEVsZW1lbnQ7XG5cbiAgICBjb25zdCB0cmlnZ2VyU2xpZEV2ZW50ID0gKCkgPT4ge1xuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0xJRCwge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiBuZXh0RWxlbWVudCxcbiAgICAgICAgZGlyZWN0aW9uOiBldmVudERpcmVjdGlvbk5hbWUsXG4gICAgICAgIGZyb206IGFjdGl2ZUVsZW1lbnRJbmRleCxcbiAgICAgICAgdG86IG5leHRFbGVtZW50SW5kZXhcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBpZiAodGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TTElERSkpIHtcbiAgICAgIG5leHRFbGVtZW50LmNsYXNzTGlzdC5hZGQob3JkZXJDbGFzc05hbWUpO1xuICAgICAgcmVmbG93KG5leHRFbGVtZW50KTtcbiAgICAgIGFjdGl2ZUVsZW1lbnQuY2xhc3NMaXN0LmFkZChkaXJlY3Rpb25hbENsYXNzTmFtZSk7XG4gICAgICBuZXh0RWxlbWVudC5jbGFzc0xpc3QuYWRkKGRpcmVjdGlvbmFsQ2xhc3NOYW1lKTtcblxuICAgICAgY29uc3QgY29tcGxldGVDYWxsQmFjayA9ICgpID0+IHtcbiAgICAgICAgbmV4dEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShkaXJlY3Rpb25hbENsYXNzTmFtZSwgb3JkZXJDbGFzc05hbWUpO1xuICAgICAgICBuZXh0RWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQUNUSVZFJDIpO1xuICAgICAgICBhY3RpdmVFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9BQ1RJVkUkMiwgb3JkZXJDbGFzc05hbWUsIGRpcmVjdGlvbmFsQ2xhc3NOYW1lKTtcbiAgICAgICAgdGhpcy5faXNTbGlkaW5nID0gZmFsc2U7XG4gICAgICAgIHNldFRpbWVvdXQodHJpZ2dlclNsaWRFdmVudCwgMCk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGNvbXBsZXRlQ2FsbEJhY2ssIGFjdGl2ZUVsZW1lbnQsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhY3RpdmVFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9BQ1RJVkUkMik7XG4gICAgICBuZXh0RWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQUNUSVZFJDIpO1xuICAgICAgdGhpcy5faXNTbGlkaW5nID0gZmFsc2U7XG4gICAgICB0cmlnZ2VyU2xpZEV2ZW50KCk7XG4gICAgfVxuXG4gICAgaWYgKGlzQ3ljbGluZykge1xuICAgICAgdGhpcy5jeWNsZSgpO1xuICAgIH1cbiAgfVxuXG4gIF9kaXJlY3Rpb25Ub09yZGVyKGRpcmVjdGlvbikge1xuICAgIGlmICghW0RJUkVDVElPTl9SSUdIVCwgRElSRUNUSU9OX0xFRlRdLmluY2x1ZGVzKGRpcmVjdGlvbikpIHtcbiAgICAgIHJldHVybiBkaXJlY3Rpb247XG4gICAgfVxuXG4gICAgaWYgKGlzUlRMKCkpIHtcbiAgICAgIHJldHVybiBkaXJlY3Rpb24gPT09IERJUkVDVElPTl9MRUZUID8gT1JERVJfUFJFViA6IE9SREVSX05FWFQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OX0xFRlQgPyBPUkRFUl9ORVhUIDogT1JERVJfUFJFVjtcbiAgfVxuXG4gIF9vcmRlclRvRGlyZWN0aW9uKG9yZGVyKSB7XG4gICAgaWYgKCFbT1JERVJfTkVYVCwgT1JERVJfUFJFVl0uaW5jbHVkZXMob3JkZXIpKSB7XG4gICAgICByZXR1cm4gb3JkZXI7XG4gICAgfVxuXG4gICAgaWYgKGlzUlRMKCkpIHtcbiAgICAgIHJldHVybiBvcmRlciA9PT0gT1JERVJfUFJFViA/IERJUkVDVElPTl9MRUZUIDogRElSRUNUSU9OX1JJR0hUO1xuICAgIH1cblxuICAgIHJldHVybiBvcmRlciA9PT0gT1JERVJfUFJFViA/IERJUkVDVElPTl9SSUdIVCA6IERJUkVDVElPTl9MRUZUO1xuICB9IC8vIFN0YXRpY1xuXG5cbiAgc3RhdGljIGNhcm91c2VsSW50ZXJmYWNlKGVsZW1lbnQsIGNvbmZpZykge1xuICAgIGNvbnN0IGRhdGEgPSBDYXJvdXNlbC5nZXRPckNyZWF0ZUluc3RhbmNlKGVsZW1lbnQsIGNvbmZpZyk7XG4gICAgbGV0IHtcbiAgICAgIF9jb25maWdcbiAgICB9ID0gZGF0YTtcblxuICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0Jykge1xuICAgICAgX2NvbmZpZyA9IHsgLi4uX2NvbmZpZyxcbiAgICAgICAgLi4uY29uZmlnXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IGFjdGlvbiA9IHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnID8gY29uZmlnIDogX2NvbmZpZy5zbGlkZTtcblxuICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnbnVtYmVyJykge1xuICAgICAgZGF0YS50byhjb25maWcpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFjdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICh0eXBlb2YgZGF0YVthY3Rpb25dID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2FjdGlvbn1cImApO1xuICAgICAgfVxuXG4gICAgICBkYXRhW2FjdGlvbl0oKTtcbiAgICB9IGVsc2UgaWYgKF9jb25maWcuaW50ZXJ2YWwgJiYgX2NvbmZpZy5yaWRlKSB7XG4gICAgICBkYXRhLnBhdXNlKCk7XG4gICAgICBkYXRhLmN5Y2xlKCk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIENhcm91c2VsLmNhcm91c2VsSW50ZXJmYWNlKHRoaXMsIGNvbmZpZyk7XG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgZGF0YUFwaUNsaWNrSGFuZGxlcihldmVudCkge1xuICAgIGNvbnN0IHRhcmdldCA9IGdldEVsZW1lbnRGcm9tU2VsZWN0b3IodGhpcyk7XG5cbiAgICBpZiAoIXRhcmdldCB8fCAhdGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0NBUk9VU0VMKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbmZpZyA9IHsgLi4uTWFuaXB1bGF0b3IuZ2V0RGF0YUF0dHJpYnV0ZXModGFyZ2V0KSxcbiAgICAgIC4uLk1hbmlwdWxhdG9yLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMpXG4gICAgfTtcbiAgICBjb25zdCBzbGlkZUluZGV4ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2RhdGEtYnMtc2xpZGUtdG8nKTtcblxuICAgIGlmIChzbGlkZUluZGV4KSB7XG4gICAgICBjb25maWcuaW50ZXJ2YWwgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBDYXJvdXNlbC5jYXJvdXNlbEludGVyZmFjZSh0YXJnZXQsIGNvbmZpZyk7XG5cbiAgICBpZiAoc2xpZGVJbmRleCkge1xuICAgICAgQ2Fyb3VzZWwuZ2V0SW5zdGFuY2UodGFyZ2V0KS50byhzbGlkZUluZGV4KTtcbiAgICB9XG5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG5cbn1cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBEYXRhIEFwaSBpbXBsZW1lbnRhdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuXG5FdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJJDUsIFNFTEVDVE9SX0RBVEFfU0xJREUsIENhcm91c2VsLmRhdGFBcGlDbGlja0hhbmRsZXIpO1xuRXZlbnRIYW5kbGVyLm9uKHdpbmRvdywgRVZFTlRfTE9BRF9EQVRBX0FQSSQyLCAoKSA9PiB7XG4gIGNvbnN0IGNhcm91c2VscyA9IFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfREFUQV9SSURFKTtcblxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gY2Fyb3VzZWxzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgQ2Fyb3VzZWwuY2Fyb3VzZWxJbnRlcmZhY2UoY2Fyb3VzZWxzW2ldLCBDYXJvdXNlbC5nZXRJbnN0YW5jZShjYXJvdXNlbHNbaV0pKTtcbiAgfVxufSk7XG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogalF1ZXJ5XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIGFkZCAuQ2Fyb3VzZWwgdG8galF1ZXJ5IG9ubHkgaWYgalF1ZXJ5IGlzIHByZXNlbnRcbiAqL1xuXG5kZWZpbmVKUXVlcnlQbHVnaW4oQ2Fyb3VzZWwpO1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY1LjEuMyk6IGNvbGxhcHNlLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb25zdGFudHNcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNvbnN0IE5BTUUkYSA9ICdjb2xsYXBzZSc7XG5jb25zdCBEQVRBX0tFWSQ5ID0gJ2JzLmNvbGxhcHNlJztcbmNvbnN0IEVWRU5UX0tFWSQ5ID0gYC4ke0RBVEFfS0VZJDl9YDtcbmNvbnN0IERBVEFfQVBJX0tFWSQ1ID0gJy5kYXRhLWFwaSc7XG5jb25zdCBEZWZhdWx0JDkgPSB7XG4gIHRvZ2dsZTogdHJ1ZSxcbiAgcGFyZW50OiBudWxsXG59O1xuY29uc3QgRGVmYXVsdFR5cGUkOSA9IHtcbiAgdG9nZ2xlOiAnYm9vbGVhbicsXG4gIHBhcmVudDogJyhudWxsfGVsZW1lbnQpJ1xufTtcbmNvbnN0IEVWRU5UX1NIT1ckNSA9IGBzaG93JHtFVkVOVF9LRVkkOX1gO1xuY29uc3QgRVZFTlRfU0hPV04kNSA9IGBzaG93biR7RVZFTlRfS0VZJDl9YDtcbmNvbnN0IEVWRU5UX0hJREUkNSA9IGBoaWRlJHtFVkVOVF9LRVkkOX1gO1xuY29uc3QgRVZFTlRfSElEREVOJDUgPSBgaGlkZGVuJHtFVkVOVF9LRVkkOX1gO1xuY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNCA9IGBjbGljayR7RVZFTlRfS0VZJDl9JHtEQVRBX0FQSV9LRVkkNX1gO1xuY29uc3QgQ0xBU1NfTkFNRV9TSE9XJDcgPSAnc2hvdyc7XG5jb25zdCBDTEFTU19OQU1FX0NPTExBUFNFID0gJ2NvbGxhcHNlJztcbmNvbnN0IENMQVNTX05BTUVfQ09MTEFQU0lORyA9ICdjb2xsYXBzaW5nJztcbmNvbnN0IENMQVNTX05BTUVfQ09MTEFQU0VEID0gJ2NvbGxhcHNlZCc7XG5jb25zdCBDTEFTU19OQU1FX0RFRVBFUl9DSElMRFJFTiA9IGA6c2NvcGUgLiR7Q0xBU1NfTkFNRV9DT0xMQVBTRX0gLiR7Q0xBU1NfTkFNRV9DT0xMQVBTRX1gO1xuY29uc3QgQ0xBU1NfTkFNRV9IT1JJWk9OVEFMID0gJ2NvbGxhcHNlLWhvcml6b250YWwnO1xuY29uc3QgV0lEVEggPSAnd2lkdGgnO1xuY29uc3QgSEVJR0hUID0gJ2hlaWdodCc7XG5jb25zdCBTRUxFQ1RPUl9BQ1RJVkVTID0gJy5jb2xsYXBzZS5zaG93LCAuY29sbGFwc2UuY29sbGFwc2luZyc7XG5jb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ0ID0gJ1tkYXRhLWJzLXRvZ2dsZT1cImNvbGxhcHNlXCJdJztcbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDbGFzcyBEZWZpbml0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jbGFzcyBDb2xsYXBzZSBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICBzdXBlcihlbGVtZW50KTtcbiAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKTtcbiAgICB0aGlzLl90cmlnZ2VyQXJyYXkgPSBbXTtcbiAgICBjb25zdCB0b2dnbGVMaXN0ID0gU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ0KTtcblxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0b2dnbGVMaXN0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBlbGVtID0gdG9nZ2xlTGlzdFtpXTtcbiAgICAgIGNvbnN0IHNlbGVjdG9yID0gZ2V0U2VsZWN0b3JGcm9tRWxlbWVudChlbGVtKTtcbiAgICAgIGNvbnN0IGZpbHRlckVsZW1lbnQgPSBTZWxlY3RvckVuZ2luZS5maW5kKHNlbGVjdG9yKS5maWx0ZXIoZm91bmRFbGVtID0+IGZvdW5kRWxlbSA9PT0gdGhpcy5fZWxlbWVudCk7XG5cbiAgICAgIGlmIChzZWxlY3RvciAhPT0gbnVsbCAmJiBmaWx0ZXJFbGVtZW50Lmxlbmd0aCkge1xuICAgICAgICB0aGlzLl9zZWxlY3RvciA9IHNlbGVjdG9yO1xuXG4gICAgICAgIHRoaXMuX3RyaWdnZXJBcnJheS5wdXNoKGVsZW0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX2luaXRpYWxpemVDaGlsZHJlbigpO1xuXG4gICAgaWYgKCF0aGlzLl9jb25maWcucGFyZW50KSB7XG4gICAgICB0aGlzLl9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3ModGhpcy5fdHJpZ2dlckFycmF5LCB0aGlzLl9pc1Nob3duKCkpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9jb25maWcudG9nZ2xlKSB7XG4gICAgICB0aGlzLnRvZ2dsZSgpO1xuICAgIH1cbiAgfSAvLyBHZXR0ZXJzXG5cblxuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIERlZmF1bHQkOTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gTkFNRSRhO1xuICB9IC8vIFB1YmxpY1xuXG5cbiAgdG9nZ2xlKCkge1xuICAgIGlmICh0aGlzLl9pc1Nob3duKCkpIHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNob3coKTtcbiAgICB9XG4gIH1cblxuICBzaG93KCkge1xuICAgIGlmICh0aGlzLl9pc1RyYW5zaXRpb25pbmcgfHwgdGhpcy5faXNTaG93bigpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGFjdGl2ZXMgPSBbXTtcbiAgICBsZXQgYWN0aXZlc0RhdGE7XG5cbiAgICBpZiAodGhpcy5fY29uZmlnLnBhcmVudCkge1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBTZWxlY3RvckVuZ2luZS5maW5kKENMQVNTX05BTUVfREVFUEVSX0NISUxEUkVOLCB0aGlzLl9jb25maWcucGFyZW50KTtcbiAgICAgIGFjdGl2ZXMgPSBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0FDVElWRVMsIHRoaXMuX2NvbmZpZy5wYXJlbnQpLmZpbHRlcihlbGVtID0+ICFjaGlsZHJlbi5pbmNsdWRlcyhlbGVtKSk7IC8vIHJlbW92ZSBjaGlsZHJlbiBpZiBncmVhdGVyIGRlcHRoXG4gICAgfVxuXG4gICAgY29uc3QgY29udGFpbmVyID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZSh0aGlzLl9zZWxlY3Rvcik7XG5cbiAgICBpZiAoYWN0aXZlcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHRlbXBBY3RpdmVEYXRhID0gYWN0aXZlcy5maW5kKGVsZW0gPT4gY29udGFpbmVyICE9PSBlbGVtKTtcbiAgICAgIGFjdGl2ZXNEYXRhID0gdGVtcEFjdGl2ZURhdGEgPyBDb2xsYXBzZS5nZXRJbnN0YW5jZSh0ZW1wQWN0aXZlRGF0YSkgOiBudWxsO1xuXG4gICAgICBpZiAoYWN0aXZlc0RhdGEgJiYgYWN0aXZlc0RhdGEuX2lzVHJhbnNpdGlvbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhcnRFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1ckNSk7XG5cbiAgICBpZiAoc3RhcnRFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYWN0aXZlcy5mb3JFYWNoKGVsZW1BY3RpdmUgPT4ge1xuICAgICAgaWYgKGNvbnRhaW5lciAhPT0gZWxlbUFjdGl2ZSkge1xuICAgICAgICBDb2xsYXBzZS5nZXRPckNyZWF0ZUluc3RhbmNlKGVsZW1BY3RpdmUsIHtcbiAgICAgICAgICB0b2dnbGU6IGZhbHNlXG4gICAgICAgIH0pLmhpZGUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFhY3RpdmVzRGF0YSkge1xuICAgICAgICBEYXRhLnNldChlbGVtQWN0aXZlLCBEQVRBX0tFWSQ5LCBudWxsKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IGRpbWVuc2lvbiA9IHRoaXMuX2dldERpbWVuc2lvbigpO1xuXG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQ09MTEFQU0UpO1xuXG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQ09MTEFQU0lORyk7XG5cbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSAwO1xuXG4gICAgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKHRoaXMuX3RyaWdnZXJBcnJheSwgdHJ1ZSk7XG5cbiAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSB0cnVlO1xuXG4gICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcblxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQ09MTEFQU0lORyk7XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0NPTExBUFNFLCBDTEFTU19OQU1FX1NIT1ckNyk7XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbZGltZW5zaW9uXSA9ICcnO1xuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPV04kNSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGNhcGl0YWxpemVkRGltZW5zaW9uID0gZGltZW5zaW9uWzBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoMSk7XG4gICAgY29uc3Qgc2Nyb2xsU2l6ZSA9IGBzY3JvbGwke2NhcGl0YWxpemVkRGltZW5zaW9ufWA7XG5cbiAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGNvbXBsZXRlLCB0aGlzLl9lbGVtZW50LCB0cnVlKTtcblxuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbZGltZW5zaW9uXSA9IGAke3RoaXMuX2VsZW1lbnRbc2Nyb2xsU2l6ZV19cHhgO1xuICB9XG5cbiAgaGlkZSgpIHtcbiAgICBpZiAodGhpcy5faXNUcmFuc2l0aW9uaW5nIHx8ICF0aGlzLl9pc1Nob3duKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzdGFydEV2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElERSQ1KTtcblxuICAgIGlmIChzdGFydEV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBkaW1lbnNpb24gPSB0aGlzLl9nZXREaW1lbnNpb24oKTtcblxuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbZGltZW5zaW9uXSA9IGAke3RoaXMuX2VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbZGltZW5zaW9uXX1weGA7XG4gICAgcmVmbG93KHRoaXMuX2VsZW1lbnQpO1xuXG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQ09MTEFQU0lORyk7XG5cbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9DT0xMQVBTRSwgQ0xBU1NfTkFNRV9TSE9XJDcpO1xuXG4gICAgY29uc3QgdHJpZ2dlckFycmF5TGVuZ3RoID0gdGhpcy5fdHJpZ2dlckFycmF5Lmxlbmd0aDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJpZ2dlckFycmF5TGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHRyaWdnZXIgPSB0aGlzLl90cmlnZ2VyQXJyYXlbaV07XG4gICAgICBjb25zdCBlbGVtID0gZ2V0RWxlbWVudEZyb21TZWxlY3Rvcih0cmlnZ2VyKTtcblxuICAgICAgaWYgKGVsZW0gJiYgIXRoaXMuX2lzU2hvd24oZWxlbSkpIHtcbiAgICAgICAgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKFt0cmlnZ2VyXSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IHRydWU7XG5cbiAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xuXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9DT0xMQVBTSU5HKTtcblxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQ09MTEFQU0UpO1xuXG4gICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURERU4kNSk7XG4gICAgfTtcblxuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbZGltZW5zaW9uXSA9ICcnO1xuXG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZSwgdGhpcy5fZWxlbWVudCwgdHJ1ZSk7XG4gIH1cblxuICBfaXNTaG93bihlbGVtZW50ID0gdGhpcy5fZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NIT1ckNyk7XG4gIH0gLy8gUHJpdmF0ZVxuXG5cbiAgX2dldENvbmZpZyhjb25maWcpIHtcbiAgICBjb25maWcgPSB7IC4uLkRlZmF1bHQkOSxcbiAgICAgIC4uLk1hbmlwdWxhdG9yLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4uY29uZmlnXG4gICAgfTtcbiAgICBjb25maWcudG9nZ2xlID0gQm9vbGVhbihjb25maWcudG9nZ2xlKTsgLy8gQ29lcmNlIHN0cmluZyB2YWx1ZXNcblxuICAgIGNvbmZpZy5wYXJlbnQgPSBnZXRFbGVtZW50KGNvbmZpZy5wYXJlbnQpO1xuICAgIHR5cGVDaGVja0NvbmZpZyhOQU1FJGEsIGNvbmZpZywgRGVmYXVsdFR5cGUkOSk7XG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfVxuXG4gIF9nZXREaW1lbnNpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfSE9SSVpPTlRBTCkgPyBXSURUSCA6IEhFSUdIVDtcbiAgfVxuXG4gIF9pbml0aWFsaXplQ2hpbGRyZW4oKSB7XG4gICAgaWYgKCF0aGlzLl9jb25maWcucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY2hpbGRyZW4gPSBTZWxlY3RvckVuZ2luZS5maW5kKENMQVNTX05BTUVfREVFUEVSX0NISUxEUkVOLCB0aGlzLl9jb25maWcucGFyZW50KTtcbiAgICBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0RBVEFfVE9HR0xFJDQsIHRoaXMuX2NvbmZpZy5wYXJlbnQpLmZpbHRlcihlbGVtID0+ICFjaGlsZHJlbi5pbmNsdWRlcyhlbGVtKSkuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGVkID0gZ2V0RWxlbWVudEZyb21TZWxlY3RvcihlbGVtZW50KTtcblxuICAgICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgIHRoaXMuX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyhbZWxlbWVudF0sIHRoaXMuX2lzU2hvd24oc2VsZWN0ZWQpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIF9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3ModHJpZ2dlckFycmF5LCBpc09wZW4pIHtcbiAgICBpZiAoIXRyaWdnZXJBcnJheS5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cmlnZ2VyQXJyYXkuZm9yRWFjaChlbGVtID0+IHtcbiAgICAgIGlmIChpc09wZW4pIHtcbiAgICAgICAgZWxlbS5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQ09MTEFQU0VEKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW0uY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0NPTExBUFNFRCk7XG4gICAgICB9XG5cbiAgICAgIGVsZW0uc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgaXNPcGVuKTtcbiAgICB9KTtcbiAgfSAvLyBTdGF0aWNcblxuXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCBfY29uZmlnID0ge307XG5cbiAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJyAmJiAvc2hvd3xoaWRlLy50ZXN0KGNvbmZpZykpIHtcbiAgICAgICAgX2NvbmZpZy50b2dnbGUgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IENvbGxhcHNlLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgX2NvbmZpZyk7XG5cbiAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YVtjb25maWddKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxufVxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIERhdGEgQXBpIGltcGxlbWVudGF0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5cbkV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNCwgU0VMRUNUT1JfREFUQV9UT0dHTEUkNCwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gIC8vIHByZXZlbnREZWZhdWx0IG9ubHkgZm9yIDxhPiBlbGVtZW50cyAod2hpY2ggY2hhbmdlIHRoZSBVUkwpIG5vdCBpbnNpZGUgdGhlIGNvbGxhcHNpYmxlIGVsZW1lbnRcbiAgaWYgKGV2ZW50LnRhcmdldC50YWdOYW1lID09PSAnQScgfHwgZXZlbnQuZGVsZWdhdGVUYXJnZXQgJiYgZXZlbnQuZGVsZWdhdGVUYXJnZXQudGFnTmFtZSA9PT0gJ0EnKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuXG4gIGNvbnN0IHNlbGVjdG9yID0gZ2V0U2VsZWN0b3JGcm9tRWxlbWVudCh0aGlzKTtcbiAgY29uc3Qgc2VsZWN0b3JFbGVtZW50cyA9IFNlbGVjdG9yRW5naW5lLmZpbmQoc2VsZWN0b3IpO1xuICBzZWxlY3RvckVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgQ29sbGFwc2UuZ2V0T3JDcmVhdGVJbnN0YW5jZShlbGVtZW50LCB7XG4gICAgICB0b2dnbGU6IGZhbHNlXG4gICAgfSkudG9nZ2xlKCk7XG4gIH0pO1xufSk7XG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogalF1ZXJ5XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIGFkZCAuQ29sbGFwc2UgdG8galF1ZXJ5IG9ubHkgaWYgalF1ZXJ5IGlzIHByZXNlbnRcbiAqL1xuXG5kZWZpbmVKUXVlcnlQbHVnaW4oQ29sbGFwc2UpO1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY1LjEuMyk6IGRyb3Bkb3duLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb25zdGFudHNcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNvbnN0IE5BTUUkOSA9ICdkcm9wZG93bic7XG5jb25zdCBEQVRBX0tFWSQ4ID0gJ2JzLmRyb3Bkb3duJztcbmNvbnN0IEVWRU5UX0tFWSQ4ID0gYC4ke0RBVEFfS0VZJDh9YDtcbmNvbnN0IERBVEFfQVBJX0tFWSQ0ID0gJy5kYXRhLWFwaSc7XG5jb25zdCBFU0NBUEVfS0VZJDIgPSAnRXNjYXBlJztcbmNvbnN0IFNQQUNFX0tFWSA9ICdTcGFjZSc7XG5jb25zdCBUQUJfS0VZJDEgPSAnVGFiJztcbmNvbnN0IEFSUk9XX1VQX0tFWSA9ICdBcnJvd1VwJztcbmNvbnN0IEFSUk9XX0RPV05fS0VZID0gJ0Fycm93RG93bic7XG5jb25zdCBSSUdIVF9NT1VTRV9CVVRUT04gPSAyOyAvLyBNb3VzZUV2ZW50LmJ1dHRvbiB2YWx1ZSBmb3IgdGhlIHNlY29uZGFyeSBidXR0b24sIHVzdWFsbHkgdGhlIHJpZ2h0IGJ1dHRvblxuXG5jb25zdCBSRUdFWFBfS0VZRE9XTiA9IG5ldyBSZWdFeHAoYCR7QVJST1dfVVBfS0VZfXwke0FSUk9XX0RPV05fS0VZfXwke0VTQ0FQRV9LRVkkMn1gKTtcbmNvbnN0IEVWRU5UX0hJREUkNCA9IGBoaWRlJHtFVkVOVF9LRVkkOH1gO1xuY29uc3QgRVZFTlRfSElEREVOJDQgPSBgaGlkZGVuJHtFVkVOVF9LRVkkOH1gO1xuY29uc3QgRVZFTlRfU0hPVyQ0ID0gYHNob3cke0VWRU5UX0tFWSQ4fWA7XG5jb25zdCBFVkVOVF9TSE9XTiQ0ID0gYHNob3duJHtFVkVOVF9LRVkkOH1gO1xuY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkMyA9IGBjbGljayR7RVZFTlRfS0VZJDh9JHtEQVRBX0FQSV9LRVkkNH1gO1xuY29uc3QgRVZFTlRfS0VZRE9XTl9EQVRBX0FQSSA9IGBrZXlkb3duJHtFVkVOVF9LRVkkOH0ke0RBVEFfQVBJX0tFWSQ0fWA7XG5jb25zdCBFVkVOVF9LRVlVUF9EQVRBX0FQSSA9IGBrZXl1cCR7RVZFTlRfS0VZJDh9JHtEQVRBX0FQSV9LRVkkNH1gO1xuY29uc3QgQ0xBU1NfTkFNRV9TSE9XJDYgPSAnc2hvdyc7XG5jb25zdCBDTEFTU19OQU1FX0RST1BVUCA9ICdkcm9wdXAnO1xuY29uc3QgQ0xBU1NfTkFNRV9EUk9QRU5EID0gJ2Ryb3BlbmQnO1xuY29uc3QgQ0xBU1NfTkFNRV9EUk9QU1RBUlQgPSAnZHJvcHN0YXJ0JztcbmNvbnN0IENMQVNTX05BTUVfTkFWQkFSID0gJ25hdmJhcic7XG5jb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQzID0gJ1tkYXRhLWJzLXRvZ2dsZT1cImRyb3Bkb3duXCJdJztcbmNvbnN0IFNFTEVDVE9SX01FTlUgPSAnLmRyb3Bkb3duLW1lbnUnO1xuY29uc3QgU0VMRUNUT1JfTkFWQkFSX05BViA9ICcubmF2YmFyLW5hdic7XG5jb25zdCBTRUxFQ1RPUl9WSVNJQkxFX0lURU1TID0gJy5kcm9wZG93bi1tZW51IC5kcm9wZG93bi1pdGVtOm5vdCguZGlzYWJsZWQpOm5vdCg6ZGlzYWJsZWQpJztcbmNvbnN0IFBMQUNFTUVOVF9UT1AgPSBpc1JUTCgpID8gJ3RvcC1lbmQnIDogJ3RvcC1zdGFydCc7XG5jb25zdCBQTEFDRU1FTlRfVE9QRU5EID0gaXNSVEwoKSA/ICd0b3Atc3RhcnQnIDogJ3RvcC1lbmQnO1xuY29uc3QgUExBQ0VNRU5UX0JPVFRPTSA9IGlzUlRMKCkgPyAnYm90dG9tLWVuZCcgOiAnYm90dG9tLXN0YXJ0JztcbmNvbnN0IFBMQUNFTUVOVF9CT1RUT01FTkQgPSBpc1JUTCgpID8gJ2JvdHRvbS1zdGFydCcgOiAnYm90dG9tLWVuZCc7XG5jb25zdCBQTEFDRU1FTlRfUklHSFQgPSBpc1JUTCgpID8gJ2xlZnQtc3RhcnQnIDogJ3JpZ2h0LXN0YXJ0JztcbmNvbnN0IFBMQUNFTUVOVF9MRUZUID0gaXNSVEwoKSA/ICdyaWdodC1zdGFydCcgOiAnbGVmdC1zdGFydCc7XG5jb25zdCBEZWZhdWx0JDggPSB7XG4gIG9mZnNldDogWzAsIDJdLFxuICBib3VuZGFyeTogJ2NsaXBwaW5nUGFyZW50cycsXG4gIHJlZmVyZW5jZTogJ3RvZ2dsZScsXG4gIGRpc3BsYXk6ICdkeW5hbWljJyxcbiAgcG9wcGVyQ29uZmlnOiBudWxsLFxuICBhdXRvQ2xvc2U6IHRydWVcbn07XG5jb25zdCBEZWZhdWx0VHlwZSQ4ID0ge1xuICBvZmZzZXQ6ICcoYXJyYXl8c3RyaW5nfGZ1bmN0aW9uKScsXG4gIGJvdW5kYXJ5OiAnKHN0cmluZ3xlbGVtZW50KScsXG4gIHJlZmVyZW5jZTogJyhzdHJpbmd8ZWxlbWVudHxvYmplY3QpJyxcbiAgZGlzcGxheTogJ3N0cmluZycsXG4gIHBvcHBlckNvbmZpZzogJyhudWxsfG9iamVjdHxmdW5jdGlvbiknLFxuICBhdXRvQ2xvc2U6ICcoYm9vbGVhbnxzdHJpbmcpJ1xufTtcbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDbGFzcyBEZWZpbml0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jbGFzcyBEcm9wZG93biBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICBzdXBlcihlbGVtZW50KTtcbiAgICB0aGlzLl9wb3BwZXIgPSBudWxsO1xuICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpO1xuICAgIHRoaXMuX21lbnUgPSB0aGlzLl9nZXRNZW51RWxlbWVudCgpO1xuICAgIHRoaXMuX2luTmF2YmFyID0gdGhpcy5fZGV0ZWN0TmF2YmFyKCk7XG4gIH0gLy8gR2V0dGVyc1xuXG5cbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBEZWZhdWx0JDg7XG4gIH1cblxuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiBEZWZhdWx0VHlwZSQ4O1xuICB9XG5cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBOQU1FJDk7XG4gIH0gLy8gUHVibGljXG5cblxuICB0b2dnbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzU2hvd24oKSA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KCk7XG4gIH1cblxuICBzaG93KCkge1xuICAgIGlmIChpc0Rpc2FibGVkKHRoaXMuX2VsZW1lbnQpIHx8IHRoaXMuX2lzU2hvd24odGhpcy5fbWVudSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCByZWxhdGVkVGFyZ2V0ID0ge1xuICAgICAgcmVsYXRlZFRhcmdldDogdGhpcy5fZWxlbWVudFxuICAgIH07XG4gICAgY29uc3Qgc2hvd0V2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPVyQ0LCByZWxhdGVkVGFyZ2V0KTtcblxuICAgIGlmIChzaG93RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHBhcmVudCA9IERyb3Bkb3duLmdldFBhcmVudEZyb21FbGVtZW50KHRoaXMuX2VsZW1lbnQpOyAvLyBUb3RhbGx5IGRpc2FibGUgUG9wcGVyIGZvciBEcm9wZG93bnMgaW4gTmF2YmFyXG5cbiAgICBpZiAodGhpcy5faW5OYXZiYXIpIHtcbiAgICAgIE1hbmlwdWxhdG9yLnNldERhdGFBdHRyaWJ1dGUodGhpcy5fbWVudSwgJ3BvcHBlcicsICdub25lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHBlcihwYXJlbnQpO1xuICAgIH0gLy8gSWYgdGhpcyBpcyBhIHRvdWNoLWVuYWJsZWQgZGV2aWNlIHdlIGFkZCBleHRyYVxuICAgIC8vIGVtcHR5IG1vdXNlb3ZlciBsaXN0ZW5lcnMgdG8gdGhlIGJvZHkncyBpbW1lZGlhdGUgY2hpbGRyZW47XG4gICAgLy8gb25seSBuZWVkZWQgYmVjYXVzZSBvZiBicm9rZW4gZXZlbnQgZGVsZWdhdGlvbiBvbiBpT1NcbiAgICAvLyBodHRwczovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTQvMDIvbW91c2VfZXZlbnRfYnViLmh0bWxcblxuXG4gICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiAhcGFyZW50LmNsb3Nlc3QoU0VMRUNUT1JfTkFWQkFSX05BVikpIHtcbiAgICAgIFtdLmNvbmNhdCguLi5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKS5mb3JFYWNoKGVsZW0gPT4gRXZlbnRIYW5kbGVyLm9uKGVsZW0sICdtb3VzZW92ZXInLCBub29wKSk7XG4gICAgfVxuXG4gICAgdGhpcy5fZWxlbWVudC5mb2N1cygpO1xuXG4gICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCB0cnVlKTtcblxuICAgIHRoaXMuX21lbnUuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1ckNik7XG5cbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XJDYpO1xuXG4gICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPV04kNCwgcmVsYXRlZFRhcmdldCk7XG4gIH1cblxuICBoaWRlKCkge1xuICAgIGlmIChpc0Rpc2FibGVkKHRoaXMuX2VsZW1lbnQpIHx8ICF0aGlzLl9pc1Nob3duKHRoaXMuX21lbnUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcmVsYXRlZFRhcmdldCA9IHtcbiAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRoaXMuX2VsZW1lbnRcbiAgICB9O1xuXG4gICAgdGhpcy5fY29tcGxldGVIaWRlKHJlbGF0ZWRUYXJnZXQpO1xuICB9XG5cbiAgZGlzcG9zZSgpIHtcbiAgICBpZiAodGhpcy5fcG9wcGVyKSB7XG4gICAgICB0aGlzLl9wb3BwZXIuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgfVxuXG4gIHVwZGF0ZSgpIHtcbiAgICB0aGlzLl9pbk5hdmJhciA9IHRoaXMuX2RldGVjdE5hdmJhcigpO1xuXG4gICAgaWYgKHRoaXMuX3BvcHBlcikge1xuICAgICAgdGhpcy5fcG9wcGVyLnVwZGF0ZSgpO1xuICAgIH1cbiAgfSAvLyBQcml2YXRlXG5cblxuICBfY29tcGxldGVIaWRlKHJlbGF0ZWRUYXJnZXQpIHtcbiAgICBjb25zdCBoaWRlRXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURFJDQsIHJlbGF0ZWRUYXJnZXQpO1xuXG4gICAgaWYgKGhpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBJZiB0aGlzIGlzIGEgdG91Y2gtZW5hYmxlZCBkZXZpY2Ugd2UgcmVtb3ZlIHRoZSBleHRyYVxuICAgIC8vIGVtcHR5IG1vdXNlb3ZlciBsaXN0ZW5lcnMgd2UgYWRkZWQgZm9yIGlPUyBzdXBwb3J0XG5cblxuICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIFtdLmNvbmNhdCguLi5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKS5mb3JFYWNoKGVsZW0gPT4gRXZlbnRIYW5kbGVyLm9mZihlbGVtLCAnbW91c2VvdmVyJywgbm9vcCkpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9wb3BwZXIpIHtcbiAgICAgIHRoaXMuX3BvcHBlci5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgdGhpcy5fbWVudS5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyQ2KTtcblxuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1ckNik7XG5cbiAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICdmYWxzZScpO1xuXG4gICAgTWFuaXB1bGF0b3IucmVtb3ZlRGF0YUF0dHJpYnV0ZSh0aGlzLl9tZW51LCAncG9wcGVyJyk7XG4gICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElEREVOJDQsIHJlbGF0ZWRUYXJnZXQpO1xuICB9XG5cbiAgX2dldENvbmZpZyhjb25maWcpIHtcbiAgICBjb25maWcgPSB7IC4uLnRoaXMuY29uc3RydWN0b3IuRGVmYXVsdCxcbiAgICAgIC4uLk1hbmlwdWxhdG9yLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4uY29uZmlnXG4gICAgfTtcbiAgICB0eXBlQ2hlY2tDb25maWcoTkFNRSQ5LCBjb25maWcsIHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFR5cGUpO1xuXG4gICAgaWYgKHR5cGVvZiBjb25maWcucmVmZXJlbmNlID09PSAnb2JqZWN0JyAmJiAhaXNFbGVtZW50KGNvbmZpZy5yZWZlcmVuY2UpICYmIHR5cGVvZiBjb25maWcucmVmZXJlbmNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gUG9wcGVyIHZpcnR1YWwgZWxlbWVudHMgcmVxdWlyZSBhIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBtZXRob2RcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7TkFNRSQ5LnRvVXBwZXJDYXNlKCl9OiBPcHRpb24gXCJyZWZlcmVuY2VcIiBwcm92aWRlZCB0eXBlIFwib2JqZWN0XCIgd2l0aG91dCBhIHJlcXVpcmVkIFwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0XCIgbWV0aG9kLmApO1xuICAgIH1cblxuICAgIHJldHVybiBjb25maWc7XG4gIH1cblxuICBfY3JlYXRlUG9wcGVyKHBhcmVudCkge1xuICAgIGlmICh0eXBlb2YgUG9wcGVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9vdHN0cmFwXFwncyBkcm9wZG93bnMgcmVxdWlyZSBQb3BwZXIgKGh0dHBzOi8vcG9wcGVyLmpzLm9yZyknKTtcbiAgICB9XG5cbiAgICBsZXQgcmVmZXJlbmNlRWxlbWVudCA9IHRoaXMuX2VsZW1lbnQ7XG5cbiAgICBpZiAodGhpcy5fY29uZmlnLnJlZmVyZW5jZSA9PT0gJ3BhcmVudCcpIHtcbiAgICAgIHJlZmVyZW5jZUVsZW1lbnQgPSBwYXJlbnQ7XG4gICAgfSBlbHNlIGlmIChpc0VsZW1lbnQodGhpcy5fY29uZmlnLnJlZmVyZW5jZSkpIHtcbiAgICAgIHJlZmVyZW5jZUVsZW1lbnQgPSBnZXRFbGVtZW50KHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UgPT09ICdvYmplY3QnKSB7XG4gICAgICByZWZlcmVuY2VFbGVtZW50ID0gdGhpcy5fY29uZmlnLnJlZmVyZW5jZTtcbiAgICB9XG5cbiAgICBjb25zdCBwb3BwZXJDb25maWcgPSB0aGlzLl9nZXRQb3BwZXJDb25maWcoKTtcblxuICAgIGNvbnN0IGlzRGlzcGxheVN0YXRpYyA9IHBvcHBlckNvbmZpZy5tb2RpZmllcnMuZmluZChtb2RpZmllciA9PiBtb2RpZmllci5uYW1lID09PSAnYXBwbHlTdHlsZXMnICYmIG1vZGlmaWVyLmVuYWJsZWQgPT09IGZhbHNlKTtcbiAgICB0aGlzLl9wb3BwZXIgPSBQb3BwZXIuY3JlYXRlUG9wcGVyKHJlZmVyZW5jZUVsZW1lbnQsIHRoaXMuX21lbnUsIHBvcHBlckNvbmZpZyk7XG5cbiAgICBpZiAoaXNEaXNwbGF5U3RhdGljKSB7XG4gICAgICBNYW5pcHVsYXRvci5zZXREYXRhQXR0cmlidXRlKHRoaXMuX21lbnUsICdwb3BwZXInLCAnc3RhdGljJyk7XG4gICAgfVxuICB9XG5cbiAgX2lzU2hvd24oZWxlbWVudCA9IHRoaXMuX2VsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TSE9XJDYpO1xuICB9XG5cbiAgX2dldE1lbnVFbGVtZW50KCkge1xuICAgIHJldHVybiBTZWxlY3RvckVuZ2luZS5uZXh0KHRoaXMuX2VsZW1lbnQsIFNFTEVDVE9SX01FTlUpWzBdO1xuICB9XG5cbiAgX2dldFBsYWNlbWVudCgpIHtcbiAgICBjb25zdCBwYXJlbnREcm9wZG93biA9IHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZTtcblxuICAgIGlmIChwYXJlbnREcm9wZG93bi5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9EUk9QRU5EKSkge1xuICAgICAgcmV0dXJuIFBMQUNFTUVOVF9SSUdIVDtcbiAgICB9XG5cbiAgICBpZiAocGFyZW50RHJvcGRvd24uY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRFJPUFNUQVJUKSkge1xuICAgICAgcmV0dXJuIFBMQUNFTUVOVF9MRUZUO1xuICAgIH0gLy8gV2UgbmVlZCB0byB0cmltIHRoZSB2YWx1ZSBiZWNhdXNlIGN1c3RvbSBwcm9wZXJ0aWVzIGNhbiBhbHNvIGluY2x1ZGUgc3BhY2VzXG5cblxuICAgIGNvbnN0IGlzRW5kID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9tZW51KS5nZXRQcm9wZXJ0eVZhbHVlKCctLWJzLXBvc2l0aW9uJykudHJpbSgpID09PSAnZW5kJztcblxuICAgIGlmIChwYXJlbnREcm9wZG93bi5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9EUk9QVVApKSB7XG4gICAgICByZXR1cm4gaXNFbmQgPyBQTEFDRU1FTlRfVE9QRU5EIDogUExBQ0VNRU5UX1RPUDtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNFbmQgPyBQTEFDRU1FTlRfQk9UVE9NRU5EIDogUExBQ0VNRU5UX0JPVFRPTTtcbiAgfVxuXG4gIF9kZXRlY3ROYXZiYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQuY2xvc2VzdChgLiR7Q0xBU1NfTkFNRV9OQVZCQVJ9YCkgIT09IG51bGw7XG4gIH1cblxuICBfZ2V0T2Zmc2V0KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG9mZnNldFxuICAgIH0gPSB0aGlzLl9jb25maWc7XG5cbiAgICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBvZmZzZXQuc3BsaXQoJywnKS5tYXAodmFsID0+IE51bWJlci5wYXJzZUludCh2YWwsIDEwKSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBwb3BwZXJEYXRhID0+IG9mZnNldChwb3BwZXJEYXRhLCB0aGlzLl9lbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG5cbiAgX2dldFBvcHBlckNvbmZpZygpIHtcbiAgICBjb25zdCBkZWZhdWx0QnNQb3BwZXJDb25maWcgPSB7XG4gICAgICBwbGFjZW1lbnQ6IHRoaXMuX2dldFBsYWNlbWVudCgpLFxuICAgICAgbW9kaWZpZXJzOiBbe1xuICAgICAgICBuYW1lOiAncHJldmVudE92ZXJmbG93JyxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIGJvdW5kYXJ5OiB0aGlzLl9jb25maWcuYm91bmRhcnlcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBuYW1lOiAnb2Zmc2V0JyxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIG9mZnNldDogdGhpcy5fZ2V0T2Zmc2V0KClcbiAgICAgICAgfVxuICAgICAgfV1cbiAgICB9OyAvLyBEaXNhYmxlIFBvcHBlciBpZiB3ZSBoYXZlIGEgc3RhdGljIGRpc3BsYXlcblxuICAgIGlmICh0aGlzLl9jb25maWcuZGlzcGxheSA9PT0gJ3N0YXRpYycpIHtcbiAgICAgIGRlZmF1bHRCc1BvcHBlckNvbmZpZy5tb2RpZmllcnMgPSBbe1xuICAgICAgICBuYW1lOiAnYXBwbHlTdHlsZXMnLFxuICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgfV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgLi4uZGVmYXVsdEJzUG9wcGVyQ29uZmlnLFxuICAgICAgLi4uKHR5cGVvZiB0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnID09PSAnZnVuY3Rpb24nID8gdGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZyhkZWZhdWx0QnNQb3BwZXJDb25maWcpIDogdGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZylcbiAgICB9O1xuICB9XG5cbiAgX3NlbGVjdE1lbnVJdGVtKHtcbiAgICBrZXksXG4gICAgdGFyZ2V0XG4gIH0pIHtcbiAgICBjb25zdCBpdGVtcyA9IFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfVklTSUJMRV9JVEVNUywgdGhpcy5fbWVudSkuZmlsdGVyKGlzVmlzaWJsZSk7XG5cbiAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gaWYgdGFyZ2V0IGlzbid0IGluY2x1ZGVkIGluIGl0ZW1zIChlLmcuIHdoZW4gZXhwYW5kaW5nIHRoZSBkcm9wZG93bilcbiAgICAvLyBhbGxvdyBjeWNsaW5nIHRvIGdldCB0aGUgbGFzdCBpdGVtIGluIGNhc2Uga2V5IGVxdWFscyBBUlJPV19VUF9LRVlcblxuXG4gICAgZ2V0TmV4dEFjdGl2ZUVsZW1lbnQoaXRlbXMsIHRhcmdldCwga2V5ID09PSBBUlJPV19ET1dOX0tFWSwgIWl0ZW1zLmluY2x1ZGVzKHRhcmdldCkpLmZvY3VzKCk7XG4gIH0gLy8gU3RhdGljXG5cblxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgZGF0YSA9IERyb3Bkb3duLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgY29uZmlnKTtcblxuICAgICAgaWYgKHR5cGVvZiBjb25maWcgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYCk7XG4gICAgICB9XG5cbiAgICAgIGRhdGFbY29uZmlnXSgpO1xuICAgIH0pO1xuICB9XG5cbiAgc3RhdGljIGNsZWFyTWVudXMoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQgJiYgKGV2ZW50LmJ1dHRvbiA9PT0gUklHSFRfTU9VU0VfQlVUVE9OIHx8IGV2ZW50LnR5cGUgPT09ICdrZXl1cCcgJiYgZXZlbnQua2V5ICE9PSBUQUJfS0VZJDEpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgdG9nZ2xlcyA9IFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfREFUQV9UT0dHTEUkMyk7XG5cbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdG9nZ2xlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgY29udGV4dCA9IERyb3Bkb3duLmdldEluc3RhbmNlKHRvZ2dsZXNbaV0pO1xuXG4gICAgICBpZiAoIWNvbnRleHQgfHwgY29udGV4dC5fY29uZmlnLmF1dG9DbG9zZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghY29udGV4dC5faXNTaG93bigpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZWxhdGVkVGFyZ2V0ID0ge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiBjb250ZXh0Ll9lbGVtZW50XG4gICAgICB9O1xuXG4gICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgY29tcG9zZWRQYXRoID0gZXZlbnQuY29tcG9zZWRQYXRoKCk7XG4gICAgICAgIGNvbnN0IGlzTWVudVRhcmdldCA9IGNvbXBvc2VkUGF0aC5pbmNsdWRlcyhjb250ZXh0Ll9tZW51KTtcblxuICAgICAgICBpZiAoY29tcG9zZWRQYXRoLmluY2x1ZGVzKGNvbnRleHQuX2VsZW1lbnQpIHx8IGNvbnRleHQuX2NvbmZpZy5hdXRvQ2xvc2UgPT09ICdpbnNpZGUnICYmICFpc01lbnVUYXJnZXQgfHwgY29udGV4dC5fY29uZmlnLmF1dG9DbG9zZSA9PT0gJ291dHNpZGUnICYmIGlzTWVudVRhcmdldCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIFRhYiBuYXZpZ2F0aW9uIHRocm91Z2ggdGhlIGRyb3Bkb3duIG1lbnUgb3IgZXZlbnRzIGZyb20gY29udGFpbmVkIGlucHV0cyBzaG91bGRuJ3QgY2xvc2UgdGhlIG1lbnVcblxuXG4gICAgICAgIGlmIChjb250ZXh0Ll9tZW51LmNvbnRhaW5zKGV2ZW50LnRhcmdldCkgJiYgKGV2ZW50LnR5cGUgPT09ICdrZXl1cCcgJiYgZXZlbnQua2V5ID09PSBUQUJfS0VZJDEgfHwgL2lucHV0fHNlbGVjdHxvcHRpb258dGV4dGFyZWF8Zm9ybS9pLnRlc3QoZXZlbnQudGFyZ2V0LnRhZ05hbWUpKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdjbGljaycpIHtcbiAgICAgICAgICByZWxhdGVkVGFyZ2V0LmNsaWNrRXZlbnQgPSBldmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb250ZXh0Ll9jb21wbGV0ZUhpZGUocmVsYXRlZFRhcmdldCk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGdldFBhcmVudEZyb21FbGVtZW50KGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZ2V0RWxlbWVudEZyb21TZWxlY3RvcihlbGVtZW50KSB8fCBlbGVtZW50LnBhcmVudE5vZGU7XG4gIH1cblxuICBzdGF0aWMgZGF0YUFwaUtleWRvd25IYW5kbGVyKGV2ZW50KSB7XG4gICAgLy8gSWYgbm90IGlucHV0L3RleHRhcmVhOlxuICAgIC8vICAtIEFuZCBub3QgYSBrZXkgaW4gUkVHRVhQX0tFWURPV04gPT4gbm90IGEgZHJvcGRvd24gY29tbWFuZFxuICAgIC8vIElmIGlucHV0L3RleHRhcmVhOlxuICAgIC8vICAtIElmIHNwYWNlIGtleSA9PiBub3QgYSBkcm9wZG93biBjb21tYW5kXG4gICAgLy8gIC0gSWYga2V5IGlzIG90aGVyIHRoYW4gZXNjYXBlXG4gICAgLy8gICAgLSBJZiBrZXkgaXMgbm90IHVwIG9yIGRvd24gPT4gbm90IGEgZHJvcGRvd24gY29tbWFuZFxuICAgIC8vICAgIC0gSWYgdHJpZ2dlciBpbnNpZGUgdGhlIG1lbnUgPT4gbm90IGEgZHJvcGRvd24gY29tbWFuZFxuICAgIGlmICgvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KGV2ZW50LnRhcmdldC50YWdOYW1lKSA/IGV2ZW50LmtleSA9PT0gU1BBQ0VfS0VZIHx8IGV2ZW50LmtleSAhPT0gRVNDQVBFX0tFWSQyICYmIChldmVudC5rZXkgIT09IEFSUk9XX0RPV05fS0VZICYmIGV2ZW50LmtleSAhPT0gQVJST1dfVVBfS0VZIHx8IGV2ZW50LnRhcmdldC5jbG9zZXN0KFNFTEVDVE9SX01FTlUpKSA6ICFSRUdFWFBfS0VZRE9XTi50ZXN0KGV2ZW50LmtleSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBpc0FjdGl2ZSA9IHRoaXMuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU0hPVyQ2KTtcblxuICAgIGlmICghaXNBY3RpdmUgJiYgZXZlbnQua2V5ID09PSBFU0NBUEVfS0VZJDIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgaWYgKGlzRGlzYWJsZWQodGhpcykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBnZXRUb2dnbGVCdXR0b24gPSB0aGlzLm1hdGNoZXMoU0VMRUNUT1JfREFUQV9UT0dHTEUkMykgPyB0aGlzIDogU2VsZWN0b3JFbmdpbmUucHJldih0aGlzLCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQzKVswXTtcbiAgICBjb25zdCBpbnN0YW5jZSA9IERyb3Bkb3duLmdldE9yQ3JlYXRlSW5zdGFuY2UoZ2V0VG9nZ2xlQnV0dG9uKTtcblxuICAgIGlmIChldmVudC5rZXkgPT09IEVTQ0FQRV9LRVkkMikge1xuICAgICAgaW5zdGFuY2UuaGlkZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudC5rZXkgPT09IEFSUk9XX1VQX0tFWSB8fCBldmVudC5rZXkgPT09IEFSUk9XX0RPV05fS0VZKSB7XG4gICAgICBpZiAoIWlzQWN0aXZlKSB7XG4gICAgICAgIGluc3RhbmNlLnNob3coKTtcbiAgICAgIH1cblxuICAgICAgaW5zdGFuY2UuX3NlbGVjdE1lbnVJdGVtKGV2ZW50KTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghaXNBY3RpdmUgfHwgZXZlbnQua2V5ID09PSBTUEFDRV9LRVkpIHtcbiAgICAgIERyb3Bkb3duLmNsZWFyTWVudXMoKTtcbiAgICB9XG4gIH1cblxufVxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIERhdGEgQXBpIGltcGxlbWVudGF0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5cbkV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfS0VZRE9XTl9EQVRBX0FQSSwgU0VMRUNUT1JfREFUQV9UT0dHTEUkMywgRHJvcGRvd24uZGF0YUFwaUtleWRvd25IYW5kbGVyKTtcbkV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfS0VZRE9XTl9EQVRBX0FQSSwgU0VMRUNUT1JfTUVOVSwgRHJvcGRvd24uZGF0YUFwaUtleWRvd25IYW5kbGVyKTtcbkV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkMywgRHJvcGRvd24uY2xlYXJNZW51cyk7XG5FdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0tFWVVQX0RBVEFfQVBJLCBEcm9wZG93bi5jbGVhck1lbnVzKTtcbkV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkMywgU0VMRUNUT1JfREFUQV9UT0dHTEUkMywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIERyb3Bkb3duLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcykudG9nZ2xlKCk7XG59KTtcbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBqUXVlcnlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogYWRkIC5Ecm9wZG93biB0byBqUXVlcnkgb25seSBpZiBqUXVlcnkgaXMgcHJlc2VudFxuICovXG5cbmRlZmluZUpRdWVyeVBsdWdpbihEcm9wZG93bik7XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjUuMS4zKTogdXRpbC9zY3JvbGxCYXIuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuY29uc3QgU0VMRUNUT1JfRklYRURfQ09OVEVOVCA9ICcuZml4ZWQtdG9wLCAuZml4ZWQtYm90dG9tLCAuaXMtZml4ZWQsIC5zdGlja3ktdG9wJztcbmNvbnN0IFNFTEVDVE9SX1NUSUNLWV9DT05URU5UID0gJy5zdGlja3ktdG9wJztcblxuY2xhc3MgU2Nyb2xsQmFySGVscGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IGRvY3VtZW50LmJvZHk7XG4gIH1cblxuICBnZXRXaWR0aCgpIHtcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93L2lubmVyV2lkdGgjdXNhZ2Vfbm90ZXNcbiAgICBjb25zdCBkb2N1bWVudFdpZHRoID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuICAgIHJldHVybiBNYXRoLmFicyh3aW5kb3cuaW5uZXJXaWR0aCAtIGRvY3VtZW50V2lkdGgpO1xuICB9XG5cbiAgaGlkZSgpIHtcbiAgICBjb25zdCB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKTtcblxuICAgIHRoaXMuX2Rpc2FibGVPdmVyRmxvdygpOyAvLyBnaXZlIHBhZGRpbmcgdG8gZWxlbWVudCB0byBiYWxhbmNlIHRoZSBoaWRkZW4gc2Nyb2xsYmFyIHdpZHRoXG5cblxuICAgIHRoaXMuX3NldEVsZW1lbnRBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQsICdwYWRkaW5nUmlnaHQnLCBjYWxjdWxhdGVkVmFsdWUgPT4gY2FsY3VsYXRlZFZhbHVlICsgd2lkdGgpOyAvLyB0cmljazogV2UgYWRqdXN0IHBvc2l0aXZlIHBhZGRpbmdSaWdodCBhbmQgbmVnYXRpdmUgbWFyZ2luUmlnaHQgdG8gc3RpY2t5LXRvcCBlbGVtZW50cyB0byBrZWVwIHNob3dpbmcgZnVsbHdpZHRoXG5cblxuICAgIHRoaXMuX3NldEVsZW1lbnRBdHRyaWJ1dGVzKFNFTEVDVE9SX0ZJWEVEX0NPTlRFTlQsICdwYWRkaW5nUmlnaHQnLCBjYWxjdWxhdGVkVmFsdWUgPT4gY2FsY3VsYXRlZFZhbHVlICsgd2lkdGgpO1xuXG4gICAgdGhpcy5fc2V0RWxlbWVudEF0dHJpYnV0ZXMoU0VMRUNUT1JfU1RJQ0tZX0NPTlRFTlQsICdtYXJnaW5SaWdodCcsIGNhbGN1bGF0ZWRWYWx1ZSA9PiBjYWxjdWxhdGVkVmFsdWUgLSB3aWR0aCk7XG4gIH1cblxuICBfZGlzYWJsZU92ZXJGbG93KCkge1xuICAgIHRoaXMuX3NhdmVJbml0aWFsQXR0cmlidXRlKHRoaXMuX2VsZW1lbnQsICdvdmVyZmxvdycpO1xuXG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICB9XG5cbiAgX3NldEVsZW1lbnRBdHRyaWJ1dGVzKHNlbGVjdG9yLCBzdHlsZVByb3AsIGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgc2Nyb2xsYmFyV2lkdGggPSB0aGlzLmdldFdpZHRoKCk7XG5cbiAgICBjb25zdCBtYW5pcHVsYXRpb25DYWxsQmFjayA9IGVsZW1lbnQgPT4ge1xuICAgICAgaWYgKGVsZW1lbnQgIT09IHRoaXMuX2VsZW1lbnQgJiYgd2luZG93LmlubmVyV2lkdGggPiBlbGVtZW50LmNsaWVudFdpZHRoICsgc2Nyb2xsYmFyV2lkdGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9zYXZlSW5pdGlhbEF0dHJpYnV0ZShlbGVtZW50LCBzdHlsZVByb3ApO1xuXG4gICAgICBjb25zdCBjYWxjdWxhdGVkVmFsdWUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KVtzdHlsZVByb3BdO1xuICAgICAgZWxlbWVudC5zdHlsZVtzdHlsZVByb3BdID0gYCR7Y2FsbGJhY2soTnVtYmVyLnBhcnNlRmxvYXQoY2FsY3VsYXRlZFZhbHVlKSl9cHhgO1xuICAgIH07XG5cbiAgICB0aGlzLl9hcHBseU1hbmlwdWxhdGlvbkNhbGxiYWNrKHNlbGVjdG9yLCBtYW5pcHVsYXRpb25DYWxsQmFjayk7XG4gIH1cblxuICByZXNldCgpIHtcbiAgICB0aGlzLl9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQsICdvdmVyZmxvdycpO1xuXG4gICAgdGhpcy5fcmVzZXRFbGVtZW50QXR0cmlidXRlcyh0aGlzLl9lbGVtZW50LCAncGFkZGluZ1JpZ2h0Jyk7XG5cbiAgICB0aGlzLl9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzKFNFTEVDVE9SX0ZJWEVEX0NPTlRFTlQsICdwYWRkaW5nUmlnaHQnKTtcblxuICAgIHRoaXMuX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXMoU0VMRUNUT1JfU1RJQ0tZX0NPTlRFTlQsICdtYXJnaW5SaWdodCcpO1xuICB9XG5cbiAgX3NhdmVJbml0aWFsQXR0cmlidXRlKGVsZW1lbnQsIHN0eWxlUHJvcCkge1xuICAgIGNvbnN0IGFjdHVhbFZhbHVlID0gZWxlbWVudC5zdHlsZVtzdHlsZVByb3BdO1xuXG4gICAgaWYgKGFjdHVhbFZhbHVlKSB7XG4gICAgICBNYW5pcHVsYXRvci5zZXREYXRhQXR0cmlidXRlKGVsZW1lbnQsIHN0eWxlUHJvcCwgYWN0dWFsVmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIF9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzKHNlbGVjdG9yLCBzdHlsZVByb3ApIHtcbiAgICBjb25zdCBtYW5pcHVsYXRpb25DYWxsQmFjayA9IGVsZW1lbnQgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSBNYW5pcHVsYXRvci5nZXREYXRhQXR0cmlidXRlKGVsZW1lbnQsIHN0eWxlUHJvcCk7XG5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUucmVtb3ZlUHJvcGVydHkoc3R5bGVQcm9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIE1hbmlwdWxhdG9yLnJlbW92ZURhdGFBdHRyaWJ1dGUoZWxlbWVudCwgc3R5bGVQcm9wKTtcbiAgICAgICAgZWxlbWVudC5zdHlsZVtzdHlsZVByb3BdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuX2FwcGx5TWFuaXB1bGF0aW9uQ2FsbGJhY2soc2VsZWN0b3IsIG1hbmlwdWxhdGlvbkNhbGxCYWNrKTtcbiAgfVxuXG4gIF9hcHBseU1hbmlwdWxhdGlvbkNhbGxiYWNrKHNlbGVjdG9yLCBjYWxsQmFjaykge1xuICAgIGlmIChpc0VsZW1lbnQoc2VsZWN0b3IpKSB7XG4gICAgICBjYWxsQmFjayhzZWxlY3Rvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIFNlbGVjdG9yRW5naW5lLmZpbmQoc2VsZWN0b3IsIHRoaXMuX2VsZW1lbnQpLmZvckVhY2goY2FsbEJhY2spO1xuICAgIH1cbiAgfVxuXG4gIGlzT3ZlcmZsb3dpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0V2lkdGgoKSA+IDA7XG4gIH1cblxufVxuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY1LjEuMyk6IHV0aWwvYmFja2Ryb3AuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuY29uc3QgRGVmYXVsdCQ3ID0ge1xuICBjbGFzc05hbWU6ICdtb2RhbC1iYWNrZHJvcCcsXG4gIGlzVmlzaWJsZTogdHJ1ZSxcbiAgLy8gaWYgZmFsc2UsIHdlIHVzZSB0aGUgYmFja2Ryb3AgaGVscGVyIHdpdGhvdXQgYWRkaW5nIGFueSBlbGVtZW50IHRvIHRoZSBkb21cbiAgaXNBbmltYXRlZDogZmFsc2UsXG4gIHJvb3RFbGVtZW50OiAnYm9keScsXG4gIC8vIGdpdmUgdGhlIGNob2ljZSB0byBwbGFjZSBiYWNrZHJvcCB1bmRlciBkaWZmZXJlbnQgZWxlbWVudHNcbiAgY2xpY2tDYWxsYmFjazogbnVsbFxufTtcbmNvbnN0IERlZmF1bHRUeXBlJDcgPSB7XG4gIGNsYXNzTmFtZTogJ3N0cmluZycsXG4gIGlzVmlzaWJsZTogJ2Jvb2xlYW4nLFxuICBpc0FuaW1hdGVkOiAnYm9vbGVhbicsXG4gIHJvb3RFbGVtZW50OiAnKGVsZW1lbnR8c3RyaW5nKScsXG4gIGNsaWNrQ2FsbGJhY2s6ICcoZnVuY3Rpb258bnVsbCknXG59O1xuY29uc3QgTkFNRSQ4ID0gJ2JhY2tkcm9wJztcbmNvbnN0IENMQVNTX05BTUVfRkFERSQ0ID0gJ2ZhZGUnO1xuY29uc3QgQ0xBU1NfTkFNRV9TSE9XJDUgPSAnc2hvdyc7XG5jb25zdCBFVkVOVF9NT1VTRURPV04gPSBgbW91c2Vkb3duLmJzLiR7TkFNRSQ4fWA7XG5cbmNsYXNzIEJhY2tkcm9wIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZyk7XG4gICAgdGhpcy5faXNBcHBlbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICB9XG5cbiAgc2hvdyhjYWxsYmFjaykge1xuICAgIGlmICghdGhpcy5fY29uZmlnLmlzVmlzaWJsZSkge1xuICAgICAgZXhlY3V0ZShjYWxsYmFjayk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fYXBwZW5kKCk7XG5cbiAgICBpZiAodGhpcy5fY29uZmlnLmlzQW5pbWF0ZWQpIHtcbiAgICAgIHJlZmxvdyh0aGlzLl9nZXRFbGVtZW50KCkpO1xuICAgIH1cblxuICAgIHRoaXMuX2dldEVsZW1lbnQoKS5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVyQ1KTtcblxuICAgIHRoaXMuX2VtdWxhdGVBbmltYXRpb24oKCkgPT4ge1xuICAgICAgZXhlY3V0ZShjYWxsYmFjayk7XG4gICAgfSk7XG4gIH1cblxuICBoaWRlKGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLl9jb25maWcuaXNWaXNpYmxlKSB7XG4gICAgICBleGVjdXRlKGNhbGxiYWNrKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9nZXRFbGVtZW50KCkuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1ckNSk7XG5cbiAgICB0aGlzLl9lbXVsYXRlQW5pbWF0aW9uKCgpID0+IHtcbiAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgZXhlY3V0ZShjYWxsYmFjayk7XG4gICAgfSk7XG4gIH0gLy8gUHJpdmF0ZVxuXG5cbiAgX2dldEVsZW1lbnQoKSB7XG4gICAgaWYgKCF0aGlzLl9lbGVtZW50KSB7XG4gICAgICBjb25zdCBiYWNrZHJvcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgYmFja2Ryb3AuY2xhc3NOYW1lID0gdGhpcy5fY29uZmlnLmNsYXNzTmFtZTtcblxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5pc0FuaW1hdGVkKSB7XG4gICAgICAgIGJhY2tkcm9wLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9GQURFJDQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9lbGVtZW50ID0gYmFja2Ryb3A7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQ7XG4gIH1cblxuICBfZ2V0Q29uZmlnKGNvbmZpZykge1xuICAgIGNvbmZpZyA9IHsgLi4uRGVmYXVsdCQ3LFxuICAgICAgLi4uKHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnID8gY29uZmlnIDoge30pXG4gICAgfTsgLy8gdXNlIGdldEVsZW1lbnQoKSB3aXRoIHRoZSBkZWZhdWx0IFwiYm9keVwiIHRvIGdldCBhIGZyZXNoIEVsZW1lbnQgb24gZWFjaCBpbnN0YW50aWF0aW9uXG5cbiAgICBjb25maWcucm9vdEVsZW1lbnQgPSBnZXRFbGVtZW50KGNvbmZpZy5yb290RWxlbWVudCk7XG4gICAgdHlwZUNoZWNrQ29uZmlnKE5BTUUkOCwgY29uZmlnLCBEZWZhdWx0VHlwZSQ3KTtcbiAgICByZXR1cm4gY29uZmlnO1xuICB9XG5cbiAgX2FwcGVuZCgpIHtcbiAgICBpZiAodGhpcy5faXNBcHBlbmRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2NvbmZpZy5yb290RWxlbWVudC5hcHBlbmQodGhpcy5fZ2V0RWxlbWVudCgpKTtcblxuICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9nZXRFbGVtZW50KCksIEVWRU5UX01PVVNFRE9XTiwgKCkgPT4ge1xuICAgICAgZXhlY3V0ZSh0aGlzLl9jb25maWcuY2xpY2tDYWxsYmFjayk7XG4gICAgfSk7XG4gICAgdGhpcy5faXNBcHBlbmRlZCA9IHRydWU7XG4gIH1cblxuICBkaXNwb3NlKCkge1xuICAgIGlmICghdGhpcy5faXNBcHBlbmRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIEV2ZW50SGFuZGxlci5vZmYodGhpcy5fZWxlbWVudCwgRVZFTlRfTU9VU0VET1dOKTtcblxuICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlKCk7XG5cbiAgICB0aGlzLl9pc0FwcGVuZGVkID0gZmFsc2U7XG4gIH1cblxuICBfZW11bGF0ZUFuaW1hdGlvbihjYWxsYmFjaykge1xuICAgIGV4ZWN1dGVBZnRlclRyYW5zaXRpb24oY2FsbGJhY2ssIHRoaXMuX2dldEVsZW1lbnQoKSwgdGhpcy5fY29uZmlnLmlzQW5pbWF0ZWQpO1xuICB9XG5cbn1cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NS4xLjMpOiB1dGlsL2ZvY3VzdHJhcC5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5jb25zdCBEZWZhdWx0JDYgPSB7XG4gIHRyYXBFbGVtZW50OiBudWxsLFxuICAvLyBUaGUgZWxlbWVudCB0byB0cmFwIGZvY3VzIGluc2lkZSBvZlxuICBhdXRvZm9jdXM6IHRydWVcbn07XG5jb25zdCBEZWZhdWx0VHlwZSQ2ID0ge1xuICB0cmFwRWxlbWVudDogJ2VsZW1lbnQnLFxuICBhdXRvZm9jdXM6ICdib29sZWFuJ1xufTtcbmNvbnN0IE5BTUUkNyA9ICdmb2N1c3RyYXAnO1xuY29uc3QgREFUQV9LRVkkNyA9ICdicy5mb2N1c3RyYXAnO1xuY29uc3QgRVZFTlRfS0VZJDcgPSBgLiR7REFUQV9LRVkkN31gO1xuY29uc3QgRVZFTlRfRk9DVVNJTiQxID0gYGZvY3VzaW4ke0VWRU5UX0tFWSQ3fWA7XG5jb25zdCBFVkVOVF9LRVlET1dOX1RBQiA9IGBrZXlkb3duLnRhYiR7RVZFTlRfS0VZJDd9YDtcbmNvbnN0IFRBQl9LRVkgPSAnVGFiJztcbmNvbnN0IFRBQl9OQVZfRk9SV0FSRCA9ICdmb3J3YXJkJztcbmNvbnN0IFRBQl9OQVZfQkFDS1dBUkQgPSAnYmFja3dhcmQnO1xuXG5jbGFzcyBGb2N1c1RyYXAge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKTtcbiAgICB0aGlzLl9pc0FjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMuX2xhc3RUYWJOYXZEaXJlY3Rpb24gPSBudWxsO1xuICB9XG5cbiAgYWN0aXZhdGUoKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHJhcEVsZW1lbnQsXG4gICAgICBhdXRvZm9jdXNcbiAgICB9ID0gdGhpcy5fY29uZmlnO1xuXG4gICAgaWYgKHRoaXMuX2lzQWN0aXZlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGF1dG9mb2N1cykge1xuICAgICAgdHJhcEVsZW1lbnQuZm9jdXMoKTtcbiAgICB9XG5cbiAgICBFdmVudEhhbmRsZXIub2ZmKGRvY3VtZW50LCBFVkVOVF9LRVkkNyk7IC8vIGd1YXJkIGFnYWluc3QgaW5maW5pdGUgZm9jdXMgbG9vcFxuXG4gICAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9GT0NVU0lOJDEsIGV2ZW50ID0+IHRoaXMuX2hhbmRsZUZvY3VzaW4oZXZlbnQpKTtcbiAgICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0tFWURPV05fVEFCLCBldmVudCA9PiB0aGlzLl9oYW5kbGVLZXlkb3duKGV2ZW50KSk7XG4gICAgdGhpcy5faXNBY3RpdmUgPSB0cnVlO1xuICB9XG5cbiAgZGVhY3RpdmF0ZSgpIHtcbiAgICBpZiAoIXRoaXMuX2lzQWN0aXZlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5faXNBY3RpdmUgPSBmYWxzZTtcbiAgICBFdmVudEhhbmRsZXIub2ZmKGRvY3VtZW50LCBFVkVOVF9LRVkkNyk7XG4gIH0gLy8gUHJpdmF0ZVxuXG5cbiAgX2hhbmRsZUZvY3VzaW4oZXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICB0YXJnZXRcbiAgICB9ID0gZXZlbnQ7XG4gICAgY29uc3Qge1xuICAgICAgdHJhcEVsZW1lbnRcbiAgICB9ID0gdGhpcy5fY29uZmlnO1xuXG4gICAgaWYgKHRhcmdldCA9PT0gZG9jdW1lbnQgfHwgdGFyZ2V0ID09PSB0cmFwRWxlbWVudCB8fCB0cmFwRWxlbWVudC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZWxlbWVudHMgPSBTZWxlY3RvckVuZ2luZS5mb2N1c2FibGVDaGlsZHJlbih0cmFwRWxlbWVudCk7XG5cbiAgICBpZiAoZWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0cmFwRWxlbWVudC5mb2N1cygpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fbGFzdFRhYk5hdkRpcmVjdGlvbiA9PT0gVEFCX05BVl9CQUNLV0FSRCkge1xuICAgICAgZWxlbWVudHNbZWxlbWVudHMubGVuZ3RoIC0gMV0uZm9jdXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudHNbMF0uZm9jdXMoKTtcbiAgICB9XG4gIH1cblxuICBfaGFuZGxlS2V5ZG93bihldmVudCkge1xuICAgIGlmIChldmVudC5rZXkgIT09IFRBQl9LRVkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9sYXN0VGFiTmF2RGlyZWN0aW9uID0gZXZlbnQuc2hpZnRLZXkgPyBUQUJfTkFWX0JBQ0tXQVJEIDogVEFCX05BVl9GT1JXQVJEO1xuICB9XG5cbiAgX2dldENvbmZpZyhjb25maWcpIHtcbiAgICBjb25maWcgPSB7IC4uLkRlZmF1bHQkNixcbiAgICAgIC4uLih0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyA/IGNvbmZpZyA6IHt9KVxuICAgIH07XG4gICAgdHlwZUNoZWNrQ29uZmlnKE5BTUUkNywgY29uZmlnLCBEZWZhdWx0VHlwZSQ2KTtcbiAgICByZXR1cm4gY29uZmlnO1xuICB9XG5cbn1cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NS4xLjMpOiBtb2RhbC5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29uc3RhbnRzXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jb25zdCBOQU1FJDYgPSAnbW9kYWwnO1xuY29uc3QgREFUQV9LRVkkNiA9ICdicy5tb2RhbCc7XG5jb25zdCBFVkVOVF9LRVkkNiA9IGAuJHtEQVRBX0tFWSQ2fWA7XG5jb25zdCBEQVRBX0FQSV9LRVkkMyA9ICcuZGF0YS1hcGknO1xuY29uc3QgRVNDQVBFX0tFWSQxID0gJ0VzY2FwZSc7XG5jb25zdCBEZWZhdWx0JDUgPSB7XG4gIGJhY2tkcm9wOiB0cnVlLFxuICBrZXlib2FyZDogdHJ1ZSxcbiAgZm9jdXM6IHRydWVcbn07XG5jb25zdCBEZWZhdWx0VHlwZSQ1ID0ge1xuICBiYWNrZHJvcDogJyhib29sZWFufHN0cmluZyknLFxuICBrZXlib2FyZDogJ2Jvb2xlYW4nLFxuICBmb2N1czogJ2Jvb2xlYW4nXG59O1xuY29uc3QgRVZFTlRfSElERSQzID0gYGhpZGUke0VWRU5UX0tFWSQ2fWA7XG5jb25zdCBFVkVOVF9ISURFX1BSRVZFTlRFRCA9IGBoaWRlUHJldmVudGVkJHtFVkVOVF9LRVkkNn1gO1xuY29uc3QgRVZFTlRfSElEREVOJDMgPSBgaGlkZGVuJHtFVkVOVF9LRVkkNn1gO1xuY29uc3QgRVZFTlRfU0hPVyQzID0gYHNob3cke0VWRU5UX0tFWSQ2fWA7XG5jb25zdCBFVkVOVF9TSE9XTiQzID0gYHNob3duJHtFVkVOVF9LRVkkNn1gO1xuY29uc3QgRVZFTlRfUkVTSVpFID0gYHJlc2l6ZSR7RVZFTlRfS0VZJDZ9YDtcbmNvbnN0IEVWRU5UX0NMSUNLX0RJU01JU1MgPSBgY2xpY2suZGlzbWlzcyR7RVZFTlRfS0VZJDZ9YDtcbmNvbnN0IEVWRU5UX0tFWURPV05fRElTTUlTUyQxID0gYGtleWRvd24uZGlzbWlzcyR7RVZFTlRfS0VZJDZ9YDtcbmNvbnN0IEVWRU5UX01PVVNFVVBfRElTTUlTUyA9IGBtb3VzZXVwLmRpc21pc3Mke0VWRU5UX0tFWSQ2fWA7XG5jb25zdCBFVkVOVF9NT1VTRURPV05fRElTTUlTUyA9IGBtb3VzZWRvd24uZGlzbWlzcyR7RVZFTlRfS0VZJDZ9YDtcbmNvbnN0IEVWRU5UX0NMSUNLX0RBVEFfQVBJJDIgPSBgY2xpY2ske0VWRU5UX0tFWSQ2fSR7REFUQV9BUElfS0VZJDN9YDtcbmNvbnN0IENMQVNTX05BTUVfT1BFTiA9ICdtb2RhbC1vcGVuJztcbmNvbnN0IENMQVNTX05BTUVfRkFERSQzID0gJ2ZhZGUnO1xuY29uc3QgQ0xBU1NfTkFNRV9TSE9XJDQgPSAnc2hvdyc7XG5jb25zdCBDTEFTU19OQU1FX1NUQVRJQyA9ICdtb2RhbC1zdGF0aWMnO1xuY29uc3QgT1BFTl9TRUxFQ1RPUiQxID0gJy5tb2RhbC5zaG93JztcbmNvbnN0IFNFTEVDVE9SX0RJQUxPRyA9ICcubW9kYWwtZGlhbG9nJztcbmNvbnN0IFNFTEVDVE9SX01PREFMX0JPRFkgPSAnLm1vZGFsLWJvZHknO1xuY29uc3QgU0VMRUNUT1JfREFUQV9UT0dHTEUkMiA9ICdbZGF0YS1icy10b2dnbGU9XCJtb2RhbFwiXSc7XG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ2xhc3MgRGVmaW5pdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY2xhc3MgTW9kYWwgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgc3VwZXIoZWxlbWVudCk7XG4gICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZyk7XG4gICAgdGhpcy5fZGlhbG9nID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9ESUFMT0csIHRoaXMuX2VsZW1lbnQpO1xuICAgIHRoaXMuX2JhY2tkcm9wID0gdGhpcy5faW5pdGlhbGl6ZUJhY2tEcm9wKCk7XG4gICAgdGhpcy5fZm9jdXN0cmFwID0gdGhpcy5faW5pdGlhbGl6ZUZvY3VzVHJhcCgpO1xuICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZTtcbiAgICB0aGlzLl9pZ25vcmVCYWNrZHJvcENsaWNrID0gZmFsc2U7XG4gICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fc2Nyb2xsQmFyID0gbmV3IFNjcm9sbEJhckhlbHBlcigpO1xuICB9IC8vIEdldHRlcnNcblxuXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gRGVmYXVsdCQ1O1xuICB9XG5cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBOQU1FJDY7XG4gIH0gLy8gUHVibGljXG5cblxuICB0b2dnbGUocmVsYXRlZFRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLl9pc1Nob3duID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3cocmVsYXRlZFRhcmdldCk7XG4gIH1cblxuICBzaG93KHJlbGF0ZWRUYXJnZXQpIHtcbiAgICBpZiAodGhpcy5faXNTaG93biB8fCB0aGlzLl9pc1RyYW5zaXRpb25pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzaG93RXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XJDMsIHtcbiAgICAgIHJlbGF0ZWRUYXJnZXRcbiAgICB9KTtcblxuICAgIGlmIChzaG93RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2lzU2hvd24gPSB0cnVlO1xuXG4gICAgaWYgKHRoaXMuX2lzQW5pbWF0ZWQoKSkge1xuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLl9zY3JvbGxCYXIuaGlkZSgpO1xuXG4gICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfT1BFTik7XG5cbiAgICB0aGlzLl9hZGp1c3REaWFsb2coKTtcblxuICAgIHRoaXMuX3NldEVzY2FwZUV2ZW50KCk7XG5cbiAgICB0aGlzLl9zZXRSZXNpemVFdmVudCgpO1xuXG4gICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2RpYWxvZywgRVZFTlRfTU9VU0VET1dOX0RJU01JU1MsICgpID0+IHtcbiAgICAgIEV2ZW50SGFuZGxlci5vbmUodGhpcy5fZWxlbWVudCwgRVZFTlRfTU9VU0VVUF9ESVNNSVNTLCBldmVudCA9PiB7XG4gICAgICAgIGlmIChldmVudC50YXJnZXQgPT09IHRoaXMuX2VsZW1lbnQpIHtcbiAgICAgICAgICB0aGlzLl9pZ25vcmVCYWNrZHJvcENsaWNrID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9zaG93QmFja2Ryb3AoKCkgPT4gdGhpcy5fc2hvd0VsZW1lbnQocmVsYXRlZFRhcmdldCkpO1xuICB9XG5cbiAgaGlkZSgpIHtcbiAgICBpZiAoIXRoaXMuX2lzU2hvd24gfHwgdGhpcy5faXNUcmFuc2l0aW9uaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgaGlkZUV2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElERSQzKTtcblxuICAgIGlmIChoaWRlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZTtcblxuICAgIGNvbnN0IGlzQW5pbWF0ZWQgPSB0aGlzLl9pc0FuaW1hdGVkKCk7XG5cbiAgICBpZiAoaXNBbmltYXRlZCkge1xuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLl9zZXRFc2NhcGVFdmVudCgpO1xuXG4gICAgdGhpcy5fc2V0UmVzaXplRXZlbnQoKTtcblxuICAgIHRoaXMuX2ZvY3VzdHJhcC5kZWFjdGl2YXRlKCk7XG5cbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDQpO1xuXG4gICAgRXZlbnRIYW5kbGVyLm9mZih0aGlzLl9lbGVtZW50LCBFVkVOVF9DTElDS19ESVNNSVNTKTtcbiAgICBFdmVudEhhbmRsZXIub2ZmKHRoaXMuX2RpYWxvZywgRVZFTlRfTU9VU0VET1dOX0RJU01JU1MpO1xuXG4gICAgdGhpcy5fcXVldWVDYWxsYmFjaygoKSA9PiB0aGlzLl9oaWRlTW9kYWwoKSwgdGhpcy5fZWxlbWVudCwgaXNBbmltYXRlZCk7XG4gIH1cblxuICBkaXNwb3NlKCkge1xuICAgIFt3aW5kb3csIHRoaXMuX2RpYWxvZ10uZm9yRWFjaChodG1sRWxlbWVudCA9PiBFdmVudEhhbmRsZXIub2ZmKGh0bWxFbGVtZW50LCBFVkVOVF9LRVkkNikpO1xuXG4gICAgdGhpcy5fYmFja2Ryb3AuZGlzcG9zZSgpO1xuXG4gICAgdGhpcy5fZm9jdXN0cmFwLmRlYWN0aXZhdGUoKTtcblxuICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgfVxuXG4gIGhhbmRsZVVwZGF0ZSgpIHtcbiAgICB0aGlzLl9hZGp1c3REaWFsb2coKTtcbiAgfSAvLyBQcml2YXRlXG5cblxuICBfaW5pdGlhbGl6ZUJhY2tEcm9wKCkge1xuICAgIHJldHVybiBuZXcgQmFja2Ryb3Aoe1xuICAgICAgaXNWaXNpYmxlOiBCb29sZWFuKHRoaXMuX2NvbmZpZy5iYWNrZHJvcCksXG4gICAgICAvLyAnc3RhdGljJyBvcHRpb24gd2lsbCBiZSB0cmFuc2xhdGVkIHRvIHRydWUsIGFuZCBib29sZWFucyB3aWxsIGtlZXAgdGhlaXIgdmFsdWVcbiAgICAgIGlzQW5pbWF0ZWQ6IHRoaXMuX2lzQW5pbWF0ZWQoKVxuICAgIH0pO1xuICB9XG5cbiAgX2luaXRpYWxpemVGb2N1c1RyYXAoKSB7XG4gICAgcmV0dXJuIG5ldyBGb2N1c1RyYXAoe1xuICAgICAgdHJhcEVsZW1lbnQ6IHRoaXMuX2VsZW1lbnRcbiAgICB9KTtcbiAgfVxuXG4gIF9nZXRDb25maWcoY29uZmlnKSB7XG4gICAgY29uZmlnID0geyAuLi5EZWZhdWx0JDUsXG4gICAgICAuLi5NYW5pcHVsYXRvci5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgIC4uLih0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyA/IGNvbmZpZyA6IHt9KVxuICAgIH07XG4gICAgdHlwZUNoZWNrQ29uZmlnKE5BTUUkNiwgY29uZmlnLCBEZWZhdWx0VHlwZSQ1KTtcbiAgICByZXR1cm4gY29uZmlnO1xuICB9XG5cbiAgX3Nob3dFbGVtZW50KHJlbGF0ZWRUYXJnZXQpIHtcbiAgICBjb25zdCBpc0FuaW1hdGVkID0gdGhpcy5faXNBbmltYXRlZCgpO1xuXG4gICAgY29uc3QgbW9kYWxCb2R5ID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9NT0RBTF9CT0RZLCB0aGlzLl9kaWFsb2cpO1xuXG4gICAgaWYgKCF0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUgfHwgdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgLy8gRG9uJ3QgbW92ZSBtb2RhbCdzIERPTSBwb3NpdGlvblxuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmQodGhpcy5fZWxlbWVudCk7XG4gICAgfVxuXG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblxuICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpO1xuXG4gICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbW9kYWwnLCB0cnVlKTtcblxuICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2RpYWxvZycpO1xuXG4gICAgdGhpcy5fZWxlbWVudC5zY3JvbGxUb3AgPSAwO1xuXG4gICAgaWYgKG1vZGFsQm9keSkge1xuICAgICAgbW9kYWxCb2R5LnNjcm9sbFRvcCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKGlzQW5pbWF0ZWQpIHtcbiAgICAgIHJlZmxvdyh0aGlzLl9lbGVtZW50KTtcbiAgICB9XG5cbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XJDQpO1xuXG4gICAgY29uc3QgdHJhbnNpdGlvbkNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5mb2N1cykge1xuICAgICAgICB0aGlzLl9mb2N1c3RyYXAuYWN0aXZhdGUoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XTiQzLCB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXRcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKHRyYW5zaXRpb25Db21wbGV0ZSwgdGhpcy5fZGlhbG9nLCBpc0FuaW1hdGVkKTtcbiAgfVxuXG4gIF9zZXRFc2NhcGVFdmVudCgpIHtcbiAgICBpZiAodGhpcy5faXNTaG93bikge1xuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0tFWURPV05fRElTTUlTUyQxLCBldmVudCA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9jb25maWcua2V5Ym9hcmQgJiYgZXZlbnQua2V5ID09PSBFU0NBUEVfS0VZJDEpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9jb25maWcua2V5Ym9hcmQgJiYgZXZlbnQua2V5ID09PSBFU0NBUEVfS0VZJDEpIHtcbiAgICAgICAgICB0aGlzLl90cmlnZ2VyQmFja2Ryb3BUcmFuc2l0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBFdmVudEhhbmRsZXIub2ZmKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0tFWURPV05fRElTTUlTUyQxKTtcbiAgICB9XG4gIH1cblxuICBfc2V0UmVzaXplRXZlbnQoKSB7XG4gICAgaWYgKHRoaXMuX2lzU2hvd24pIHtcbiAgICAgIEV2ZW50SGFuZGxlci5vbih3aW5kb3csIEVWRU5UX1JFU0laRSwgKCkgPT4gdGhpcy5fYWRqdXN0RGlhbG9nKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBFdmVudEhhbmRsZXIub2ZmKHdpbmRvdywgRVZFTlRfUkVTSVpFKTtcbiAgICB9XG4gIH1cblxuICBfaGlkZU1vZGFsKCkge1xuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsIHRydWUpO1xuXG4gICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtbW9kYWwnKTtcblxuICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdyb2xlJyk7XG5cbiAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcblxuICAgIHRoaXMuX2JhY2tkcm9wLmhpZGUoKCkgPT4ge1xuICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfT1BFTik7XG5cbiAgICAgIHRoaXMuX3Jlc2V0QWRqdXN0bWVudHMoKTtcblxuICAgICAgdGhpcy5fc2Nyb2xsQmFyLnJlc2V0KCk7XG5cbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJRERFTiQzKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9zaG93QmFja2Ryb3AoY2FsbGJhY2spIHtcbiAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfQ0xJQ0tfRElTTUlTUywgZXZlbnQgPT4ge1xuICAgICAgaWYgKHRoaXMuX2lnbm9yZUJhY2tkcm9wQ2xpY2spIHtcbiAgICAgICAgdGhpcy5faWdub3JlQmFja2Ryb3BDbGljayA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudC50YXJnZXQgIT09IGV2ZW50LmN1cnJlbnRUYXJnZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fY29uZmlnLmJhY2tkcm9wID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9jb25maWcuYmFja2Ryb3AgPT09ICdzdGF0aWMnKSB7XG4gICAgICAgIHRoaXMuX3RyaWdnZXJCYWNrZHJvcFRyYW5zaXRpb24oKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuX2JhY2tkcm9wLnNob3coY2FsbGJhY2spO1xuICB9XG5cbiAgX2lzQW5pbWF0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRkFERSQzKTtcbiAgfVxuXG4gIF90cmlnZ2VyQmFja2Ryb3BUcmFuc2l0aW9uKCkge1xuICAgIGNvbnN0IGhpZGVFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJREVfUFJFVkVOVEVEKTtcblxuICAgIGlmIChoaWRlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIGNsYXNzTGlzdCxcbiAgICAgIHNjcm9sbEhlaWdodCxcbiAgICAgIHN0eWxlXG4gICAgfSA9IHRoaXMuX2VsZW1lbnQ7XG4gICAgY29uc3QgaXNNb2RhbE92ZXJmbG93aW5nID0gc2Nyb2xsSGVpZ2h0ID4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDsgLy8gcmV0dXJuIGlmIHRoZSBmb2xsb3dpbmcgYmFja2dyb3VuZCB0cmFuc2l0aW9uIGhhc24ndCB5ZXQgY29tcGxldGVkXG5cbiAgICBpZiAoIWlzTW9kYWxPdmVyZmxvd2luZyAmJiBzdHlsZS5vdmVyZmxvd1kgPT09ICdoaWRkZW4nIHx8IGNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NUQVRJQykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWlzTW9kYWxPdmVyZmxvd2luZykge1xuICAgICAgc3R5bGUub3ZlcmZsb3dZID0gJ2hpZGRlbic7XG4gICAgfVxuXG4gICAgY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NUQVRJQyk7XG5cbiAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgIGNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TVEFUSUMpO1xuXG4gICAgICBpZiAoIWlzTW9kYWxPdmVyZmxvd2luZykge1xuICAgICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICBzdHlsZS5vdmVyZmxvd1kgPSAnJztcbiAgICAgICAgfSwgdGhpcy5fZGlhbG9nKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLl9kaWFsb2cpO1xuXG4gICAgdGhpcy5fZWxlbWVudC5mb2N1cygpO1xuICB9IC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gdGhlIGZvbGxvd2luZyBtZXRob2RzIGFyZSB1c2VkIHRvIGhhbmRsZSBvdmVyZmxvd2luZyBtb2RhbHNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbiAgX2FkanVzdERpYWxvZygpIHtcbiAgICBjb25zdCBpc01vZGFsT3ZlcmZsb3dpbmcgPSB0aGlzLl9lbGVtZW50LnNjcm9sbEhlaWdodCA+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XG5cbiAgICBjb25zdCBzY3JvbGxiYXJXaWR0aCA9IHRoaXMuX3Njcm9sbEJhci5nZXRXaWR0aCgpO1xuXG4gICAgY29uc3QgaXNCb2R5T3ZlcmZsb3dpbmcgPSBzY3JvbGxiYXJXaWR0aCA+IDA7XG5cbiAgICBpZiAoIWlzQm9keU92ZXJmbG93aW5nICYmIGlzTW9kYWxPdmVyZmxvd2luZyAmJiAhaXNSVEwoKSB8fCBpc0JvZHlPdmVyZmxvd2luZyAmJiAhaXNNb2RhbE92ZXJmbG93aW5nICYmIGlzUlRMKCkpIHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUucGFkZGluZ0xlZnQgPSBgJHtzY3JvbGxiYXJXaWR0aH1weGA7XG4gICAgfVxuXG4gICAgaWYgKGlzQm9keU92ZXJmbG93aW5nICYmICFpc01vZGFsT3ZlcmZsb3dpbmcgJiYgIWlzUlRMKCkgfHwgIWlzQm9keU92ZXJmbG93aW5nICYmIGlzTW9kYWxPdmVyZmxvd2luZyAmJiBpc1JUTCgpKSB7XG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdSaWdodCA9IGAke3Njcm9sbGJhcldpZHRofXB4YDtcbiAgICB9XG4gIH1cblxuICBfcmVzZXRBZGp1c3RtZW50cygpIHtcbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdMZWZ0ID0gJyc7XG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nUmlnaHQgPSAnJztcbiAgfSAvLyBTdGF0aWNcblxuXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnLCByZWxhdGVkVGFyZ2V0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCBkYXRhID0gTW9kYWwuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCBjb25maWcpO1xuXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKTtcbiAgICAgIH1cblxuICAgICAgZGF0YVtjb25maWddKHJlbGF0ZWRUYXJnZXQpO1xuICAgIH0pO1xuICB9XG5cbn1cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBEYXRhIEFwaSBpbXBsZW1lbnRhdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuXG5FdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJJDIsIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDIsIGZ1bmN0aW9uIChldmVudCkge1xuICBjb25zdCB0YXJnZXQgPSBnZXRFbGVtZW50RnJvbVNlbGVjdG9yKHRoaXMpO1xuXG4gIGlmIChbJ0EnLCAnQVJFQSddLmluY2x1ZGVzKHRoaXMudGFnTmFtZSkpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG5cbiAgRXZlbnRIYW5kbGVyLm9uZSh0YXJnZXQsIEVWRU5UX1NIT1ckMywgc2hvd0V2ZW50ID0+IHtcbiAgICBpZiAoc2hvd0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIC8vIG9ubHkgcmVnaXN0ZXIgZm9jdXMgcmVzdG9yZXIgaWYgbW9kYWwgd2lsbCBhY3R1YWxseSBnZXQgc2hvd25cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBFdmVudEhhbmRsZXIub25lKHRhcmdldCwgRVZFTlRfSElEREVOJDMsICgpID0+IHtcbiAgICAgIGlmIChpc1Zpc2libGUodGhpcykpIHtcbiAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTsgLy8gYXZvaWQgY29uZmxpY3Qgd2hlbiBjbGlja2luZyBtb2RkYWwgdG9nZ2xlciB3aGlsZSBhbm90aGVyIG9uZSBpcyBvcGVuXG5cbiAgY29uc3QgYWxsUmVhZHlPcGVuID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShPUEVOX1NFTEVDVE9SJDEpO1xuXG4gIGlmIChhbGxSZWFkeU9wZW4pIHtcbiAgICBNb2RhbC5nZXRJbnN0YW5jZShhbGxSZWFkeU9wZW4pLmhpZGUoKTtcbiAgfVxuXG4gIGNvbnN0IGRhdGEgPSBNb2RhbC5nZXRPckNyZWF0ZUluc3RhbmNlKHRhcmdldCk7XG4gIGRhdGEudG9nZ2xlKHRoaXMpO1xufSk7XG5lbmFibGVEaXNtaXNzVHJpZ2dlcihNb2RhbCk7XG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogalF1ZXJ5XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIGFkZCAuTW9kYWwgdG8galF1ZXJ5IG9ubHkgaWYgalF1ZXJ5IGlzIHByZXNlbnRcbiAqL1xuXG5kZWZpbmVKUXVlcnlQbHVnaW4oTW9kYWwpO1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY1LjEuMyk6IG9mZmNhbnZhcy5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29uc3RhbnRzXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jb25zdCBOQU1FJDUgPSAnb2ZmY2FudmFzJztcbmNvbnN0IERBVEFfS0VZJDUgPSAnYnMub2ZmY2FudmFzJztcbmNvbnN0IEVWRU5UX0tFWSQ1ID0gYC4ke0RBVEFfS0VZJDV9YDtcbmNvbnN0IERBVEFfQVBJX0tFWSQyID0gJy5kYXRhLWFwaSc7XG5jb25zdCBFVkVOVF9MT0FEX0RBVEFfQVBJJDEgPSBgbG9hZCR7RVZFTlRfS0VZJDV9JHtEQVRBX0FQSV9LRVkkMn1gO1xuY29uc3QgRVNDQVBFX0tFWSA9ICdFc2NhcGUnO1xuY29uc3QgRGVmYXVsdCQ0ID0ge1xuICBiYWNrZHJvcDogdHJ1ZSxcbiAga2V5Ym9hcmQ6IHRydWUsXG4gIHNjcm9sbDogZmFsc2Vcbn07XG5jb25zdCBEZWZhdWx0VHlwZSQ0ID0ge1xuICBiYWNrZHJvcDogJ2Jvb2xlYW4nLFxuICBrZXlib2FyZDogJ2Jvb2xlYW4nLFxuICBzY3JvbGw6ICdib29sZWFuJ1xufTtcbmNvbnN0IENMQVNTX05BTUVfU0hPVyQzID0gJ3Nob3cnO1xuY29uc3QgQ0xBU1NfTkFNRV9CQUNLRFJPUCA9ICdvZmZjYW52YXMtYmFja2Ryb3AnO1xuY29uc3QgT1BFTl9TRUxFQ1RPUiA9ICcub2ZmY2FudmFzLnNob3cnO1xuY29uc3QgRVZFTlRfU0hPVyQyID0gYHNob3cke0VWRU5UX0tFWSQ1fWA7XG5jb25zdCBFVkVOVF9TSE9XTiQyID0gYHNob3duJHtFVkVOVF9LRVkkNX1gO1xuY29uc3QgRVZFTlRfSElERSQyID0gYGhpZGUke0VWRU5UX0tFWSQ1fWA7XG5jb25zdCBFVkVOVF9ISURERU4kMiA9IGBoaWRkZW4ke0VWRU5UX0tFWSQ1fWA7XG5jb25zdCBFVkVOVF9DTElDS19EQVRBX0FQSSQxID0gYGNsaWNrJHtFVkVOVF9LRVkkNX0ke0RBVEFfQVBJX0tFWSQyfWA7XG5jb25zdCBFVkVOVF9LRVlET1dOX0RJU01JU1MgPSBga2V5ZG93bi5kaXNtaXNzJHtFVkVOVF9LRVkkNX1gO1xuY29uc3QgU0VMRUNUT1JfREFUQV9UT0dHTEUkMSA9ICdbZGF0YS1icy10b2dnbGU9XCJvZmZjYW52YXNcIl0nO1xuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENsYXNzIERlZmluaXRpb25cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNsYXNzIE9mZmNhbnZhcyBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICBzdXBlcihlbGVtZW50KTtcbiAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKTtcbiAgICB0aGlzLl9pc1Nob3duID0gZmFsc2U7XG4gICAgdGhpcy5fYmFja2Ryb3AgPSB0aGlzLl9pbml0aWFsaXplQmFja0Ryb3AoKTtcbiAgICB0aGlzLl9mb2N1c3RyYXAgPSB0aGlzLl9pbml0aWFsaXplRm9jdXNUcmFwKCk7XG5cbiAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xuICB9IC8vIEdldHRlcnNcblxuXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gTkFNRSQ1O1xuICB9XG5cbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBEZWZhdWx0JDQ7XG4gIH0gLy8gUHVibGljXG5cblxuICB0b2dnbGUocmVsYXRlZFRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLl9pc1Nob3duID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3cocmVsYXRlZFRhcmdldCk7XG4gIH1cblxuICBzaG93KHJlbGF0ZWRUYXJnZXQpIHtcbiAgICBpZiAodGhpcy5faXNTaG93bikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNob3dFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1ckMiwge1xuICAgICAgcmVsYXRlZFRhcmdldFxuICAgIH0pO1xuXG4gICAgaWYgKHNob3dFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5faXNTaG93biA9IHRydWU7XG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuXG4gICAgdGhpcy5fYmFja2Ryb3Auc2hvdygpO1xuXG4gICAgaWYgKCF0aGlzLl9jb25maWcuc2Nyb2xsKSB7XG4gICAgICBuZXcgU2Nyb2xsQmFySGVscGVyKCkuaGlkZSgpO1xuICAgIH1cblxuICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpO1xuXG4gICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbW9kYWwnLCB0cnVlKTtcblxuICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2RpYWxvZycpO1xuXG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVyQzKTtcblxuICAgIGNvbnN0IGNvbXBsZXRlQ2FsbEJhY2sgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX2NvbmZpZy5zY3JvbGwpIHtcbiAgICAgICAgdGhpcy5fZm9jdXN0cmFwLmFjdGl2YXRlKCk7XG4gICAgICB9XG5cbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1dOJDIsIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldFxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGVDYWxsQmFjaywgdGhpcy5fZWxlbWVudCwgdHJ1ZSk7XG4gIH1cblxuICBoaWRlKCkge1xuICAgIGlmICghdGhpcy5faXNTaG93bikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGhpZGVFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJREUkMik7XG5cbiAgICBpZiAoaGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9mb2N1c3RyYXAuZGVhY3RpdmF0ZSgpO1xuXG4gICAgdGhpcy5fZWxlbWVudC5ibHVyKCk7XG5cbiAgICB0aGlzLl9pc1Nob3duID0gZmFsc2U7XG5cbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDMpO1xuXG4gICAgdGhpcy5fYmFja2Ryb3AuaGlkZSgpO1xuXG4gICAgY29uc3QgY29tcGxldGVDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsIHRydWUpO1xuXG4gICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1tb2RhbCcpO1xuXG4gICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgncm9sZScpO1xuXG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcblxuICAgICAgaWYgKCF0aGlzLl9jb25maWcuc2Nyb2xsKSB7XG4gICAgICAgIG5ldyBTY3JvbGxCYXJIZWxwZXIoKS5yZXNldCgpO1xuICAgICAgfVxuXG4gICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURERU4kMik7XG4gICAgfTtcblxuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGVDYWxsYmFjaywgdGhpcy5fZWxlbWVudCwgdHJ1ZSk7XG4gIH1cblxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX2JhY2tkcm9wLmRpc3Bvc2UoKTtcblxuICAgIHRoaXMuX2ZvY3VzdHJhcC5kZWFjdGl2YXRlKCk7XG5cbiAgICBzdXBlci5kaXNwb3NlKCk7XG4gIH0gLy8gUHJpdmF0ZVxuXG5cbiAgX2dldENvbmZpZyhjb25maWcpIHtcbiAgICBjb25maWcgPSB7IC4uLkRlZmF1bHQkNCxcbiAgICAgIC4uLk1hbmlwdWxhdG9yLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4uKHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnID8gY29uZmlnIDoge30pXG4gICAgfTtcbiAgICB0eXBlQ2hlY2tDb25maWcoTkFNRSQ1LCBjb25maWcsIERlZmF1bHRUeXBlJDQpO1xuICAgIHJldHVybiBjb25maWc7XG4gIH1cblxuICBfaW5pdGlhbGl6ZUJhY2tEcm9wKCkge1xuICAgIHJldHVybiBuZXcgQmFja2Ryb3Aoe1xuICAgICAgY2xhc3NOYW1lOiBDTEFTU19OQU1FX0JBQ0tEUk9QLFxuICAgICAgaXNWaXNpYmxlOiB0aGlzLl9jb25maWcuYmFja2Ryb3AsXG4gICAgICBpc0FuaW1hdGVkOiB0cnVlLFxuICAgICAgcm9vdEVsZW1lbnQ6IHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZSxcbiAgICAgIGNsaWNrQ2FsbGJhY2s6ICgpID0+IHRoaXMuaGlkZSgpXG4gICAgfSk7XG4gIH1cblxuICBfaW5pdGlhbGl6ZUZvY3VzVHJhcCgpIHtcbiAgICByZXR1cm4gbmV3IEZvY3VzVHJhcCh7XG4gICAgICB0cmFwRWxlbWVudDogdGhpcy5fZWxlbWVudFxuICAgIH0pO1xuICB9XG5cbiAgX2FkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9LRVlET1dOX0RJU01JU1MsIGV2ZW50ID0+IHtcbiAgICAgIGlmICh0aGlzLl9jb25maWcua2V5Ym9hcmQgJiYgZXZlbnQua2V5ID09PSBFU0NBUEVfS0VZKSB7XG4gICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9IC8vIFN0YXRpY1xuXG5cbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBPZmZjYW52YXMuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCBjb25maWcpO1xuXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YVtjb25maWddID09PSB1bmRlZmluZWQgfHwgY29uZmlnLnN0YXJ0c1dpdGgoJ18nKSB8fCBjb25maWcgPT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKTtcbiAgICAgIH1cblxuICAgICAgZGF0YVtjb25maWddKHRoaXMpO1xuICAgIH0pO1xuICB9XG5cbn1cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBEYXRhIEFwaSBpbXBsZW1lbnRhdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuXG5FdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJJDEsIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDEsIGZ1bmN0aW9uIChldmVudCkge1xuICBjb25zdCB0YXJnZXQgPSBnZXRFbGVtZW50RnJvbVNlbGVjdG9yKHRoaXMpO1xuXG4gIGlmIChbJ0EnLCAnQVJFQSddLmluY2x1ZGVzKHRoaXMudGFnTmFtZSkpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG5cbiAgaWYgKGlzRGlzYWJsZWQodGhpcykpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBFdmVudEhhbmRsZXIub25lKHRhcmdldCwgRVZFTlRfSElEREVOJDIsICgpID0+IHtcbiAgICAvLyBmb2N1cyBvbiB0cmlnZ2VyIHdoZW4gaXQgaXMgY2xvc2VkXG4gICAgaWYgKGlzVmlzaWJsZSh0aGlzKSkge1xuICAgICAgdGhpcy5mb2N1cygpO1xuICAgIH1cbiAgfSk7IC8vIGF2b2lkIGNvbmZsaWN0IHdoZW4gY2xpY2tpbmcgYSB0b2dnbGVyIG9mIGFuIG9mZmNhbnZhcywgd2hpbGUgYW5vdGhlciBpcyBvcGVuXG5cbiAgY29uc3QgYWxsUmVhZHlPcGVuID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShPUEVOX1NFTEVDVE9SKTtcblxuICBpZiAoYWxsUmVhZHlPcGVuICYmIGFsbFJlYWR5T3BlbiAhPT0gdGFyZ2V0KSB7XG4gICAgT2ZmY2FudmFzLmdldEluc3RhbmNlKGFsbFJlYWR5T3BlbikuaGlkZSgpO1xuICB9XG5cbiAgY29uc3QgZGF0YSA9IE9mZmNhbnZhcy5nZXRPckNyZWF0ZUluc3RhbmNlKHRhcmdldCk7XG4gIGRhdGEudG9nZ2xlKHRoaXMpO1xufSk7XG5FdmVudEhhbmRsZXIub24od2luZG93LCBFVkVOVF9MT0FEX0RBVEFfQVBJJDEsICgpID0+IFNlbGVjdG9yRW5naW5lLmZpbmQoT1BFTl9TRUxFQ1RPUikuZm9yRWFjaChlbCA9PiBPZmZjYW52YXMuZ2V0T3JDcmVhdGVJbnN0YW5jZShlbCkuc2hvdygpKSk7XG5lbmFibGVEaXNtaXNzVHJpZ2dlcihPZmZjYW52YXMpO1xuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIGpRdWVyeVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuZGVmaW5lSlF1ZXJ5UGx1Z2luKE9mZmNhbnZhcyk7XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjUuMS4zKTogdXRpbC9zYW5pdGl6ZXIuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuY29uc3QgdXJpQXR0cmlidXRlcyA9IG5ldyBTZXQoWydiYWNrZ3JvdW5kJywgJ2NpdGUnLCAnaHJlZicsICdpdGVtdHlwZScsICdsb25nZGVzYycsICdwb3N0ZXInLCAnc3JjJywgJ3hsaW5rOmhyZWYnXSk7XG5jb25zdCBBUklBX0FUVFJJQlVURV9QQVRURVJOID0gL15hcmlhLVtcXHctXSokL2k7XG4vKipcbiAqIEEgcGF0dGVybiB0aGF0IHJlY29nbml6ZXMgYSBjb21tb25seSB1c2VmdWwgc3Vic2V0IG9mIFVSTHMgdGhhdCBhcmUgc2FmZS5cbiAqXG4gKiBTaG91dG91dCB0byBBbmd1bGFyIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvYmxvYi8xMi4yLngvcGFja2FnZXMvY29yZS9zcmMvc2FuaXRpemF0aW9uL3VybF9zYW5pdGl6ZXIudHNcbiAqL1xuXG5jb25zdCBTQUZFX1VSTF9QQVRURVJOID0gL14oPzooPzpodHRwcz98bWFpbHRvfGZ0cHx0ZWx8ZmlsZXxzbXMpOnxbXiMmLzo/XSooPzpbIy8/XXwkKSkvaTtcbi8qKlxuICogQSBwYXR0ZXJuIHRoYXQgbWF0Y2hlcyBzYWZlIGRhdGEgVVJMcy4gT25seSBtYXRjaGVzIGltYWdlLCB2aWRlbyBhbmQgYXVkaW8gdHlwZXMuXG4gKlxuICogU2hvdXRvdXQgdG8gQW5ndWxhciBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2Jsb2IvMTIuMi54L3BhY2thZ2VzL2NvcmUvc3JjL3Nhbml0aXphdGlvbi91cmxfc2FuaXRpemVyLnRzXG4gKi9cblxuY29uc3QgREFUQV9VUkxfUEFUVEVSTiA9IC9eZGF0YTooPzppbWFnZVxcLyg/OmJtcHxnaWZ8anBlZ3xqcGd8cG5nfHRpZmZ8d2VicCl8dmlkZW9cXC8oPzptcGVnfG1wNHxvZ2d8d2VibSl8YXVkaW9cXC8oPzptcDN8b2dhfG9nZ3xvcHVzKSk7YmFzZTY0LFtcXGQrL2Etel0rPSokL2k7XG5cbmNvbnN0IGFsbG93ZWRBdHRyaWJ1dGUgPSAoYXR0cmlidXRlLCBhbGxvd2VkQXR0cmlidXRlTGlzdCkgPT4ge1xuICBjb25zdCBhdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKGFsbG93ZWRBdHRyaWJ1dGVMaXN0LmluY2x1ZGVzKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgaWYgKHVyaUF0dHJpYnV0ZXMuaGFzKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICByZXR1cm4gQm9vbGVhbihTQUZFX1VSTF9QQVRURVJOLnRlc3QoYXR0cmlidXRlLm5vZGVWYWx1ZSkgfHwgREFUQV9VUkxfUEFUVEVSTi50ZXN0KGF0dHJpYnV0ZS5ub2RlVmFsdWUpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGNvbnN0IHJlZ0V4cCA9IGFsbG93ZWRBdHRyaWJ1dGVMaXN0LmZpbHRlcihhdHRyaWJ1dGVSZWdleCA9PiBhdHRyaWJ1dGVSZWdleCBpbnN0YW5jZW9mIFJlZ0V4cCk7IC8vIENoZWNrIGlmIGEgcmVndWxhciBleHByZXNzaW9uIHZhbGlkYXRlcyB0aGUgYXR0cmlidXRlLlxuXG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSByZWdFeHAubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAocmVnRXhwW2ldLnRlc3QoYXR0cmlidXRlTmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmNvbnN0IERlZmF1bHRBbGxvd2xpc3QgPSB7XG4gIC8vIEdsb2JhbCBhdHRyaWJ1dGVzIGFsbG93ZWQgb24gYW55IHN1cHBsaWVkIGVsZW1lbnQgYmVsb3cuXG4gICcqJzogWydjbGFzcycsICdkaXInLCAnaWQnLCAnbGFuZycsICdyb2xlJywgQVJJQV9BVFRSSUJVVEVfUEFUVEVSTl0sXG4gIGE6IFsndGFyZ2V0JywgJ2hyZWYnLCAndGl0bGUnLCAncmVsJ10sXG4gIGFyZWE6IFtdLFxuICBiOiBbXSxcbiAgYnI6IFtdLFxuICBjb2w6IFtdLFxuICBjb2RlOiBbXSxcbiAgZGl2OiBbXSxcbiAgZW06IFtdLFxuICBocjogW10sXG4gIGgxOiBbXSxcbiAgaDI6IFtdLFxuICBoMzogW10sXG4gIGg0OiBbXSxcbiAgaDU6IFtdLFxuICBoNjogW10sXG4gIGk6IFtdLFxuICBpbWc6IFsnc3JjJywgJ3NyY3NldCcsICdhbHQnLCAndGl0bGUnLCAnd2lkdGgnLCAnaGVpZ2h0J10sXG4gIGxpOiBbXSxcbiAgb2w6IFtdLFxuICBwOiBbXSxcbiAgcHJlOiBbXSxcbiAgczogW10sXG4gIHNtYWxsOiBbXSxcbiAgc3BhbjogW10sXG4gIHN1YjogW10sXG4gIHN1cDogW10sXG4gIHN0cm9uZzogW10sXG4gIHU6IFtdLFxuICB1bDogW11cbn07XG5mdW5jdGlvbiBzYW5pdGl6ZUh0bWwodW5zYWZlSHRtbCwgYWxsb3dMaXN0LCBzYW5pdGl6ZUZuKSB7XG4gIGlmICghdW5zYWZlSHRtbC5sZW5ndGgpIHtcbiAgICByZXR1cm4gdW5zYWZlSHRtbDtcbiAgfVxuXG4gIGlmIChzYW5pdGl6ZUZuICYmIHR5cGVvZiBzYW5pdGl6ZUZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHNhbml0aXplRm4odW5zYWZlSHRtbCk7XG4gIH1cblxuICBjb25zdCBkb21QYXJzZXIgPSBuZXcgd2luZG93LkRPTVBhcnNlcigpO1xuICBjb25zdCBjcmVhdGVkRG9jdW1lbnQgPSBkb21QYXJzZXIucGFyc2VGcm9tU3RyaW5nKHVuc2FmZUh0bWwsICd0ZXh0L2h0bWwnKTtcbiAgY29uc3QgZWxlbWVudHMgPSBbXS5jb25jYXQoLi4uY3JlYXRlZERvY3VtZW50LmJvZHkucXVlcnlTZWxlY3RvckFsbCgnKicpKTtcblxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgY29uc3QgZWxlbWVudE5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICBpZiAoIU9iamVjdC5rZXlzKGFsbG93TGlzdCkuaW5jbHVkZXMoZWxlbWVudE5hbWUpKSB7XG4gICAgICBlbGVtZW50LnJlbW92ZSgpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgYXR0cmlidXRlTGlzdCA9IFtdLmNvbmNhdCguLi5lbGVtZW50LmF0dHJpYnV0ZXMpO1xuICAgIGNvbnN0IGFsbG93ZWRBdHRyaWJ1dGVzID0gW10uY29uY2F0KGFsbG93TGlzdFsnKiddIHx8IFtdLCBhbGxvd0xpc3RbZWxlbWVudE5hbWVdIHx8IFtdKTtcbiAgICBhdHRyaWJ1dGVMaXN0LmZvckVhY2goYXR0cmlidXRlID0+IHtcbiAgICAgIGlmICghYWxsb3dlZEF0dHJpYnV0ZShhdHRyaWJ1dGUsIGFsbG93ZWRBdHRyaWJ1dGVzKSkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUubm9kZU5hbWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZWREb2N1bWVudC5ib2R5LmlubmVySFRNTDtcbn1cblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NS4xLjMpOiB0b29sdGlwLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb25zdGFudHNcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNvbnN0IE5BTUUkNCA9ICd0b29sdGlwJztcbmNvbnN0IERBVEFfS0VZJDQgPSAnYnMudG9vbHRpcCc7XG5jb25zdCBFVkVOVF9LRVkkNCA9IGAuJHtEQVRBX0tFWSQ0fWA7XG5jb25zdCBDTEFTU19QUkVGSVgkMSA9ICdicy10b29sdGlwJztcbmNvbnN0IERJU0FMTE9XRURfQVRUUklCVVRFUyA9IG5ldyBTZXQoWydzYW5pdGl6ZScsICdhbGxvd0xpc3QnLCAnc2FuaXRpemVGbiddKTtcbmNvbnN0IERlZmF1bHRUeXBlJDMgPSB7XG4gIGFuaW1hdGlvbjogJ2Jvb2xlYW4nLFxuICB0ZW1wbGF0ZTogJ3N0cmluZycsXG4gIHRpdGxlOiAnKHN0cmluZ3xlbGVtZW50fGZ1bmN0aW9uKScsXG4gIHRyaWdnZXI6ICdzdHJpbmcnLFxuICBkZWxheTogJyhudW1iZXJ8b2JqZWN0KScsXG4gIGh0bWw6ICdib29sZWFuJyxcbiAgc2VsZWN0b3I6ICcoc3RyaW5nfGJvb2xlYW4pJyxcbiAgcGxhY2VtZW50OiAnKHN0cmluZ3xmdW5jdGlvbiknLFxuICBvZmZzZXQ6ICcoYXJyYXl8c3RyaW5nfGZ1bmN0aW9uKScsXG4gIGNvbnRhaW5lcjogJyhzdHJpbmd8ZWxlbWVudHxib29sZWFuKScsXG4gIGZhbGxiYWNrUGxhY2VtZW50czogJ2FycmF5JyxcbiAgYm91bmRhcnk6ICcoc3RyaW5nfGVsZW1lbnQpJyxcbiAgY3VzdG9tQ2xhc3M6ICcoc3RyaW5nfGZ1bmN0aW9uKScsXG4gIHNhbml0aXplOiAnYm9vbGVhbicsXG4gIHNhbml0aXplRm46ICcobnVsbHxmdW5jdGlvbiknLFxuICBhbGxvd0xpc3Q6ICdvYmplY3QnLFxuICBwb3BwZXJDb25maWc6ICcobnVsbHxvYmplY3R8ZnVuY3Rpb24pJ1xufTtcbmNvbnN0IEF0dGFjaG1lbnRNYXAgPSB7XG4gIEFVVE86ICdhdXRvJyxcbiAgVE9QOiAndG9wJyxcbiAgUklHSFQ6IGlzUlRMKCkgPyAnbGVmdCcgOiAncmlnaHQnLFxuICBCT1RUT006ICdib3R0b20nLFxuICBMRUZUOiBpc1JUTCgpID8gJ3JpZ2h0JyA6ICdsZWZ0J1xufTtcbmNvbnN0IERlZmF1bHQkMyA9IHtcbiAgYW5pbWF0aW9uOiB0cnVlLFxuICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJ0b29sdGlwXCIgcm9sZT1cInRvb2x0aXBcIj4nICsgJzxkaXYgY2xhc3M9XCJ0b29sdGlwLWFycm93XCI+PC9kaXY+JyArICc8ZGl2IGNsYXNzPVwidG9vbHRpcC1pbm5lclwiPjwvZGl2PicgKyAnPC9kaXY+JyxcbiAgdHJpZ2dlcjogJ2hvdmVyIGZvY3VzJyxcbiAgdGl0bGU6ICcnLFxuICBkZWxheTogMCxcbiAgaHRtbDogZmFsc2UsXG4gIHNlbGVjdG9yOiBmYWxzZSxcbiAgcGxhY2VtZW50OiAndG9wJyxcbiAgb2Zmc2V0OiBbMCwgMF0sXG4gIGNvbnRhaW5lcjogZmFsc2UsXG4gIGZhbGxiYWNrUGxhY2VtZW50czogWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXSxcbiAgYm91bmRhcnk6ICdjbGlwcGluZ1BhcmVudHMnLFxuICBjdXN0b21DbGFzczogJycsXG4gIHNhbml0aXplOiB0cnVlLFxuICBzYW5pdGl6ZUZuOiBudWxsLFxuICBhbGxvd0xpc3Q6IERlZmF1bHRBbGxvd2xpc3QsXG4gIHBvcHBlckNvbmZpZzogbnVsbFxufTtcbmNvbnN0IEV2ZW50JDIgPSB7XG4gIEhJREU6IGBoaWRlJHtFVkVOVF9LRVkkNH1gLFxuICBISURERU46IGBoaWRkZW4ke0VWRU5UX0tFWSQ0fWAsXG4gIFNIT1c6IGBzaG93JHtFVkVOVF9LRVkkNH1gLFxuICBTSE9XTjogYHNob3duJHtFVkVOVF9LRVkkNH1gLFxuICBJTlNFUlRFRDogYGluc2VydGVkJHtFVkVOVF9LRVkkNH1gLFxuICBDTElDSzogYGNsaWNrJHtFVkVOVF9LRVkkNH1gLFxuICBGT0NVU0lOOiBgZm9jdXNpbiR7RVZFTlRfS0VZJDR9YCxcbiAgRk9DVVNPVVQ6IGBmb2N1c291dCR7RVZFTlRfS0VZJDR9YCxcbiAgTU9VU0VFTlRFUjogYG1vdXNlZW50ZXIke0VWRU5UX0tFWSQ0fWAsXG4gIE1PVVNFTEVBVkU6IGBtb3VzZWxlYXZlJHtFVkVOVF9LRVkkNH1gXG59O1xuY29uc3QgQ0xBU1NfTkFNRV9GQURFJDIgPSAnZmFkZSc7XG5jb25zdCBDTEFTU19OQU1FX01PREFMID0gJ21vZGFsJztcbmNvbnN0IENMQVNTX05BTUVfU0hPVyQyID0gJ3Nob3cnO1xuY29uc3QgSE9WRVJfU1RBVEVfU0hPVyA9ICdzaG93JztcbmNvbnN0IEhPVkVSX1NUQVRFX09VVCA9ICdvdXQnO1xuY29uc3QgU0VMRUNUT1JfVE9PTFRJUF9JTk5FUiA9ICcudG9vbHRpcC1pbm5lcic7XG5jb25zdCBTRUxFQ1RPUl9NT0RBTCA9IGAuJHtDTEFTU19OQU1FX01PREFMfWA7XG5jb25zdCBFVkVOVF9NT0RBTF9ISURFID0gJ2hpZGUuYnMubW9kYWwnO1xuY29uc3QgVFJJR0dFUl9IT1ZFUiA9ICdob3Zlcic7XG5jb25zdCBUUklHR0VSX0ZPQ1VTID0gJ2ZvY3VzJztcbmNvbnN0IFRSSUdHRVJfQ0xJQ0sgPSAnY2xpY2snO1xuY29uc3QgVFJJR0dFUl9NQU5VQUwgPSAnbWFudWFsJztcbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDbGFzcyBEZWZpbml0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jbGFzcyBUb29sdGlwIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xuICAgIGlmICh0eXBlb2YgUG9wcGVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9vdHN0cmFwXFwncyB0b29sdGlwcyByZXF1aXJlIFBvcHBlciAoaHR0cHM6Ly9wb3BwZXIuanMub3JnKScpO1xuICAgIH1cblxuICAgIHN1cGVyKGVsZW1lbnQpOyAvLyBwcml2YXRlXG5cbiAgICB0aGlzLl9pc0VuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMuX3RpbWVvdXQgPSAwO1xuICAgIHRoaXMuX2hvdmVyU3RhdGUgPSAnJztcbiAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyID0ge307XG4gICAgdGhpcy5fcG9wcGVyID0gbnVsbDsgLy8gUHJvdGVjdGVkXG5cbiAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKTtcbiAgICB0aGlzLnRpcCA9IG51bGw7XG5cbiAgICB0aGlzLl9zZXRMaXN0ZW5lcnMoKTtcbiAgfSAvLyBHZXR0ZXJzXG5cblxuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIERlZmF1bHQkMztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gTkFNRSQ0O1xuICB9XG5cbiAgc3RhdGljIGdldCBFdmVudCgpIHtcbiAgICByZXR1cm4gRXZlbnQkMjtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgcmV0dXJuIERlZmF1bHRUeXBlJDM7XG4gIH0gLy8gUHVibGljXG5cblxuICBlbmFibGUoKSB7XG4gICAgdGhpcy5faXNFbmFibGVkID0gdHJ1ZTtcbiAgfVxuXG4gIGRpc2FibGUoKSB7XG4gICAgdGhpcy5faXNFbmFibGVkID0gZmFsc2U7XG4gIH1cblxuICB0b2dnbGVFbmFibGVkKCkge1xuICAgIHRoaXMuX2lzRW5hYmxlZCA9ICF0aGlzLl9pc0VuYWJsZWQ7XG4gIH1cblxuICB0b2dnbGUoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuX2lzRW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudCkge1xuICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuX2luaXRpYWxpemVPbkRlbGVnYXRlZFRhcmdldChldmVudCk7XG5cbiAgICAgIGNvbnRleHQuX2FjdGl2ZVRyaWdnZXIuY2xpY2sgPSAhY29udGV4dC5fYWN0aXZlVHJpZ2dlci5jbGljaztcblxuICAgICAgaWYgKGNvbnRleHQuX2lzV2l0aEFjdGl2ZVRyaWdnZXIoKSkge1xuICAgICAgICBjb250ZXh0Ll9lbnRlcihudWxsLCBjb250ZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQuX2xlYXZlKG51bGwsIGNvbnRleHQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5nZXRUaXBFbGVtZW50KCkuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU0hPVyQyKSkge1xuICAgICAgICB0aGlzLl9sZWF2ZShudWxsLCB0aGlzKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2VudGVyKG51bGwsIHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xuICAgIEV2ZW50SGFuZGxlci5vZmYodGhpcy5fZWxlbWVudC5jbG9zZXN0KFNFTEVDVE9SX01PREFMKSwgRVZFTlRfTU9EQUxfSElERSwgdGhpcy5faGlkZU1vZGFsSGFuZGxlcik7XG5cbiAgICBpZiAodGhpcy50aXApIHtcbiAgICAgIHRoaXMudGlwLnJlbW92ZSgpO1xuICAgIH1cblxuICAgIHRoaXMuX2Rpc3Bvc2VQb3BwZXIoKTtcblxuICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgfVxuXG4gIHNob3coKSB7XG4gICAgaWYgKHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSB1c2Ugc2hvdyBvbiB2aXNpYmxlIGVsZW1lbnRzJyk7XG4gICAgfVxuXG4gICAgaWYgKCEodGhpcy5pc1dpdGhDb250ZW50KCkgJiYgdGhpcy5faXNFbmFibGVkKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNob3dFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuRXZlbnQuU0hPVyk7XG4gICAgY29uc3Qgc2hhZG93Um9vdCA9IGZpbmRTaGFkb3dSb290KHRoaXMuX2VsZW1lbnQpO1xuICAgIGNvbnN0IGlzSW5UaGVEb20gPSBzaGFkb3dSb290ID09PSBudWxsID8gdGhpcy5fZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyh0aGlzLl9lbGVtZW50KSA6IHNoYWRvd1Jvb3QuY29udGFpbnModGhpcy5fZWxlbWVudCk7XG5cbiAgICBpZiAoc2hvd0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgfHwgIWlzSW5UaGVEb20pIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEEgdHJpY2sgdG8gcmVjcmVhdGUgYSB0b29sdGlwIGluIGNhc2UgYSBuZXcgdGl0bGUgaXMgZ2l2ZW4gYnkgdXNpbmcgdGhlIE5PVCBkb2N1bWVudGVkIGBkYXRhLWJzLW9yaWdpbmFsLXRpdGxlYFxuICAgIC8vIFRoaXMgd2lsbCBiZSByZW1vdmVkIGxhdGVyIGluIGZhdm9yIG9mIGEgYHNldENvbnRlbnRgIG1ldGhvZFxuXG5cbiAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5OQU1FID09PSAndG9vbHRpcCcgJiYgdGhpcy50aXAgJiYgdGhpcy5nZXRUaXRsZSgpICE9PSB0aGlzLnRpcC5xdWVyeVNlbGVjdG9yKFNFTEVDVE9SX1RPT0xUSVBfSU5ORVIpLmlubmVySFRNTCkge1xuICAgICAgdGhpcy5fZGlzcG9zZVBvcHBlcigpO1xuXG4gICAgICB0aGlzLnRpcC5yZW1vdmUoKTtcbiAgICAgIHRoaXMudGlwID0gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCB0aXAgPSB0aGlzLmdldFRpcEVsZW1lbnQoKTtcbiAgICBjb25zdCB0aXBJZCA9IGdldFVJRCh0aGlzLmNvbnN0cnVjdG9yLk5BTUUpO1xuICAgIHRpcC5zZXRBdHRyaWJ1dGUoJ2lkJywgdGlwSWQpO1xuXG4gICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknLCB0aXBJZCk7XG5cbiAgICBpZiAodGhpcy5fY29uZmlnLmFuaW1hdGlvbikge1xuICAgICAgdGlwLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9GQURFJDIpO1xuICAgIH1cblxuICAgIGNvbnN0IHBsYWNlbWVudCA9IHR5cGVvZiB0aGlzLl9jb25maWcucGxhY2VtZW50ID09PSAnZnVuY3Rpb24nID8gdGhpcy5fY29uZmlnLnBsYWNlbWVudC5jYWxsKHRoaXMsIHRpcCwgdGhpcy5fZWxlbWVudCkgOiB0aGlzLl9jb25maWcucGxhY2VtZW50O1xuXG4gICAgY29uc3QgYXR0YWNobWVudCA9IHRoaXMuX2dldEF0dGFjaG1lbnQocGxhY2VtZW50KTtcblxuICAgIHRoaXMuX2FkZEF0dGFjaG1lbnRDbGFzcyhhdHRhY2htZW50KTtcblxuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRhaW5lclxuICAgIH0gPSB0aGlzLl9jb25maWc7XG4gICAgRGF0YS5zZXQodGlwLCB0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZLCB0aGlzKTtcblxuICAgIGlmICghdGhpcy5fZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyh0aGlzLnRpcCkpIHtcbiAgICAgIGNvbnRhaW5lci5hcHBlbmQodGlwKTtcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuRXZlbnQuSU5TRVJURUQpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9wb3BwZXIpIHtcbiAgICAgIHRoaXMuX3BvcHBlci51cGRhdGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcG9wcGVyID0gUG9wcGVyLmNyZWF0ZVBvcHBlcih0aGlzLl9lbGVtZW50LCB0aXAsIHRoaXMuX2dldFBvcHBlckNvbmZpZyhhdHRhY2htZW50KSk7XG4gICAgfVxuXG4gICAgdGlwLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XJDIpO1xuXG4gICAgY29uc3QgY3VzdG9tQ2xhc3MgPSB0aGlzLl9yZXNvbHZlUG9zc2libGVGdW5jdGlvbih0aGlzLl9jb25maWcuY3VzdG9tQ2xhc3MpO1xuXG4gICAgaWYgKGN1c3RvbUNsYXNzKSB7XG4gICAgICB0aXAuY2xhc3NMaXN0LmFkZCguLi5jdXN0b21DbGFzcy5zcGxpdCgnICcpKTtcbiAgICB9IC8vIElmIHRoaXMgaXMgYSB0b3VjaC1lbmFibGVkIGRldmljZSB3ZSBhZGQgZXh0cmFcbiAgICAvLyBlbXB0eSBtb3VzZW92ZXIgbGlzdGVuZXJzIHRvIHRoZSBib2R5J3MgaW1tZWRpYXRlIGNoaWxkcmVuO1xuICAgIC8vIG9ubHkgbmVlZGVkIGJlY2F1c2Ugb2YgYnJva2VuIGV2ZW50IGRlbGVnYXRpb24gb24gaU9TXG4gICAgLy8gaHR0cHM6Ly93d3cucXVpcmtzbW9kZS5vcmcvYmxvZy9hcmNoaXZlcy8yMDE0LzAyL21vdXNlX2V2ZW50X2J1Yi5odG1sXG5cblxuICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIFtdLmNvbmNhdCguLi5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKS5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICBFdmVudEhhbmRsZXIub24oZWxlbWVudCwgJ21vdXNlb3ZlcicsIG5vb3ApO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICBjb25zdCBwcmV2SG92ZXJTdGF0ZSA9IHRoaXMuX2hvdmVyU3RhdGU7XG4gICAgICB0aGlzLl9ob3ZlclN0YXRlID0gbnVsbDtcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuRXZlbnQuU0hPV04pO1xuXG4gICAgICBpZiAocHJldkhvdmVyU3RhdGUgPT09IEhPVkVSX1NUQVRFX09VVCkge1xuICAgICAgICB0aGlzLl9sZWF2ZShudWxsLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgaXNBbmltYXRlZCA9IHRoaXMudGlwLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0ZBREUkMik7XG5cbiAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGNvbXBsZXRlLCB0aGlzLnRpcCwgaXNBbmltYXRlZCk7XG4gIH1cblxuICBoaWRlKCkge1xuICAgIGlmICghdGhpcy5fcG9wcGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgdGlwID0gdGhpcy5nZXRUaXBFbGVtZW50KCk7XG5cbiAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9pc1dpdGhBY3RpdmVUcmlnZ2VyKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5faG92ZXJTdGF0ZSAhPT0gSE9WRVJfU1RBVEVfU0hPVykge1xuICAgICAgICB0aXAucmVtb3ZlKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NsZWFuVGlwQ2xhc3MoKTtcblxuICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknKTtcblxuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5ISURERU4pO1xuXG4gICAgICB0aGlzLl9kaXNwb3NlUG9wcGVyKCk7XG4gICAgfTtcblxuICAgIGNvbnN0IGhpZGVFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuRXZlbnQuSElERSk7XG5cbiAgICBpZiAoaGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aXAuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1ckMik7IC8vIElmIHRoaXMgaXMgYSB0b3VjaC1lbmFibGVkIGRldmljZSB3ZSByZW1vdmUgdGhlIGV4dHJhXG4gICAgLy8gZW1wdHkgbW91c2VvdmVyIGxpc3RlbmVycyB3ZSBhZGRlZCBmb3IgaU9TIHN1cHBvcnRcblxuICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIFtdLmNvbmNhdCguLi5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKS5mb3JFYWNoKGVsZW1lbnQgPT4gRXZlbnRIYW5kbGVyLm9mZihlbGVtZW50LCAnbW91c2VvdmVyJywgbm9vcCkpO1xuICAgIH1cblxuICAgIHRoaXMuX2FjdGl2ZVRyaWdnZXJbVFJJR0dFUl9DTElDS10gPSBmYWxzZTtcbiAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyW1RSSUdHRVJfRk9DVVNdID0gZmFsc2U7XG4gICAgdGhpcy5fYWN0aXZlVHJpZ2dlcltUUklHR0VSX0hPVkVSXSA9IGZhbHNlO1xuICAgIGNvbnN0IGlzQW5pbWF0ZWQgPSB0aGlzLnRpcC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9GQURFJDIpO1xuXG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZSwgdGhpcy50aXAsIGlzQW5pbWF0ZWQpO1xuXG4gICAgdGhpcy5faG92ZXJTdGF0ZSA9ICcnO1xuICB9XG5cbiAgdXBkYXRlKCkge1xuICAgIGlmICh0aGlzLl9wb3BwZXIgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX3BvcHBlci51cGRhdGUoKTtcbiAgICB9XG4gIH0gLy8gUHJvdGVjdGVkXG5cblxuICBpc1dpdGhDb250ZW50KCkge1xuICAgIHJldHVybiBCb29sZWFuKHRoaXMuZ2V0VGl0bGUoKSk7XG4gIH1cblxuICBnZXRUaXBFbGVtZW50KCkge1xuICAgIGlmICh0aGlzLnRpcCkge1xuICAgICAgcmV0dXJuIHRoaXMudGlwO1xuICAgIH1cblxuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBlbGVtZW50LmlubmVySFRNTCA9IHRoaXMuX2NvbmZpZy50ZW1wbGF0ZTtcbiAgICBjb25zdCB0aXAgPSBlbGVtZW50LmNoaWxkcmVuWzBdO1xuICAgIHRoaXMuc2V0Q29udGVudCh0aXApO1xuICAgIHRpcC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfRkFERSQyLCBDTEFTU19OQU1FX1NIT1ckMik7XG4gICAgdGhpcy50aXAgPSB0aXA7XG4gICAgcmV0dXJuIHRoaXMudGlwO1xuICB9XG5cbiAgc2V0Q29udGVudCh0aXApIHtcbiAgICB0aGlzLl9zYW5pdGl6ZUFuZFNldENvbnRlbnQodGlwLCB0aGlzLmdldFRpdGxlKCksIFNFTEVDVE9SX1RPT0xUSVBfSU5ORVIpO1xuICB9XG5cbiAgX3Nhbml0aXplQW5kU2V0Q29udGVudCh0ZW1wbGF0ZSwgY29udGVudCwgc2VsZWN0b3IpIHtcbiAgICBjb25zdCB0ZW1wbGF0ZUVsZW1lbnQgPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKHNlbGVjdG9yLCB0ZW1wbGF0ZSk7XG5cbiAgICBpZiAoIWNvbnRlbnQgJiYgdGVtcGxhdGVFbGVtZW50KSB7XG4gICAgICB0ZW1wbGF0ZUVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyB3ZSB1c2UgYXBwZW5kIGZvciBodG1sIG9iamVjdHMgdG8gbWFpbnRhaW4ganMgZXZlbnRzXG5cblxuICAgIHRoaXMuc2V0RWxlbWVudENvbnRlbnQodGVtcGxhdGVFbGVtZW50LCBjb250ZW50KTtcbiAgfVxuXG4gIHNldEVsZW1lbnRDb250ZW50KGVsZW1lbnQsIGNvbnRlbnQpIHtcbiAgICBpZiAoZWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc0VsZW1lbnQoY29udGVudCkpIHtcbiAgICAgIGNvbnRlbnQgPSBnZXRFbGVtZW50KGNvbnRlbnQpOyAvLyBjb250ZW50IGlzIGEgRE9NIG5vZGUgb3IgYSBqUXVlcnlcblxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5odG1sKSB7XG4gICAgICAgIGlmIChjb250ZW50LnBhcmVudE5vZGUgIT09IGVsZW1lbnQpIHtcbiAgICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9ICcnO1xuICAgICAgICAgIGVsZW1lbnQuYXBwZW5kKGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LnRleHRDb250ZW50ID0gY29udGVudC50ZXh0Q29udGVudDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9jb25maWcuaHRtbCkge1xuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5zYW5pdGl6ZSkge1xuICAgICAgICBjb250ZW50ID0gc2FuaXRpemVIdG1sKGNvbnRlbnQsIHRoaXMuX2NvbmZpZy5hbGxvd0xpc3QsIHRoaXMuX2NvbmZpZy5zYW5pdGl6ZUZuKTtcbiAgICAgIH1cblxuICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSBjb250ZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LnRleHRDb250ZW50ID0gY29udGVudDtcbiAgICB9XG4gIH1cblxuICBnZXRUaXRsZSgpIHtcbiAgICBjb25zdCB0aXRsZSA9IHRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWJzLW9yaWdpbmFsLXRpdGxlJykgfHwgdGhpcy5fY29uZmlnLnRpdGxlO1xuXG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKHRpdGxlKTtcbiAgfVxuXG4gIHVwZGF0ZUF0dGFjaG1lbnQoYXR0YWNobWVudCkge1xuICAgIGlmIChhdHRhY2htZW50ID09PSAncmlnaHQnKSB7XG4gICAgICByZXR1cm4gJ2VuZCc7XG4gICAgfVxuXG4gICAgaWYgKGF0dGFjaG1lbnQgPT09ICdsZWZ0Jykge1xuICAgICAgcmV0dXJuICdzdGFydCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGF0dGFjaG1lbnQ7XG4gIH0gLy8gUHJpdmF0ZVxuXG5cbiAgX2luaXRpYWxpemVPbkRlbGVnYXRlZFRhcmdldChldmVudCwgY29udGV4dCkge1xuICAgIHJldHVybiBjb250ZXh0IHx8IHRoaXMuY29uc3RydWN0b3IuZ2V0T3JDcmVhdGVJbnN0YW5jZShldmVudC5kZWxlZ2F0ZVRhcmdldCwgdGhpcy5fZ2V0RGVsZWdhdGVDb25maWcoKSk7XG4gIH1cblxuICBfZ2V0T2Zmc2V0KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG9mZnNldFxuICAgIH0gPSB0aGlzLl9jb25maWc7XG5cbiAgICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBvZmZzZXQuc3BsaXQoJywnKS5tYXAodmFsID0+IE51bWJlci5wYXJzZUludCh2YWwsIDEwKSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBwb3BwZXJEYXRhID0+IG9mZnNldChwb3BwZXJEYXRhLCB0aGlzLl9lbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG5cbiAgX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKGNvbnRlbnQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGNvbnRlbnQgPT09ICdmdW5jdGlvbicgPyBjb250ZW50LmNhbGwodGhpcy5fZWxlbWVudCkgOiBjb250ZW50O1xuICB9XG5cbiAgX2dldFBvcHBlckNvbmZpZyhhdHRhY2htZW50KSB7XG4gICAgY29uc3QgZGVmYXVsdEJzUG9wcGVyQ29uZmlnID0ge1xuICAgICAgcGxhY2VtZW50OiBhdHRhY2htZW50LFxuICAgICAgbW9kaWZpZXJzOiBbe1xuICAgICAgICBuYW1lOiAnZmxpcCcsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBmYWxsYmFja1BsYWNlbWVudHM6IHRoaXMuX2NvbmZpZy5mYWxsYmFja1BsYWNlbWVudHNcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBuYW1lOiAnb2Zmc2V0JyxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIG9mZnNldDogdGhpcy5fZ2V0T2Zmc2V0KClcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBuYW1lOiAncHJldmVudE92ZXJmbG93JyxcbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgIGJvdW5kYXJ5OiB0aGlzLl9jb25maWcuYm91bmRhcnlcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBuYW1lOiAnYXJyb3cnLFxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgZWxlbWVudDogYC4ke3RoaXMuY29uc3RydWN0b3IuTkFNRX0tYXJyb3dgXG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAgbmFtZTogJ29uQ2hhbmdlJyxcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgcGhhc2U6ICdhZnRlcldyaXRlJyxcbiAgICAgICAgZm46IGRhdGEgPT4gdGhpcy5faGFuZGxlUG9wcGVyUGxhY2VtZW50Q2hhbmdlKGRhdGEpXG4gICAgICB9XSxcbiAgICAgIG9uRmlyc3RVcGRhdGU6IGRhdGEgPT4ge1xuICAgICAgICBpZiAoZGF0YS5vcHRpb25zLnBsYWNlbWVudCAhPT0gZGF0YS5wbGFjZW1lbnQpIHtcbiAgICAgICAgICB0aGlzLl9oYW5kbGVQb3BwZXJQbGFjZW1lbnRDaGFuZ2UoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB7IC4uLmRlZmF1bHRCc1BvcHBlckNvbmZpZyxcbiAgICAgIC4uLih0eXBlb2YgdGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZyA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMuX2NvbmZpZy5wb3BwZXJDb25maWcoZGVmYXVsdEJzUG9wcGVyQ29uZmlnKSA6IHRoaXMuX2NvbmZpZy5wb3BwZXJDb25maWcpXG4gICAgfTtcbiAgfVxuXG4gIF9hZGRBdHRhY2htZW50Q2xhc3MoYXR0YWNobWVudCkge1xuICAgIHRoaXMuZ2V0VGlwRWxlbWVudCgpLmNsYXNzTGlzdC5hZGQoYCR7dGhpcy5fZ2V0QmFzaWNDbGFzc1ByZWZpeCgpfS0ke3RoaXMudXBkYXRlQXR0YWNobWVudChhdHRhY2htZW50KX1gKTtcbiAgfVxuXG4gIF9nZXRBdHRhY2htZW50KHBsYWNlbWVudCkge1xuICAgIHJldHVybiBBdHRhY2htZW50TWFwW3BsYWNlbWVudC50b1VwcGVyQ2FzZSgpXTtcbiAgfVxuXG4gIF9zZXRMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgdHJpZ2dlcnMgPSB0aGlzLl9jb25maWcudHJpZ2dlci5zcGxpdCgnICcpO1xuXG4gICAgdHJpZ2dlcnMuZm9yRWFjaCh0cmlnZ2VyID0+IHtcbiAgICAgIGlmICh0cmlnZ2VyID09PSAnY2xpY2snKSB7XG4gICAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LkNMSUNLLCB0aGlzLl9jb25maWcuc2VsZWN0b3IsIGV2ZW50ID0+IHRoaXMudG9nZ2xlKGV2ZW50KSk7XG4gICAgICB9IGVsc2UgaWYgKHRyaWdnZXIgIT09IFRSSUdHRVJfTUFOVUFMKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50SW4gPSB0cmlnZ2VyID09PSBUUklHR0VSX0hPVkVSID8gdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5NT1VTRUVOVEVSIDogdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5GT0NVU0lOO1xuICAgICAgICBjb25zdCBldmVudE91dCA9IHRyaWdnZXIgPT09IFRSSUdHRVJfSE9WRVIgPyB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50Lk1PVVNFTEVBVkUgOiB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LkZPQ1VTT1VUO1xuICAgICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgZXZlbnRJbiwgdGhpcy5fY29uZmlnLnNlbGVjdG9yLCBldmVudCA9PiB0aGlzLl9lbnRlcihldmVudCkpO1xuICAgICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgZXZlbnRPdXQsIHRoaXMuX2NvbmZpZy5zZWxlY3RvciwgZXZlbnQgPT4gdGhpcy5fbGVhdmUoZXZlbnQpKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuX2hpZGVNb2RhbEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5fZWxlbWVudCkge1xuICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQuY2xvc2VzdChTRUxFQ1RPUl9NT0RBTCksIEVWRU5UX01PREFMX0hJREUsIHRoaXMuX2hpZGVNb2RhbEhhbmRsZXIpO1xuXG4gICAgaWYgKHRoaXMuX2NvbmZpZy5zZWxlY3Rvcikge1xuICAgICAgdGhpcy5fY29uZmlnID0geyAuLi50aGlzLl9jb25maWcsXG4gICAgICAgIHRyaWdnZXI6ICdtYW51YWwnLFxuICAgICAgICBzZWxlY3RvcjogJydcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2ZpeFRpdGxlKCk7XG4gICAgfVxuICB9XG5cbiAgX2ZpeFRpdGxlKCkge1xuICAgIGNvbnN0IHRpdGxlID0gdGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3RpdGxlJyk7XG5cbiAgICBjb25zdCBvcmlnaW5hbFRpdGxlVHlwZSA9IHR5cGVvZiB0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1icy1vcmlnaW5hbC10aXRsZScpO1xuXG4gICAgaWYgKHRpdGxlIHx8IG9yaWdpbmFsVGl0bGVUeXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtYnMtb3JpZ2luYWwtdGl0bGUnLCB0aXRsZSB8fCAnJyk7XG5cbiAgICAgIGlmICh0aXRsZSAmJiAhdGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnKSAmJiAhdGhpcy5fZWxlbWVudC50ZXh0Q29udGVudCkge1xuICAgICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIHRpdGxlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgJycpO1xuICAgIH1cbiAgfVxuXG4gIF9lbnRlcihldmVudCwgY29udGV4dCkge1xuICAgIGNvbnRleHQgPSB0aGlzLl9pbml0aWFsaXplT25EZWxlZ2F0ZWRUYXJnZXQoZXZlbnQsIGNvbnRleHQpO1xuXG4gICAgaWYgKGV2ZW50KSB7XG4gICAgICBjb250ZXh0Ll9hY3RpdmVUcmlnZ2VyW2V2ZW50LnR5cGUgPT09ICdmb2N1c2luJyA/IFRSSUdHRVJfRk9DVVMgOiBUUklHR0VSX0hPVkVSXSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRleHQuZ2V0VGlwRWxlbWVudCgpLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NIT1ckMikgfHwgY29udGV4dC5faG92ZXJTdGF0ZSA9PT0gSE9WRVJfU1RBVEVfU0hPVykge1xuICAgICAgY29udGV4dC5faG92ZXJTdGF0ZSA9IEhPVkVSX1NUQVRFX1NIT1c7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2xlYXJUaW1lb3V0KGNvbnRleHQuX3RpbWVvdXQpO1xuICAgIGNvbnRleHQuX2hvdmVyU3RhdGUgPSBIT1ZFUl9TVEFURV9TSE9XO1xuXG4gICAgaWYgKCFjb250ZXh0Ll9jb25maWcuZGVsYXkgfHwgIWNvbnRleHQuX2NvbmZpZy5kZWxheS5zaG93KSB7XG4gICAgICBjb250ZXh0LnNob3coKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb250ZXh0Ll90aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoY29udGV4dC5faG92ZXJTdGF0ZSA9PT0gSE9WRVJfU1RBVEVfU0hPVykge1xuICAgICAgICBjb250ZXh0LnNob3coKTtcbiAgICAgIH1cbiAgICB9LCBjb250ZXh0Ll9jb25maWcuZGVsYXkuc2hvdyk7XG4gIH1cblxuICBfbGVhdmUoZXZlbnQsIGNvbnRleHQpIHtcbiAgICBjb250ZXh0ID0gdGhpcy5faW5pdGlhbGl6ZU9uRGVsZWdhdGVkVGFyZ2V0KGV2ZW50LCBjb250ZXh0KTtcblxuICAgIGlmIChldmVudCkge1xuICAgICAgY29udGV4dC5fYWN0aXZlVHJpZ2dlcltldmVudC50eXBlID09PSAnZm9jdXNvdXQnID8gVFJJR0dFUl9GT0NVUyA6IFRSSUdHRVJfSE9WRVJdID0gY29udGV4dC5fZWxlbWVudC5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KTtcbiAgICB9XG5cbiAgICBpZiAoY29udGV4dC5faXNXaXRoQWN0aXZlVHJpZ2dlcigpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2xlYXJUaW1lb3V0KGNvbnRleHQuX3RpbWVvdXQpO1xuICAgIGNvbnRleHQuX2hvdmVyU3RhdGUgPSBIT1ZFUl9TVEFURV9PVVQ7XG5cbiAgICBpZiAoIWNvbnRleHQuX2NvbmZpZy5kZWxheSB8fCAhY29udGV4dC5fY29uZmlnLmRlbGF5LmhpZGUpIHtcbiAgICAgIGNvbnRleHQuaGlkZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnRleHQuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmIChjb250ZXh0Ll9ob3ZlclN0YXRlID09PSBIT1ZFUl9TVEFURV9PVVQpIHtcbiAgICAgICAgY29udGV4dC5oaWRlKCk7XG4gICAgICB9XG4gICAgfSwgY29udGV4dC5fY29uZmlnLmRlbGF5LmhpZGUpO1xuICB9XG5cbiAgX2lzV2l0aEFjdGl2ZVRyaWdnZXIoKSB7XG4gICAgZm9yIChjb25zdCB0cmlnZ2VyIGluIHRoaXMuX2FjdGl2ZVRyaWdnZXIpIHtcbiAgICAgIGlmICh0aGlzLl9hY3RpdmVUcmlnZ2VyW3RyaWdnZXJdKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIF9nZXRDb25maWcoY29uZmlnKSB7XG4gICAgY29uc3QgZGF0YUF0dHJpYnV0ZXMgPSBNYW5pcHVsYXRvci5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICBPYmplY3Qua2V5cyhkYXRhQXR0cmlidXRlcykuZm9yRWFjaChkYXRhQXR0ciA9PiB7XG4gICAgICBpZiAoRElTQUxMT1dFRF9BVFRSSUJVVEVTLmhhcyhkYXRhQXR0cikpIHtcbiAgICAgICAgZGVsZXRlIGRhdGFBdHRyaWJ1dGVzW2RhdGFBdHRyXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25maWcgPSB7IC4uLnRoaXMuY29uc3RydWN0b3IuRGVmYXVsdCxcbiAgICAgIC4uLmRhdGFBdHRyaWJ1dGVzLFxuICAgICAgLi4uKHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnICYmIGNvbmZpZyA/IGNvbmZpZyA6IHt9KVxuICAgIH07XG4gICAgY29uZmlnLmNvbnRhaW5lciA9IGNvbmZpZy5jb250YWluZXIgPT09IGZhbHNlID8gZG9jdW1lbnQuYm9keSA6IGdldEVsZW1lbnQoY29uZmlnLmNvbnRhaW5lcik7XG5cbiAgICBpZiAodHlwZW9mIGNvbmZpZy5kZWxheSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGNvbmZpZy5kZWxheSA9IHtcbiAgICAgICAgc2hvdzogY29uZmlnLmRlbGF5LFxuICAgICAgICBoaWRlOiBjb25maWcuZGVsYXlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb25maWcudGl0bGUgPT09ICdudW1iZXInKSB7XG4gICAgICBjb25maWcudGl0bGUgPSBjb25maWcudGl0bGUudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNvbmZpZy5jb250ZW50ID09PSAnbnVtYmVyJykge1xuICAgICAgY29uZmlnLmNvbnRlbnQgPSBjb25maWcuY29udGVudC50b1N0cmluZygpO1xuICAgIH1cblxuICAgIHR5cGVDaGVja0NvbmZpZyhOQU1FJDQsIGNvbmZpZywgdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0VHlwZSk7XG5cbiAgICBpZiAoY29uZmlnLnNhbml0aXplKSB7XG4gICAgICBjb25maWcudGVtcGxhdGUgPSBzYW5pdGl6ZUh0bWwoY29uZmlnLnRlbXBsYXRlLCBjb25maWcuYWxsb3dMaXN0LCBjb25maWcuc2FuaXRpemVGbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfVxuXG4gIF9nZXREZWxlZ2F0ZUNvbmZpZygpIHtcbiAgICBjb25zdCBjb25maWcgPSB7fTtcblxuICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuX2NvbmZpZykge1xuICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFtrZXldICE9PSB0aGlzLl9jb25maWdba2V5XSkge1xuICAgICAgICBjb25maWdba2V5XSA9IHRoaXMuX2NvbmZpZ1trZXldO1xuICAgICAgfVxuICAgIH0gLy8gSW4gdGhlIGZ1dHVyZSBjYW4gYmUgcmVwbGFjZWQgd2l0aDpcbiAgICAvLyBjb25zdCBrZXlzV2l0aERpZmZlcmVudFZhbHVlcyA9IE9iamVjdC5lbnRyaWVzKHRoaXMuX2NvbmZpZykuZmlsdGVyKGVudHJ5ID0+IHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFtlbnRyeVswXV0gIT09IHRoaXMuX2NvbmZpZ1tlbnRyeVswXV0pXG4gICAgLy8gYE9iamVjdC5mcm9tRW50cmllcyhrZXlzV2l0aERpZmZlcmVudFZhbHVlcylgXG5cblxuICAgIHJldHVybiBjb25maWc7XG4gIH1cblxuICBfY2xlYW5UaXBDbGFzcygpIHtcbiAgICBjb25zdCB0aXAgPSB0aGlzLmdldFRpcEVsZW1lbnQoKTtcbiAgICBjb25zdCBiYXNpY0NsYXNzUHJlZml4UmVnZXggPSBuZXcgUmVnRXhwKGAoXnxcXFxccykke3RoaXMuX2dldEJhc2ljQ2xhc3NQcmVmaXgoKX1cXFxcUytgLCAnZycpO1xuICAgIGNvbnN0IHRhYkNsYXNzID0gdGlwLmdldEF0dHJpYnV0ZSgnY2xhc3MnKS5tYXRjaChiYXNpY0NsYXNzUHJlZml4UmVnZXgpO1xuXG4gICAgaWYgKHRhYkNsYXNzICE9PSBudWxsICYmIHRhYkNsYXNzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRhYkNsYXNzLm1hcCh0b2tlbiA9PiB0b2tlbi50cmltKCkpLmZvckVhY2godENsYXNzID0+IHRpcC5jbGFzc0xpc3QucmVtb3ZlKHRDbGFzcykpO1xuICAgIH1cbiAgfVxuXG4gIF9nZXRCYXNpY0NsYXNzUHJlZml4KCkge1xuICAgIHJldHVybiBDTEFTU19QUkVGSVgkMTtcbiAgfVxuXG4gIF9oYW5kbGVQb3BwZXJQbGFjZW1lbnRDaGFuZ2UocG9wcGVyRGF0YSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YXRlXG4gICAgfSA9IHBvcHBlckRhdGE7XG5cbiAgICBpZiAoIXN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy50aXAgPSBzdGF0ZS5lbGVtZW50cy5wb3BwZXI7XG5cbiAgICB0aGlzLl9jbGVhblRpcENsYXNzKCk7XG5cbiAgICB0aGlzLl9hZGRBdHRhY2htZW50Q2xhc3ModGhpcy5fZ2V0QXR0YWNobWVudChzdGF0ZS5wbGFjZW1lbnQpKTtcbiAgfVxuXG4gIF9kaXNwb3NlUG9wcGVyKCkge1xuICAgIGlmICh0aGlzLl9wb3BwZXIpIHtcbiAgICAgIHRoaXMuX3BvcHBlci5kZXN0cm95KCk7XG5cbiAgICAgIHRoaXMuX3BvcHBlciA9IG51bGw7XG4gICAgfVxuICB9IC8vIFN0YXRpY1xuXG5cbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBUb29sdGlwLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgY29uZmlnKTtcblxuICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYCk7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhW2NvbmZpZ10oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG59XG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogalF1ZXJ5XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIGFkZCAuVG9vbHRpcCB0byBqUXVlcnkgb25seSBpZiBqUXVlcnkgaXMgcHJlc2VudFxuICovXG5cblxuZGVmaW5lSlF1ZXJ5UGx1Z2luKFRvb2x0aXApO1xuXG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY1LjEuMyk6IHBvcG92ZXIuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvbnN0YW50c1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY29uc3QgTkFNRSQzID0gJ3BvcG92ZXInO1xuY29uc3QgREFUQV9LRVkkMyA9ICdicy5wb3BvdmVyJztcbmNvbnN0IEVWRU5UX0tFWSQzID0gYC4ke0RBVEFfS0VZJDN9YDtcbmNvbnN0IENMQVNTX1BSRUZJWCA9ICdicy1wb3BvdmVyJztcbmNvbnN0IERlZmF1bHQkMiA9IHsgLi4uVG9vbHRpcC5EZWZhdWx0LFxuICBwbGFjZW1lbnQ6ICdyaWdodCcsXG4gIG9mZnNldDogWzAsIDhdLFxuICB0cmlnZ2VyOiAnY2xpY2snLFxuICBjb250ZW50OiAnJyxcbiAgdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVwicG9wb3ZlclwiIHJvbGU9XCJ0b29sdGlwXCI+JyArICc8ZGl2IGNsYXNzPVwicG9wb3Zlci1hcnJvd1wiPjwvZGl2PicgKyAnPGgzIGNsYXNzPVwicG9wb3Zlci1oZWFkZXJcIj48L2gzPicgKyAnPGRpdiBjbGFzcz1cInBvcG92ZXItYm9keVwiPjwvZGl2PicgKyAnPC9kaXY+J1xufTtcbmNvbnN0IERlZmF1bHRUeXBlJDIgPSB7IC4uLlRvb2x0aXAuRGVmYXVsdFR5cGUsXG4gIGNvbnRlbnQ6ICcoc3RyaW5nfGVsZW1lbnR8ZnVuY3Rpb24pJ1xufTtcbmNvbnN0IEV2ZW50JDEgPSB7XG4gIEhJREU6IGBoaWRlJHtFVkVOVF9LRVkkM31gLFxuICBISURERU46IGBoaWRkZW4ke0VWRU5UX0tFWSQzfWAsXG4gIFNIT1c6IGBzaG93JHtFVkVOVF9LRVkkM31gLFxuICBTSE9XTjogYHNob3duJHtFVkVOVF9LRVkkM31gLFxuICBJTlNFUlRFRDogYGluc2VydGVkJHtFVkVOVF9LRVkkM31gLFxuICBDTElDSzogYGNsaWNrJHtFVkVOVF9LRVkkM31gLFxuICBGT0NVU0lOOiBgZm9jdXNpbiR7RVZFTlRfS0VZJDN9YCxcbiAgRk9DVVNPVVQ6IGBmb2N1c291dCR7RVZFTlRfS0VZJDN9YCxcbiAgTU9VU0VFTlRFUjogYG1vdXNlZW50ZXIke0VWRU5UX0tFWSQzfWAsXG4gIE1PVVNFTEVBVkU6IGBtb3VzZWxlYXZlJHtFVkVOVF9LRVkkM31gXG59O1xuY29uc3QgU0VMRUNUT1JfVElUTEUgPSAnLnBvcG92ZXItaGVhZGVyJztcbmNvbnN0IFNFTEVDVE9SX0NPTlRFTlQgPSAnLnBvcG92ZXItYm9keSc7XG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ2xhc3MgRGVmaW5pdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY2xhc3MgUG9wb3ZlciBleHRlbmRzIFRvb2x0aXAge1xuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gRGVmYXVsdCQyO1xuICB9XG5cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBOQU1FJDM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IEV2ZW50KCkge1xuICAgIHJldHVybiBFdmVudCQxO1xuICB9XG5cbiAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICByZXR1cm4gRGVmYXVsdFR5cGUkMjtcbiAgfSAvLyBPdmVycmlkZXNcblxuXG4gIGlzV2l0aENvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VGl0bGUoKSB8fCB0aGlzLl9nZXRDb250ZW50KCk7XG4gIH1cblxuICBzZXRDb250ZW50KHRpcCkge1xuICAgIHRoaXMuX3Nhbml0aXplQW5kU2V0Q29udGVudCh0aXAsIHRoaXMuZ2V0VGl0bGUoKSwgU0VMRUNUT1JfVElUTEUpO1xuXG4gICAgdGhpcy5fc2FuaXRpemVBbmRTZXRDb250ZW50KHRpcCwgdGhpcy5fZ2V0Q29udGVudCgpLCBTRUxFQ1RPUl9DT05URU5UKTtcbiAgfSAvLyBQcml2YXRlXG5cblxuICBfZ2V0Q29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZVBvc3NpYmxlRnVuY3Rpb24odGhpcy5fY29uZmlnLmNvbnRlbnQpO1xuICB9XG5cbiAgX2dldEJhc2ljQ2xhc3NQcmVmaXgoKSB7XG4gICAgcmV0dXJuIENMQVNTX1BSRUZJWDtcbiAgfSAvLyBTdGF0aWNcblxuXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCBkYXRhID0gUG9wb3Zlci5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIGNvbmZpZyk7XG5cbiAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YVtjb25maWddKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxufVxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIGpRdWVyeVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBhZGQgLlBvcG92ZXIgdG8galF1ZXJ5IG9ubHkgaWYgalF1ZXJ5IGlzIHByZXNlbnRcbiAqL1xuXG5cbmRlZmluZUpRdWVyeVBsdWdpbihQb3BvdmVyKTtcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NS4xLjMpOiBzY3JvbGxzcHkuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvbnN0YW50c1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY29uc3QgTkFNRSQyID0gJ3Njcm9sbHNweSc7XG5jb25zdCBEQVRBX0tFWSQyID0gJ2JzLnNjcm9sbHNweSc7XG5jb25zdCBFVkVOVF9LRVkkMiA9IGAuJHtEQVRBX0tFWSQyfWA7XG5jb25zdCBEQVRBX0FQSV9LRVkkMSA9ICcuZGF0YS1hcGknO1xuY29uc3QgRGVmYXVsdCQxID0ge1xuICBvZmZzZXQ6IDEwLFxuICBtZXRob2Q6ICdhdXRvJyxcbiAgdGFyZ2V0OiAnJ1xufTtcbmNvbnN0IERlZmF1bHRUeXBlJDEgPSB7XG4gIG9mZnNldDogJ251bWJlcicsXG4gIG1ldGhvZDogJ3N0cmluZycsXG4gIHRhcmdldDogJyhzdHJpbmd8ZWxlbWVudCknXG59O1xuY29uc3QgRVZFTlRfQUNUSVZBVEUgPSBgYWN0aXZhdGUke0VWRU5UX0tFWSQyfWA7XG5jb25zdCBFVkVOVF9TQ1JPTEwgPSBgc2Nyb2xsJHtFVkVOVF9LRVkkMn1gO1xuY29uc3QgRVZFTlRfTE9BRF9EQVRBX0FQSSA9IGBsb2FkJHtFVkVOVF9LRVkkMn0ke0RBVEFfQVBJX0tFWSQxfWA7XG5jb25zdCBDTEFTU19OQU1FX0RST1BET1dOX0lURU0gPSAnZHJvcGRvd24taXRlbSc7XG5jb25zdCBDTEFTU19OQU1FX0FDVElWRSQxID0gJ2FjdGl2ZSc7XG5jb25zdCBTRUxFQ1RPUl9EQVRBX1NQWSA9ICdbZGF0YS1icy1zcHk9XCJzY3JvbGxcIl0nO1xuY29uc3QgU0VMRUNUT1JfTkFWX0xJU1RfR1JPVVAkMSA9ICcubmF2LCAubGlzdC1ncm91cCc7XG5jb25zdCBTRUxFQ1RPUl9OQVZfTElOS1MgPSAnLm5hdi1saW5rJztcbmNvbnN0IFNFTEVDVE9SX05BVl9JVEVNUyA9ICcubmF2LWl0ZW0nO1xuY29uc3QgU0VMRUNUT1JfTElTVF9JVEVNUyA9ICcubGlzdC1ncm91cC1pdGVtJztcbmNvbnN0IFNFTEVDVE9SX0xJTktfSVRFTVMgPSBgJHtTRUxFQ1RPUl9OQVZfTElOS1N9LCAke1NFTEVDVE9SX0xJU1RfSVRFTVN9LCAuJHtDTEFTU19OQU1FX0RST1BET1dOX0lURU19YDtcbmNvbnN0IFNFTEVDVE9SX0RST1BET1dOJDEgPSAnLmRyb3Bkb3duJztcbmNvbnN0IFNFTEVDVE9SX0RST1BET1dOX1RPR0dMRSQxID0gJy5kcm9wZG93bi10b2dnbGUnO1xuY29uc3QgTUVUSE9EX09GRlNFVCA9ICdvZmZzZXQnO1xuY29uc3QgTUVUSE9EX1BPU0lUSU9OID0gJ3Bvc2l0aW9uJztcbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDbGFzcyBEZWZpbml0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jbGFzcyBTY3JvbGxTcHkgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgc3VwZXIoZWxlbWVudCk7XG4gICAgdGhpcy5fc2Nyb2xsRWxlbWVudCA9IHRoaXMuX2VsZW1lbnQudGFnTmFtZSA9PT0gJ0JPRFknID8gd2luZG93IDogdGhpcy5fZWxlbWVudDtcbiAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKTtcbiAgICB0aGlzLl9vZmZzZXRzID0gW107XG4gICAgdGhpcy5fdGFyZ2V0cyA9IFtdO1xuICAgIHRoaXMuX2FjdGl2ZVRhcmdldCA9IG51bGw7XG4gICAgdGhpcy5fc2Nyb2xsSGVpZ2h0ID0gMDtcbiAgICBFdmVudEhhbmRsZXIub24odGhpcy5fc2Nyb2xsRWxlbWVudCwgRVZFTlRfU0NST0xMLCAoKSA9PiB0aGlzLl9wcm9jZXNzKCkpO1xuICAgIHRoaXMucmVmcmVzaCgpO1xuXG4gICAgdGhpcy5fcHJvY2VzcygpO1xuICB9IC8vIEdldHRlcnNcblxuXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gRGVmYXVsdCQxO1xuICB9XG5cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBOQU1FJDI7XG4gIH0gLy8gUHVibGljXG5cblxuICByZWZyZXNoKCkge1xuICAgIGNvbnN0IGF1dG9NZXRob2QgPSB0aGlzLl9zY3JvbGxFbGVtZW50ID09PSB0aGlzLl9zY3JvbGxFbGVtZW50LndpbmRvdyA/IE1FVEhPRF9PRkZTRVQgOiBNRVRIT0RfUE9TSVRJT047XG4gICAgY29uc3Qgb2Zmc2V0TWV0aG9kID0gdGhpcy5fY29uZmlnLm1ldGhvZCA9PT0gJ2F1dG8nID8gYXV0b01ldGhvZCA6IHRoaXMuX2NvbmZpZy5tZXRob2Q7XG4gICAgY29uc3Qgb2Zmc2V0QmFzZSA9IG9mZnNldE1ldGhvZCA9PT0gTUVUSE9EX1BPU0lUSU9OID8gdGhpcy5fZ2V0U2Nyb2xsVG9wKCkgOiAwO1xuICAgIHRoaXMuX29mZnNldHMgPSBbXTtcbiAgICB0aGlzLl90YXJnZXRzID0gW107XG4gICAgdGhpcy5fc2Nyb2xsSGVpZ2h0ID0gdGhpcy5fZ2V0U2Nyb2xsSGVpZ2h0KCk7XG4gICAgY29uc3QgdGFyZ2V0cyA9IFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfTElOS19JVEVNUywgdGhpcy5fY29uZmlnLnRhcmdldCk7XG4gICAgdGFyZ2V0cy5tYXAoZWxlbWVudCA9PiB7XG4gICAgICBjb25zdCB0YXJnZXRTZWxlY3RvciA9IGdldFNlbGVjdG9yRnJvbUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXRTZWxlY3RvciA/IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUodGFyZ2V0U2VsZWN0b3IpIDogbnVsbDtcblxuICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICBjb25zdCB0YXJnZXRCQ1IgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgaWYgKHRhcmdldEJDUi53aWR0aCB8fCB0YXJnZXRCQ1IuaGVpZ2h0KSB7XG4gICAgICAgICAgcmV0dXJuIFtNYW5pcHVsYXRvcltvZmZzZXRNZXRob2RdKHRhcmdldCkudG9wICsgb2Zmc2V0QmFzZSwgdGFyZ2V0U2VsZWN0b3JdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0pLmZpbHRlcihpdGVtID0+IGl0ZW0pLnNvcnQoKGEsIGIpID0+IGFbMF0gLSBiWzBdKS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgdGhpcy5fb2Zmc2V0cy5wdXNoKGl0ZW1bMF0pO1xuXG4gICAgICB0aGlzLl90YXJnZXRzLnB1c2goaXRlbVsxXSk7XG4gICAgfSk7XG4gIH1cblxuICBkaXNwb3NlKCkge1xuICAgIEV2ZW50SGFuZGxlci5vZmYodGhpcy5fc2Nyb2xsRWxlbWVudCwgRVZFTlRfS0VZJDIpO1xuICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgfSAvLyBQcml2YXRlXG5cblxuICBfZ2V0Q29uZmlnKGNvbmZpZykge1xuICAgIGNvbmZpZyA9IHsgLi4uRGVmYXVsdCQxLFxuICAgICAgLi4uTWFuaXB1bGF0b3IuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi4odHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgJiYgY29uZmlnID8gY29uZmlnIDoge30pXG4gICAgfTtcbiAgICBjb25maWcudGFyZ2V0ID0gZ2V0RWxlbWVudChjb25maWcudGFyZ2V0KSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgdHlwZUNoZWNrQ29uZmlnKE5BTUUkMiwgY29uZmlnLCBEZWZhdWx0VHlwZSQxKTtcbiAgICByZXR1cm4gY29uZmlnO1xuICB9XG5cbiAgX2dldFNjcm9sbFRvcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2Nyb2xsRWxlbWVudCA9PT0gd2luZG93ID8gdGhpcy5fc2Nyb2xsRWxlbWVudC5wYWdlWU9mZnNldCA6IHRoaXMuX3Njcm9sbEVsZW1lbnQuc2Nyb2xsVG9wO1xuICB9XG5cbiAgX2dldFNjcm9sbEhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2Nyb2xsRWxlbWVudC5zY3JvbGxIZWlnaHQgfHwgTWF0aC5tYXgoZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQsIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQpO1xuICB9XG5cbiAgX2dldE9mZnNldEhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2Nyb2xsRWxlbWVudCA9PT0gd2luZG93ID8gd2luZG93LmlubmVySGVpZ2h0IDogdGhpcy5fc2Nyb2xsRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gIH1cblxuICBfcHJvY2VzcygpIHtcbiAgICBjb25zdCBzY3JvbGxUb3AgPSB0aGlzLl9nZXRTY3JvbGxUb3AoKSArIHRoaXMuX2NvbmZpZy5vZmZzZXQ7XG5cbiAgICBjb25zdCBzY3JvbGxIZWlnaHQgPSB0aGlzLl9nZXRTY3JvbGxIZWlnaHQoKTtcblxuICAgIGNvbnN0IG1heFNjcm9sbCA9IHRoaXMuX2NvbmZpZy5vZmZzZXQgKyBzY3JvbGxIZWlnaHQgLSB0aGlzLl9nZXRPZmZzZXRIZWlnaHQoKTtcblxuICAgIGlmICh0aGlzLl9zY3JvbGxIZWlnaHQgIT09IHNjcm9sbEhlaWdodCkge1xuICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgfVxuXG4gICAgaWYgKHNjcm9sbFRvcCA+PSBtYXhTY3JvbGwpIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuX3RhcmdldHNbdGhpcy5fdGFyZ2V0cy5sZW5ndGggLSAxXTtcblxuICAgICAgaWYgKHRoaXMuX2FjdGl2ZVRhcmdldCAhPT0gdGFyZ2V0KSB7XG4gICAgICAgIHRoaXMuX2FjdGl2YXRlKHRhcmdldCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fYWN0aXZlVGFyZ2V0ICYmIHNjcm9sbFRvcCA8IHRoaXMuX29mZnNldHNbMF0gJiYgdGhpcy5fb2Zmc2V0c1swXSA+IDApIHtcbiAgICAgIHRoaXMuX2FjdGl2ZVRhcmdldCA9IG51bGw7XG5cbiAgICAgIHRoaXMuX2NsZWFyKCk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gdGhpcy5fb2Zmc2V0cy5sZW5ndGg7IGktLTspIHtcbiAgICAgIGNvbnN0IGlzQWN0aXZlVGFyZ2V0ID0gdGhpcy5fYWN0aXZlVGFyZ2V0ICE9PSB0aGlzLl90YXJnZXRzW2ldICYmIHNjcm9sbFRvcCA+PSB0aGlzLl9vZmZzZXRzW2ldICYmICh0eXBlb2YgdGhpcy5fb2Zmc2V0c1tpICsgMV0gPT09ICd1bmRlZmluZWQnIHx8IHNjcm9sbFRvcCA8IHRoaXMuX29mZnNldHNbaSArIDFdKTtcblxuICAgICAgaWYgKGlzQWN0aXZlVGFyZ2V0KSB7XG4gICAgICAgIHRoaXMuX2FjdGl2YXRlKHRoaXMuX3RhcmdldHNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9hY3RpdmF0ZSh0YXJnZXQpIHtcbiAgICB0aGlzLl9hY3RpdmVUYXJnZXQgPSB0YXJnZXQ7XG5cbiAgICB0aGlzLl9jbGVhcigpO1xuXG4gICAgY29uc3QgcXVlcmllcyA9IFNFTEVDVE9SX0xJTktfSVRFTVMuc3BsaXQoJywnKS5tYXAoc2VsZWN0b3IgPT4gYCR7c2VsZWN0b3J9W2RhdGEtYnMtdGFyZ2V0PVwiJHt0YXJnZXR9XCJdLCR7c2VsZWN0b3J9W2hyZWY9XCIke3RhcmdldH1cIl1gKTtcbiAgICBjb25zdCBsaW5rID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShxdWVyaWVzLmpvaW4oJywnKSwgdGhpcy5fY29uZmlnLnRhcmdldCk7XG4gICAgbGluay5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQUNUSVZFJDEpO1xuXG4gICAgaWYgKGxpbmsuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRFJPUERPV05fSVRFTSkpIHtcbiAgICAgIFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFJDEsIGxpbmsuY2xvc2VzdChTRUxFQ1RPUl9EUk9QRE9XTiQxKSkuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0FDVElWRSQxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgU2VsZWN0b3JFbmdpbmUucGFyZW50cyhsaW5rLCBTRUxFQ1RPUl9OQVZfTElTVF9HUk9VUCQxKS5mb3JFYWNoKGxpc3RHcm91cCA9PiB7XG4gICAgICAgIC8vIFNldCB0cmlnZ2VyZWQgbGlua3MgcGFyZW50cyBhcyBhY3RpdmVcbiAgICAgICAgLy8gV2l0aCBib3RoIDx1bD4gYW5kIDxuYXY+IG1hcmt1cCBhIHBhcmVudCBpcyB0aGUgcHJldmlvdXMgc2libGluZyBvZiBhbnkgbmF2IGFuY2VzdG9yXG4gICAgICAgIFNlbGVjdG9yRW5naW5lLnByZXYobGlzdEdyb3VwLCBgJHtTRUxFQ1RPUl9OQVZfTElOS1N9LCAke1NFTEVDVE9SX0xJU1RfSVRFTVN9YCkuZm9yRWFjaChpdGVtID0+IGl0ZW0uY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0FDVElWRSQxKSk7IC8vIEhhbmRsZSBzcGVjaWFsIGNhc2Ugd2hlbiAubmF2LWxpbmsgaXMgaW5zaWRlIC5uYXYtaXRlbVxuXG4gICAgICAgIFNlbGVjdG9yRW5naW5lLnByZXYobGlzdEdyb3VwLCBTRUxFQ1RPUl9OQVZfSVRFTVMpLmZvckVhY2gobmF2SXRlbSA9PiB7XG4gICAgICAgICAgU2VsZWN0b3JFbmdpbmUuY2hpbGRyZW4obmF2SXRlbSwgU0VMRUNUT1JfTkFWX0xJTktTKS5mb3JFYWNoKGl0ZW0gPT4gaXRlbS5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQUNUSVZFJDEpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9zY3JvbGxFbGVtZW50LCBFVkVOVF9BQ1RJVkFURSwge1xuICAgICAgcmVsYXRlZFRhcmdldDogdGFyZ2V0XG4gICAgfSk7XG4gIH1cblxuICBfY2xlYXIoKSB7XG4gICAgU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9MSU5LX0lURU1TLCB0aGlzLl9jb25maWcudGFyZ2V0KS5maWx0ZXIobm9kZSA9PiBub2RlLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0FDVElWRSQxKSkuZm9yRWFjaChub2RlID0+IG5vZGUuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0FDVElWRSQxKSk7XG4gIH0gLy8gU3RhdGljXG5cblxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgZGF0YSA9IFNjcm9sbFNweS5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIGNvbmZpZyk7XG5cbiAgICAgIGlmICh0eXBlb2YgY29uZmlnICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xuICAgICAgfVxuXG4gICAgICBkYXRhW2NvbmZpZ10oKTtcbiAgICB9KTtcbiAgfVxuXG59XG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogRGF0YSBBcGkgaW1wbGVtZW50YXRpb25cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cblxuRXZlbnRIYW5kbGVyLm9uKHdpbmRvdywgRVZFTlRfTE9BRF9EQVRBX0FQSSwgKCkgPT4ge1xuICBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0RBVEFfU1BZKS5mb3JFYWNoKHNweSA9PiBuZXcgU2Nyb2xsU3B5KHNweSkpO1xufSk7XG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogalF1ZXJ5XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIGFkZCAuU2Nyb2xsU3B5IHRvIGpRdWVyeSBvbmx5IGlmIGpRdWVyeSBpcyBwcmVzZW50XG4gKi9cblxuZGVmaW5lSlF1ZXJ5UGx1Z2luKFNjcm9sbFNweSk7XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjUuMS4zKTogdGFiLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb25zdGFudHNcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNvbnN0IE5BTUUkMSA9ICd0YWInO1xuY29uc3QgREFUQV9LRVkkMSA9ICdicy50YWInO1xuY29uc3QgRVZFTlRfS0VZJDEgPSBgLiR7REFUQV9LRVkkMX1gO1xuY29uc3QgREFUQV9BUElfS0VZID0gJy5kYXRhLWFwaSc7XG5jb25zdCBFVkVOVF9ISURFJDEgPSBgaGlkZSR7RVZFTlRfS0VZJDF9YDtcbmNvbnN0IEVWRU5UX0hJRERFTiQxID0gYGhpZGRlbiR7RVZFTlRfS0VZJDF9YDtcbmNvbnN0IEVWRU5UX1NIT1ckMSA9IGBzaG93JHtFVkVOVF9LRVkkMX1gO1xuY29uc3QgRVZFTlRfU0hPV04kMSA9IGBzaG93biR7RVZFTlRfS0VZJDF9YDtcbmNvbnN0IEVWRU5UX0NMSUNLX0RBVEFfQVBJID0gYGNsaWNrJHtFVkVOVF9LRVkkMX0ke0RBVEFfQVBJX0tFWX1gO1xuY29uc3QgQ0xBU1NfTkFNRV9EUk9QRE9XTl9NRU5VID0gJ2Ryb3Bkb3duLW1lbnUnO1xuY29uc3QgQ0xBU1NfTkFNRV9BQ1RJVkUgPSAnYWN0aXZlJztcbmNvbnN0IENMQVNTX05BTUVfRkFERSQxID0gJ2ZhZGUnO1xuY29uc3QgQ0xBU1NfTkFNRV9TSE9XJDEgPSAnc2hvdyc7XG5jb25zdCBTRUxFQ1RPUl9EUk9QRE9XTiA9ICcuZHJvcGRvd24nO1xuY29uc3QgU0VMRUNUT1JfTkFWX0xJU1RfR1JPVVAgPSAnLm5hdiwgLmxpc3QtZ3JvdXAnO1xuY29uc3QgU0VMRUNUT1JfQUNUSVZFID0gJy5hY3RpdmUnO1xuY29uc3QgU0VMRUNUT1JfQUNUSVZFX1VMID0gJzpzY29wZSA+IGxpID4gLmFjdGl2ZSc7XG5jb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSA9ICdbZGF0YS1icy10b2dnbGU9XCJ0YWJcIl0sIFtkYXRhLWJzLXRvZ2dsZT1cInBpbGxcIl0sIFtkYXRhLWJzLXRvZ2dsZT1cImxpc3RcIl0nO1xuY29uc3QgU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFID0gJy5kcm9wZG93bi10b2dnbGUnO1xuY29uc3QgU0VMRUNUT1JfRFJPUERPV05fQUNUSVZFX0NISUxEID0gJzpzY29wZSA+IC5kcm9wZG93bi1tZW51IC5hY3RpdmUnO1xuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENsYXNzIERlZmluaXRpb25cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmNsYXNzIFRhYiBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gTkFNRSQxO1xuICB9IC8vIFB1YmxpY1xuXG5cbiAgc2hvdygpIHtcbiAgICBpZiAodGhpcy5fZWxlbWVudC5wYXJlbnROb2RlICYmIHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgJiYgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9BQ1RJVkUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IHByZXZpb3VzO1xuICAgIGNvbnN0IHRhcmdldCA9IGdldEVsZW1lbnRGcm9tU2VsZWN0b3IodGhpcy5fZWxlbWVudCk7XG5cbiAgICBjb25zdCBsaXN0RWxlbWVudCA9IHRoaXMuX2VsZW1lbnQuY2xvc2VzdChTRUxFQ1RPUl9OQVZfTElTVF9HUk9VUCk7XG5cbiAgICBpZiAobGlzdEVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IGl0ZW1TZWxlY3RvciA9IGxpc3RFbGVtZW50Lm5vZGVOYW1lID09PSAnVUwnIHx8IGxpc3RFbGVtZW50Lm5vZGVOYW1lID09PSAnT0wnID8gU0VMRUNUT1JfQUNUSVZFX1VMIDogU0VMRUNUT1JfQUNUSVZFO1xuICAgICAgcHJldmlvdXMgPSBTZWxlY3RvckVuZ2luZS5maW5kKGl0ZW1TZWxlY3RvciwgbGlzdEVsZW1lbnQpO1xuICAgICAgcHJldmlvdXMgPSBwcmV2aW91c1twcmV2aW91cy5sZW5ndGggLSAxXTtcbiAgICB9XG5cbiAgICBjb25zdCBoaWRlRXZlbnQgPSBwcmV2aW91cyA/IEV2ZW50SGFuZGxlci50cmlnZ2VyKHByZXZpb3VzLCBFVkVOVF9ISURFJDEsIHtcbiAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRoaXMuX2VsZW1lbnRcbiAgICB9KSA6IG51bGw7XG4gICAgY29uc3Qgc2hvd0V2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPVyQxLCB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiBwcmV2aW91c1xuICAgIH0pO1xuXG4gICAgaWYgKHNob3dFdmVudC5kZWZhdWx0UHJldmVudGVkIHx8IGhpZGVFdmVudCAhPT0gbnVsbCAmJiBoaWRlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2FjdGl2YXRlKHRoaXMuX2VsZW1lbnQsIGxpc3RFbGVtZW50KTtcblxuICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIocHJldmlvdXMsIEVWRU5UX0hJRERFTiQxLCB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRoaXMuX2VsZW1lbnRcbiAgICAgIH0pO1xuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPV04kMSwge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiBwcmV2aW91c1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIHRoaXMuX2FjdGl2YXRlKHRhcmdldCwgdGFyZ2V0LnBhcmVudE5vZGUsIGNvbXBsZXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcGxldGUoKTtcbiAgICB9XG4gIH0gLy8gUHJpdmF0ZVxuXG5cbiAgX2FjdGl2YXRlKGVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBhY3RpdmVFbGVtZW50cyA9IGNvbnRhaW5lciAmJiAoY29udGFpbmVyLm5vZGVOYW1lID09PSAnVUwnIHx8IGNvbnRhaW5lci5ub2RlTmFtZSA9PT0gJ09MJykgPyBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0FDVElWRV9VTCwgY29udGFpbmVyKSA6IFNlbGVjdG9yRW5naW5lLmNoaWxkcmVuKGNvbnRhaW5lciwgU0VMRUNUT1JfQUNUSVZFKTtcbiAgICBjb25zdCBhY3RpdmUgPSBhY3RpdmVFbGVtZW50c1swXTtcbiAgICBjb25zdCBpc1RyYW5zaXRpb25pbmcgPSBjYWxsYmFjayAmJiBhY3RpdmUgJiYgYWN0aXZlLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0ZBREUkMSk7XG5cbiAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHRoaXMuX3RyYW5zaXRpb25Db21wbGV0ZShlbGVtZW50LCBhY3RpdmUsIGNhbGxiYWNrKTtcblxuICAgIGlmIChhY3RpdmUgJiYgaXNUcmFuc2l0aW9uaW5nKSB7XG4gICAgICBhY3RpdmUuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1ckMSk7XG5cbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIGVsZW1lbnQsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21wbGV0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIF90cmFuc2l0aW9uQ29tcGxldGUoZWxlbWVudCwgYWN0aXZlLCBjYWxsYmFjaykge1xuICAgIGlmIChhY3RpdmUpIHtcbiAgICAgIGFjdGl2ZS5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQUNUSVZFKTtcbiAgICAgIGNvbnN0IGRyb3Bkb3duQ2hpbGQgPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0RST1BET1dOX0FDVElWRV9DSElMRCwgYWN0aXZlLnBhcmVudE5vZGUpO1xuXG4gICAgICBpZiAoZHJvcGRvd25DaGlsZCkge1xuICAgICAgICBkcm9wZG93bkNoaWxkLmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9BQ1RJVkUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWN0aXZlLmdldEF0dHJpYnV0ZSgncm9sZScpID09PSAndGFiJykge1xuICAgICAgICBhY3RpdmUuc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJywgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0FDVElWRSk7XG5cbiAgICBpZiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3JvbGUnKSA9PT0gJ3RhYicpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmVmbG93KGVsZW1lbnQpO1xuXG4gICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRkFERSQxKSkge1xuICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVyQxKTtcbiAgICB9XG5cbiAgICBsZXQgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuXG4gICAgaWYgKHBhcmVudCAmJiBwYXJlbnQubm9kZU5hbWUgPT09ICdMSScpIHtcbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIGlmIChwYXJlbnQgJiYgcGFyZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0RST1BET1dOX01FTlUpKSB7XG4gICAgICBjb25zdCBkcm9wZG93bkVsZW1lbnQgPSBlbGVtZW50LmNsb3Nlc3QoU0VMRUNUT1JfRFJPUERPV04pO1xuXG4gICAgICBpZiAoZHJvcGRvd25FbGVtZW50KSB7XG4gICAgICAgIFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFLCBkcm9wZG93bkVsZW1lbnQpLmZvckVhY2goZHJvcGRvd24gPT4gZHJvcGRvd24uY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0FDVElWRSkpO1xuICAgICAgfVxuXG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIHRydWUpO1xuICAgIH1cblxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gIH0gLy8gU3RhdGljXG5cblxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgZGF0YSA9IFRhYi5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMpO1xuXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGFbY29uZmlnXSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbn1cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBEYXRhIEFwaSBpbXBsZW1lbnRhdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuXG5FdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJLCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gIGlmIChbJ0EnLCAnQVJFQSddLmluY2x1ZGVzKHRoaXMudGFnTmFtZSkpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG5cbiAgaWYgKGlzRGlzYWJsZWQodGhpcykpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBkYXRhID0gVGFiLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcyk7XG4gIGRhdGEuc2hvdygpO1xufSk7XG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogalF1ZXJ5XG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIGFkZCAuVGFiIHRvIGpRdWVyeSBvbmx5IGlmIGpRdWVyeSBpcyBwcmVzZW50XG4gKi9cblxuZGVmaW5lSlF1ZXJ5UGx1Z2luKFRhYik7XG5cbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjUuMS4zKTogdG9hc3QuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvbnN0YW50c1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY29uc3QgTkFNRSA9ICd0b2FzdCc7XG5jb25zdCBEQVRBX0tFWSA9ICdicy50b2FzdCc7XG5jb25zdCBFVkVOVF9LRVkgPSBgLiR7REFUQV9LRVl9YDtcbmNvbnN0IEVWRU5UX01PVVNFT1ZFUiA9IGBtb3VzZW92ZXIke0VWRU5UX0tFWX1gO1xuY29uc3QgRVZFTlRfTU9VU0VPVVQgPSBgbW91c2VvdXQke0VWRU5UX0tFWX1gO1xuY29uc3QgRVZFTlRfRk9DVVNJTiA9IGBmb2N1c2luJHtFVkVOVF9LRVl9YDtcbmNvbnN0IEVWRU5UX0ZPQ1VTT1VUID0gYGZvY3Vzb3V0JHtFVkVOVF9LRVl9YDtcbmNvbnN0IEVWRU5UX0hJREUgPSBgaGlkZSR7RVZFTlRfS0VZfWA7XG5jb25zdCBFVkVOVF9ISURERU4gPSBgaGlkZGVuJHtFVkVOVF9LRVl9YDtcbmNvbnN0IEVWRU5UX1NIT1cgPSBgc2hvdyR7RVZFTlRfS0VZfWA7XG5jb25zdCBFVkVOVF9TSE9XTiA9IGBzaG93biR7RVZFTlRfS0VZfWA7XG5jb25zdCBDTEFTU19OQU1FX0ZBREUgPSAnZmFkZSc7XG5jb25zdCBDTEFTU19OQU1FX0hJREUgPSAnaGlkZSc7IC8vIEBkZXByZWNhdGVkIC0ga2VwdCBoZXJlIG9ubHkgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5cbmNvbnN0IENMQVNTX05BTUVfU0hPVyA9ICdzaG93JztcbmNvbnN0IENMQVNTX05BTUVfU0hPV0lORyA9ICdzaG93aW5nJztcbmNvbnN0IERlZmF1bHRUeXBlID0ge1xuICBhbmltYXRpb246ICdib29sZWFuJyxcbiAgYXV0b2hpZGU6ICdib29sZWFuJyxcbiAgZGVsYXk6ICdudW1iZXInXG59O1xuY29uc3QgRGVmYXVsdCA9IHtcbiAgYW5pbWF0aW9uOiB0cnVlLFxuICBhdXRvaGlkZTogdHJ1ZSxcbiAgZGVsYXk6IDUwMDBcbn07XG4vKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ2xhc3MgRGVmaW5pdGlvblxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuY2xhc3MgVG9hc3QgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgc3VwZXIoZWxlbWVudCk7XG4gICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZyk7XG4gICAgdGhpcy5fdGltZW91dCA9IG51bGw7XG4gICAgdGhpcy5faGFzTW91c2VJbnRlcmFjdGlvbiA9IGZhbHNlO1xuICAgIHRoaXMuX2hhc0tleWJvYXJkSW50ZXJhY3Rpb24gPSBmYWxzZTtcblxuICAgIHRoaXMuX3NldExpc3RlbmVycygpO1xuICB9IC8vIEdldHRlcnNcblxuXG4gIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgcmV0dXJuIERlZmF1bHRUeXBlO1xuICB9XG5cbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBEZWZhdWx0O1xuICB9XG5cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBOQU1FO1xuICB9IC8vIFB1YmxpY1xuXG5cbiAgc2hvdygpIHtcbiAgICBjb25zdCBzaG93RXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XKTtcblxuICAgIGlmIChzaG93RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2NsZWFyVGltZW91dCgpO1xuXG4gICAgaWYgKHRoaXMuX2NvbmZpZy5hbmltYXRpb24pIHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0ZBREUpO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPV0lORyk7XG5cbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1dOKTtcblxuICAgICAgdGhpcy5fbWF5YmVTY2hlZHVsZUhpZGUoKTtcbiAgICB9O1xuXG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfSElERSk7IC8vIEBkZXByZWNhdGVkXG5cblxuICAgIHJlZmxvdyh0aGlzLl9lbGVtZW50KTtcblxuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1cpO1xuXG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPV0lORyk7XG5cbiAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGNvbXBsZXRlLCB0aGlzLl9lbGVtZW50LCB0aGlzLl9jb25maWcuYW5pbWF0aW9uKTtcbiAgfVxuXG4gIGhpZGUoKSB7XG4gICAgaWYgKCF0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NIT1cpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgaGlkZUV2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElERSk7XG5cbiAgICBpZiAoaGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0hJREUpOyAvLyBAZGVwcmVjYXRlZFxuXG5cbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1dJTkcpO1xuXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XKTtcblxuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElEREVOKTtcbiAgICB9O1xuXG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPV0lORyk7XG5cbiAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGNvbXBsZXRlLCB0aGlzLl9lbGVtZW50LCB0aGlzLl9jb25maWcuYW5pbWF0aW9uKTtcbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fY2xlYXJUaW1lb3V0KCk7XG5cbiAgICBpZiAodGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TSE9XKSkge1xuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyk7XG4gICAgfVxuXG4gICAgc3VwZXIuZGlzcG9zZSgpO1xuICB9IC8vIFByaXZhdGVcblxuXG4gIF9nZXRDb25maWcoY29uZmlnKSB7XG4gICAgY29uZmlnID0geyAuLi5EZWZhdWx0LFxuICAgICAgLi4uTWFuaXB1bGF0b3IuZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi4odHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgJiYgY29uZmlnID8gY29uZmlnIDoge30pXG4gICAgfTtcbiAgICB0eXBlQ2hlY2tDb25maWcoTkFNRSwgY29uZmlnLCB0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRUeXBlKTtcbiAgICByZXR1cm4gY29uZmlnO1xuICB9XG5cbiAgX21heWJlU2NoZWR1bGVIaWRlKCkge1xuICAgIGlmICghdGhpcy5fY29uZmlnLmF1dG9oaWRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2hhc01vdXNlSW50ZXJhY3Rpb24gfHwgdGhpcy5faGFzS2V5Ym9hcmRJbnRlcmFjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH0sIHRoaXMuX2NvbmZpZy5kZWxheSk7XG4gIH1cblxuICBfb25JbnRlcmFjdGlvbihldmVudCwgaXNJbnRlcmFjdGluZykge1xuICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgY2FzZSAnbW91c2VvdmVyJzpcbiAgICAgIGNhc2UgJ21vdXNlb3V0JzpcbiAgICAgICAgdGhpcy5faGFzTW91c2VJbnRlcmFjdGlvbiA9IGlzSW50ZXJhY3Rpbmc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdmb2N1c2luJzpcbiAgICAgIGNhc2UgJ2ZvY3Vzb3V0JzpcbiAgICAgICAgdGhpcy5faGFzS2V5Ym9hcmRJbnRlcmFjdGlvbiA9IGlzSW50ZXJhY3Rpbmc7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChpc0ludGVyYWN0aW5nKSB7XG4gICAgICB0aGlzLl9jbGVhclRpbWVvdXQoKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG5leHRFbGVtZW50ID0gZXZlbnQucmVsYXRlZFRhcmdldDtcblxuICAgIGlmICh0aGlzLl9lbGVtZW50ID09PSBuZXh0RWxlbWVudCB8fCB0aGlzLl9lbGVtZW50LmNvbnRhaW5zKG5leHRFbGVtZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX21heWJlU2NoZWR1bGVIaWRlKCk7XG4gIH1cblxuICBfc2V0TGlzdGVuZXJzKCkge1xuICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9NT1VTRU9WRVIsIGV2ZW50ID0+IHRoaXMuX29uSW50ZXJhY3Rpb24oZXZlbnQsIHRydWUpKTtcbiAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfTU9VU0VPVVQsIGV2ZW50ID0+IHRoaXMuX29uSW50ZXJhY3Rpb24oZXZlbnQsIGZhbHNlKSk7XG4gICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0ZPQ1VTSU4sIGV2ZW50ID0+IHRoaXMuX29uSW50ZXJhY3Rpb24oZXZlbnQsIHRydWUpKTtcbiAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfRk9DVVNPVVQsIGV2ZW50ID0+IHRoaXMuX29uSW50ZXJhY3Rpb24oZXZlbnQsIGZhbHNlKSk7XG4gIH1cblxuICBfY2xlYXJUaW1lb3V0KCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcbiAgICB0aGlzLl90aW1lb3V0ID0gbnVsbDtcbiAgfSAvLyBTdGF0aWNcblxuXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCBkYXRhID0gVG9hc3QuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCBjb25maWcpO1xuXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGFbY29uZmlnXSh0aGlzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG59XG5cbmVuYWJsZURpc21pc3NUcmlnZ2VyKFRvYXN0KTtcbi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBqUXVlcnlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogYWRkIC5Ub2FzdCB0byBqUXVlcnkgb25seSBpZiBqUXVlcnkgaXMgcHJlc2VudFxuICovXG5cbmRlZmluZUpRdWVyeVBsdWdpbihUb2FzdCk7XG5cbmV4cG9ydCB7IEFsZXJ0LCBCdXR0b24sIENhcm91c2VsLCBDb2xsYXBzZSwgRHJvcGRvd24sIE1vZGFsLCBPZmZjYW52YXMsIFBvcG92ZXIsIFNjcm9sbFNweSwgVGFiLCBUb2FzdCwgVG9vbHRpcCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ym9vdHN0cmFwLmVzbS5qcy5tYXBcbiIsIi8qIVxuICogS25vY2tvdXQgSmF2YVNjcmlwdCBsaWJyYXJ5IHYzLjUuMVxuICogKGMpIFRoZSBLbm9ja291dC5qcyB0ZWFtIC0gaHR0cDovL2tub2Nrb3V0anMuY29tL1xuICogTGljZW5zZTogTUlUIChodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocClcbiAqL1xuXG4oZnVuY3Rpb24oKSB7KGZ1bmN0aW9uKG4pe3ZhciBBPXRoaXN8fCgwLGV2YWwpKFwidGhpc1wiKSx3PUEuZG9jdW1lbnQsUj1BLm5hdmlnYXRvcix2PUEualF1ZXJ5LEg9QS5KU09OO3Z8fFwidW5kZWZpbmVkXCI9PT10eXBlb2YgalF1ZXJ5fHwodj1qUXVlcnkpOyhmdW5jdGlvbihuKXtcImZ1bmN0aW9uXCI9PT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXCJleHBvcnRzXCIsXCJyZXF1aXJlXCJdLG4pOlwib2JqZWN0XCI9PT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09PXR5cGVvZiBtb2R1bGU/bihtb2R1bGUuZXhwb3J0c3x8ZXhwb3J0cyk6bihBLmtvPXt9KX0pKGZ1bmN0aW9uKFMsVCl7ZnVuY3Rpb24gSyhhLGMpe3JldHVybiBudWxsPT09YXx8dHlwZW9mIGEgaW4gVz9hPT09YzohMX1mdW5jdGlvbiBYKGIsYyl7dmFyIGQ7cmV0dXJuIGZ1bmN0aW9uKCl7ZHx8KGQ9YS5hLnNldFRpbWVvdXQoZnVuY3Rpb24oKXtkPW47YigpfSxjKSl9fWZ1bmN0aW9uIFkoYixjKXt2YXIgZDtyZXR1cm4gZnVuY3Rpb24oKXtjbGVhclRpbWVvdXQoZCk7XG5kPWEuYS5zZXRUaW1lb3V0KGIsYyl9fWZ1bmN0aW9uIFooYSxjKXtjJiZcImNoYW5nZVwiIT09Yz9cImJlZm9yZUNoYW5nZVwiPT09Yz90aGlzLnBjKGEpOnRoaXMuZ2IoYSxjKTp0aGlzLnFjKGEpfWZ1bmN0aW9uIGFhKGEsYyl7bnVsbCE9PWMmJmMucyYmYy5zKCl9ZnVuY3Rpb24gYmEoYSxjKXt2YXIgZD10aGlzLnFkLGU9ZFtyXTtlLnJhfHwodGhpcy5RYiYmdGhpcy5tYltjXT8oZC51YyhjLGEsdGhpcy5tYltjXSksdGhpcy5tYltjXT1udWxsLC0tdGhpcy5RYik6ZS5JW2NdfHxkLnVjKGMsYSxlLko/e2RhOmF9OmQuJGMoYSkpLGEuSmEmJmEuZ2QoKSl9dmFyIGE9XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBTP1M6e307YS5iPWZ1bmN0aW9uKGIsYyl7Zm9yKHZhciBkPWIuc3BsaXQoXCIuXCIpLGU9YSxmPTA7ZjxkLmxlbmd0aC0xO2YrKyllPWVbZFtmXV07ZVtkW2QubGVuZ3RoLTFdXT1jfTthLkw9ZnVuY3Rpb24oYSxjLGQpe2FbY109ZH07YS52ZXJzaW9uPVwiMy41LjFcIjthLmIoXCJ2ZXJzaW9uXCIsXG5hLnZlcnNpb24pO2Eub3B0aW9ucz17ZGVmZXJVcGRhdGVzOiExLHVzZU9ubHlOYXRpdmVFdmVudHM6ITEsZm9yZWFjaEhpZGVzRGVzdHJveWVkOiExfTthLmE9ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGEsYil7Zm9yKHZhciBjIGluIGEpZi5jYWxsKGEsYykmJmIoYyxhW2NdKX1mdW5jdGlvbiBjKGEsYil7aWYoYilmb3IodmFyIGMgaW4gYilmLmNhbGwoYixjKSYmKGFbY109YltjXSk7cmV0dXJuIGF9ZnVuY3Rpb24gZChhLGIpe2EuX19wcm90b19fPWI7cmV0dXJuIGF9ZnVuY3Rpb24gZShiLGMsZCxlKXt2YXIgbD1iW2NdLm1hdGNoKHEpfHxbXTthLmEuRChkLm1hdGNoKHEpLGZ1bmN0aW9uKGIpe2EuYS5OYShsLGIsZSl9KTtiW2NdPWwuam9pbihcIiBcIil9dmFyIGY9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxnPXtfX3Byb3RvX186W119aW5zdGFuY2VvZiBBcnJheSxoPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBTeW1ib2wsbT17fSxrPXt9O21bUiYmL0ZpcmVmb3hcXC8yL2kudGVzdChSLnVzZXJBZ2VudCk/XG5cIktleWJvYXJkRXZlbnRcIjpcIlVJRXZlbnRzXCJdPVtcImtleXVwXCIsXCJrZXlkb3duXCIsXCJrZXlwcmVzc1wiXTttLk1vdXNlRXZlbnRzPVwiY2xpY2sgZGJsY2xpY2sgbW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmVcIi5zcGxpdChcIiBcIik7YihtLGZ1bmN0aW9uKGEsYil7aWYoYi5sZW5ndGgpZm9yKHZhciBjPTAsZD1iLmxlbmd0aDtjPGQ7YysrKWtbYltjXV09YX0pO3ZhciBsPXtwcm9wZXJ0eWNoYW5nZTohMH0scD13JiZmdW5jdGlvbigpe2Zvcih2YXIgYT0zLGI9dy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLGM9Yi5nZXRFbGVtZW50c0J5VGFnTmFtZShcImlcIik7Yi5pbm5lckhUTUw9XCJcXHgzYyEtLVtpZiBndCBJRSBcIisgKythK1wiXT48aT48L2k+PCFbZW5kaWZdLS1cXHgzZVwiLGNbMF07KTtyZXR1cm4gNDxhP2E6bn0oKSxxPS9cXFMrL2csdDtyZXR1cm57SmM6W1wiYXV0aGVudGljaXR5X3Rva2VuXCIsL15fX1JlcXVlc3RWZXJpZmljYXRpb25Ub2tlbihfLiopPyQvXSxcbkQ6ZnVuY3Rpb24oYSxiLGMpe2Zvcih2YXIgZD0wLGU9YS5sZW5ndGg7ZDxlO2QrKyliLmNhbGwoYyxhW2RdLGQsYSl9LEE6XCJmdW5jdGlvblwiPT10eXBlb2YgQXJyYXkucHJvdG90eXBlLmluZGV4T2Y/ZnVuY3Rpb24oYSxiKXtyZXR1cm4gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChhLGIpfTpmdW5jdGlvbihhLGIpe2Zvcih2YXIgYz0wLGQ9YS5sZW5ndGg7YzxkO2MrKylpZihhW2NdPT09YilyZXR1cm4gYztyZXR1cm4tMX0sTGI6ZnVuY3Rpb24oYSxiLGMpe2Zvcih2YXIgZD0wLGU9YS5sZW5ndGg7ZDxlO2QrKylpZihiLmNhbGwoYyxhW2RdLGQsYSkpcmV0dXJuIGFbZF07cmV0dXJuIG59LFBhOmZ1bmN0aW9uKGIsYyl7dmFyIGQ9YS5hLkEoYixjKTswPGQ/Yi5zcGxpY2UoZCwxKTowPT09ZCYmYi5zaGlmdCgpfSx3YzpmdW5jdGlvbihiKXt2YXIgYz1bXTtiJiZhLmEuRChiLGZ1bmN0aW9uKGIpezA+YS5hLkEoYyxiKSYmYy5wdXNoKGIpfSk7cmV0dXJuIGN9LE1iOmZ1bmN0aW9uKGEsXG5iLGMpe3ZhciBkPVtdO2lmKGEpZm9yKHZhciBlPTAsbD1hLmxlbmd0aDtlPGw7ZSsrKWQucHVzaChiLmNhbGwoYyxhW2VdLGUpKTtyZXR1cm4gZH0samI6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPVtdO2lmKGEpZm9yKHZhciBlPTAsbD1hLmxlbmd0aDtlPGw7ZSsrKWIuY2FsbChjLGFbZV0sZSkmJmQucHVzaChhW2VdKTtyZXR1cm4gZH0sTmI6ZnVuY3Rpb24oYSxiKXtpZihiIGluc3RhbmNlb2YgQXJyYXkpYS5wdXNoLmFwcGx5KGEsYik7ZWxzZSBmb3IodmFyIGM9MCxkPWIubGVuZ3RoO2M8ZDtjKyspYS5wdXNoKGJbY10pO3JldHVybiBhfSxOYTpmdW5jdGlvbihiLGMsZCl7dmFyIGU9YS5hLkEoYS5hLmJjKGIpLGMpOzA+ZT9kJiZiLnB1c2goYyk6ZHx8Yi5zcGxpY2UoZSwxKX0sQmE6ZyxleHRlbmQ6YyxzZXRQcm90b3R5cGVPZjpkLEFiOmc/ZDpjLFA6YixHYTpmdW5jdGlvbihhLGIsYyl7aWYoIWEpcmV0dXJuIGE7dmFyIGQ9e30sZTtmb3IoZSBpbiBhKWYuY2FsbChhLGUpJiYoZFtlXT1cbmIuY2FsbChjLGFbZV0sZSxhKSk7cmV0dXJuIGR9LFRiOmZ1bmN0aW9uKGIpe2Zvcig7Yi5maXJzdENoaWxkOylhLnJlbW92ZU5vZGUoYi5maXJzdENoaWxkKX0sWWI6ZnVuY3Rpb24oYil7Yj1hLmEubGEoYik7Zm9yKHZhciBjPShiWzBdJiZiWzBdLm93bmVyRG9jdW1lbnR8fHcpLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksZD0wLGU9Yi5sZW5ndGg7ZDxlO2QrKyljLmFwcGVuZENoaWxkKGEub2EoYltkXSkpO3JldHVybiBjfSxDYTpmdW5jdGlvbihiLGMpe2Zvcih2YXIgZD0wLGU9Yi5sZW5ndGgsbD1bXTtkPGU7ZCsrKXt2YXIgaz1iW2RdLmNsb25lTm9kZSghMCk7bC5wdXNoKGM/YS5vYShrKTprKX1yZXR1cm4gbH0sdmE6ZnVuY3Rpb24oYixjKXthLmEuVGIoYik7aWYoYylmb3IodmFyIGQ9MCxlPWMubGVuZ3RoO2Q8ZTtkKyspYi5hcHBlbmRDaGlsZChjW2RdKX0sWGM6ZnVuY3Rpb24oYixjKXt2YXIgZD1iLm5vZGVUeXBlP1tiXTpiO2lmKDA8ZC5sZW5ndGgpe2Zvcih2YXIgZT1kWzBdLFxubD1lLnBhcmVudE5vZGUsaz0wLGY9Yy5sZW5ndGg7azxmO2srKylsLmluc2VydEJlZm9yZShjW2tdLGUpO2s9MDtmb3IoZj1kLmxlbmd0aDtrPGY7aysrKWEucmVtb3ZlTm9kZShkW2tdKX19LFVhOmZ1bmN0aW9uKGEsYil7aWYoYS5sZW5ndGgpe2ZvcihiPTg9PT1iLm5vZGVUeXBlJiZiLnBhcmVudE5vZGV8fGI7YS5sZW5ndGgmJmFbMF0ucGFyZW50Tm9kZSE9PWI7KWEuc3BsaWNlKDAsMSk7Zm9yKDsxPGEubGVuZ3RoJiZhW2EubGVuZ3RoLTFdLnBhcmVudE5vZGUhPT1iOylhLmxlbmd0aC0tO2lmKDE8YS5sZW5ndGgpe3ZhciBjPWFbMF0sZD1hW2EubGVuZ3RoLTFdO2ZvcihhLmxlbmd0aD0wO2MhPT1kOylhLnB1c2goYyksYz1jLm5leHRTaWJsaW5nO2EucHVzaChkKX19cmV0dXJuIGF9LFpjOmZ1bmN0aW9uKGEsYil7Nz5wP2Euc2V0QXR0cmlidXRlKFwic2VsZWN0ZWRcIixiKTphLnNlbGVjdGVkPWJ9LERiOmZ1bmN0aW9uKGEpe3JldHVybiBudWxsPT09YXx8YT09PW4/XCJcIjphLnRyaW0/XG5hLnRyaW0oKTphLnRvU3RyaW5nKCkucmVwbGFjZSgvXltcXHNcXHhhMF0rfFtcXHNcXHhhMF0rJC9nLFwiXCIpfSxVZDpmdW5jdGlvbihhLGIpe2E9YXx8XCJcIjtyZXR1cm4gYi5sZW5ndGg+YS5sZW5ndGg/ITE6YS5zdWJzdHJpbmcoMCxiLmxlbmd0aCk9PT1ifSx2ZDpmdW5jdGlvbihhLGIpe2lmKGE9PT1iKXJldHVybiEwO2lmKDExPT09YS5ub2RlVHlwZSlyZXR1cm4hMTtpZihiLmNvbnRhaW5zKXJldHVybiBiLmNvbnRhaW5zKDEhPT1hLm5vZGVUeXBlP2EucGFyZW50Tm9kZTphKTtpZihiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKXJldHVybiAxNj09KGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYSkmMTYpO2Zvcig7YSYmYSE9YjspYT1hLnBhcmVudE5vZGU7cmV0dXJuISFhfSxTYjpmdW5jdGlvbihiKXtyZXR1cm4gYS5hLnZkKGIsYi5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCl9LGtkOmZ1bmN0aW9uKGIpe3JldHVybiEhYS5hLkxiKGIsYS5hLlNiKX0sUjpmdW5jdGlvbihhKXtyZXR1cm4gYSYmXG5hLnRhZ05hbWUmJmEudGFnTmFtZS50b0xvd2VyQ2FzZSgpfSxBYzpmdW5jdGlvbihiKXtyZXR1cm4gYS5vbkVycm9yP2Z1bmN0aW9uKCl7dHJ5e3JldHVybiBiLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1jYXRjaChjKXt0aHJvdyBhLm9uRXJyb3ImJmEub25FcnJvcihjKSxjO319OmJ9LHNldFRpbWVvdXQ6ZnVuY3Rpb24oYixjKXtyZXR1cm4gc2V0VGltZW91dChhLmEuQWMoYiksYyl9LEdjOmZ1bmN0aW9uKGIpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXthLm9uRXJyb3ImJmEub25FcnJvcihiKTt0aHJvdyBiO30sMCl9LEI6ZnVuY3Rpb24oYixjLGQpe3ZhciBlPWEuYS5BYyhkKTtkPWxbY107aWYoYS5vcHRpb25zLnVzZU9ubHlOYXRpdmVFdmVudHN8fGR8fCF2KWlmKGR8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIGIuYWRkRXZlbnRMaXN0ZW5lcilpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgYi5hdHRhY2hFdmVudCl7dmFyIGs9ZnVuY3Rpb24oYSl7ZS5jYWxsKGIsYSl9LGY9XCJvblwiK2M7Yi5hdHRhY2hFdmVudChmLFxuayk7YS5hLksuemEoYixmdW5jdGlvbigpe2IuZGV0YWNoRXZlbnQoZixrKX0pfWVsc2UgdGhyb3cgRXJyb3IoXCJCcm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBhZGRFdmVudExpc3RlbmVyIG9yIGF0dGFjaEV2ZW50XCIpO2Vsc2UgYi5hZGRFdmVudExpc3RlbmVyKGMsZSwhMSk7ZWxzZSB0fHwodD1cImZ1bmN0aW9uXCI9PXR5cGVvZiB2KGIpLm9uP1wib25cIjpcImJpbmRcIiksdihiKVt0XShjLGUpfSxGYjpmdW5jdGlvbihiLGMpe2lmKCFifHwhYi5ub2RlVHlwZSl0aHJvdyBFcnJvcihcImVsZW1lbnQgbXVzdCBiZSBhIERPTSBub2RlIHdoZW4gY2FsbGluZyB0cmlnZ2VyRXZlbnRcIik7dmFyIGQ7XCJpbnB1dFwiPT09YS5hLlIoYikmJmIudHlwZSYmXCJjbGlja1wiPT1jLnRvTG93ZXJDYXNlKCk/KGQ9Yi50eXBlLGQ9XCJjaGVja2JveFwiPT1kfHxcInJhZGlvXCI9PWQpOmQ9ITE7aWYoYS5vcHRpb25zLnVzZU9ubHlOYXRpdmVFdmVudHN8fCF2fHxkKWlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHcuY3JlYXRlRXZlbnQpaWYoXCJmdW5jdGlvblwiPT1cbnR5cGVvZiBiLmRpc3BhdGNoRXZlbnQpZD13LmNyZWF0ZUV2ZW50KGtbY118fFwiSFRNTEV2ZW50c1wiKSxkLmluaXRFdmVudChjLCEwLCEwLEEsMCwwLDAsMCwwLCExLCExLCExLCExLDAsYiksYi5kaXNwYXRjaEV2ZW50KGQpO2Vsc2UgdGhyb3cgRXJyb3IoXCJUaGUgc3VwcGxpZWQgZWxlbWVudCBkb2Vzbid0IHN1cHBvcnQgZGlzcGF0Y2hFdmVudFwiKTtlbHNlIGlmKGQmJmIuY2xpY2spYi5jbGljaygpO2Vsc2UgaWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGIuZmlyZUV2ZW50KWIuZmlyZUV2ZW50KFwib25cIitjKTtlbHNlIHRocm93IEVycm9yKFwiQnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgdHJpZ2dlcmluZyBldmVudHNcIik7ZWxzZSB2KGIpLnRyaWdnZXIoYyl9LGY6ZnVuY3Rpb24oYil7cmV0dXJuIGEuTyhiKT9iKCk6Yn0sYmM6ZnVuY3Rpb24oYil7cmV0dXJuIGEuTyhiKT9iLnYoKTpifSxFYjpmdW5jdGlvbihiLGMsZCl7dmFyIGw7YyYmKFwib2JqZWN0XCI9PT10eXBlb2YgYi5jbGFzc0xpc3Q/XG4obD1iLmNsYXNzTGlzdFtkP1wiYWRkXCI6XCJyZW1vdmVcIl0sYS5hLkQoYy5tYXRjaChxKSxmdW5jdGlvbihhKXtsLmNhbGwoYi5jbGFzc0xpc3QsYSl9KSk6XCJzdHJpbmdcIj09PXR5cGVvZiBiLmNsYXNzTmFtZS5iYXNlVmFsP2UoYi5jbGFzc05hbWUsXCJiYXNlVmFsXCIsYyxkKTplKGIsXCJjbGFzc05hbWVcIixjLGQpKX0sQmI6ZnVuY3Rpb24oYixjKXt2YXIgZD1hLmEuZihjKTtpZihudWxsPT09ZHx8ZD09PW4pZD1cIlwiO3ZhciBlPWEuaC5maXJzdENoaWxkKGIpOyFlfHwzIT1lLm5vZGVUeXBlfHxhLmgubmV4dFNpYmxpbmcoZSk/YS5oLnZhKGIsW2Iub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShkKV0pOmUuZGF0YT1kO2EuYS5BZChiKX0sWWM6ZnVuY3Rpb24oYSxiKXthLm5hbWU9YjtpZig3Pj1wKXRyeXt2YXIgYz1hLm5hbWUucmVwbGFjZSgvWyY8PidcIl0vZyxmdW5jdGlvbihhKXtyZXR1cm5cIiYjXCIrYS5jaGFyQ29kZUF0KDApK1wiO1wifSk7YS5tZXJnZUF0dHJpYnV0ZXMody5jcmVhdGVFbGVtZW50KFwiPGlucHV0IG5hbWU9J1wiK1xuYytcIicvPlwiKSwhMSl9Y2F0Y2goZCl7fX0sQWQ6ZnVuY3Rpb24oYSl7OTw9cCYmKGE9MT09YS5ub2RlVHlwZT9hOmEucGFyZW50Tm9kZSxhLnN0eWxlJiYoYS5zdHlsZS56b29tPWEuc3R5bGUuem9vbSkpfSx3ZDpmdW5jdGlvbihhKXtpZihwKXt2YXIgYj1hLnN0eWxlLndpZHRoO2Euc3R5bGUud2lkdGg9MDthLnN0eWxlLndpZHRoPWJ9fSxQZDpmdW5jdGlvbihiLGMpe2I9YS5hLmYoYik7Yz1hLmEuZihjKTtmb3IodmFyIGQ9W10sZT1iO2U8PWM7ZSsrKWQucHVzaChlKTtyZXR1cm4gZH0sbGE6ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPVtdLGM9MCxkPWEubGVuZ3RoO2M8ZDtjKyspYi5wdXNoKGFbY10pO3JldHVybiBifSxEYTpmdW5jdGlvbihhKXtyZXR1cm4gaD9TeW1ib2woYSk6YX0sWmQ6Nj09PXAsJGQ6Nz09PXAsVzpwLExjOmZ1bmN0aW9uKGIsYyl7Zm9yKHZhciBkPWEuYS5sYShiLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaW5wdXRcIikpLmNvbmNhdChhLmEubGEoYi5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRleHRhcmVhXCIpKSksXG5lPVwic3RyaW5nXCI9PXR5cGVvZiBjP2Z1bmN0aW9uKGEpe3JldHVybiBhLm5hbWU9PT1jfTpmdW5jdGlvbihhKXtyZXR1cm4gYy50ZXN0KGEubmFtZSl9LGw9W10saz1kLmxlbmd0aC0xOzA8PWs7ay0tKWUoZFtrXSkmJmwucHVzaChkW2tdKTtyZXR1cm4gbH0sTmQ6ZnVuY3Rpb24oYil7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGImJihiPWEuYS5EYihiKSk/SCYmSC5wYXJzZT9ILnBhcnNlKGIpOihuZXcgRnVuY3Rpb24oXCJyZXR1cm4gXCIrYikpKCk6bnVsbH0saGM6ZnVuY3Rpb24oYixjLGQpe2lmKCFIfHwhSC5zdHJpbmdpZnkpdGhyb3cgRXJyb3IoXCJDYW5ub3QgZmluZCBKU09OLnN0cmluZ2lmeSgpLiBTb21lIGJyb3dzZXJzIChlLmcuLCBJRSA8IDgpIGRvbid0IHN1cHBvcnQgaXQgbmF0aXZlbHksIGJ1dCB5b3UgY2FuIG92ZXJjb21lIHRoaXMgYnkgYWRkaW5nIGEgc2NyaXB0IHJlZmVyZW5jZSB0byBqc29uMi5qcywgZG93bmxvYWRhYmxlIGZyb20gaHR0cDovL3d3dy5qc29uLm9yZy9qc29uMi5qc1wiKTtcbnJldHVybiBILnN0cmluZ2lmeShhLmEuZihiKSxjLGQpfSxPZDpmdW5jdGlvbihjLGQsZSl7ZT1lfHx7fTt2YXIgbD1lLnBhcmFtc3x8e30saz1lLmluY2x1ZGVGaWVsZHN8fHRoaXMuSmMsZj1jO2lmKFwib2JqZWN0XCI9PXR5cGVvZiBjJiZcImZvcm1cIj09PWEuYS5SKGMpKWZvcih2YXIgZj1jLmFjdGlvbixoPWsubGVuZ3RoLTE7MDw9aDtoLS0pZm9yKHZhciBnPWEuYS5MYyhjLGtbaF0pLG09Zy5sZW5ndGgtMTswPD1tO20tLSlsW2dbbV0ubmFtZV09Z1ttXS52YWx1ZTtkPWEuYS5mKGQpO3ZhciBwPXcuY3JlYXRlRWxlbWVudChcImZvcm1cIik7cC5zdHlsZS5kaXNwbGF5PVwibm9uZVwiO3AuYWN0aW9uPWY7cC5tZXRob2Q9XCJwb3N0XCI7Zm9yKHZhciBxIGluIGQpYz13LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKSxjLnR5cGU9XCJoaWRkZW5cIixjLm5hbWU9cSxjLnZhbHVlPWEuYS5oYyhhLmEuZihkW3FdKSkscC5hcHBlbmRDaGlsZChjKTtiKGwsZnVuY3Rpb24oYSxiKXt2YXIgYz13LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbmMudHlwZT1cImhpZGRlblwiO2MubmFtZT1hO2MudmFsdWU9YjtwLmFwcGVuZENoaWxkKGMpfSk7dy5ib2R5LmFwcGVuZENoaWxkKHApO2Uuc3VibWl0dGVyP2Uuc3VibWl0dGVyKHApOnAuc3VibWl0KCk7c2V0VGltZW91dChmdW5jdGlvbigpe3AucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwKX0sMCl9fX0oKTthLmIoXCJ1dGlsc1wiLGEuYSk7YS5iKFwidXRpbHMuYXJyYXlGb3JFYWNoXCIsYS5hLkQpO2EuYihcInV0aWxzLmFycmF5Rmlyc3RcIixhLmEuTGIpO2EuYihcInV0aWxzLmFycmF5RmlsdGVyXCIsYS5hLmpiKTthLmIoXCJ1dGlscy5hcnJheUdldERpc3RpbmN0VmFsdWVzXCIsYS5hLndjKTthLmIoXCJ1dGlscy5hcnJheUluZGV4T2ZcIixhLmEuQSk7YS5iKFwidXRpbHMuYXJyYXlNYXBcIixhLmEuTWIpO2EuYihcInV0aWxzLmFycmF5UHVzaEFsbFwiLGEuYS5OYik7YS5iKFwidXRpbHMuYXJyYXlSZW1vdmVJdGVtXCIsYS5hLlBhKTthLmIoXCJ1dGlscy5jbG9uZU5vZGVzXCIsYS5hLkNhKTthLmIoXCJ1dGlscy5jcmVhdGVTeW1ib2xPclN0cmluZ1wiLFxuYS5hLkRhKTthLmIoXCJ1dGlscy5leHRlbmRcIixhLmEuZXh0ZW5kKTthLmIoXCJ1dGlscy5maWVsZHNJbmNsdWRlZFdpdGhKc29uUG9zdFwiLGEuYS5KYyk7YS5iKFwidXRpbHMuZ2V0Rm9ybUZpZWxkc1wiLGEuYS5MYyk7YS5iKFwidXRpbHMub2JqZWN0TWFwXCIsYS5hLkdhKTthLmIoXCJ1dGlscy5wZWVrT2JzZXJ2YWJsZVwiLGEuYS5iYyk7YS5iKFwidXRpbHMucG9zdEpzb25cIixhLmEuT2QpO2EuYihcInV0aWxzLnBhcnNlSnNvblwiLGEuYS5OZCk7YS5iKFwidXRpbHMucmVnaXN0ZXJFdmVudEhhbmRsZXJcIixhLmEuQik7YS5iKFwidXRpbHMuc3RyaW5naWZ5SnNvblwiLGEuYS5oYyk7YS5iKFwidXRpbHMucmFuZ2VcIixhLmEuUGQpO2EuYihcInV0aWxzLnRvZ2dsZURvbU5vZGVDc3NDbGFzc1wiLGEuYS5FYik7YS5iKFwidXRpbHMudHJpZ2dlckV2ZW50XCIsYS5hLkZiKTthLmIoXCJ1dGlscy51bndyYXBPYnNlcnZhYmxlXCIsYS5hLmYpO2EuYihcInV0aWxzLm9iamVjdEZvckVhY2hcIixhLmEuUCk7YS5iKFwidXRpbHMuYWRkT3JSZW1vdmVJdGVtXCIsXG5hLmEuTmEpO2EuYihcInV0aWxzLnNldFRleHRDb250ZW50XCIsYS5hLkJiKTthLmIoXCJ1bndyYXBcIixhLmEuZik7RnVuY3Rpb24ucHJvdG90eXBlLmJpbmR8fChGdW5jdGlvbi5wcm90b3R5cGUuYmluZD1mdW5jdGlvbihhKXt2YXIgYz10aGlzO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBmdW5jdGlvbigpe3JldHVybiBjLmFwcGx5KGEsYXJndW1lbnRzKX07dmFyIGQ9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpO3JldHVybiBmdW5jdGlvbigpe3ZhciBlPWQuc2xpY2UoMCk7ZS5wdXNoLmFwcGx5KGUsYXJndW1lbnRzKTtyZXR1cm4gYy5hcHBseShhLGUpfX0pO2EuYS5nPW5ldyBmdW5jdGlvbigpe3ZhciBiPTAsYz1cIl9fa29fX1wiKyhuZXcgRGF0ZSkuZ2V0VGltZSgpLGQ9e30sZSxmO2EuYS5XPyhlPWZ1bmN0aW9uKGEsZSl7dmFyIGY9YVtjXTtpZighZnx8XCJudWxsXCI9PT1mfHwhZFtmXSl7aWYoIWUpcmV0dXJuIG47Zj1hW2NdPVwia29cIitiKys7ZFtmXT1cbnt9fXJldHVybiBkW2ZdfSxmPWZ1bmN0aW9uKGEpe3ZhciBiPWFbY107cmV0dXJuIGI/KGRlbGV0ZSBkW2JdLGFbY109bnVsbCwhMCk6ITF9KTooZT1mdW5jdGlvbihhLGIpe3ZhciBkPWFbY107IWQmJmImJihkPWFbY109e30pO3JldHVybiBkfSxmPWZ1bmN0aW9uKGEpe3JldHVybiBhW2NdPyhkZWxldGUgYVtjXSwhMCk6ITF9KTtyZXR1cm57Z2V0OmZ1bmN0aW9uKGEsYil7dmFyIGM9ZShhLCExKTtyZXR1cm4gYyYmY1tiXX0sc2V0OmZ1bmN0aW9uKGEsYixjKXsoYT1lKGEsYyE9PW4pKSYmKGFbYl09Yyl9LFViOmZ1bmN0aW9uKGEsYixjKXthPWUoYSwhMCk7cmV0dXJuIGFbYl18fChhW2JdPWMpfSxjbGVhcjpmLFo6ZnVuY3Rpb24oKXtyZXR1cm4gYisrICtjfX19O2EuYihcInV0aWxzLmRvbURhdGFcIixhLmEuZyk7YS5iKFwidXRpbHMuZG9tRGF0YS5jbGVhclwiLGEuYS5nLmNsZWFyKTthLmEuSz1uZXcgZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGIsYyl7dmFyIGQ9YS5hLmcuZ2V0KGIsZSk7XG5kPT09biYmYyYmKGQ9W10sYS5hLmcuc2V0KGIsZSxkKSk7cmV0dXJuIGR9ZnVuY3Rpb24gYyhjKXt2YXIgZT1iKGMsITEpO2lmKGUpZm9yKHZhciBlPWUuc2xpY2UoMCksaz0wO2s8ZS5sZW5ndGg7aysrKWVba10oYyk7YS5hLmcuY2xlYXIoYyk7YS5hLksuY2xlYW5FeHRlcm5hbERhdGEoYyk7Z1tjLm5vZGVUeXBlXSYmZChjLmNoaWxkTm9kZXMsITApfWZ1bmN0aW9uIGQoYixkKXtmb3IodmFyIGU9W10sbCxmPTA7ZjxiLmxlbmd0aDtmKyspaWYoIWR8fDg9PT1iW2ZdLm5vZGVUeXBlKWlmKGMoZVtlLmxlbmd0aF09bD1iW2ZdKSxiW2ZdIT09bClmb3IoO2YtLSYmLTE9PWEuYS5BKGUsYltmXSk7KTt9dmFyIGU9YS5hLmcuWigpLGY9ezE6ITAsODohMCw5OiEwfSxnPXsxOiEwLDk6ITB9O3JldHVybnt6YTpmdW5jdGlvbihhLGMpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGMpdGhyb3cgRXJyb3IoXCJDYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb25cIik7YihhLCEwKS5wdXNoKGMpfSx5YjpmdW5jdGlvbihjLFxuZCl7dmFyIGY9YihjLCExKTtmJiYoYS5hLlBhKGYsZCksMD09Zi5sZW5ndGgmJmEuYS5nLnNldChjLGUsbikpfSxvYTpmdW5jdGlvbihiKXthLnUuRyhmdW5jdGlvbigpe2ZbYi5ub2RlVHlwZV0mJihjKGIpLGdbYi5ub2RlVHlwZV0mJmQoYi5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikpKX0pO3JldHVybiBifSxyZW1vdmVOb2RlOmZ1bmN0aW9uKGIpe2Eub2EoYik7Yi5wYXJlbnROb2RlJiZiLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYil9LGNsZWFuRXh0ZXJuYWxEYXRhOmZ1bmN0aW9uKGEpe3YmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHYuY2xlYW5EYXRhJiZ2LmNsZWFuRGF0YShbYV0pfX19O2Eub2E9YS5hLksub2E7YS5yZW1vdmVOb2RlPWEuYS5LLnJlbW92ZU5vZGU7YS5iKFwiY2xlYW5Ob2RlXCIsYS5vYSk7YS5iKFwicmVtb3ZlTm9kZVwiLGEucmVtb3ZlTm9kZSk7YS5iKFwidXRpbHMuZG9tTm9kZURpc3Bvc2FsXCIsYS5hLkspO2EuYihcInV0aWxzLmRvbU5vZGVEaXNwb3NhbC5hZGREaXNwb3NlQ2FsbGJhY2tcIixcbmEuYS5LLnphKTthLmIoXCJ1dGlscy5kb21Ob2RlRGlzcG9zYWwucmVtb3ZlRGlzcG9zZUNhbGxiYWNrXCIsYS5hLksueWIpOyhmdW5jdGlvbigpe3ZhciBiPVswLFwiXCIsXCJcIl0sYz1bMSxcIjx0YWJsZT5cIixcIjwvdGFibGU+XCJdLGQ9WzMsXCI8dGFibGU+PHRib2R5Pjx0cj5cIixcIjwvdHI+PC90Ym9keT48L3RhYmxlPlwiXSxlPVsxLFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlwiLFwiPC9zZWxlY3Q+XCJdLGY9e3RoZWFkOmMsdGJvZHk6Yyx0Zm9vdDpjLHRyOlsyLFwiPHRhYmxlPjx0Ym9keT5cIixcIjwvdGJvZHk+PC90YWJsZT5cIl0sdGQ6ZCx0aDpkLG9wdGlvbjplLG9wdGdyb3VwOmV9LGc9OD49YS5hLlc7YS5hLnVhPWZ1bmN0aW9uKGMsZCl7dmFyIGU7aWYodilpZih2LnBhcnNlSFRNTCllPXYucGFyc2VIVE1MKGMsZCl8fFtdO2Vsc2V7aWYoKGU9di5jbGVhbihbY10sZCkpJiZlWzBdKXtmb3IodmFyIGw9ZVswXTtsLnBhcmVudE5vZGUmJjExIT09bC5wYXJlbnROb2RlLm5vZGVUeXBlOylsPWwucGFyZW50Tm9kZTtcbmwucGFyZW50Tm9kZSYmbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGwpfX1lbHNleyhlPWQpfHwoZT13KTt2YXIgbD1lLnBhcmVudFdpbmRvd3x8ZS5kZWZhdWx0Vmlld3x8QSxwPWEuYS5EYihjKS50b0xvd2VyQ2FzZSgpLHE9ZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLHQ7dD0ocD1wLm1hdGNoKC9eKD86XFx4M2MhLS0uKj8tLVxceDNlXFxzKj8pKj88KFthLXpdKylbXFxzPl0vKSkmJmZbcFsxXV18fGI7cD10WzBdO3Q9XCJpZ25vcmVkPGRpdj5cIit0WzFdK2MrdFsyXStcIjwvZGl2PlwiO1wiZnVuY3Rpb25cIj09dHlwZW9mIGwuaW5uZXJTaGl2P3EuYXBwZW5kQ2hpbGQobC5pbm5lclNoaXYodCkpOihnJiZlLmJvZHkuYXBwZW5kQ2hpbGQocSkscS5pbm5lckhUTUw9dCxnJiZxLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocSkpO2Zvcig7cC0tOylxPXEubGFzdENoaWxkO2U9YS5hLmxhKHEubGFzdENoaWxkLmNoaWxkTm9kZXMpfXJldHVybiBlfTthLmEuTWQ9ZnVuY3Rpb24oYixjKXt2YXIgZD1hLmEudWEoYixcbmMpO3JldHVybiBkLmxlbmd0aCYmZFswXS5wYXJlbnRFbGVtZW50fHxhLmEuWWIoZCl9O2EuYS5mYz1mdW5jdGlvbihiLGMpe2EuYS5UYihiKTtjPWEuYS5mKGMpO2lmKG51bGwhPT1jJiZjIT09bilpZihcInN0cmluZ1wiIT10eXBlb2YgYyYmKGM9Yy50b1N0cmluZygpKSx2KXYoYikuaHRtbChjKTtlbHNlIGZvcih2YXIgZD1hLmEudWEoYyxiLm93bmVyRG9jdW1lbnQpLGU9MDtlPGQubGVuZ3RoO2UrKyliLmFwcGVuZENoaWxkKGRbZV0pfX0pKCk7YS5iKFwidXRpbHMucGFyc2VIdG1sRnJhZ21lbnRcIixhLmEudWEpO2EuYihcInV0aWxzLnNldEh0bWxcIixhLmEuZmMpO2EuYWE9ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGMsZSl7aWYoYylpZig4PT1jLm5vZGVUeXBlKXt2YXIgZj1hLmFhLlVjKGMubm9kZVZhbHVlKTtudWxsIT1mJiZlLnB1c2goe3VkOmMsS2Q6Zn0pfWVsc2UgaWYoMT09Yy5ub2RlVHlwZSlmb3IodmFyIGY9MCxnPWMuY2hpbGROb2RlcyxoPWcubGVuZ3RoO2Y8aDtmKyspYihnW2ZdLFxuZSl9dmFyIGM9e307cmV0dXJue1hiOmZ1bmN0aW9uKGEpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGEpdGhyb3cgRXJyb3IoXCJZb3UgY2FuIG9ubHkgcGFzcyBhIGZ1bmN0aW9uIHRvIGtvLm1lbW9pemF0aW9uLm1lbW9pemUoKVwiKTt2YXIgYj0oNDI5NDk2NzI5NiooMStNYXRoLnJhbmRvbSgpKXwwKS50b1N0cmluZygxNikuc3Vic3RyaW5nKDEpKyg0Mjk0OTY3Mjk2KigxK01hdGgucmFuZG9tKCkpfDApLnRvU3RyaW5nKDE2KS5zdWJzdHJpbmcoMSk7Y1tiXT1hO3JldHVyblwiXFx4M2MhLS1ba29fbWVtbzpcIitiK1wiXS0tXFx4M2VcIn0sYmQ6ZnVuY3Rpb24oYSxiKXt2YXIgZj1jW2FdO2lmKGY9PT1uKXRocm93IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhbnkgbWVtbyB3aXRoIElEIFwiK2ErXCIuIFBlcmhhcHMgaXQncyBhbHJlYWR5IGJlZW4gdW5tZW1vaXplZC5cIik7dHJ5e3JldHVybiBmLmFwcGx5KG51bGwsYnx8W10pLCEwfWZpbmFsbHl7ZGVsZXRlIGNbYV19fSxjZDpmdW5jdGlvbihjLGUpe3ZhciBmPVxuW107YihjLGYpO2Zvcih2YXIgZz0wLGg9Zi5sZW5ndGg7ZzxoO2crKyl7dmFyIG09ZltnXS51ZCxrPVttXTtlJiZhLmEuTmIoayxlKTthLmFhLmJkKGZbZ10uS2Qsayk7bS5ub2RlVmFsdWU9XCJcIjttLnBhcmVudE5vZGUmJm0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChtKX19LFVjOmZ1bmN0aW9uKGEpe3JldHVybihhPWEubWF0Y2goL15cXFtrb19tZW1vXFw6KC4qPylcXF0kLykpP2FbMV06bnVsbH19fSgpO2EuYihcIm1lbW9pemF0aW9uXCIsYS5hYSk7YS5iKFwibWVtb2l6YXRpb24ubWVtb2l6ZVwiLGEuYWEuWGIpO2EuYihcIm1lbW9pemF0aW9uLnVubWVtb2l6ZVwiLGEuYWEuYmQpO2EuYihcIm1lbW9pemF0aW9uLnBhcnNlTWVtb1RleHRcIixhLmFhLlVjKTthLmIoXCJtZW1vaXphdGlvbi51bm1lbW9pemVEb21Ob2RlQW5kRGVzY2VuZGFudHNcIixhLmFhLmNkKTthLm5hPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYigpe2lmKGYpZm9yKHZhciBiPWYsYz0wLGQ7aDxmOylpZihkPWVbaCsrXSl7aWYoaD5iKXtpZig1RTM8PVxuKytjKXtoPWY7YS5hLkdjKEVycm9yKFwiJ1RvbyBtdWNoIHJlY3Vyc2lvbicgYWZ0ZXIgcHJvY2Vzc2luZyBcIitjK1wiIHRhc2sgZ3JvdXBzLlwiKSk7YnJlYWt9Yj1mfXRyeXtkKCl9Y2F0Y2gocCl7YS5hLkdjKHApfX19ZnVuY3Rpb24gYygpe2IoKTtoPWY9ZS5sZW5ndGg9MH12YXIgZCxlPVtdLGY9MCxnPTEsaD0wO0EuTXV0YXRpb25PYnNlcnZlcj9kPWZ1bmN0aW9uKGEpe3ZhciBiPXcuY3JlYXRlRWxlbWVudChcImRpdlwiKTsobmV3IE11dGF0aW9uT2JzZXJ2ZXIoYSkpLm9ic2VydmUoYix7YXR0cmlidXRlczohMH0pO3JldHVybiBmdW5jdGlvbigpe2IuY2xhc3NMaXN0LnRvZ2dsZShcImZvb1wiKX19KGMpOmQ9dyYmXCJvbnJlYWR5c3RhdGVjaGFuZ2VcImluIHcuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKT9mdW5jdGlvbihhKXt2YXIgYj13LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7Yi5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKXtiLm9ucmVhZHlzdGF0ZWNoYW5nZT1udWxsO3cuZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKGIpO1xuYj1udWxsO2EoKX07dy5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoYil9OmZ1bmN0aW9uKGEpe3NldFRpbWVvdXQoYSwwKX07cmV0dXJue3NjaGVkdWxlcjpkLHpiOmZ1bmN0aW9uKGIpe2Z8fGEubmEuc2NoZWR1bGVyKGMpO2VbZisrXT1iO3JldHVybiBnKyt9LGNhbmNlbDpmdW5jdGlvbihhKXthPWEtKGctZik7YT49aCYmYTxmJiYoZVthXT1udWxsKX0scmVzZXRGb3JUZXN0aW5nOmZ1bmN0aW9uKCl7dmFyIGE9Zi1oO2g9Zj1lLmxlbmd0aD0wO3JldHVybiBhfSxTZDpifX0oKTthLmIoXCJ0YXNrc1wiLGEubmEpO2EuYihcInRhc2tzLnNjaGVkdWxlXCIsYS5uYS56Yik7YS5iKFwidGFza3MucnVuRWFybHlcIixhLm5hLlNkKTthLlRhPXt0aHJvdHRsZTpmdW5jdGlvbihiLGMpe2IudGhyb3R0bGVFdmFsdWF0aW9uPWM7dmFyIGQ9bnVsbDtyZXR1cm4gYS4kKHtyZWFkOmIsd3JpdGU6ZnVuY3Rpb24oZSl7Y2xlYXJUaW1lb3V0KGQpO2Q9YS5hLnNldFRpbWVvdXQoZnVuY3Rpb24oKXtiKGUpfSxcbmMpfX0pfSxyYXRlTGltaXQ6ZnVuY3Rpb24oYSxjKXt2YXIgZCxlLGY7XCJudW1iZXJcIj09dHlwZW9mIGM/ZD1jOihkPWMudGltZW91dCxlPWMubWV0aG9kKTthLkhiPSExO2Y9XCJmdW5jdGlvblwiPT10eXBlb2YgZT9lOlwibm90aWZ5V2hlbkNoYW5nZXNTdG9wXCI9PWU/WTpYO2EudWIoZnVuY3Rpb24oYSl7cmV0dXJuIGYoYSxkLGMpfSl9LGRlZmVycmVkOmZ1bmN0aW9uKGIsYyl7aWYoITAhPT1jKXRocm93IEVycm9yKFwiVGhlICdkZWZlcnJlZCcgZXh0ZW5kZXIgb25seSBhY2NlcHRzIHRoZSB2YWx1ZSAndHJ1ZScsIGJlY2F1c2UgaXQgaXMgbm90IHN1cHBvcnRlZCB0byB0dXJuIGRlZmVycmFsIG9mZiBvbmNlIGVuYWJsZWQuXCIpO2IuSGJ8fChiLkhiPSEwLGIudWIoZnVuY3Rpb24oYyl7dmFyIGUsZj0hMTtyZXR1cm4gZnVuY3Rpb24oKXtpZighZil7YS5uYS5jYW5jZWwoZSk7ZT1hLm5hLnpiKGMpO3RyeXtmPSEwLGIubm90aWZ5U3Vic2NyaWJlcnMobixcImRpcnR5XCIpfWZpbmFsbHl7Zj1cbiExfX19fSkpfSxub3RpZnk6ZnVuY3Rpb24oYSxjKXthLmVxdWFsaXR5Q29tcGFyZXI9XCJhbHdheXNcIj09Yz9udWxsOkt9fTt2YXIgVz17dW5kZWZpbmVkOjEsXCJib29sZWFuXCI6MSxudW1iZXI6MSxzdHJpbmc6MX07YS5iKFwiZXh0ZW5kZXJzXCIsYS5UYSk7YS5pYz1mdW5jdGlvbihiLGMsZCl7dGhpcy5kYT1iO3RoaXMubGM9Yzt0aGlzLm1jPWQ7dGhpcy5JYj0hMTt0aGlzLmZiPXRoaXMuSmI9bnVsbDthLkwodGhpcyxcImRpc3Bvc2VcIix0aGlzLnMpO2EuTCh0aGlzLFwiZGlzcG9zZVdoZW5Ob2RlSXNSZW1vdmVkXCIsdGhpcy5sKX07YS5pYy5wcm90b3R5cGUucz1mdW5jdGlvbigpe3RoaXMuSWJ8fCh0aGlzLmZiJiZhLmEuSy55Yih0aGlzLkpiLHRoaXMuZmIpLHRoaXMuSWI9ITAsdGhpcy5tYygpLHRoaXMuZGE9dGhpcy5sYz10aGlzLm1jPXRoaXMuSmI9dGhpcy5mYj1udWxsKX07YS5pYy5wcm90b3R5cGUubD1mdW5jdGlvbihiKXt0aGlzLkpiPWI7YS5hLksuemEoYix0aGlzLmZiPXRoaXMucy5iaW5kKHRoaXMpKX07XG5hLlQ9ZnVuY3Rpb24oKXthLmEuQWIodGhpcyxEKTtELnFiKHRoaXMpfTt2YXIgRD17cWI6ZnVuY3Rpb24oYSl7YS5VPXtjaGFuZ2U6W119O2Euc2M9MX0sc3Vic2NyaWJlOmZ1bmN0aW9uKGIsYyxkKXt2YXIgZT10aGlzO2Q9ZHx8XCJjaGFuZ2VcIjt2YXIgZj1uZXcgYS5pYyhlLGM/Yi5iaW5kKGMpOmIsZnVuY3Rpb24oKXthLmEuUGEoZS5VW2RdLGYpO2UuaGImJmUuaGIoZCl9KTtlLlFhJiZlLlFhKGQpO2UuVVtkXXx8KGUuVVtkXT1bXSk7ZS5VW2RdLnB1c2goZik7cmV0dXJuIGZ9LG5vdGlmeVN1YnNjcmliZXJzOmZ1bmN0aW9uKGIsYyl7Yz1jfHxcImNoYW5nZVwiO1wiY2hhbmdlXCI9PT1jJiZ0aGlzLkdiKCk7aWYodGhpcy5XYShjKSl7dmFyIGQ9XCJjaGFuZ2VcIj09PWMmJnRoaXMuZWR8fHRoaXMuVVtjXS5zbGljZSgwKTt0cnl7YS51LnhjKCk7Zm9yKHZhciBlPTAsZjtmPWRbZV07KytlKWYuSWJ8fGYubGMoYil9ZmluYWxseXthLnUuZW5kKCl9fX0sb2I6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zY30sXG5EZDpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5vYigpIT09YX0sR2I6ZnVuY3Rpb24oKXsrK3RoaXMuc2N9LHViOmZ1bmN0aW9uKGIpe3ZhciBjPXRoaXMsZD1hLk8oYyksZSxmLGcsaCxtO2MuZ2J8fChjLmdiPWMubm90aWZ5U3Vic2NyaWJlcnMsYy5ub3RpZnlTdWJzY3JpYmVycz1aKTt2YXIgaz1iKGZ1bmN0aW9uKCl7Yy5KYT0hMTtkJiZoPT09YyYmKGg9Yy5uYz9jLm5jKCk6YygpKTt2YXIgYT1mfHxtJiZjLnNiKGcsaCk7bT1mPWU9ITE7YSYmYy5nYihnPWgpfSk7Yy5xYz1mdW5jdGlvbihhLGIpe2ImJmMuSmF8fChtPSFiKTtjLmVkPWMuVS5jaGFuZ2Uuc2xpY2UoMCk7Yy5KYT1lPSEwO2g9YTtrKCl9O2MucGM9ZnVuY3Rpb24oYSl7ZXx8KGc9YSxjLmdiKGEsXCJiZWZvcmVDaGFuZ2VcIikpfTtjLnJjPWZ1bmN0aW9uKCl7bT0hMH07Yy5nZD1mdW5jdGlvbigpe2Muc2IoZyxjLnYoITApKSYmKGY9ITApfX0sV2E6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuVVthXSYmdGhpcy5VW2FdLmxlbmd0aH0sXG5CZDpmdW5jdGlvbihiKXtpZihiKXJldHVybiB0aGlzLlVbYl0mJnRoaXMuVVtiXS5sZW5ndGh8fDA7dmFyIGM9MDthLmEuUCh0aGlzLlUsZnVuY3Rpb24oYSxiKXtcImRpcnR5XCIhPT1hJiYoYys9Yi5sZW5ndGgpfSk7cmV0dXJuIGN9LHNiOmZ1bmN0aW9uKGEsYyl7cmV0dXJuIXRoaXMuZXF1YWxpdHlDb21wYXJlcnx8IXRoaXMuZXF1YWxpdHlDb21wYXJlcihhLGMpfSx0b1N0cmluZzpmdW5jdGlvbigpe3JldHVyblwiW29iamVjdCBPYmplY3RdXCJ9LGV4dGVuZDpmdW5jdGlvbihiKXt2YXIgYz10aGlzO2ImJmEuYS5QKGIsZnVuY3Rpb24oYixlKXt2YXIgZj1hLlRhW2JdO1wiZnVuY3Rpb25cIj09dHlwZW9mIGYmJihjPWYoYyxlKXx8Yyl9KTtyZXR1cm4gY319O2EuTChELFwiaW5pdFwiLEQucWIpO2EuTChELFwic3Vic2NyaWJlXCIsRC5zdWJzY3JpYmUpO2EuTChELFwiZXh0ZW5kXCIsRC5leHRlbmQpO2EuTChELFwiZ2V0U3Vic2NyaXB0aW9uc0NvdW50XCIsRC5CZCk7YS5hLkJhJiZhLmEuc2V0UHJvdG90eXBlT2YoRCxcbkZ1bmN0aW9uLnByb3RvdHlwZSk7YS5ULmZuPUQ7YS5RYz1mdW5jdGlvbihhKXtyZXR1cm4gbnVsbCE9YSYmXCJmdW5jdGlvblwiPT10eXBlb2YgYS5zdWJzY3JpYmUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGEubm90aWZ5U3Vic2NyaWJlcnN9O2EuYihcInN1YnNjcmliYWJsZVwiLGEuVCk7YS5iKFwiaXNTdWJzY3JpYmFibGVcIixhLlFjKTthLlM9YS51PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYihhKXtkLnB1c2goZSk7ZT1hfWZ1bmN0aW9uIGMoKXtlPWQucG9wKCl9dmFyIGQ9W10sZSxmPTA7cmV0dXJue3hjOmIsZW5kOmMsY2M6ZnVuY3Rpb24oYil7aWYoZSl7aWYoIWEuUWMoYikpdGhyb3cgRXJyb3IoXCJPbmx5IHN1YnNjcmliYWJsZSB0aGluZ3MgY2FuIGFjdCBhcyBkZXBlbmRlbmNpZXNcIik7ZS5vZC5jYWxsKGUucGQsYixiLmZkfHwoYi5mZD0rK2YpKX19LEc6ZnVuY3Rpb24oYSxkLGUpe3RyeXtyZXR1cm4gYigpLGEuYXBwbHkoZCxlfHxbXSl9ZmluYWxseXtjKCl9fSxxYTpmdW5jdGlvbigpe2lmKGUpcmV0dXJuIGUuby5xYSgpfSxcblZhOmZ1bmN0aW9uKCl7aWYoZSlyZXR1cm4gZS5vLlZhKCl9LFlhOmZ1bmN0aW9uKCl7aWYoZSlyZXR1cm4gZS5ZYX0sbzpmdW5jdGlvbigpe2lmKGUpcmV0dXJuIGUub319fSgpO2EuYihcImNvbXB1dGVkQ29udGV4dFwiLGEuUyk7YS5iKFwiY29tcHV0ZWRDb250ZXh0LmdldERlcGVuZGVuY2llc0NvdW50XCIsYS5TLnFhKTthLmIoXCJjb21wdXRlZENvbnRleHQuZ2V0RGVwZW5kZW5jaWVzXCIsYS5TLlZhKTthLmIoXCJjb21wdXRlZENvbnRleHQuaXNJbml0aWFsXCIsYS5TLllhKTthLmIoXCJjb21wdXRlZENvbnRleHQucmVnaXN0ZXJEZXBlbmRlbmN5XCIsYS5TLmNjKTthLmIoXCJpZ25vcmVEZXBlbmRlbmNpZXNcIixhLllkPWEudS5HKTt2YXIgST1hLmEuRGEoXCJfbGF0ZXN0VmFsdWVcIik7YS50YT1mdW5jdGlvbihiKXtmdW5jdGlvbiBjKCl7aWYoMDxhcmd1bWVudHMubGVuZ3RoKXJldHVybiBjLnNiKGNbSV0sYXJndW1lbnRzWzBdKSYmKGMueWEoKSxjW0ldPWFyZ3VtZW50c1swXSxjLnhhKCkpLHRoaXM7XG5hLnUuY2MoYyk7cmV0dXJuIGNbSV19Y1tJXT1iO2EuYS5CYXx8YS5hLmV4dGVuZChjLGEuVC5mbik7YS5ULmZuLnFiKGMpO2EuYS5BYihjLEYpO2Eub3B0aW9ucy5kZWZlclVwZGF0ZXMmJmEuVGEuZGVmZXJyZWQoYywhMCk7cmV0dXJuIGN9O3ZhciBGPXtlcXVhbGl0eUNvbXBhcmVyOkssdjpmdW5jdGlvbigpe3JldHVybiB0aGlzW0ldfSx4YTpmdW5jdGlvbigpe3RoaXMubm90aWZ5U3Vic2NyaWJlcnModGhpc1tJXSxcInNwZWN0YXRlXCIpO3RoaXMubm90aWZ5U3Vic2NyaWJlcnModGhpc1tJXSl9LHlhOmZ1bmN0aW9uKCl7dGhpcy5ub3RpZnlTdWJzY3JpYmVycyh0aGlzW0ldLFwiYmVmb3JlQ2hhbmdlXCIpfX07YS5hLkJhJiZhLmEuc2V0UHJvdG90eXBlT2YoRixhLlQuZm4pO3ZhciBHPWEudGEuTWE9XCJfX2tvX3Byb3RvX19cIjtGW0ddPWEudGE7YS5PPWZ1bmN0aW9uKGIpe2lmKChiPVwiZnVuY3Rpb25cIj09dHlwZW9mIGImJmJbR10pJiZiIT09RltHXSYmYiE9PWEuby5mbltHXSl0aHJvdyBFcnJvcihcIkludmFsaWQgb2JqZWN0IHRoYXQgbG9va3MgbGlrZSBhbiBvYnNlcnZhYmxlOyBwb3NzaWJseSBmcm9tIGFub3RoZXIgS25vY2tvdXQgaW5zdGFuY2VcIik7XG5yZXR1cm4hIWJ9O2EuWmE9ZnVuY3Rpb24oYil7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgYiYmKGJbR109PT1GW0ddfHxiW0ddPT09YS5vLmZuW0ddJiZiLk5jKX07YS5iKFwib2JzZXJ2YWJsZVwiLGEudGEpO2EuYihcImlzT2JzZXJ2YWJsZVwiLGEuTyk7YS5iKFwiaXNXcml0ZWFibGVPYnNlcnZhYmxlXCIsYS5aYSk7YS5iKFwiaXNXcml0YWJsZU9ic2VydmFibGVcIixhLlphKTthLmIoXCJvYnNlcnZhYmxlLmZuXCIsRik7YS5MKEYsXCJwZWVrXCIsRi52KTthLkwoRixcInZhbHVlSGFzTXV0YXRlZFwiLEYueGEpO2EuTChGLFwidmFsdWVXaWxsTXV0YXRlXCIsRi55YSk7YS5IYT1mdW5jdGlvbihiKXtiPWJ8fFtdO2lmKFwib2JqZWN0XCIhPXR5cGVvZiBifHwhKFwibGVuZ3RoXCJpbiBiKSl0aHJvdyBFcnJvcihcIlRoZSBhcmd1bWVudCBwYXNzZWQgd2hlbiBpbml0aWFsaXppbmcgYW4gb2JzZXJ2YWJsZSBhcnJheSBtdXN0IGJlIGFuIGFycmF5LCBvciBudWxsLCBvciB1bmRlZmluZWQuXCIpO2I9YS50YShiKTthLmEuQWIoYixcbmEuSGEuZm4pO3JldHVybiBiLmV4dGVuZCh7dHJhY2tBcnJheUNoYW5nZXM6ITB9KX07YS5IYS5mbj17cmVtb3ZlOmZ1bmN0aW9uKGIpe2Zvcih2YXIgYz10aGlzLnYoKSxkPVtdLGU9XCJmdW5jdGlvblwiIT10eXBlb2YgYnx8YS5PKGIpP2Z1bmN0aW9uKGEpe3JldHVybiBhPT09Yn06YixmPTA7ZjxjLmxlbmd0aDtmKyspe3ZhciBnPWNbZl07aWYoZShnKSl7MD09PWQubGVuZ3RoJiZ0aGlzLnlhKCk7aWYoY1tmXSE9PWcpdGhyb3cgRXJyb3IoXCJBcnJheSBtb2RpZmllZCBkdXJpbmcgcmVtb3ZlOyBjYW5ub3QgcmVtb3ZlIGl0ZW1cIik7ZC5wdXNoKGcpO2Muc3BsaWNlKGYsMSk7Zi0tfX1kLmxlbmd0aCYmdGhpcy54YSgpO3JldHVybiBkfSxyZW1vdmVBbGw6ZnVuY3Rpb24oYil7aWYoYj09PW4pe3ZhciBjPXRoaXMudigpLGQ9Yy5zbGljZSgwKTt0aGlzLnlhKCk7Yy5zcGxpY2UoMCxjLmxlbmd0aCk7dGhpcy54YSgpO3JldHVybiBkfXJldHVybiBiP3RoaXMucmVtb3ZlKGZ1bmN0aW9uKGMpe3JldHVybiAwPD1cbmEuYS5BKGIsYyl9KTpbXX0sZGVzdHJveTpmdW5jdGlvbihiKXt2YXIgYz10aGlzLnYoKSxkPVwiZnVuY3Rpb25cIiE9dHlwZW9mIGJ8fGEuTyhiKT9mdW5jdGlvbihhKXtyZXR1cm4gYT09PWJ9OmI7dGhpcy55YSgpO2Zvcih2YXIgZT1jLmxlbmd0aC0xOzA8PWU7ZS0tKXt2YXIgZj1jW2VdO2QoZikmJihmLl9kZXN0cm95PSEwKX10aGlzLnhhKCl9LGRlc3Ryb3lBbGw6ZnVuY3Rpb24oYil7cmV0dXJuIGI9PT1uP3RoaXMuZGVzdHJveShmdW5jdGlvbigpe3JldHVybiEwfSk6Yj90aGlzLmRlc3Ryb3koZnVuY3Rpb24oYyl7cmV0dXJuIDA8PWEuYS5BKGIsYyl9KTpbXX0saW5kZXhPZjpmdW5jdGlvbihiKXt2YXIgYz10aGlzKCk7cmV0dXJuIGEuYS5BKGMsYil9LHJlcGxhY2U6ZnVuY3Rpb24oYSxjKXt2YXIgZD10aGlzLmluZGV4T2YoYSk7MDw9ZCYmKHRoaXMueWEoKSx0aGlzLnYoKVtkXT1jLHRoaXMueGEoKSl9LHNvcnRlZDpmdW5jdGlvbihhKXt2YXIgYz10aGlzKCkuc2xpY2UoMCk7XG5yZXR1cm4gYT9jLnNvcnQoYSk6Yy5zb3J0KCl9LHJldmVyc2VkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMoKS5zbGljZSgwKS5yZXZlcnNlKCl9fTthLmEuQmEmJmEuYS5zZXRQcm90b3R5cGVPZihhLkhhLmZuLGEudGEuZm4pO2EuYS5EKFwicG9wIHB1c2ggcmV2ZXJzZSBzaGlmdCBzb3J0IHNwbGljZSB1bnNoaWZ0XCIuc3BsaXQoXCIgXCIpLGZ1bmN0aW9uKGIpe2EuSGEuZm5bYl09ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnYoKTt0aGlzLnlhKCk7dGhpcy56YyhhLGIsYXJndW1lbnRzKTt2YXIgZD1hW2JdLmFwcGx5KGEsYXJndW1lbnRzKTt0aGlzLnhhKCk7cmV0dXJuIGQ9PT1hP3RoaXM6ZH19KTthLmEuRChbXCJzbGljZVwiXSxmdW5jdGlvbihiKXthLkhhLmZuW2JdPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcygpO3JldHVybiBhW2JdLmFwcGx5KGEsYXJndW1lbnRzKX19KTthLlBjPWZ1bmN0aW9uKGIpe3JldHVybiBhLk8oYikmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGIucmVtb3ZlJiZcImZ1bmN0aW9uXCI9PVxudHlwZW9mIGIucHVzaH07YS5iKFwib2JzZXJ2YWJsZUFycmF5XCIsYS5IYSk7YS5iKFwiaXNPYnNlcnZhYmxlQXJyYXlcIixhLlBjKTthLlRhLnRyYWNrQXJyYXlDaGFuZ2VzPWZ1bmN0aW9uKGIsYyl7ZnVuY3Rpb24gZCgpe2Z1bmN0aW9uIGMoKXtpZihtKXt2YXIgZD1bXS5jb25jYXQoYi52KCl8fFtdKSxlO2lmKGIuV2EoXCJhcnJheUNoYW5nZVwiKSl7aWYoIWZ8fDE8bSlmPWEuYS5QYihrLGQsYi5PYik7ZT1mfWs9ZDtmPW51bGw7bT0wO2UmJmUubGVuZ3RoJiZiLm5vdGlmeVN1YnNjcmliZXJzKGUsXCJhcnJheUNoYW5nZVwiKX19ZT9jKCk6KGU9ITAsaD1iLnN1YnNjcmliZShmdW5jdGlvbigpeysrbX0sbnVsbCxcInNwZWN0YXRlXCIpLGs9W10uY29uY2F0KGIudigpfHxbXSksZj1udWxsLGc9Yi5zdWJzY3JpYmUoYykpfWIuT2I9e307YyYmXCJvYmplY3RcIj09dHlwZW9mIGMmJmEuYS5leHRlbmQoYi5PYixjKTtiLk9iLnNwYXJzZT0hMDtpZighYi56Yyl7dmFyIGU9ITEsZj1udWxsLGcsaCxtPTAsXG5rLGw9Yi5RYSxwPWIuaGI7Yi5RYT1mdW5jdGlvbihhKXtsJiZsLmNhbGwoYixhKTtcImFycmF5Q2hhbmdlXCI9PT1hJiZkKCl9O2IuaGI9ZnVuY3Rpb24oYSl7cCYmcC5jYWxsKGIsYSk7XCJhcnJheUNoYW5nZVwiIT09YXx8Yi5XYShcImFycmF5Q2hhbmdlXCIpfHwoZyYmZy5zKCksaCYmaC5zKCksaD1nPW51bGwsZT0hMSxrPW4pfTtiLnpjPWZ1bmN0aW9uKGIsYyxkKXtmdW5jdGlvbiBsKGEsYixjKXtyZXR1cm4ga1trLmxlbmd0aF09e3N0YXR1czphLHZhbHVlOmIsaW5kZXg6Y319aWYoZSYmIW0pe3ZhciBrPVtdLHA9Yi5sZW5ndGgsZz1kLmxlbmd0aCxoPTA7c3dpdGNoKGMpe2Nhc2UgXCJwdXNoXCI6aD1wO2Nhc2UgXCJ1bnNoaWZ0XCI6Zm9yKGM9MDtjPGc7YysrKWwoXCJhZGRlZFwiLGRbY10saCtjKTticmVhaztjYXNlIFwicG9wXCI6aD1wLTE7Y2FzZSBcInNoaWZ0XCI6cCYmbChcImRlbGV0ZWRcIixiW2hdLGgpO2JyZWFrO2Nhc2UgXCJzcGxpY2VcIjpjPU1hdGgubWluKE1hdGgubWF4KDAsMD5kWzBdP3ArZFswXTpcbmRbMF0pLHApO2Zvcih2YXIgcD0xPT09Zz9wOk1hdGgubWluKGMrKGRbMV18fDApLHApLGc9YytnLTIsaD1NYXRoLm1heChwLGcpLFU9W10sTD1bXSxuPTI7YzxoOysrYywrK24pYzxwJiZMLnB1c2gobChcImRlbGV0ZWRcIixiW2NdLGMpKSxjPGcmJlUucHVzaChsKFwiYWRkZWRcIixkW25dLGMpKTthLmEuS2MoTCxVKTticmVhaztkZWZhdWx0OnJldHVybn1mPWt9fX19O3ZhciByPWEuYS5EYShcIl9zdGF0ZVwiKTthLm89YS4kPWZ1bmN0aW9uKGIsYyxkKXtmdW5jdGlvbiBlKCl7aWYoMDxhcmd1bWVudHMubGVuZ3RoKXtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgZilmLmFwcGx5KGcubmIsYXJndW1lbnRzKTtlbHNlIHRocm93IEVycm9yKFwiQ2Fubm90IHdyaXRlIGEgdmFsdWUgdG8gYSBrby5jb21wdXRlZCB1bmxlc3MgeW91IHNwZWNpZnkgYSAnd3JpdGUnIG9wdGlvbi4gSWYgeW91IHdpc2ggdG8gcmVhZCB0aGUgY3VycmVudCB2YWx1ZSwgZG9uJ3QgcGFzcyBhbnkgcGFyYW1ldGVycy5cIik7cmV0dXJuIHRoaXN9Zy5yYXx8XG5hLnUuY2MoZSk7KGcua2F8fGcuSiYmZS5YYSgpKSYmZS5oYSgpO3JldHVybiBnLlh9XCJvYmplY3RcIj09PXR5cGVvZiBiP2Q9YjooZD1kfHx7fSxiJiYoZC5yZWFkPWIpKTtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBkLnJlYWQpdGhyb3cgRXJyb3IoXCJQYXNzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUga28uY29tcHV0ZWRcIik7dmFyIGY9ZC53cml0ZSxnPXtYOm4sc2E6ITAsa2E6ITAscmI6ITEsamM6ITEscmE6ITEsd2I6ITEsSjohMSxXYzpkLnJlYWQsbmI6Y3x8ZC5vd25lcixsOmQuZGlzcG9zZVdoZW5Ob2RlSXNSZW1vdmVkfHxkLmx8fG51bGwsU2E6ZC5kaXNwb3NlV2hlbnx8ZC5TYSxSYjpudWxsLEk6e30sVjowLEljOm51bGx9O2Vbcl09ZztlLk5jPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBmO2EuYS5CYXx8YS5hLmV4dGVuZChlLGEuVC5mbik7YS5ULmZuLnFiKGUpO2EuYS5BYihlLEMpO2QucHVyZT8oZy53Yj0hMCxnLko9ITAsYS5hLmV4dGVuZChlLGRhKSk6XG5kLmRlZmVyRXZhbHVhdGlvbiYmYS5hLmV4dGVuZChlLGVhKTthLm9wdGlvbnMuZGVmZXJVcGRhdGVzJiZhLlRhLmRlZmVycmVkKGUsITApO2cubCYmKGcuamM9ITAsZy5sLm5vZGVUeXBlfHwoZy5sPW51bGwpKTtnLkp8fGQuZGVmZXJFdmFsdWF0aW9ufHxlLmhhKCk7Zy5sJiZlLmphKCkmJmEuYS5LLnphKGcubCxnLlJiPWZ1bmN0aW9uKCl7ZS5zKCl9KTtyZXR1cm4gZX07dmFyIEM9e2VxdWFsaXR5Q29tcGFyZXI6SyxxYTpmdW5jdGlvbigpe3JldHVybiB0aGlzW3JdLlZ9LFZhOmZ1bmN0aW9uKCl7dmFyIGI9W107YS5hLlAodGhpc1tyXS5JLGZ1bmN0aW9uKGEsZCl7YltkLkthXT1kLmRhfSk7cmV0dXJuIGJ9LFZiOmZ1bmN0aW9uKGIpe2lmKCF0aGlzW3JdLlYpcmV0dXJuITE7dmFyIGM9dGhpcy5WYSgpO3JldHVybi0xIT09YS5hLkEoYyxiKT8hMDohIWEuYS5MYihjLGZ1bmN0aW9uKGEpe3JldHVybiBhLlZiJiZhLlZiKGIpfSl9LHVjOmZ1bmN0aW9uKGEsYyxkKXtpZih0aGlzW3JdLndiJiZcbmM9PT10aGlzKXRocm93IEVycm9yKFwiQSAncHVyZScgY29tcHV0ZWQgbXVzdCBub3QgYmUgY2FsbGVkIHJlY3Vyc2l2ZWx5XCIpO3RoaXNbcl0uSVthXT1kO2QuS2E9dGhpc1tyXS5WKys7ZC5MYT1jLm9iKCl9LFhhOmZ1bmN0aW9uKCl7dmFyIGEsYyxkPXRoaXNbcl0uSTtmb3IoYSBpbiBkKWlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkLGEpJiYoYz1kW2FdLHRoaXMuSWEmJmMuZGEuSmF8fGMuZGEuRGQoYy5MYSkpKXJldHVybiEwfSxKZDpmdW5jdGlvbigpe3RoaXMuSWEmJiF0aGlzW3JdLnJiJiZ0aGlzLklhKCExKX0samE6ZnVuY3Rpb24oKXt2YXIgYT10aGlzW3JdO3JldHVybiBhLmthfHwwPGEuVn0sUmQ6ZnVuY3Rpb24oKXt0aGlzLkphP3RoaXNbcl0ua2EmJih0aGlzW3JdLnNhPSEwKTp0aGlzLkhjKCl9LCRjOmZ1bmN0aW9uKGEpe2lmKGEuSGIpe3ZhciBjPWEuc3Vic2NyaWJlKHRoaXMuSmQsdGhpcyxcImRpcnR5XCIpLGQ9YS5zdWJzY3JpYmUodGhpcy5SZCxcbnRoaXMpO3JldHVybntkYTphLHM6ZnVuY3Rpb24oKXtjLnMoKTtkLnMoKX19fXJldHVybiBhLnN1YnNjcmliZSh0aGlzLkhjLHRoaXMpfSxIYzpmdW5jdGlvbigpe3ZhciBiPXRoaXMsYz1iLnRocm90dGxlRXZhbHVhdGlvbjtjJiYwPD1jPyhjbGVhclRpbWVvdXQodGhpc1tyXS5JYyksdGhpc1tyXS5JYz1hLmEuc2V0VGltZW91dChmdW5jdGlvbigpe2IuaGEoITApfSxjKSk6Yi5JYT9iLklhKCEwKTpiLmhhKCEwKX0saGE6ZnVuY3Rpb24oYil7dmFyIGM9dGhpc1tyXSxkPWMuU2EsZT0hMTtpZighYy5yYiYmIWMucmEpe2lmKGMubCYmIWEuYS5TYihjLmwpfHxkJiZkKCkpe2lmKCFjLmpjKXt0aGlzLnMoKTtyZXR1cm59fWVsc2UgYy5qYz0hMTtjLnJiPSEwO3RyeXtlPXRoaXMuemQoYil9ZmluYWxseXtjLnJiPSExfXJldHVybiBlfX0semQ6ZnVuY3Rpb24oYil7dmFyIGM9dGhpc1tyXSxkPSExLGU9Yy53Yj9uOiFjLlYsZD17cWQ6dGhpcyxtYjpjLkksUWI6Yy5WfTthLnUueGMoe3BkOmQsXG5vZDpiYSxvOnRoaXMsWWE6ZX0pO2MuST17fTtjLlY9MDt2YXIgZj10aGlzLnlkKGMsZCk7Yy5WP2Q9dGhpcy5zYihjLlgsZik6KHRoaXMucygpLGQ9ITApO2QmJihjLko/dGhpcy5HYigpOnRoaXMubm90aWZ5U3Vic2NyaWJlcnMoYy5YLFwiYmVmb3JlQ2hhbmdlXCIpLGMuWD1mLHRoaXMubm90aWZ5U3Vic2NyaWJlcnMoYy5YLFwic3BlY3RhdGVcIiksIWMuSiYmYiYmdGhpcy5ub3RpZnlTdWJzY3JpYmVycyhjLlgpLHRoaXMucmMmJnRoaXMucmMoKSk7ZSYmdGhpcy5ub3RpZnlTdWJzY3JpYmVycyhjLlgsXCJhd2FrZVwiKTtyZXR1cm4gZH0seWQ6ZnVuY3Rpb24oYixjKXt0cnl7dmFyIGQ9Yi5XYztyZXR1cm4gYi5uYj9kLmNhbGwoYi5uYik6ZCgpfWZpbmFsbHl7YS51LmVuZCgpLGMuUWImJiFiLkomJmEuYS5QKGMubWIsYWEpLGIuc2E9Yi5rYT0hMX19LHY6ZnVuY3Rpb24oYSl7dmFyIGM9dGhpc1tyXTsoYy5rYSYmKGF8fCFjLlYpfHxjLkomJnRoaXMuWGEoKSkmJnRoaXMuaGEoKTtyZXR1cm4gYy5YfSxcbnViOmZ1bmN0aW9uKGIpe2EuVC5mbi51Yi5jYWxsKHRoaXMsYik7dGhpcy5uYz1mdW5jdGlvbigpe3RoaXNbcl0uSnx8KHRoaXNbcl0uc2E/dGhpcy5oYSgpOnRoaXNbcl0ua2E9ITEpO3JldHVybiB0aGlzW3JdLlh9O3RoaXMuSWE9ZnVuY3Rpb24oYSl7dGhpcy5wYyh0aGlzW3JdLlgpO3RoaXNbcl0ua2E9ITA7YSYmKHRoaXNbcl0uc2E9ITApO3RoaXMucWModGhpcywhYSl9fSxzOmZ1bmN0aW9uKCl7dmFyIGI9dGhpc1tyXTshYi5KJiZiLkkmJmEuYS5QKGIuSSxmdW5jdGlvbihhLGIpe2IucyYmYi5zKCl9KTtiLmwmJmIuUmImJmEuYS5LLnliKGIubCxiLlJiKTtiLkk9bjtiLlY9MDtiLnJhPSEwO2Iuc2E9ITE7Yi5rYT0hMTtiLko9ITE7Yi5sPW47Yi5TYT1uO2IuV2M9bjt0aGlzLk5jfHwoYi5uYj1uKX19LGRhPXtRYTpmdW5jdGlvbihiKXt2YXIgYz10aGlzLGQ9Y1tyXTtpZighZC5yYSYmZC5KJiZcImNoYW5nZVwiPT1iKXtkLko9ITE7aWYoZC5zYXx8Yy5YYSgpKWQuST1udWxsLGQuVj1cbjAsYy5oYSgpJiZjLkdiKCk7ZWxzZXt2YXIgZT1bXTthLmEuUChkLkksZnVuY3Rpb24oYSxiKXtlW2IuS2FdPWF9KTthLmEuRChlLGZ1bmN0aW9uKGEsYil7dmFyIGU9ZC5JW2FdLG09Yy4kYyhlLmRhKTttLkthPWI7bS5MYT1lLkxhO2QuSVthXT1tfSk7Yy5YYSgpJiZjLmhhKCkmJmMuR2IoKX1kLnJhfHxjLm5vdGlmeVN1YnNjcmliZXJzKGQuWCxcImF3YWtlXCIpfX0saGI6ZnVuY3Rpb24oYil7dmFyIGM9dGhpc1tyXTtjLnJhfHxcImNoYW5nZVwiIT1ifHx0aGlzLldhKFwiY2hhbmdlXCIpfHwoYS5hLlAoYy5JLGZ1bmN0aW9uKGEsYil7Yi5zJiYoYy5JW2FdPXtkYTpiLmRhLEthOmIuS2EsTGE6Yi5MYX0sYi5zKCkpfSksYy5KPSEwLHRoaXMubm90aWZ5U3Vic2NyaWJlcnMobixcImFzbGVlcFwiKSl9LG9iOmZ1bmN0aW9uKCl7dmFyIGI9dGhpc1tyXTtiLkomJihiLnNhfHx0aGlzLlhhKCkpJiZ0aGlzLmhhKCk7cmV0dXJuIGEuVC5mbi5vYi5jYWxsKHRoaXMpfX0sZWE9e1FhOmZ1bmN0aW9uKGEpe1wiY2hhbmdlXCIhPVxuYSYmXCJiZWZvcmVDaGFuZ2VcIiE9YXx8dGhpcy52KCl9fTthLmEuQmEmJmEuYS5zZXRQcm90b3R5cGVPZihDLGEuVC5mbik7dmFyIE49YS50YS5NYTtDW05dPWEubzthLk9jPWZ1bmN0aW9uKGEpe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIGEmJmFbTl09PT1DW05dfTthLkZkPWZ1bmN0aW9uKGIpe3JldHVybiBhLk9jKGIpJiZiW3JdJiZiW3JdLndifTthLmIoXCJjb21wdXRlZFwiLGEubyk7YS5iKFwiZGVwZW5kZW50T2JzZXJ2YWJsZVwiLGEubyk7YS5iKFwiaXNDb21wdXRlZFwiLGEuT2MpO2EuYihcImlzUHVyZUNvbXB1dGVkXCIsYS5GZCk7YS5iKFwiY29tcHV0ZWQuZm5cIixDKTthLkwoQyxcInBlZWtcIixDLnYpO2EuTChDLFwiZGlzcG9zZVwiLEMucyk7YS5MKEMsXCJpc0FjdGl2ZVwiLEMuamEpO2EuTChDLFwiZ2V0RGVwZW5kZW5jaWVzQ291bnRcIixDLnFhKTthLkwoQyxcImdldERlcGVuZGVuY2llc1wiLEMuVmEpO2EueGI9ZnVuY3Rpb24oYixjKXtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgYilyZXR1cm4gYS5vKGIsXG5jLHtwdXJlOiEwfSk7Yj1hLmEuZXh0ZW5kKHt9LGIpO2IucHVyZT0hMDtyZXR1cm4gYS5vKGIsYyl9O2EuYihcInB1cmVDb21wdXRlZFwiLGEueGIpOyhmdW5jdGlvbigpe2Z1bmN0aW9uIGIoYSxmLGcpe2c9Z3x8bmV3IGQ7YT1mKGEpO2lmKFwib2JqZWN0XCIhPXR5cGVvZiBhfHxudWxsPT09YXx8YT09PW58fGEgaW5zdGFuY2VvZiBSZWdFeHB8fGEgaW5zdGFuY2VvZiBEYXRlfHxhIGluc3RhbmNlb2YgU3RyaW5nfHxhIGluc3RhbmNlb2YgTnVtYmVyfHxhIGluc3RhbmNlb2YgQm9vbGVhbilyZXR1cm4gYTt2YXIgaD1hIGluc3RhbmNlb2YgQXJyYXk/W106e307Zy5zYXZlKGEsaCk7YyhhLGZ1bmN0aW9uKGMpe3ZhciBkPWYoYVtjXSk7c3dpdGNoKHR5cGVvZiBkKXtjYXNlIFwiYm9vbGVhblwiOmNhc2UgXCJudW1iZXJcIjpjYXNlIFwic3RyaW5nXCI6Y2FzZSBcImZ1bmN0aW9uXCI6aFtjXT1kO2JyZWFrO2Nhc2UgXCJvYmplY3RcIjpjYXNlIFwidW5kZWZpbmVkXCI6dmFyIGw9Zy5nZXQoZCk7aFtjXT1sIT09XG5uP2w6YihkLGYsZyl9fSk7cmV0dXJuIGh9ZnVuY3Rpb24gYyhhLGIpe2lmKGEgaW5zdGFuY2VvZiBBcnJheSl7Zm9yKHZhciBjPTA7YzxhLmxlbmd0aDtjKyspYihjKTtcImZ1bmN0aW9uXCI9PXR5cGVvZiBhLnRvSlNPTiYmYihcInRvSlNPTlwiKX1lbHNlIGZvcihjIGluIGEpYihjKX1mdW5jdGlvbiBkKCl7dGhpcy5rZXlzPVtdO3RoaXMudmFsdWVzPVtdfWEuYWQ9ZnVuY3Rpb24oYyl7aWYoMD09YXJndW1lbnRzLmxlbmd0aCl0aHJvdyBFcnJvcihcIldoZW4gY2FsbGluZyBrby50b0pTLCBwYXNzIHRoZSBvYmplY3QgeW91IHdhbnQgdG8gY29udmVydC5cIik7cmV0dXJuIGIoYyxmdW5jdGlvbihiKXtmb3IodmFyIGM9MDthLk8oYikmJjEwPmM7YysrKWI9YigpO3JldHVybiBifSl9O2EudG9KU09OPWZ1bmN0aW9uKGIsYyxkKXtiPWEuYWQoYik7cmV0dXJuIGEuYS5oYyhiLGMsZCl9O2QucHJvdG90eXBlPXtjb25zdHJ1Y3RvcjpkLHNhdmU6ZnVuY3Rpb24oYixjKXt2YXIgZD1hLmEuQSh0aGlzLmtleXMsXG5iKTswPD1kP3RoaXMudmFsdWVzW2RdPWM6KHRoaXMua2V5cy5wdXNoKGIpLHRoaXMudmFsdWVzLnB1c2goYykpfSxnZXQ6ZnVuY3Rpb24oYil7Yj1hLmEuQSh0aGlzLmtleXMsYik7cmV0dXJuIDA8PWI/dGhpcy52YWx1ZXNbYl06bn19fSkoKTthLmIoXCJ0b0pTXCIsYS5hZCk7YS5iKFwidG9KU09OXCIsYS50b0pTT04pO2EuV2Q9ZnVuY3Rpb24oYixjLGQpe2Z1bmN0aW9uIGUoYyl7dmFyIGU9YS54YihiLGQpLmV4dGVuZCh7bWE6XCJhbHdheXNcIn0pLGg9ZS5zdWJzY3JpYmUoZnVuY3Rpb24oYSl7YSYmKGgucygpLGMoYSkpfSk7ZS5ub3RpZnlTdWJzY3JpYmVycyhlLnYoKSk7cmV0dXJuIGh9cmV0dXJuXCJmdW5jdGlvblwiIT09dHlwZW9mIFByb21pc2V8fGM/ZShjLmJpbmQoZCkpOm5ldyBQcm9taXNlKGUpfTthLmIoXCJ3aGVuXCIsYS5XZCk7KGZ1bmN0aW9uKCl7YS53PXtNOmZ1bmN0aW9uKGIpe3N3aXRjaChhLmEuUihiKSl7Y2FzZSBcIm9wdGlvblwiOnJldHVybiEwPT09Yi5fX2tvX19oYXNEb21EYXRhT3B0aW9uVmFsdWVfXz9cbmEuYS5nLmdldChiLGEuYy5vcHRpb25zLiRiKTo3Pj1hLmEuVz9iLmdldEF0dHJpYnV0ZU5vZGUoXCJ2YWx1ZVwiKSYmYi5nZXRBdHRyaWJ1dGVOb2RlKFwidmFsdWVcIikuc3BlY2lmaWVkP2IudmFsdWU6Yi50ZXh0OmIudmFsdWU7Y2FzZSBcInNlbGVjdFwiOnJldHVybiAwPD1iLnNlbGVjdGVkSW5kZXg/YS53Lk0oYi5vcHRpb25zW2Iuc2VsZWN0ZWRJbmRleF0pOm47ZGVmYXVsdDpyZXR1cm4gYi52YWx1ZX19LGNiOmZ1bmN0aW9uKGIsYyxkKXtzd2l0Y2goYS5hLlIoYikpe2Nhc2UgXCJvcHRpb25cIjpcInN0cmluZ1wiPT09dHlwZW9mIGM/KGEuYS5nLnNldChiLGEuYy5vcHRpb25zLiRiLG4pLFwiX19rb19faGFzRG9tRGF0YU9wdGlvblZhbHVlX19cImluIGImJmRlbGV0ZSBiLl9fa29fX2hhc0RvbURhdGFPcHRpb25WYWx1ZV9fLGIudmFsdWU9Yyk6KGEuYS5nLnNldChiLGEuYy5vcHRpb25zLiRiLGMpLGIuX19rb19faGFzRG9tRGF0YU9wdGlvblZhbHVlX189ITAsYi52YWx1ZT1cIm51bWJlclwiPT09XG50eXBlb2YgYz9jOlwiXCIpO2JyZWFrO2Nhc2UgXCJzZWxlY3RcIjppZihcIlwiPT09Y3x8bnVsbD09PWMpYz1uO2Zvcih2YXIgZT0tMSxmPTAsZz1iLm9wdGlvbnMubGVuZ3RoLGg7ZjxnOysrZilpZihoPWEudy5NKGIub3B0aW9uc1tmXSksaD09Y3x8XCJcIj09PWgmJmM9PT1uKXtlPWY7YnJlYWt9aWYoZHx8MDw9ZXx8Yz09PW4mJjE8Yi5zaXplKWIuc2VsZWN0ZWRJbmRleD1lLDY9PT1hLmEuVyYmYS5hLnNldFRpbWVvdXQoZnVuY3Rpb24oKXtiLnNlbGVjdGVkSW5kZXg9ZX0sMCk7YnJlYWs7ZGVmYXVsdDppZihudWxsPT09Y3x8Yz09PW4pYz1cIlwiO2IudmFsdWU9Y319fX0pKCk7YS5iKFwic2VsZWN0RXh0ZW5zaW9uc1wiLGEudyk7YS5iKFwic2VsZWN0RXh0ZW5zaW9ucy5yZWFkVmFsdWVcIixhLncuTSk7YS5iKFwic2VsZWN0RXh0ZW5zaW9ucy53cml0ZVZhbHVlXCIsYS53LmNiKTthLm09ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGIpe2I9YS5hLkRiKGIpOzEyMz09PWIuY2hhckNvZGVBdCgwKSYmKGI9Yi5zbGljZSgxLFxuLTEpKTtiKz1cIlxcbixcIjt2YXIgYz1bXSxkPWIubWF0Y2goZSkscCxxPVtdLGg9MDtpZigxPGQubGVuZ3RoKXtmb3IodmFyIHg9MCxCO0I9ZFt4XTsrK3gpe3ZhciB1PUIuY2hhckNvZGVBdCgwKTtpZig0ND09PXUpe2lmKDA+PWgpe2MucHVzaChwJiZxLmxlbmd0aD97a2V5OnAsdmFsdWU6cS5qb2luKFwiXCIpfTp7dW5rbm93bjpwfHxxLmpvaW4oXCJcIil9KTtwPWg9MDtxPVtdO2NvbnRpbnVlfX1lbHNlIGlmKDU4PT09dSl7aWYoIWgmJiFwJiYxPT09cS5sZW5ndGgpe3A9cS5wb3AoKTtjb250aW51ZX19ZWxzZSBpZig0Nz09PXUmJjE8Qi5sZW5ndGgmJig0Nz09PUIuY2hhckNvZGVBdCgxKXx8NDI9PT1CLmNoYXJDb2RlQXQoMSkpKWNvbnRpbnVlO2Vsc2UgNDc9PT11JiZ4JiYxPEIubGVuZ3RoPyh1PWRbeC0xXS5tYXRjaChmKSkmJiFnW3VbMF1dJiYoYj1iLnN1YnN0cihiLmluZGV4T2YoQikrMSksZD1iLm1hdGNoKGUpLHg9LTEsQj1cIi9cIik6NDA9PT11fHwxMjM9PT11fHw5MT09PXU/KytoOlxuNDE9PT11fHwxMjU9PT11fHw5Mz09PXU/LS1oOnB8fHEubGVuZ3RofHwzNCE9PXUmJjM5IT09dXx8KEI9Qi5zbGljZSgxLC0xKSk7cS5wdXNoKEIpfWlmKDA8aCl0aHJvdyBFcnJvcihcIlVuYmFsYW5jZWQgcGFyZW50aGVzZXMsIGJyYWNlcywgb3IgYnJhY2tldHNcIik7fXJldHVybiBjfXZhciBjPVtcInRydWVcIixcImZhbHNlXCIsXCJudWxsXCIsXCJ1bmRlZmluZWRcIl0sZD0vXig/OlskX2Etel1bJFxcd10qfCguKykoXFwuXFxzKlskX2Etel1bJFxcd10qfFxcWy4rXFxdKSkkL2ksZT1SZWdFeHAoXCJcXFwiKD86XFxcXFxcXFwufFteXFxcIl0pKlxcXCJ8Jyg/OlxcXFxcXFxcLnxbXiddKSonfGAoPzpcXFxcXFxcXC58W15gXSkqYHwvXFxcXCooPzpbXipdfFxcXFwqK1teKi9dKSpcXFxcKisvfC8vLipcXG58Lyg/OlxcXFxcXFxcLnxbXi9dKSsvdyp8W15cXFxcczosL11bXixcXFwiJ2B7fSgpLzpbXFxcXF1dKlteXFxcXHMsXFxcIidge30oKS86W1xcXFxdXXxbXlxcXFxzXVwiLFwiZ1wiKSxmPS9bXFxdKVwiJ0EtWmEtejAtOV8kXSskLyxnPXtcImluXCI6MSxcInJldHVyblwiOjEsXCJ0eXBlb2ZcIjoxfSxcbmg9e307cmV0dXJue1JhOltdLHdhOmgsYWM6Yix2YjpmdW5jdGlvbihlLGYpe2Z1bmN0aW9uIGwoYixlKXt2YXIgZjtpZigheCl7dmFyIGs9YS5nZXRCaW5kaW5nSGFuZGxlcihiKTtpZihrJiZrLnByZXByb2Nlc3MmJiEoZT1rLnByZXByb2Nlc3MoZSxiLGwpKSlyZXR1cm47aWYoaz1oW2JdKWY9ZSwwPD1hLmEuQShjLGYpP2Y9ITE6KGs9Zi5tYXRjaChkKSxmPW51bGw9PT1rPyExOmtbMV0/XCJPYmplY3QoXCIra1sxXStcIilcIitrWzJdOmYpLGs9ZjtrJiZxLnB1c2goXCInXCIrKFwic3RyaW5nXCI9PXR5cGVvZiBoW2JdP2hbYl06YikrXCInOmZ1bmN0aW9uKF96KXtcIitmK1wiPV96fVwiKX1nJiYoZT1cImZ1bmN0aW9uKCl7cmV0dXJuIFwiK2UrXCIgfVwiKTtwLnB1c2goXCInXCIrYitcIic6XCIrZSl9Zj1mfHx7fTt2YXIgcD1bXSxxPVtdLGc9Zi52YWx1ZUFjY2Vzc29ycyx4PWYuYmluZGluZ1BhcmFtcyxCPVwic3RyaW5nXCI9PT10eXBlb2YgZT9iKGUpOmU7YS5hLkQoQixmdW5jdGlvbihhKXtsKGEua2V5fHxhLnVua25vd24sXG5hLnZhbHVlKX0pO3EubGVuZ3RoJiZsKFwiX2tvX3Byb3BlcnR5X3dyaXRlcnNcIixcIntcIitxLmpvaW4oXCIsXCIpK1wiIH1cIik7cmV0dXJuIHAuam9pbihcIixcIil9LElkOmZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPTA7YzxhLmxlbmd0aDtjKyspaWYoYVtjXS5rZXk9PWIpcmV0dXJuITA7cmV0dXJuITF9LGViOmZ1bmN0aW9uKGIsYyxkLGUsZil7aWYoYiYmYS5PKGIpKSFhLlphKGIpfHxmJiZiLnYoKT09PWV8fGIoZSk7ZWxzZSBpZigoYj1jLmdldChcIl9rb19wcm9wZXJ0eV93cml0ZXJzXCIpKSYmYltkXSliW2RdKGUpfX19KCk7YS5iKFwiZXhwcmVzc2lvblJld3JpdGluZ1wiLGEubSk7YS5iKFwiZXhwcmVzc2lvblJld3JpdGluZy5iaW5kaW5nUmV3cml0ZVZhbGlkYXRvcnNcIixhLm0uUmEpO2EuYihcImV4cHJlc3Npb25SZXdyaXRpbmcucGFyc2VPYmplY3RMaXRlcmFsXCIsYS5tLmFjKTthLmIoXCJleHByZXNzaW9uUmV3cml0aW5nLnByZVByb2Nlc3NCaW5kaW5nc1wiLGEubS52Yik7YS5iKFwiZXhwcmVzc2lvblJld3JpdGluZy5fdHdvV2F5QmluZGluZ3NcIixcbmEubS53YSk7YS5iKFwianNvbkV4cHJlc3Npb25SZXdyaXRpbmdcIixhLm0pO2EuYihcImpzb25FeHByZXNzaW9uUmV3cml0aW5nLmluc2VydFByb3BlcnR5QWNjZXNzb3JzSW50b0pzb25cIixhLm0udmIpOyhmdW5jdGlvbigpe2Z1bmN0aW9uIGIoYSl7cmV0dXJuIDg9PWEubm9kZVR5cGUmJmcudGVzdChmP2EudGV4dDphLm5vZGVWYWx1ZSl9ZnVuY3Rpb24gYyhhKXtyZXR1cm4gOD09YS5ub2RlVHlwZSYmaC50ZXN0KGY/YS50ZXh0OmEubm9kZVZhbHVlKX1mdW5jdGlvbiBkKGQsZSl7Zm9yKHZhciBmPWQsaD0xLGc9W107Zj1mLm5leHRTaWJsaW5nOyl7aWYoYyhmKSYmKGEuYS5nLnNldChmLGssITApLGgtLSwwPT09aCkpcmV0dXJuIGc7Zy5wdXNoKGYpO2IoZikmJmgrK31pZighZSl0aHJvdyBFcnJvcihcIkNhbm5vdCBmaW5kIGNsb3NpbmcgY29tbWVudCB0YWcgdG8gbWF0Y2g6IFwiK2Qubm9kZVZhbHVlKTtyZXR1cm4gbnVsbH1mdW5jdGlvbiBlKGEsYil7dmFyIGM9ZChhLGIpO3JldHVybiBjP1xuMDxjLmxlbmd0aD9jW2MubGVuZ3RoLTFdLm5leHRTaWJsaW5nOmEubmV4dFNpYmxpbmc6bnVsbH12YXIgZj13JiZcIlxceDNjIS0tdGVzdC0tXFx4M2VcIj09PXcuY3JlYXRlQ29tbWVudChcInRlc3RcIikudGV4dCxnPWY/L15cXHgzYyEtLVxccyprbyg/OlxccysoW1xcc1xcU10rKSk/XFxzKi0tXFx4M2UkLzovXlxccyprbyg/OlxccysoW1xcc1xcU10rKSk/XFxzKiQvLGg9Zj8vXlxceDNjIS0tXFxzKlxcL2tvXFxzKi0tXFx4M2UkLzovXlxccypcXC9rb1xccyokLyxtPXt1bDohMCxvbDohMH0saz1cIl9fa29fbWF0Y2hlZEVuZENvbW1lbnRfX1wiO2EuaD17ZWE6e30sY2hpbGROb2RlczpmdW5jdGlvbihhKXtyZXR1cm4gYihhKT9kKGEpOmEuY2hpbGROb2Rlc30sRWE6ZnVuY3Rpb24oYyl7aWYoYihjKSl7Yz1hLmguY2hpbGROb2RlcyhjKTtmb3IodmFyIGQ9MCxlPWMubGVuZ3RoO2Q8ZTtkKyspYS5yZW1vdmVOb2RlKGNbZF0pfWVsc2UgYS5hLlRiKGMpfSx2YTpmdW5jdGlvbihjLGQpe2lmKGIoYykpe2EuaC5FYShjKTtmb3IodmFyIGU9XG5jLm5leHRTaWJsaW5nLGY9MCxrPWQubGVuZ3RoO2Y8aztmKyspZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShkW2ZdLGUpfWVsc2UgYS5hLnZhKGMsZCl9LFZjOmZ1bmN0aW9uKGEsYyl7dmFyIGQ7YihhKT8oZD1hLm5leHRTaWJsaW5nLGE9YS5wYXJlbnROb2RlKTpkPWEuZmlyc3RDaGlsZDtkP2MhPT1kJiZhLmluc2VydEJlZm9yZShjLGQpOmEuYXBwZW5kQ2hpbGQoYyl9LFdiOmZ1bmN0aW9uKGMsZCxlKXtlPyhlPWUubmV4dFNpYmxpbmcsYihjKSYmKGM9Yy5wYXJlbnROb2RlKSxlP2QhPT1lJiZjLmluc2VydEJlZm9yZShkLGUpOmMuYXBwZW5kQ2hpbGQoZCkpOmEuaC5WYyhjLGQpfSxmaXJzdENoaWxkOmZ1bmN0aW9uKGEpe2lmKGIoYSkpcmV0dXJuIWEubmV4dFNpYmxpbmd8fGMoYS5uZXh0U2libGluZyk/bnVsbDphLm5leHRTaWJsaW5nO2lmKGEuZmlyc3RDaGlsZCYmYyhhLmZpcnN0Q2hpbGQpKXRocm93IEVycm9yKFwiRm91bmQgaW52YWxpZCBlbmQgY29tbWVudCwgYXMgdGhlIGZpcnN0IGNoaWxkIG9mIFwiK1xuYSk7cmV0dXJuIGEuZmlyc3RDaGlsZH0sbmV4dFNpYmxpbmc6ZnVuY3Rpb24oZCl7YihkKSYmKGQ9ZShkKSk7aWYoZC5uZXh0U2libGluZyYmYyhkLm5leHRTaWJsaW5nKSl7dmFyIGY9ZC5uZXh0U2libGluZztpZihjKGYpJiYhYS5hLmcuZ2V0KGYsaykpdGhyb3cgRXJyb3IoXCJGb3VuZCBlbmQgY29tbWVudCB3aXRob3V0IGEgbWF0Y2hpbmcgb3BlbmluZyBjb21tZW50LCBhcyBjaGlsZCBvZiBcIitkKTtyZXR1cm4gbnVsbH1yZXR1cm4gZC5uZXh0U2libGluZ30sQ2Q6YixWZDpmdW5jdGlvbihhKXtyZXR1cm4oYT0oZj9hLnRleHQ6YS5ub2RlVmFsdWUpLm1hdGNoKGcpKT9hWzFdOm51bGx9LFNjOmZ1bmN0aW9uKGQpe2lmKG1bYS5hLlIoZCldKXt2YXIgZj1kLmZpcnN0Q2hpbGQ7aWYoZil7ZG8gaWYoMT09PWYubm9kZVR5cGUpe3ZhciBrO2s9Zi5maXJzdENoaWxkO3ZhciBoPW51bGw7aWYoayl7ZG8gaWYoaCloLnB1c2goayk7ZWxzZSBpZihiKGspKXt2YXIgZz1lKGssITApO2c/az1cbmc6aD1ba119ZWxzZSBjKGspJiYoaD1ba10pO3doaWxlKGs9ay5uZXh0U2libGluZyl9aWYoaz1oKWZvcihoPWYubmV4dFNpYmxpbmcsZz0wO2c8ay5sZW5ndGg7ZysrKWg/ZC5pbnNlcnRCZWZvcmUoa1tnXSxoKTpkLmFwcGVuZENoaWxkKGtbZ10pfXdoaWxlKGY9Zi5uZXh0U2libGluZyl9fX19fSkoKTthLmIoXCJ2aXJ0dWFsRWxlbWVudHNcIixhLmgpO2EuYihcInZpcnR1YWxFbGVtZW50cy5hbGxvd2VkQmluZGluZ3NcIixhLmguZWEpO2EuYihcInZpcnR1YWxFbGVtZW50cy5lbXB0eU5vZGVcIixhLmguRWEpO2EuYihcInZpcnR1YWxFbGVtZW50cy5pbnNlcnRBZnRlclwiLGEuaC5XYik7YS5iKFwidmlydHVhbEVsZW1lbnRzLnByZXBlbmRcIixhLmguVmMpO2EuYihcInZpcnR1YWxFbGVtZW50cy5zZXREb21Ob2RlQ2hpbGRyZW5cIixhLmgudmEpOyhmdW5jdGlvbigpe2EuZ2E9ZnVuY3Rpb24oKXt0aGlzLm5kPXt9fTthLmEuZXh0ZW5kKGEuZ2EucHJvdG90eXBlLHtub2RlSGFzQmluZGluZ3M6ZnVuY3Rpb24oYil7c3dpdGNoKGIubm9kZVR5cGUpe2Nhc2UgMTpyZXR1cm4gbnVsbCE9XG5iLmdldEF0dHJpYnV0ZShcImRhdGEtYmluZFwiKXx8YS5qLmdldENvbXBvbmVudE5hbWVGb3JOb2RlKGIpO2Nhc2UgODpyZXR1cm4gYS5oLkNkKGIpO2RlZmF1bHQ6cmV0dXJuITF9fSxnZXRCaW5kaW5nczpmdW5jdGlvbihiLGMpe3ZhciBkPXRoaXMuZ2V0QmluZGluZ3NTdHJpbmcoYixjKSxkPWQ/dGhpcy5wYXJzZUJpbmRpbmdzU3RyaW5nKGQsYyxiKTpudWxsO3JldHVybiBhLmoudGMoZCxiLGMsITEpfSxnZXRCaW5kaW5nQWNjZXNzb3JzOmZ1bmN0aW9uKGIsYyl7dmFyIGQ9dGhpcy5nZXRCaW5kaW5nc1N0cmluZyhiLGMpLGQ9ZD90aGlzLnBhcnNlQmluZGluZ3NTdHJpbmcoZCxjLGIse3ZhbHVlQWNjZXNzb3JzOiEwfSk6bnVsbDtyZXR1cm4gYS5qLnRjKGQsYixjLCEwKX0sZ2V0QmluZGluZ3NTdHJpbmc6ZnVuY3Rpb24oYil7c3dpdGNoKGIubm9kZVR5cGUpe2Nhc2UgMTpyZXR1cm4gYi5nZXRBdHRyaWJ1dGUoXCJkYXRhLWJpbmRcIik7Y2FzZSA4OnJldHVybiBhLmguVmQoYik7ZGVmYXVsdDpyZXR1cm4gbnVsbH19LFxucGFyc2VCaW5kaW5nc1N0cmluZzpmdW5jdGlvbihiLGMsZCxlKXt0cnl7dmFyIGY9dGhpcy5uZCxnPWIrKGUmJmUudmFsdWVBY2Nlc3NvcnN8fFwiXCIpLGg7aWYoIShoPWZbZ10pKXt2YXIgbSxrPVwid2l0aCgkY29udGV4dCl7d2l0aCgkZGF0YXx8e30pe3JldHVybntcIithLm0udmIoYixlKStcIn19fVwiO209bmV3IEZ1bmN0aW9uKFwiJGNvbnRleHRcIixcIiRlbGVtZW50XCIsayk7aD1mW2ddPW19cmV0dXJuIGgoYyxkKX1jYXRjaChsKXt0aHJvdyBsLm1lc3NhZ2U9XCJVbmFibGUgdG8gcGFyc2UgYmluZGluZ3MuXFxuQmluZGluZ3MgdmFsdWU6IFwiK2IrXCJcXG5NZXNzYWdlOiBcIitsLm1lc3NhZ2UsbDt9fX0pO2EuZ2EuaW5zdGFuY2U9bmV3IGEuZ2F9KSgpO2EuYihcImJpbmRpbmdQcm92aWRlclwiLGEuZ2EpOyhmdW5jdGlvbigpe2Z1bmN0aW9uIGIoYil7dmFyIGM9KGI9YS5hLmcuZ2V0KGIseikpJiZiLk47YyYmKGIuTj1udWxsLGMuVGMoKSl9ZnVuY3Rpb24gYyhjLGQsZSl7dGhpcy5ub2RlPWM7dGhpcy55Yz1cbmQ7dGhpcy5rYj1bXTt0aGlzLkg9ITE7ZC5OfHxhLmEuSy56YShjLGIpO2UmJmUuTiYmKGUuTi5rYi5wdXNoKGMpLHRoaXMuS2I9ZSl9ZnVuY3Rpb24gZChhKXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gYX19ZnVuY3Rpb24gZShhKXtyZXR1cm4gYSgpfWZ1bmN0aW9uIGYoYil7cmV0dXJuIGEuYS5HYShhLnUuRyhiKSxmdW5jdGlvbihhLGMpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiBiKClbY119fSl9ZnVuY3Rpb24gZyhiLGMsZSl7cmV0dXJuXCJmdW5jdGlvblwiPT09dHlwZW9mIGI/ZihiLmJpbmQobnVsbCxjLGUpKTphLmEuR2EoYixkKX1mdW5jdGlvbiBoKGEsYil7cmV0dXJuIGYodGhpcy5nZXRCaW5kaW5ncy5iaW5kKHRoaXMsYSxiKSl9ZnVuY3Rpb24gbShiLGMpe3ZhciBkPWEuaC5maXJzdENoaWxkKGMpO2lmKGQpe3ZhciBlLGY9YS5nYS5pbnN0YW5jZSxsPWYucHJlcHJvY2Vzc05vZGU7aWYobCl7Zm9yKDtlPWQ7KWQ9YS5oLm5leHRTaWJsaW5nKGUpLGwuY2FsbChmLGUpO1xuZD1hLmguZmlyc3RDaGlsZChjKX1mb3IoO2U9ZDspZD1hLmgubmV4dFNpYmxpbmcoZSksayhiLGUpfWEuaS5tYShjLGEuaS5IKX1mdW5jdGlvbiBrKGIsYyl7dmFyIGQ9YixlPTE9PT1jLm5vZGVUeXBlO2UmJmEuaC5TYyhjKTtpZihlfHxhLmdhLmluc3RhbmNlLm5vZGVIYXNCaW5kaW5ncyhjKSlkPXAoYyxudWxsLGIpLmJpbmRpbmdDb250ZXh0Rm9yRGVzY2VuZGFudHM7ZCYmIXVbYS5hLlIoYyldJiZtKGQsYyl9ZnVuY3Rpb24gbChiKXt2YXIgYz1bXSxkPXt9LGU9W107YS5hLlAoYixmdW5jdGlvbiBjYShmKXtpZighZFtmXSl7dmFyIGs9YS5nZXRCaW5kaW5nSGFuZGxlcihmKTtrJiYoay5hZnRlciYmKGUucHVzaChmKSxhLmEuRChrLmFmdGVyLGZ1bmN0aW9uKGMpe2lmKGJbY10pe2lmKC0xIT09YS5hLkEoZSxjKSl0aHJvdyBFcnJvcihcIkNhbm5vdCBjb21iaW5lIHRoZSBmb2xsb3dpbmcgYmluZGluZ3MsIGJlY2F1c2UgdGhleSBoYXZlIGEgY3ljbGljIGRlcGVuZGVuY3k6IFwiK2Uuam9pbihcIiwgXCIpKTtcbmNhKGMpfX0pLGUubGVuZ3RoLS0pLGMucHVzaCh7a2V5OmYsTWM6a30pKTtkW2ZdPSEwfX0pO3JldHVybiBjfWZ1bmN0aW9uIHAoYixjLGQpe3ZhciBmPWEuYS5nLlViKGIseix7fSksaz1mLmhkO2lmKCFjKXtpZihrKXRocm93IEVycm9yKFwiWW91IGNhbm5vdCBhcHBseSBiaW5kaW5ncyBtdWx0aXBsZSB0aW1lcyB0byB0aGUgc2FtZSBlbGVtZW50LlwiKTtmLmhkPSEwfWt8fChmLmNvbnRleHQ9ZCk7Zi5aYnx8KGYuWmI9e30pO3ZhciBnO2lmKGMmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBjKWc9YztlbHNle3ZhciBwPWEuZ2EuaW5zdGFuY2UscT1wLmdldEJpbmRpbmdBY2Nlc3NvcnN8fGgsbT1hLiQoZnVuY3Rpb24oKXtpZihnPWM/YyhkLGIpOnEuY2FsbChwLGIsZCkpe2lmKGRbdF0pZFt0XSgpO2lmKGRbQl0pZFtCXSgpfXJldHVybiBnfSxudWxsLHtsOmJ9KTtnJiZtLmphKCl8fChtPW51bGwpfXZhciB4PWQsdTtpZihnKXt2YXIgSj1mdW5jdGlvbigpe3JldHVybiBhLmEuR2EobT9tKCk6XG5nLGUpfSxyPW0/ZnVuY3Rpb24oYSl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGUobSgpW2FdKX19OmZ1bmN0aW9uKGEpe3JldHVybiBnW2FdfTtKLmdldD1mdW5jdGlvbihhKXtyZXR1cm4gZ1thXSYmZShyKGEpKX07Si5oYXM9ZnVuY3Rpb24oYSl7cmV0dXJuIGEgaW4gZ307YS5pLkggaW4gZyYmYS5pLnN1YnNjcmliZShiLGEuaS5ILGZ1bmN0aW9uKCl7dmFyIGM9KDAsZ1thLmkuSF0pKCk7aWYoYyl7dmFyIGQ9YS5oLmNoaWxkTm9kZXMoYik7ZC5sZW5ndGgmJmMoZCxhLkVjKGRbMF0pKX19KTthLmkucGEgaW4gZyYmKHg9YS5pLkNiKGIsZCksYS5pLnN1YnNjcmliZShiLGEuaS5wYSxmdW5jdGlvbigpe3ZhciBjPSgwLGdbYS5pLnBhXSkoKTtjJiZhLmguZmlyc3RDaGlsZChiKSYmYyhiKX0pKTtmPWwoZyk7YS5hLkQoZixmdW5jdGlvbihjKXt2YXIgZD1jLk1jLmluaXQsZT1jLk1jLnVwZGF0ZSxmPWMua2V5O2lmKDg9PT1iLm5vZGVUeXBlJiYhYS5oLmVhW2ZdKXRocm93IEVycm9yKFwiVGhlIGJpbmRpbmcgJ1wiK1xuZitcIicgY2Fubm90IGJlIHVzZWQgd2l0aCB2aXJ0dWFsIGVsZW1lbnRzXCIpO3RyeXtcImZ1bmN0aW9uXCI9PXR5cGVvZiBkJiZhLnUuRyhmdW5jdGlvbigpe3ZhciBhPWQoYixyKGYpLEoseC4kZGF0YSx4KTtpZihhJiZhLmNvbnRyb2xzRGVzY2VuZGFudEJpbmRpbmdzKXtpZih1IT09bil0aHJvdyBFcnJvcihcIk11bHRpcGxlIGJpbmRpbmdzIChcIit1K1wiIGFuZCBcIitmK1wiKSBhcmUgdHJ5aW5nIHRvIGNvbnRyb2wgZGVzY2VuZGFudCBiaW5kaW5ncyBvZiB0aGUgc2FtZSBlbGVtZW50LiBZb3UgY2Fubm90IHVzZSB0aGVzZSBiaW5kaW5ncyB0b2dldGhlciBvbiB0aGUgc2FtZSBlbGVtZW50LlwiKTt1PWZ9fSksXCJmdW5jdGlvblwiPT10eXBlb2YgZSYmYS4kKGZ1bmN0aW9uKCl7ZShiLHIoZiksSix4LiRkYXRhLHgpfSxudWxsLHtsOmJ9KX1jYXRjaChrKXt0aHJvdyBrLm1lc3NhZ2U9J1VuYWJsZSB0byBwcm9jZXNzIGJpbmRpbmcgXCInK2YrXCI6IFwiK2dbZl0rJ1wiXFxuTWVzc2FnZTogJytrLm1lc3NhZ2UsXG5rO319KX1mPXU9PT1uO3JldHVybntzaG91bGRCaW5kRGVzY2VuZGFudHM6ZixiaW5kaW5nQ29udGV4dEZvckRlc2NlbmRhbnRzOmYmJnh9fWZ1bmN0aW9uIHEoYixjKXtyZXR1cm4gYiYmYiBpbnN0YW5jZW9mIGEuZmE/YjpuZXcgYS5mYShiLG4sbixjKX12YXIgdD1hLmEuRGEoXCJfc3Vic2NyaWJhYmxlXCIpLHg9YS5hLkRhKFwiX2FuY2VzdG9yQmluZGluZ0luZm9cIiksQj1hLmEuRGEoXCJfZGF0YURlcGVuZGVuY3lcIik7YS5jPXt9O3ZhciB1PXtzY3JpcHQ6ITAsdGV4dGFyZWE6ITAsdGVtcGxhdGU6ITB9O2EuZ2V0QmluZGluZ0hhbmRsZXI9ZnVuY3Rpb24oYil7cmV0dXJuIGEuY1tiXX07dmFyIEo9e307YS5mYT1mdW5jdGlvbihiLGMsZCxlLGYpe2Z1bmN0aW9uIGsoKXt2YXIgYj1wP2goKTpoLGY9YS5hLmYoYik7Yz8oYS5hLmV4dGVuZChsLGMpLHggaW4gYyYmKGxbeF09Y1t4XSkpOihsLiRwYXJlbnRzPVtdLGwuJHJvb3Q9ZixsLmtvPWEpO2xbdF09cTtnP2Y9bC4kZGF0YToobC4kcmF3RGF0YT1cbmIsbC4kZGF0YT1mKTtkJiYobFtkXT1mKTtlJiZlKGwsYyxmKTtpZihjJiZjW3RdJiYhYS5TLm8oKS5WYihjW3RdKSljW3RdKCk7bSYmKGxbQl09bSk7cmV0dXJuIGwuJGRhdGF9dmFyIGw9dGhpcyxnPWI9PT1KLGg9Zz9uOmIscD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBoJiYhYS5PKGgpLHEsbT1mJiZmLmRhdGFEZXBlbmRlbmN5O2YmJmYuZXhwb3J0RGVwZW5kZW5jaWVzP2soKToocT1hLnhiKGspLHEudigpLHEuamEoKT9xLmVxdWFsaXR5Q29tcGFyZXI9bnVsbDpsW3RdPW4pfTthLmZhLnByb3RvdHlwZS5jcmVhdGVDaGlsZENvbnRleHQ9ZnVuY3Rpb24oYixjLGQsZSl7IWUmJmMmJlwib2JqZWN0XCI9PXR5cGVvZiBjJiYoZT1jLGM9ZS5hcyxkPWUuZXh0ZW5kKTtpZihjJiZlJiZlLm5vQ2hpbGRDb250ZXh0KXt2YXIgZj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBiJiYhYS5PKGIpO3JldHVybiBuZXcgYS5mYShKLHRoaXMsbnVsbCxmdW5jdGlvbihhKXtkJiZkKGEpO2FbY109Zj9iKCk6Yn0sZSl9cmV0dXJuIG5ldyBhLmZhKGIsXG50aGlzLGMsZnVuY3Rpb24oYSxiKXthLiRwYXJlbnRDb250ZXh0PWI7YS4kcGFyZW50PWIuJGRhdGE7YS4kcGFyZW50cz0oYi4kcGFyZW50c3x8W10pLnNsaWNlKDApO2EuJHBhcmVudHMudW5zaGlmdChhLiRwYXJlbnQpO2QmJmQoYSl9LGUpfTthLmZhLnByb3RvdHlwZS5leHRlbmQ9ZnVuY3Rpb24oYixjKXtyZXR1cm4gbmV3IGEuZmEoSix0aGlzLG51bGwsZnVuY3Rpb24oYyl7YS5hLmV4dGVuZChjLFwiZnVuY3Rpb25cIj09dHlwZW9mIGI/YihjKTpiKX0sYyl9O3ZhciB6PWEuYS5nLlooKTtjLnByb3RvdHlwZS5UYz1mdW5jdGlvbigpe3RoaXMuS2ImJnRoaXMuS2IuTiYmdGhpcy5LYi5OLnNkKHRoaXMubm9kZSl9O2MucHJvdG90eXBlLnNkPWZ1bmN0aW9uKGIpe2EuYS5QYSh0aGlzLmtiLGIpOyF0aGlzLmtiLmxlbmd0aCYmdGhpcy5IJiZ0aGlzLkNjKCl9O2MucHJvdG90eXBlLkNjPWZ1bmN0aW9uKCl7dGhpcy5IPSEwO3RoaXMueWMuTiYmIXRoaXMua2IubGVuZ3RoJiYodGhpcy55Yy5OPVxubnVsbCxhLmEuSy55Yih0aGlzLm5vZGUsYiksYS5pLm1hKHRoaXMubm9kZSxhLmkucGEpLHRoaXMuVGMoKSl9O2EuaT17SDpcImNoaWxkcmVuQ29tcGxldGVcIixwYTpcImRlc2NlbmRhbnRzQ29tcGxldGVcIixzdWJzY3JpYmU6ZnVuY3Rpb24oYixjLGQsZSxmKXt2YXIgaz1hLmEuZy5VYihiLHose30pO2suRmF8fChrLkZhPW5ldyBhLlQpO2YmJmYubm90aWZ5SW1tZWRpYXRlbHkmJmsuWmJbY10mJmEudS5HKGQsZSxbYl0pO3JldHVybiBrLkZhLnN1YnNjcmliZShkLGUsYyl9LG1hOmZ1bmN0aW9uKGIsYyl7dmFyIGQ9YS5hLmcuZ2V0KGIseik7aWYoZCYmKGQuWmJbY109ITAsZC5GYSYmZC5GYS5ub3RpZnlTdWJzY3JpYmVycyhiLGMpLGM9PWEuaS5IKSlpZihkLk4pZC5OLkNjKCk7ZWxzZSBpZihkLk49PT1uJiZkLkZhJiZkLkZhLldhKGEuaS5wYSkpdGhyb3cgRXJyb3IoXCJkZXNjZW5kYW50c0NvbXBsZXRlIGV2ZW50IG5vdCBzdXBwb3J0ZWQgZm9yIGJpbmRpbmdzIG9uIHRoaXMgbm9kZVwiKTtcbn0sQ2I6ZnVuY3Rpb24oYixkKXt2YXIgZT1hLmEuZy5VYihiLHose30pO2UuTnx8KGUuTj1uZXcgYyhiLGUsZFt4XSkpO3JldHVybiBkW3hdPT1lP2Q6ZC5leHRlbmQoZnVuY3Rpb24oYSl7YVt4XT1lfSl9fTthLlRkPWZ1bmN0aW9uKGIpe3JldHVybihiPWEuYS5nLmdldChiLHopKSYmYi5jb250ZXh0fTthLmliPWZ1bmN0aW9uKGIsYyxkKXsxPT09Yi5ub2RlVHlwZSYmYS5oLlNjKGIpO3JldHVybiBwKGIsYyxxKGQpKX07YS5sZD1mdW5jdGlvbihiLGMsZCl7ZD1xKGQpO3JldHVybiBhLmliKGIsZyhjLGQsYiksZCl9O2EuT2E9ZnVuY3Rpb24oYSxiKXsxIT09Yi5ub2RlVHlwZSYmOCE9PWIubm9kZVR5cGV8fG0ocShhKSxiKX07YS52Yz1mdW5jdGlvbihhLGIsYyl7IXYmJkEualF1ZXJ5JiYodj1BLmpRdWVyeSk7aWYoMj5hcmd1bWVudHMubGVuZ3RoKXtpZihiPXcuYm9keSwhYil0aHJvdyBFcnJvcihcImtvLmFwcGx5QmluZGluZ3M6IGNvdWxkIG5vdCBmaW5kIGRvY3VtZW50LmJvZHk7IGhhcyB0aGUgZG9jdW1lbnQgYmVlbiBsb2FkZWQ/XCIpO1xufWVsc2UgaWYoIWJ8fDEhPT1iLm5vZGVUeXBlJiY4IT09Yi5ub2RlVHlwZSl0aHJvdyBFcnJvcihcImtvLmFwcGx5QmluZGluZ3M6IGZpcnN0IHBhcmFtZXRlciBzaG91bGQgYmUgeW91ciB2aWV3IG1vZGVsOyBzZWNvbmQgcGFyYW1ldGVyIHNob3VsZCBiZSBhIERPTSBub2RlXCIpO2socShhLGMpLGIpfTthLkRjPWZ1bmN0aW9uKGIpe3JldHVybiFifHwxIT09Yi5ub2RlVHlwZSYmOCE9PWIubm9kZVR5cGU/bjphLlRkKGIpfTthLkVjPWZ1bmN0aW9uKGIpe3JldHVybihiPWEuRGMoYikpP2IuJGRhdGE6bn07YS5iKFwiYmluZGluZ0hhbmRsZXJzXCIsYS5jKTthLmIoXCJiaW5kaW5nRXZlbnRcIixhLmkpO2EuYihcImJpbmRpbmdFdmVudC5zdWJzY3JpYmVcIixhLmkuc3Vic2NyaWJlKTthLmIoXCJiaW5kaW5nRXZlbnQuc3RhcnRQb3NzaWJseUFzeW5jQ29udGVudEJpbmRpbmdcIixhLmkuQ2IpO2EuYihcImFwcGx5QmluZGluZ3NcIixhLnZjKTthLmIoXCJhcHBseUJpbmRpbmdzVG9EZXNjZW5kYW50c1wiLGEuT2EpO1xuYS5iKFwiYXBwbHlCaW5kaW5nQWNjZXNzb3JzVG9Ob2RlXCIsYS5pYik7YS5iKFwiYXBwbHlCaW5kaW5nc1RvTm9kZVwiLGEubGQpO2EuYihcImNvbnRleHRGb3JcIixhLkRjKTthLmIoXCJkYXRhRm9yXCIsYS5FYyl9KSgpOyhmdW5jdGlvbihiKXtmdW5jdGlvbiBjKGMsZSl7dmFyIGs9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGYsYyk/ZltjXTpiLGw7az9rLnN1YnNjcmliZShlKTooaz1mW2NdPW5ldyBhLlQsay5zdWJzY3JpYmUoZSksZChjLGZ1bmN0aW9uKGIsZCl7dmFyIGU9ISghZHx8IWQuc3luY2hyb25vdXMpO2dbY109e2RlZmluaXRpb246YixHZDplfTtkZWxldGUgZltjXTtsfHxlP2subm90aWZ5U3Vic2NyaWJlcnMoYik6YS5uYS56YihmdW5jdGlvbigpe2subm90aWZ5U3Vic2NyaWJlcnMoYil9KX0pLGw9ITApfWZ1bmN0aW9uIGQoYSxiKXtlKFwiZ2V0Q29uZmlnXCIsW2FdLGZ1bmN0aW9uKGMpe2M/ZShcImxvYWRDb21wb25lbnRcIixbYSxjXSxmdW5jdGlvbihhKXtiKGEsXG5jKX0pOmIobnVsbCxudWxsKX0pfWZ1bmN0aW9uIGUoYyxkLGYsbCl7bHx8KGw9YS5qLmxvYWRlcnMuc2xpY2UoMCkpO3ZhciBnPWwuc2hpZnQoKTtpZihnKXt2YXIgcT1nW2NdO2lmKHEpe3ZhciB0PSExO2lmKHEuYXBwbHkoZyxkLmNvbmNhdChmdW5jdGlvbihhKXt0P2YobnVsbCk6bnVsbCE9PWE/ZihhKTplKGMsZCxmLGwpfSkpIT09YiYmKHQ9ITAsIWcuc3VwcHJlc3NMb2FkZXJFeGNlcHRpb25zKSl0aHJvdyBFcnJvcihcIkNvbXBvbmVudCBsb2FkZXJzIG11c3Qgc3VwcGx5IHZhbHVlcyBieSBpbnZva2luZyB0aGUgY2FsbGJhY2ssIG5vdCBieSByZXR1cm5pbmcgdmFsdWVzIHN5bmNocm9ub3VzbHkuXCIpO31lbHNlIGUoYyxkLGYsbCl9ZWxzZSBmKG51bGwpfXZhciBmPXt9LGc9e307YS5qPXtnZXQ6ZnVuY3Rpb24oZCxlKXt2YXIgZj1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZyxkKT9nW2RdOmI7Zj9mLkdkP2EudS5HKGZ1bmN0aW9uKCl7ZShmLmRlZmluaXRpb24pfSk6XG5hLm5hLnpiKGZ1bmN0aW9uKCl7ZShmLmRlZmluaXRpb24pfSk6YyhkLGUpfSxCYzpmdW5jdGlvbihhKXtkZWxldGUgZ1thXX0sb2M6ZX07YS5qLmxvYWRlcnM9W107YS5iKFwiY29tcG9uZW50c1wiLGEuaik7YS5iKFwiY29tcG9uZW50cy5nZXRcIixhLmouZ2V0KTthLmIoXCJjb21wb25lbnRzLmNsZWFyQ2FjaGVkRGVmaW5pdGlvblwiLGEuai5CYyl9KSgpOyhmdW5jdGlvbigpe2Z1bmN0aW9uIGIoYixjLGQsZSl7ZnVuY3Rpb24gZygpezA9PT0tLUImJmUoaCl9dmFyIGg9e30sQj0yLHU9ZC50ZW1wbGF0ZTtkPWQudmlld01vZGVsO3U/ZihjLHUsZnVuY3Rpb24oYyl7YS5qLm9jKFwibG9hZFRlbXBsYXRlXCIsW2IsY10sZnVuY3Rpb24oYSl7aC50ZW1wbGF0ZT1hO2coKX0pfSk6ZygpO2Q/ZihjLGQsZnVuY3Rpb24oYyl7YS5qLm9jKFwibG9hZFZpZXdNb2RlbFwiLFtiLGNdLGZ1bmN0aW9uKGEpe2hbbV09YTtnKCl9KX0pOmcoKX1mdW5jdGlvbiBjKGEsYixkKXtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgYilkKGZ1bmN0aW9uKGEpe3JldHVybiBuZXcgYihhKX0pO1xuZWxzZSBpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgYlttXSlkKGJbbV0pO2Vsc2UgaWYoXCJpbnN0YW5jZVwiaW4gYil7dmFyIGU9Yi5pbnN0YW5jZTtkKGZ1bmN0aW9uKCl7cmV0dXJuIGV9KX1lbHNlXCJ2aWV3TW9kZWxcImluIGI/YyhhLGIudmlld01vZGVsLGQpOmEoXCJVbmtub3duIHZpZXdNb2RlbCB2YWx1ZTogXCIrYil9ZnVuY3Rpb24gZChiKXtzd2l0Y2goYS5hLlIoYikpe2Nhc2UgXCJzY3JpcHRcIjpyZXR1cm4gYS5hLnVhKGIudGV4dCk7Y2FzZSBcInRleHRhcmVhXCI6cmV0dXJuIGEuYS51YShiLnZhbHVlKTtjYXNlIFwidGVtcGxhdGVcIjppZihlKGIuY29udGVudCkpcmV0dXJuIGEuYS5DYShiLmNvbnRlbnQuY2hpbGROb2Rlcyl9cmV0dXJuIGEuYS5DYShiLmNoaWxkTm9kZXMpfWZ1bmN0aW9uIGUoYSl7cmV0dXJuIEEuRG9jdW1lbnRGcmFnbWVudD9hIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudDphJiYxMT09PWEubm9kZVR5cGV9ZnVuY3Rpb24gZihhLGIsYyl7XCJzdHJpbmdcIj09PXR5cGVvZiBiLnJlcXVpcmU/XG5UfHxBLnJlcXVpcmU/KFR8fEEucmVxdWlyZSkoW2IucmVxdWlyZV0sZnVuY3Rpb24oYSl7YSYmXCJvYmplY3RcIj09PXR5cGVvZiBhJiZhLlhkJiZhW1wiZGVmYXVsdFwiXSYmKGE9YVtcImRlZmF1bHRcIl0pO2MoYSl9KTphKFwiVXNlcyByZXF1aXJlLCBidXQgbm8gQU1EIGxvYWRlciBpcyBwcmVzZW50XCIpOmMoYil9ZnVuY3Rpb24gZyhhKXtyZXR1cm4gZnVuY3Rpb24oYil7dGhyb3cgRXJyb3IoXCJDb21wb25lbnQgJ1wiK2ErXCInOiBcIitiKTt9fXZhciBoPXt9O2Euai5yZWdpc3Rlcj1mdW5jdGlvbihiLGMpe2lmKCFjKXRocm93IEVycm9yKFwiSW52YWxpZCBjb25maWd1cmF0aW9uIGZvciBcIitiKTtpZihhLmoudGIoYikpdGhyb3cgRXJyb3IoXCJDb21wb25lbnQgXCIrYitcIiBpcyBhbHJlYWR5IHJlZ2lzdGVyZWRcIik7aFtiXT1jfTthLmoudGI9ZnVuY3Rpb24oYSl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChoLGEpfTthLmoudW5yZWdpc3Rlcj1mdW5jdGlvbihiKXtkZWxldGUgaFtiXTtcbmEuai5CYyhiKX07YS5qLkZjPXtnZXRDb25maWc6ZnVuY3Rpb24oYixjKXtjKGEuai50YihiKT9oW2JdOm51bGwpfSxsb2FkQ29tcG9uZW50OmZ1bmN0aW9uKGEsYyxkKXt2YXIgZT1nKGEpO2YoZSxjLGZ1bmN0aW9uKGMpe2IoYSxlLGMsZCl9KX0sbG9hZFRlbXBsYXRlOmZ1bmN0aW9uKGIsYyxmKXtiPWcoYik7aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBjKWYoYS5hLnVhKGMpKTtlbHNlIGlmKGMgaW5zdGFuY2VvZiBBcnJheSlmKGMpO2Vsc2UgaWYoZShjKSlmKGEuYS5sYShjLmNoaWxkTm9kZXMpKTtlbHNlIGlmKGMuZWxlbWVudClpZihjPWMuZWxlbWVudCxBLkhUTUxFbGVtZW50P2MgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDpjJiZjLnRhZ05hbWUmJjE9PT1jLm5vZGVUeXBlKWYoZChjKSk7ZWxzZSBpZihcInN0cmluZ1wiPT09dHlwZW9mIGMpe3ZhciBoPXcuZ2V0RWxlbWVudEJ5SWQoYyk7aD9mKGQoaCkpOmIoXCJDYW5ub3QgZmluZCBlbGVtZW50IHdpdGggSUQgXCIrYyl9ZWxzZSBiKFwiVW5rbm93biBlbGVtZW50IHR5cGU6IFwiK1xuYyk7ZWxzZSBiKFwiVW5rbm93biB0ZW1wbGF0ZSB2YWx1ZTogXCIrYyl9LGxvYWRWaWV3TW9kZWw6ZnVuY3Rpb24oYSxiLGQpe2MoZyhhKSxiLGQpfX07dmFyIG09XCJjcmVhdGVWaWV3TW9kZWxcIjthLmIoXCJjb21wb25lbnRzLnJlZ2lzdGVyXCIsYS5qLnJlZ2lzdGVyKTthLmIoXCJjb21wb25lbnRzLmlzUmVnaXN0ZXJlZFwiLGEuai50Yik7YS5iKFwiY29tcG9uZW50cy51bnJlZ2lzdGVyXCIsYS5qLnVucmVnaXN0ZXIpO2EuYihcImNvbXBvbmVudHMuZGVmYXVsdExvYWRlclwiLGEuai5GYyk7YS5qLmxvYWRlcnMucHVzaChhLmouRmMpO2Euai5kZD1ofSkoKTsoZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGIsZSl7dmFyIGY9Yi5nZXRBdHRyaWJ1dGUoXCJwYXJhbXNcIik7aWYoZil7dmFyIGY9Yy5wYXJzZUJpbmRpbmdzU3RyaW5nKGYsZSxiLHt2YWx1ZUFjY2Vzc29yczohMCxiaW5kaW5nUGFyYW1zOiEwfSksZj1hLmEuR2EoZixmdW5jdGlvbihjKXtyZXR1cm4gYS5vKGMsbnVsbCx7bDpifSl9KSxnPWEuYS5HYShmLFxuZnVuY3Rpb24oYyl7dmFyIGU9Yy52KCk7cmV0dXJuIGMuamEoKT9hLm8oe3JlYWQ6ZnVuY3Rpb24oKXtyZXR1cm4gYS5hLmYoYygpKX0sd3JpdGU6YS5aYShlKSYmZnVuY3Rpb24oYSl7YygpKGEpfSxsOmJ9KTplfSk7T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGcsXCIkcmF3XCIpfHwoZy4kcmF3PWYpO3JldHVybiBnfXJldHVybnskcmF3Ont9fX1hLmouZ2V0Q29tcG9uZW50TmFtZUZvck5vZGU9ZnVuY3Rpb24oYil7dmFyIGM9YS5hLlIoYik7aWYoYS5qLnRiKGMpJiYoLTEhPWMuaW5kZXhPZihcIi1cIil8fFwiW29iamVjdCBIVE1MVW5rbm93bkVsZW1lbnRdXCI9PVwiXCIrYnx8OD49YS5hLlcmJmIudGFnTmFtZT09PWMpKXJldHVybiBjfTthLmoudGM9ZnVuY3Rpb24oYyxlLGYsZyl7aWYoMT09PWUubm9kZVR5cGUpe3ZhciBoPWEuai5nZXRDb21wb25lbnROYW1lRm9yTm9kZShlKTtpZihoKXtjPWN8fHt9O2lmKGMuY29tcG9uZW50KXRocm93IEVycm9yKCdDYW5ub3QgdXNlIHRoZSBcImNvbXBvbmVudFwiIGJpbmRpbmcgb24gYSBjdXN0b20gZWxlbWVudCBtYXRjaGluZyBhIGNvbXBvbmVudCcpO1xudmFyIG09e25hbWU6aCxwYXJhbXM6YihlLGYpfTtjLmNvbXBvbmVudD1nP2Z1bmN0aW9uKCl7cmV0dXJuIG19Om19fXJldHVybiBjfTt2YXIgYz1uZXcgYS5nYTs5PmEuYS5XJiYoYS5qLnJlZ2lzdGVyPWZ1bmN0aW9uKGEpe3JldHVybiBmdW5jdGlvbihiKXtyZXR1cm4gYS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9fShhLmoucmVnaXN0ZXIpLHcuY3JlYXRlRG9jdW1lbnRGcmFnbWVudD1mdW5jdGlvbihiKXtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgYz1iKCksZj1hLmouZGQsZztmb3IoZyBpbiBmKTtyZXR1cm4gY319KHcuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCkpfSkoKTsoZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGIsYyxkKXtjPWMudGVtcGxhdGU7aWYoIWMpdGhyb3cgRXJyb3IoXCJDb21wb25lbnQgJ1wiK2IrXCInIGhhcyBubyB0ZW1wbGF0ZVwiKTtiPWEuYS5DYShjKTthLmgudmEoZCxiKX1mdW5jdGlvbiBjKGEsYixjKXt2YXIgZD1hLmNyZWF0ZVZpZXdNb2RlbDtyZXR1cm4gZD9kLmNhbGwoYSxcbmIsYyk6Yn12YXIgZD0wO2EuYy5jb21wb25lbnQ9e2luaXQ6ZnVuY3Rpb24oZSxmLGcsaCxtKXtmdW5jdGlvbiBrKCl7dmFyIGE9bCYmbC5kaXNwb3NlO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBhJiZhLmNhbGwobCk7cSYmcS5zKCk7cD1sPXE9bnVsbH12YXIgbCxwLHEsdD1hLmEubGEoYS5oLmNoaWxkTm9kZXMoZSkpO2EuaC5FYShlKTthLmEuSy56YShlLGspO2EubyhmdW5jdGlvbigpe3ZhciBnPWEuYS5mKGYoKSksaCx1O1wic3RyaW5nXCI9PT10eXBlb2YgZz9oPWc6KGg9YS5hLmYoZy5uYW1lKSx1PWEuYS5mKGcucGFyYW1zKSk7aWYoIWgpdGhyb3cgRXJyb3IoXCJObyBjb21wb25lbnQgbmFtZSBzcGVjaWZpZWRcIik7dmFyIG49YS5pLkNiKGUsbSksej1wPSsrZDthLmouZ2V0KGgsZnVuY3Rpb24oZCl7aWYocD09PXope2soKTtpZighZCl0aHJvdyBFcnJvcihcIlVua25vd24gY29tcG9uZW50ICdcIitoK1wiJ1wiKTtiKGgsZCxlKTt2YXIgZj1jKGQsdSx7ZWxlbWVudDplLHRlbXBsYXRlTm9kZXM6dH0pO1xuZD1uLmNyZWF0ZUNoaWxkQ29udGV4dChmLHtleHRlbmQ6ZnVuY3Rpb24oYSl7YS4kY29tcG9uZW50PWY7YS4kY29tcG9uZW50VGVtcGxhdGVOb2Rlcz10fX0pO2YmJmYua29EZXNjZW5kYW50c0NvbXBsZXRlJiYocT1hLmkuc3Vic2NyaWJlKGUsYS5pLnBhLGYua29EZXNjZW5kYW50c0NvbXBsZXRlLGYpKTtsPWY7YS5PYShkLGUpfX0pfSxudWxsLHtsOmV9KTtyZXR1cm57Y29udHJvbHNEZXNjZW5kYW50QmluZGluZ3M6ITB9fX07YS5oLmVhLmNvbXBvbmVudD0hMH0pKCk7dmFyIFY9e1wiY2xhc3NcIjpcImNsYXNzTmFtZVwiLFwiZm9yXCI6XCJodG1sRm9yXCJ9O2EuYy5hdHRyPXt1cGRhdGU6ZnVuY3Rpb24oYixjKXt2YXIgZD1hLmEuZihjKCkpfHx7fTthLmEuUChkLGZ1bmN0aW9uKGMsZCl7ZD1hLmEuZihkKTt2YXIgZz1jLmluZGV4T2YoXCI6XCIpLGc9XCJsb29rdXBOYW1lc3BhY2VVUklcImluIGImJjA8ZyYmYi5sb29rdXBOYW1lc3BhY2VVUkkoYy5zdWJzdHIoMCxnKSksaD0hMT09PWR8fG51bGw9PT1cbmR8fGQ9PT1uO2g/Zz9iLnJlbW92ZUF0dHJpYnV0ZU5TKGcsYyk6Yi5yZW1vdmVBdHRyaWJ1dGUoYyk6ZD1kLnRvU3RyaW5nKCk7OD49YS5hLlcmJmMgaW4gVj8oYz1WW2NdLGg/Yi5yZW1vdmVBdHRyaWJ1dGUoYyk6YltjXT1kKTpofHwoZz9iLnNldEF0dHJpYnV0ZU5TKGcsYyxkKTpiLnNldEF0dHJpYnV0ZShjLGQpKTtcIm5hbWVcIj09PWMmJmEuYS5ZYyhiLGg/XCJcIjpkKX0pfX07KGZ1bmN0aW9uKCl7YS5jLmNoZWNrZWQ9e2FmdGVyOltcInZhbHVlXCIsXCJhdHRyXCJdLGluaXQ6ZnVuY3Rpb24oYixjLGQpe2Z1bmN0aW9uIGUoKXt2YXIgZT1iLmNoZWNrZWQsZj1nKCk7aWYoIWEuUy5ZYSgpJiYoZXx8IW0mJiFhLlMucWEoKSkpe3ZhciBrPWEudS5HKGMpO2lmKGwpe3ZhciBxPXA/ay52KCk6ayx6PXQ7dD1mO3ohPT1mP2UmJihhLmEuTmEocSxmLCEwKSxhLmEuTmEocSx6LCExKSk6YS5hLk5hKHEsZixlKTtwJiZhLlphKGspJiZrKHEpfWVsc2UgaCYmKGY9PT1uP2Y9ZTplfHwoZj1uKSksYS5tLmViKGssXG5kLFwiY2hlY2tlZFwiLGYsITApfX1mdW5jdGlvbiBmKCl7dmFyIGQ9YS5hLmYoYygpKSxlPWcoKTtsPyhiLmNoZWNrZWQ9MDw9YS5hLkEoZCxlKSx0PWUpOmIuY2hlY2tlZD1oJiZlPT09bj8hIWQ6ZygpPT09ZH12YXIgZz1hLnhiKGZ1bmN0aW9uKCl7aWYoZC5oYXMoXCJjaGVja2VkVmFsdWVcIikpcmV0dXJuIGEuYS5mKGQuZ2V0KFwiY2hlY2tlZFZhbHVlXCIpKTtpZihxKXJldHVybiBkLmhhcyhcInZhbHVlXCIpP2EuYS5mKGQuZ2V0KFwidmFsdWVcIikpOmIudmFsdWV9KSxoPVwiY2hlY2tib3hcIj09Yi50eXBlLG09XCJyYWRpb1wiPT1iLnR5cGU7aWYoaHx8bSl7dmFyIGs9YygpLGw9aCYmYS5hLmYoaylpbnN0YW5jZW9mIEFycmF5LHA9IShsJiZrLnB1c2gmJmsuc3BsaWNlKSxxPW18fGwsdD1sP2coKTpuO20mJiFiLm5hbWUmJmEuYy51bmlxdWVOYW1lLmluaXQoYixmdW5jdGlvbigpe3JldHVybiEwfSk7YS5vKGUsbnVsbCx7bDpifSk7YS5hLkIoYixcImNsaWNrXCIsZSk7YS5vKGYsbnVsbCx7bDpifSk7XG5rPW59fX07YS5tLndhLmNoZWNrZWQ9ITA7YS5jLmNoZWNrZWRWYWx1ZT17dXBkYXRlOmZ1bmN0aW9uKGIsYyl7Yi52YWx1ZT1hLmEuZihjKCkpfX19KSgpO2EuY1tcImNsYXNzXCJdPXt1cGRhdGU6ZnVuY3Rpb24oYixjKXt2YXIgZD1hLmEuRGIoYS5hLmYoYygpKSk7YS5hLkViKGIsYi5fX2tvX19jc3NWYWx1ZSwhMSk7Yi5fX2tvX19jc3NWYWx1ZT1kO2EuYS5FYihiLGQsITApfX07YS5jLmNzcz17dXBkYXRlOmZ1bmN0aW9uKGIsYyl7dmFyIGQ9YS5hLmYoYygpKTtudWxsIT09ZCYmXCJvYmplY3RcIj09dHlwZW9mIGQ/YS5hLlAoZCxmdW5jdGlvbihjLGQpe2Q9YS5hLmYoZCk7YS5hLkViKGIsYyxkKX0pOmEuY1tcImNsYXNzXCJdLnVwZGF0ZShiLGMpfX07YS5jLmVuYWJsZT17dXBkYXRlOmZ1bmN0aW9uKGIsYyl7dmFyIGQ9YS5hLmYoYygpKTtkJiZiLmRpc2FibGVkP2IucmVtb3ZlQXR0cmlidXRlKFwiZGlzYWJsZWRcIik6ZHx8Yi5kaXNhYmxlZHx8KGIuZGlzYWJsZWQ9ITApfX07YS5jLmRpc2FibGU9XG57dXBkYXRlOmZ1bmN0aW9uKGIsYyl7YS5jLmVuYWJsZS51cGRhdGUoYixmdW5jdGlvbigpe3JldHVybiFhLmEuZihjKCkpfSl9fTthLmMuZXZlbnQ9e2luaXQ6ZnVuY3Rpb24oYixjLGQsZSxmKXt2YXIgZz1jKCl8fHt9O2EuYS5QKGcsZnVuY3Rpb24oZyl7XCJzdHJpbmdcIj09dHlwZW9mIGcmJmEuYS5CKGIsZyxmdW5jdGlvbihiKXt2YXIgayxsPWMoKVtnXTtpZihsKXt0cnl7dmFyIHA9YS5hLmxhKGFyZ3VtZW50cyk7ZT1mLiRkYXRhO3AudW5zaGlmdChlKTtrPWwuYXBwbHkoZSxwKX1maW5hbGx5eyEwIT09ayYmKGIucHJldmVudERlZmF1bHQ/Yi5wcmV2ZW50RGVmYXVsdCgpOmIucmV0dXJuVmFsdWU9ITEpfSExPT09ZC5nZXQoZytcIkJ1YmJsZVwiKSYmKGIuY2FuY2VsQnViYmxlPSEwLGIuc3RvcFByb3BhZ2F0aW9uJiZiLnN0b3BQcm9wYWdhdGlvbigpKX19KX0pfX07YS5jLmZvcmVhY2g9e1JjOmZ1bmN0aW9uKGIpe3JldHVybiBmdW5jdGlvbigpe3ZhciBjPWIoKSxkPWEuYS5iYyhjKTtcbmlmKCFkfHxcIm51bWJlclwiPT10eXBlb2YgZC5sZW5ndGgpcmV0dXJue2ZvcmVhY2g6Yyx0ZW1wbGF0ZUVuZ2luZTphLmJhLk1hfTthLmEuZihjKTtyZXR1cm57Zm9yZWFjaDpkLmRhdGEsYXM6ZC5hcyxub0NoaWxkQ29udGV4dDpkLm5vQ2hpbGRDb250ZXh0LGluY2x1ZGVEZXN0cm95ZWQ6ZC5pbmNsdWRlRGVzdHJveWVkLGFmdGVyQWRkOmQuYWZ0ZXJBZGQsYmVmb3JlUmVtb3ZlOmQuYmVmb3JlUmVtb3ZlLGFmdGVyUmVuZGVyOmQuYWZ0ZXJSZW5kZXIsYmVmb3JlTW92ZTpkLmJlZm9yZU1vdmUsYWZ0ZXJNb3ZlOmQuYWZ0ZXJNb3ZlLHRlbXBsYXRlRW5naW5lOmEuYmEuTWF9fX0saW5pdDpmdW5jdGlvbihiLGMpe3JldHVybiBhLmMudGVtcGxhdGUuaW5pdChiLGEuYy5mb3JlYWNoLlJjKGMpKX0sdXBkYXRlOmZ1bmN0aW9uKGIsYyxkLGUsZil7cmV0dXJuIGEuYy50ZW1wbGF0ZS51cGRhdGUoYixhLmMuZm9yZWFjaC5SYyhjKSxkLGUsZil9fTthLm0uUmEuZm9yZWFjaD0hMTthLmguZWEuZm9yZWFjaD1cbiEwO2EuYy5oYXNmb2N1cz17aW5pdDpmdW5jdGlvbihiLGMsZCl7ZnVuY3Rpb24gZShlKXtiLl9fa29faGFzZm9jdXNVcGRhdGluZz0hMDt2YXIgZj1iLm93bmVyRG9jdW1lbnQ7aWYoXCJhY3RpdmVFbGVtZW50XCJpbiBmKXt2YXIgZzt0cnl7Zz1mLmFjdGl2ZUVsZW1lbnR9Y2F0Y2gobCl7Zz1mLmJvZHl9ZT1nPT09Yn1mPWMoKTthLm0uZWIoZixkLFwiaGFzZm9jdXNcIixlLCEwKTtiLl9fa29faGFzZm9jdXNMYXN0VmFsdWU9ZTtiLl9fa29faGFzZm9jdXNVcGRhdGluZz0hMX12YXIgZj1lLmJpbmQobnVsbCwhMCksZz1lLmJpbmQobnVsbCwhMSk7YS5hLkIoYixcImZvY3VzXCIsZik7YS5hLkIoYixcImZvY3VzaW5cIixmKTthLmEuQihiLFwiYmx1clwiLGcpO2EuYS5CKGIsXCJmb2N1c291dFwiLGcpO2IuX19rb19oYXNmb2N1c0xhc3RWYWx1ZT0hMX0sdXBkYXRlOmZ1bmN0aW9uKGIsYyl7dmFyIGQ9ISFhLmEuZihjKCkpO2IuX19rb19oYXNmb2N1c1VwZGF0aW5nfHxiLl9fa29faGFzZm9jdXNMYXN0VmFsdWU9PT1cbmR8fChkP2IuZm9jdXMoKTpiLmJsdXIoKSwhZCYmYi5fX2tvX2hhc2ZvY3VzTGFzdFZhbHVlJiZiLm93bmVyRG9jdW1lbnQuYm9keS5mb2N1cygpLGEudS5HKGEuYS5GYixudWxsLFtiLGQ/XCJmb2N1c2luXCI6XCJmb2N1c291dFwiXSkpfX07YS5tLndhLmhhc2ZvY3VzPSEwO2EuYy5oYXNGb2N1cz1hLmMuaGFzZm9jdXM7YS5tLndhLmhhc0ZvY3VzPVwiaGFzZm9jdXNcIjthLmMuaHRtbD17aW5pdDpmdW5jdGlvbigpe3JldHVybntjb250cm9sc0Rlc2NlbmRhbnRCaW5kaW5nczohMH19LHVwZGF0ZTpmdW5jdGlvbihiLGMpe2EuYS5mYyhiLGMoKSl9fTsoZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGIsZCxlKXthLmNbYl09e2luaXQ6ZnVuY3Rpb24oYixjLGgsbSxrKXt2YXIgbCxwLHE9e30sdCx4LG47aWYoZCl7bT1oLmdldChcImFzXCIpO3ZhciB1PWguZ2V0KFwibm9DaGlsZENvbnRleHRcIik7bj0hKG0mJnUpO3E9e2FzOm0sbm9DaGlsZENvbnRleHQ6dSxleHBvcnREZXBlbmRlbmNpZXM6bn19eD0odD1cblwicmVuZGVyXCI9PWguZ2V0KFwiY29tcGxldGVPblwiKSl8fGguaGFzKGEuaS5wYSk7YS5vKGZ1bmN0aW9uKCl7dmFyIGg9YS5hLmYoYygpKSxtPSFlIT09IWgsdT0hcCxyO2lmKG58fG0hPT1sKXt4JiYoaz1hLmkuQ2IoYixrKSk7aWYobSl7aWYoIWR8fG4pcS5kYXRhRGVwZW5kZW5jeT1hLlMubygpO3I9ZD9rLmNyZWF0ZUNoaWxkQ29udGV4dChcImZ1bmN0aW9uXCI9PXR5cGVvZiBoP2g6YyxxKTphLlMucWEoKT9rLmV4dGVuZChudWxsLHEpOmt9dSYmYS5TLnFhKCkmJihwPWEuYS5DYShhLmguY2hpbGROb2RlcyhiKSwhMCkpO20/KHV8fGEuaC52YShiLGEuYS5DYShwKSksYS5PYShyLGIpKTooYS5oLkVhKGIpLHR8fGEuaS5tYShiLGEuaS5IKSk7bD1tfX0sbnVsbCx7bDpifSk7cmV0dXJue2NvbnRyb2xzRGVzY2VuZGFudEJpbmRpbmdzOiEwfX19O2EubS5SYVtiXT0hMTthLmguZWFbYl09ITB9YihcImlmXCIpO2IoXCJpZm5vdFwiLCExLCEwKTtiKFwid2l0aFwiLCEwKX0pKCk7YS5jLmxldD17aW5pdDpmdW5jdGlvbihiLFxuYyxkLGUsZil7Yz1mLmV4dGVuZChjKTthLk9hKGMsYik7cmV0dXJue2NvbnRyb2xzRGVzY2VuZGFudEJpbmRpbmdzOiEwfX19O2EuaC5lYS5sZXQ9ITA7dmFyIFE9e307YS5jLm9wdGlvbnM9e2luaXQ6ZnVuY3Rpb24oYil7aWYoXCJzZWxlY3RcIiE9PWEuYS5SKGIpKXRocm93IEVycm9yKFwib3B0aW9ucyBiaW5kaW5nIGFwcGxpZXMgb25seSB0byBTRUxFQ1QgZWxlbWVudHNcIik7Zm9yKDswPGIubGVuZ3RoOyliLnJlbW92ZSgwKTtyZXR1cm57Y29udHJvbHNEZXNjZW5kYW50QmluZGluZ3M6ITB9fSx1cGRhdGU6ZnVuY3Rpb24oYixjLGQpe2Z1bmN0aW9uIGUoKXtyZXR1cm4gYS5hLmpiKGIub3B0aW9ucyxmdW5jdGlvbihhKXtyZXR1cm4gYS5zZWxlY3RlZH0pfWZ1bmN0aW9uIGYoYSxiLGMpe3ZhciBkPXR5cGVvZiBiO3JldHVyblwiZnVuY3Rpb25cIj09ZD9iKGEpOlwic3RyaW5nXCI9PWQ/YVtiXTpjfWZ1bmN0aW9uIGcoYyxkKXtpZih4JiZsKWEuaS5tYShiLGEuaS5IKTtlbHNlIGlmKHQubGVuZ3RoKXt2YXIgZT1cbjA8PWEuYS5BKHQsYS53Lk0oZFswXSkpO2EuYS5aYyhkWzBdLGUpO3gmJiFlJiZhLnUuRyhhLmEuRmIsbnVsbCxbYixcImNoYW5nZVwiXSl9fXZhciBoPWIubXVsdGlwbGUsbT0wIT1iLmxlbmd0aCYmaD9iLnNjcm9sbFRvcDpudWxsLGs9YS5hLmYoYygpKSxsPWQuZ2V0KFwidmFsdWVBbGxvd1Vuc2V0XCIpJiZkLmhhcyhcInZhbHVlXCIpLHA9ZC5nZXQoXCJvcHRpb25zSW5jbHVkZURlc3Ryb3llZFwiKTtjPXt9O3ZhciBxLHQ9W107bHx8KGg/dD1hLmEuTWIoZSgpLGEudy5NKTowPD1iLnNlbGVjdGVkSW5kZXgmJnQucHVzaChhLncuTShiLm9wdGlvbnNbYi5zZWxlY3RlZEluZGV4XSkpKTtrJiYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIGsubGVuZ3RoJiYoaz1ba10pLHE9YS5hLmpiKGssZnVuY3Rpb24oYil7cmV0dXJuIHB8fGI9PT1ufHxudWxsPT09Ynx8IWEuYS5mKGIuX2Rlc3Ryb3kpfSksZC5oYXMoXCJvcHRpb25zQ2FwdGlvblwiKSYmKGs9YS5hLmYoZC5nZXQoXCJvcHRpb25zQ2FwdGlvblwiKSksbnVsbCE9PVxuayYmayE9PW4mJnEudW5zaGlmdChRKSkpO3ZhciB4PSExO2MuYmVmb3JlUmVtb3ZlPWZ1bmN0aW9uKGEpe2IucmVtb3ZlQ2hpbGQoYSl9O2s9ZztkLmhhcyhcIm9wdGlvbnNBZnRlclJlbmRlclwiKSYmXCJmdW5jdGlvblwiPT10eXBlb2YgZC5nZXQoXCJvcHRpb25zQWZ0ZXJSZW5kZXJcIikmJihrPWZ1bmN0aW9uKGIsYyl7ZygwLGMpO2EudS5HKGQuZ2V0KFwib3B0aW9uc0FmdGVyUmVuZGVyXCIpLG51bGwsW2NbMF0sYiE9PVE/YjpuXSl9KTthLmEuZWMoYixxLGZ1bmN0aW9uKGMsZSxnKXtnLmxlbmd0aCYmKHQ9IWwmJmdbMF0uc2VsZWN0ZWQ/W2Eudy5NKGdbMF0pXTpbXSx4PSEwKTtlPWIub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO2M9PT1RPyhhLmEuQmIoZSxkLmdldChcIm9wdGlvbnNDYXB0aW9uXCIpKSxhLncuY2IoZSxuKSk6KGc9ZihjLGQuZ2V0KFwib3B0aW9uc1ZhbHVlXCIpLGMpLGEudy5jYihlLGEuYS5mKGcpKSxjPWYoYyxkLmdldChcIm9wdGlvbnNUZXh0XCIpLGcpLFxuYS5hLkJiKGUsYykpO3JldHVybltlXX0sYyxrKTtpZighbCl7dmFyIEI7aD9CPXQubGVuZ3RoJiZlKCkubGVuZ3RoPHQubGVuZ3RoOkI9dC5sZW5ndGgmJjA8PWIuc2VsZWN0ZWRJbmRleD9hLncuTShiLm9wdGlvbnNbYi5zZWxlY3RlZEluZGV4XSkhPT10WzBdOnQubGVuZ3RofHwwPD1iLnNlbGVjdGVkSW5kZXg7QiYmYS51LkcoYS5hLkZiLG51bGwsW2IsXCJjaGFuZ2VcIl0pfShsfHxhLlMuWWEoKSkmJmEuaS5tYShiLGEuaS5IKTthLmEud2QoYik7bSYmMjA8TWF0aC5hYnMobS1iLnNjcm9sbFRvcCkmJihiLnNjcm9sbFRvcD1tKX19O2EuYy5vcHRpb25zLiRiPWEuYS5nLlooKTthLmMuc2VsZWN0ZWRPcHRpb25zPXtpbml0OmZ1bmN0aW9uKGIsYyxkKXtmdW5jdGlvbiBlKCl7dmFyIGU9YygpLGY9W107YS5hLkQoYi5nZXRFbGVtZW50c0J5VGFnTmFtZShcIm9wdGlvblwiKSxmdW5jdGlvbihiKXtiLnNlbGVjdGVkJiZmLnB1c2goYS53Lk0oYikpfSk7YS5tLmViKGUsZCxcInNlbGVjdGVkT3B0aW9uc1wiLFxuZil9ZnVuY3Rpb24gZigpe3ZhciBkPWEuYS5mKGMoKSksZT1iLnNjcm9sbFRvcDtkJiZcIm51bWJlclwiPT10eXBlb2YgZC5sZW5ndGgmJmEuYS5EKGIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJvcHRpb25cIiksZnVuY3Rpb24oYil7dmFyIGM9MDw9YS5hLkEoZCxhLncuTShiKSk7Yi5zZWxlY3RlZCE9YyYmYS5hLlpjKGIsYyl9KTtiLnNjcm9sbFRvcD1lfWlmKFwic2VsZWN0XCIhPWEuYS5SKGIpKXRocm93IEVycm9yKFwic2VsZWN0ZWRPcHRpb25zIGJpbmRpbmcgYXBwbGllcyBvbmx5IHRvIFNFTEVDVCBlbGVtZW50c1wiKTt2YXIgZzthLmkuc3Vic2NyaWJlKGIsYS5pLkgsZnVuY3Rpb24oKXtnP2UoKTooYS5hLkIoYixcImNoYW5nZVwiLGUpLGc9YS5vKGYsbnVsbCx7bDpifSkpfSxudWxsLHtub3RpZnlJbW1lZGlhdGVseTohMH0pfSx1cGRhdGU6ZnVuY3Rpb24oKXt9fTthLm0ud2Euc2VsZWN0ZWRPcHRpb25zPSEwO2EuYy5zdHlsZT17dXBkYXRlOmZ1bmN0aW9uKGIsYyl7dmFyIGQ9YS5hLmYoYygpfHxcbnt9KTthLmEuUChkLGZ1bmN0aW9uKGMsZCl7ZD1hLmEuZihkKTtpZihudWxsPT09ZHx8ZD09PW58fCExPT09ZClkPVwiXCI7aWYodil2KGIpLmNzcyhjLGQpO2Vsc2UgaWYoL14tLS8udGVzdChjKSliLnN0eWxlLnNldFByb3BlcnR5KGMsZCk7ZWxzZXtjPWMucmVwbGFjZSgvLShcXHcpL2csZnVuY3Rpb24oYSxiKXtyZXR1cm4gYi50b1VwcGVyQ2FzZSgpfSk7dmFyIGc9Yi5zdHlsZVtjXTtiLnN0eWxlW2NdPWQ7ZD09PWd8fGIuc3R5bGVbY10hPWd8fGlzTmFOKGQpfHwoYi5zdHlsZVtjXT1kK1wicHhcIil9fSl9fTthLmMuc3VibWl0PXtpbml0OmZ1bmN0aW9uKGIsYyxkLGUsZil7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgYygpKXRocm93IEVycm9yKFwiVGhlIHZhbHVlIGZvciBhIHN1Ym1pdCBiaW5kaW5nIG11c3QgYmUgYSBmdW5jdGlvblwiKTthLmEuQihiLFwic3VibWl0XCIsZnVuY3Rpb24oYSl7dmFyIGQsZT1jKCk7dHJ5e2Q9ZS5jYWxsKGYuJGRhdGEsYil9ZmluYWxseXshMCE9PWQmJihhLnByZXZlbnREZWZhdWx0P1xuYS5wcmV2ZW50RGVmYXVsdCgpOmEucmV0dXJuVmFsdWU9ITEpfX0pfX07YS5jLnRleHQ9e2luaXQ6ZnVuY3Rpb24oKXtyZXR1cm57Y29udHJvbHNEZXNjZW5kYW50QmluZGluZ3M6ITB9fSx1cGRhdGU6ZnVuY3Rpb24oYixjKXthLmEuQmIoYixjKCkpfX07YS5oLmVhLnRleHQ9ITA7KGZ1bmN0aW9uKCl7aWYoQSYmQS5uYXZpZ2F0b3Ipe3ZhciBiPWZ1bmN0aW9uKGEpe2lmKGEpcmV0dXJuIHBhcnNlRmxvYXQoYVsxXSl9LGM9QS5uYXZpZ2F0b3IudXNlckFnZW50LGQsZSxmLGcsaDsoZD1BLm9wZXJhJiZBLm9wZXJhLnZlcnNpb24mJnBhcnNlSW50KEEub3BlcmEudmVyc2lvbigpKSl8fChoPWIoYy5tYXRjaCgvRWRnZVxcLyhbXiBdKykkLykpKXx8YihjLm1hdGNoKC9DaHJvbWVcXC8oW14gXSspLykpfHwoZT1iKGMubWF0Y2goL1ZlcnNpb25cXC8oW14gXSspIFNhZmFyaS8pKSl8fChmPWIoYy5tYXRjaCgvRmlyZWZveFxcLyhbXiBdKykvKSkpfHwoZz1hLmEuV3x8YihjLm1hdGNoKC9NU0lFIChbXiBdKykvKSkpfHxcbihnPWIoYy5tYXRjaCgvcnY6KFteICldKykvKSkpfWlmKDg8PWcmJjEwPmcpdmFyIG09YS5hLmcuWigpLGs9YS5hLmcuWigpLGw9ZnVuY3Rpb24oYil7dmFyIGM9dGhpcy5hY3RpdmVFbGVtZW50OyhjPWMmJmEuYS5nLmdldChjLGspKSYmYyhiKX0scD1mdW5jdGlvbihiLGMpe3ZhciBkPWIub3duZXJEb2N1bWVudDthLmEuZy5nZXQoZCxtKXx8KGEuYS5nLnNldChkLG0sITApLGEuYS5CKGQsXCJzZWxlY3Rpb25jaGFuZ2VcIixsKSk7YS5hLmcuc2V0KGIsayxjKX07YS5jLnRleHRJbnB1dD17aW5pdDpmdW5jdGlvbihiLGMsayl7ZnVuY3Rpb24gbChjLGQpe2EuYS5CKGIsYyxkKX1mdW5jdGlvbiBtKCl7dmFyIGQ9YS5hLmYoYygpKTtpZihudWxsPT09ZHx8ZD09PW4pZD1cIlwiO0whPT1uJiZkPT09TD9hLmEuc2V0VGltZW91dChtLDQpOmIudmFsdWUhPT1kJiYoeT0hMCxiLnZhbHVlPWQseT0hMSx2PWIudmFsdWUpfWZ1bmN0aW9uIHIoKXt3fHwoTD1iLnZhbHVlLHc9YS5hLnNldFRpbWVvdXQoeixcbjQpKX1mdW5jdGlvbiB6KCl7Y2xlYXJUaW1lb3V0KHcpO0w9dz1uO3ZhciBkPWIudmFsdWU7diE9PWQmJih2PWQsYS5tLmViKGMoKSxrLFwidGV4dElucHV0XCIsZCkpfXZhciB2PWIudmFsdWUsdyxMLEE9OT09YS5hLlc/cjp6LHk9ITE7ZyYmbChcImtleXByZXNzXCIseik7MTE+ZyYmbChcInByb3BlcnR5Y2hhbmdlXCIsZnVuY3Rpb24oYSl7eXx8XCJ2YWx1ZVwiIT09YS5wcm9wZXJ0eU5hbWV8fEEoYSl9KTs4PT1nJiYobChcImtleXVwXCIseiksbChcImtleWRvd25cIix6KSk7cCYmKHAoYixBKSxsKFwiZHJhZ2VuZFwiLHIpKTsoIWd8fDk8PWcpJiZsKFwiaW5wdXRcIixBKTs1PmUmJlwidGV4dGFyZWFcIj09PWEuYS5SKGIpPyhsKFwia2V5ZG93blwiLHIpLGwoXCJwYXN0ZVwiLHIpLGwoXCJjdXRcIixyKSk6MTE+ZD9sKFwia2V5ZG93blwiLHIpOjQ+Zj8obChcIkRPTUF1dG9Db21wbGV0ZVwiLHopLGwoXCJkcmFnZHJvcFwiLHopLGwoXCJkcm9wXCIseikpOmgmJlwibnVtYmVyXCI9PT1iLnR5cGUmJmwoXCJrZXlkb3duXCIscik7bChcImNoYW5nZVwiLFxueik7bChcImJsdXJcIix6KTthLm8obSxudWxsLHtsOmJ9KX19O2EubS53YS50ZXh0SW5wdXQ9ITA7YS5jLnRleHRpbnB1dD17cHJlcHJvY2VzczpmdW5jdGlvbihhLGIsYyl7YyhcInRleHRJbnB1dFwiLGEpfX19KSgpO2EuYy51bmlxdWVOYW1lPXtpbml0OmZ1bmN0aW9uKGIsYyl7aWYoYygpKXt2YXIgZD1cImtvX3VuaXF1ZV9cIisgKythLmMudW5pcXVlTmFtZS5yZDthLmEuWWMoYixkKX19fTthLmMudW5pcXVlTmFtZS5yZD0wO2EuYy51c2luZz17aW5pdDpmdW5jdGlvbihiLGMsZCxlLGYpe3ZhciBnO2QuaGFzKFwiYXNcIikmJihnPXthczpkLmdldChcImFzXCIpLG5vQ2hpbGRDb250ZXh0OmQuZ2V0KFwibm9DaGlsZENvbnRleHRcIil9KTtjPWYuY3JlYXRlQ2hpbGRDb250ZXh0KGMsZyk7YS5PYShjLGIpO3JldHVybntjb250cm9sc0Rlc2NlbmRhbnRCaW5kaW5nczohMH19fTthLmguZWEudXNpbmc9ITA7YS5jLnZhbHVlPXtpbml0OmZ1bmN0aW9uKGIsYyxkKXt2YXIgZT1hLmEuUihiKSxmPVwiaW5wdXRcIj09XG5lO2lmKCFmfHxcImNoZWNrYm94XCIhPWIudHlwZSYmXCJyYWRpb1wiIT1iLnR5cGUpe3ZhciBnPVtdLGg9ZC5nZXQoXCJ2YWx1ZVVwZGF0ZVwiKSxtPSExLGs9bnVsbDtoJiYoXCJzdHJpbmdcIj09dHlwZW9mIGg/Zz1baF06Zz1hLmEud2MoaCksYS5hLlBhKGcsXCJjaGFuZ2VcIikpO3ZhciBsPWZ1bmN0aW9uKCl7az1udWxsO209ITE7dmFyIGU9YygpLGY9YS53Lk0oYik7YS5tLmViKGUsZCxcInZhbHVlXCIsZil9OyFhLmEuV3x8IWZ8fFwidGV4dFwiIT1iLnR5cGV8fFwib2ZmXCI9PWIuYXV0b2NvbXBsZXRlfHxiLmZvcm0mJlwib2ZmXCI9PWIuZm9ybS5hdXRvY29tcGxldGV8fC0xIT1hLmEuQShnLFwicHJvcGVydHljaGFuZ2VcIil8fChhLmEuQihiLFwicHJvcGVydHljaGFuZ2VcIixmdW5jdGlvbigpe209ITB9KSxhLmEuQihiLFwiZm9jdXNcIixmdW5jdGlvbigpe209ITF9KSxhLmEuQihiLFwiYmx1clwiLGZ1bmN0aW9uKCl7bSYmbCgpfSkpO2EuYS5EKGcsZnVuY3Rpb24oYyl7dmFyIGQ9bDthLmEuVWQoYyxcImFmdGVyXCIpJiZcbihkPWZ1bmN0aW9uKCl7az1hLncuTShiKTthLmEuc2V0VGltZW91dChsLDApfSxjPWMuc3Vic3RyaW5nKDUpKTthLmEuQihiLGMsZCl9KTt2YXIgcDtwPWYmJlwiZmlsZVwiPT1iLnR5cGU/ZnVuY3Rpb24oKXt2YXIgZD1hLmEuZihjKCkpO251bGw9PT1kfHxkPT09bnx8XCJcIj09PWQ/Yi52YWx1ZT1cIlwiOmEudS5HKGwpfTpmdW5jdGlvbigpe3ZhciBmPWEuYS5mKGMoKSksZz1hLncuTShiKTtpZihudWxsIT09ayYmZj09PWspYS5hLnNldFRpbWVvdXQocCwwKTtlbHNlIGlmKGYhPT1nfHxnPT09bilcInNlbGVjdFwiPT09ZT8oZz1kLmdldChcInZhbHVlQWxsb3dVbnNldFwiKSxhLncuY2IoYixmLGcpLGd8fGY9PT1hLncuTShiKXx8YS51LkcobCkpOmEudy5jYihiLGYpfTtpZihcInNlbGVjdFwiPT09ZSl7dmFyIHE7YS5pLnN1YnNjcmliZShiLGEuaS5ILGZ1bmN0aW9uKCl7cT9kLmdldChcInZhbHVlQWxsb3dVbnNldFwiKT9wKCk6bCgpOihhLmEuQihiLFwiY2hhbmdlXCIsbCkscT1hLm8ocCxudWxsLHtsOmJ9KSl9LFxubnVsbCx7bm90aWZ5SW1tZWRpYXRlbHk6ITB9KX1lbHNlIGEuYS5CKGIsXCJjaGFuZ2VcIixsKSxhLm8ocCxudWxsLHtsOmJ9KX1lbHNlIGEuaWIoYix7Y2hlY2tlZFZhbHVlOmN9KX0sdXBkYXRlOmZ1bmN0aW9uKCl7fX07YS5tLndhLnZhbHVlPSEwO2EuYy52aXNpYmxlPXt1cGRhdGU6ZnVuY3Rpb24oYixjKXt2YXIgZD1hLmEuZihjKCkpLGU9XCJub25lXCIhPWIuc3R5bGUuZGlzcGxheTtkJiYhZT9iLnN0eWxlLmRpc3BsYXk9XCJcIjohZCYmZSYmKGIuc3R5bGUuZGlzcGxheT1cIm5vbmVcIil9fTthLmMuaGlkZGVuPXt1cGRhdGU6ZnVuY3Rpb24oYixjKXthLmMudmlzaWJsZS51cGRhdGUoYixmdW5jdGlvbigpe3JldHVybiFhLmEuZihjKCkpfSl9fTsoZnVuY3Rpb24oYil7YS5jW2JdPXtpbml0OmZ1bmN0aW9uKGMsZCxlLGYsZyl7cmV0dXJuIGEuYy5ldmVudC5pbml0LmNhbGwodGhpcyxjLGZ1bmN0aW9uKCl7dmFyIGE9e307YVtiXT1kKCk7cmV0dXJuIGF9LGUsZixnKX19fSkoXCJjbGlja1wiKTtcbmEuY2E9ZnVuY3Rpb24oKXt9O2EuY2EucHJvdG90eXBlLnJlbmRlclRlbXBsYXRlU291cmNlPWZ1bmN0aW9uKCl7dGhyb3cgRXJyb3IoXCJPdmVycmlkZSByZW5kZXJUZW1wbGF0ZVNvdXJjZVwiKTt9O2EuY2EucHJvdG90eXBlLmNyZWF0ZUphdmFTY3JpcHRFdmFsdWF0b3JCbG9jaz1mdW5jdGlvbigpe3Rocm93IEVycm9yKFwiT3ZlcnJpZGUgY3JlYXRlSmF2YVNjcmlwdEV2YWx1YXRvckJsb2NrXCIpO307YS5jYS5wcm90b3R5cGUubWFrZVRlbXBsYXRlU291cmNlPWZ1bmN0aW9uKGIsYyl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGIpe2M9Y3x8dzt2YXIgZD1jLmdldEVsZW1lbnRCeUlkKGIpO2lmKCFkKXRocm93IEVycm9yKFwiQ2Fubm90IGZpbmQgdGVtcGxhdGUgd2l0aCBJRCBcIitiKTtyZXR1cm4gbmV3IGEuQy5GKGQpfWlmKDE9PWIubm9kZVR5cGV8fDg9PWIubm9kZVR5cGUpcmV0dXJuIG5ldyBhLkMuaWEoYik7dGhyb3cgRXJyb3IoXCJVbmtub3duIHRlbXBsYXRlIHR5cGU6IFwiK2IpO307YS5jYS5wcm90b3R5cGUucmVuZGVyVGVtcGxhdGU9XG5mdW5jdGlvbihhLGMsZCxlKXthPXRoaXMubWFrZVRlbXBsYXRlU291cmNlKGEsZSk7cmV0dXJuIHRoaXMucmVuZGVyVGVtcGxhdGVTb3VyY2UoYSxjLGQsZSl9O2EuY2EucHJvdG90eXBlLmlzVGVtcGxhdGVSZXdyaXR0ZW49ZnVuY3Rpb24oYSxjKXtyZXR1cm4hMT09PXRoaXMuYWxsb3dUZW1wbGF0ZVJld3JpdGluZz8hMDp0aGlzLm1ha2VUZW1wbGF0ZVNvdXJjZShhLGMpLmRhdGEoXCJpc1Jld3JpdHRlblwiKX07YS5jYS5wcm90b3R5cGUucmV3cml0ZVRlbXBsYXRlPWZ1bmN0aW9uKGEsYyxkKXthPXRoaXMubWFrZVRlbXBsYXRlU291cmNlKGEsZCk7Yz1jKGEudGV4dCgpKTthLnRleHQoYyk7YS5kYXRhKFwiaXNSZXdyaXR0ZW5cIiwhMCl9O2EuYihcInRlbXBsYXRlRW5naW5lXCIsYS5jYSk7YS5rYz1mdW5jdGlvbigpe2Z1bmN0aW9uIGIoYixjLGQsaCl7Yj1hLm0uYWMoYik7Zm9yKHZhciBtPWEubS5SYSxrPTA7azxiLmxlbmd0aDtrKyspe3ZhciBsPWJba10ua2V5O2lmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtLFxubCkpe3ZhciBwPW1bbF07aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIHApe2lmKGw9cChiW2tdLnZhbHVlKSl0aHJvdyBFcnJvcihsKTt9ZWxzZSBpZighcCl0aHJvdyBFcnJvcihcIlRoaXMgdGVtcGxhdGUgZW5naW5lIGRvZXMgbm90IHN1cHBvcnQgdGhlICdcIitsK1wiJyBiaW5kaW5nIHdpdGhpbiBpdHMgdGVtcGxhdGVzXCIpO319ZD1cImtvLl9fdHJfYW1idG5zKGZ1bmN0aW9uKCRjb250ZXh0LCRlbGVtZW50KXtyZXR1cm4oZnVuY3Rpb24oKXtyZXR1cm57IFwiK2EubS52YihiLHt2YWx1ZUFjY2Vzc29yczohMH0pK1wiIH0gfSkoKX0sJ1wiK2QudG9Mb3dlckNhc2UoKStcIicpXCI7cmV0dXJuIGguY3JlYXRlSmF2YVNjcmlwdEV2YWx1YXRvckJsb2NrKGQpK2N9dmFyIGM9Lyg8KFthLXpdK1xcZCopKD86XFxzKyg/IWRhdGEtYmluZFxccyo9XFxzKilbYS16MC05XFwtXSsoPzo9KD86XFxcIlteXFxcIl0qXFxcInxcXCdbXlxcJ10qXFwnfFtePl0qKSk/KSpcXHMrKWRhdGEtYmluZFxccyo9XFxzKihbXCInXSkoW1xcc1xcU10qPylcXDMvZ2ksXG5kPS9cXHgzYyEtLVxccyprb1xcYlxccyooW1xcc1xcU10qPylcXHMqLS1cXHgzZS9nO3JldHVybnt4ZDpmdW5jdGlvbihiLGMsZCl7Yy5pc1RlbXBsYXRlUmV3cml0dGVuKGIsZCl8fGMucmV3cml0ZVRlbXBsYXRlKGIsZnVuY3Rpb24oYil7cmV0dXJuIGEua2MuTGQoYixjKX0sZCl9LExkOmZ1bmN0aW9uKGEsZil7cmV0dXJuIGEucmVwbGFjZShjLGZ1bmN0aW9uKGEsYyxkLGUsbCl7cmV0dXJuIGIobCxjLGQsZil9KS5yZXBsYWNlKGQsZnVuY3Rpb24oYSxjKXtyZXR1cm4gYihjLFwiXFx4M2MhLS0ga28gLS1cXHgzZVwiLFwiI2NvbW1lbnRcIixmKX0pfSxtZDpmdW5jdGlvbihiLGMpe3JldHVybiBhLmFhLlhiKGZ1bmN0aW9uKGQsaCl7dmFyIG09ZC5uZXh0U2libGluZzttJiZtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk9PT1jJiZhLmliKG0sYixoKX0pfX19KCk7YS5iKFwiX190cl9hbWJ0bnNcIixhLmtjLm1kKTsoZnVuY3Rpb24oKXthLkM9e307YS5DLkY9ZnVuY3Rpb24oYil7aWYodGhpcy5GPWIpe3ZhciBjPVxuYS5hLlIoYik7dGhpcy5hYj1cInNjcmlwdFwiPT09Yz8xOlwidGV4dGFyZWFcIj09PWM/MjpcInRlbXBsYXRlXCI9PWMmJmIuY29udGVudCYmMTE9PT1iLmNvbnRlbnQubm9kZVR5cGU/Mzo0fX07YS5DLkYucHJvdG90eXBlLnRleHQ9ZnVuY3Rpb24oKXt2YXIgYj0xPT09dGhpcy5hYj9cInRleHRcIjoyPT09dGhpcy5hYj9cInZhbHVlXCI6XCJpbm5lckhUTUxcIjtpZigwPT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLkZbYl07dmFyIGM9YXJndW1lbnRzWzBdO1wiaW5uZXJIVE1MXCI9PT1iP2EuYS5mYyh0aGlzLkYsYyk6dGhpcy5GW2JdPWN9O3ZhciBiPWEuYS5nLlooKStcIl9cIjthLkMuRi5wcm90b3R5cGUuZGF0YT1mdW5jdGlvbihjKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gYS5hLmcuZ2V0KHRoaXMuRixiK2MpO2EuYS5nLnNldCh0aGlzLkYsYitjLGFyZ3VtZW50c1sxXSl9O3ZhciBjPWEuYS5nLlooKTthLkMuRi5wcm90b3R5cGUubm9kZXM9ZnVuY3Rpb24oKXt2YXIgYj10aGlzLkY7XG5pZigwPT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hLmEuZy5nZXQoYixjKXx8e30sZj1lLmxifHwoMz09PXRoaXMuYWI/Yi5jb250ZW50OjQ9PT10aGlzLmFiP2I6bik7aWYoIWZ8fGUuamQpe3ZhciBnPXRoaXMudGV4dCgpO2cmJmchPT1lLmJiJiYoZj1hLmEuTWQoZyxiLm93bmVyRG9jdW1lbnQpLGEuYS5nLnNldChiLGMse2xiOmYsYmI6ZyxqZDohMH0pKX1yZXR1cm4gZn1lPWFyZ3VtZW50c1swXTt0aGlzLmFiIT09biYmdGhpcy50ZXh0KFwiXCIpO2EuYS5nLnNldChiLGMse2xiOmV9KX07YS5DLmlhPWZ1bmN0aW9uKGEpe3RoaXMuRj1hfTthLkMuaWEucHJvdG90eXBlPW5ldyBhLkMuRjthLkMuaWEucHJvdG90eXBlLmNvbnN0cnVjdG9yPWEuQy5pYTthLkMuaWEucHJvdG90eXBlLnRleHQ9ZnVuY3Rpb24oKXtpZigwPT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgYj1hLmEuZy5nZXQodGhpcy5GLGMpfHx7fTtiLmJiPT09biYmYi5sYiYmKGIuYmI9Yi5sYi5pbm5lckhUTUwpO3JldHVybiBiLmJifWEuYS5nLnNldCh0aGlzLkYsXG5jLHtiYjphcmd1bWVudHNbMF19KX07YS5iKFwidGVtcGxhdGVTb3VyY2VzXCIsYS5DKTthLmIoXCJ0ZW1wbGF0ZVNvdXJjZXMuZG9tRWxlbWVudFwiLGEuQy5GKTthLmIoXCJ0ZW1wbGF0ZVNvdXJjZXMuYW5vbnltb3VzVGVtcGxhdGVcIixhLkMuaWEpfSkoKTsoZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGIsYyxkKXt2YXIgZTtmb3IoYz1hLmgubmV4dFNpYmxpbmcoYyk7YiYmKGU9YikhPT1jOyliPWEuaC5uZXh0U2libGluZyhlKSxkKGUsYil9ZnVuY3Rpb24gYyhjLGQpe2lmKGMubGVuZ3RoKXt2YXIgZT1jWzBdLGY9Y1tjLmxlbmd0aC0xXSxnPWUucGFyZW50Tm9kZSxoPWEuZ2EuaW5zdGFuY2UsbT1oLnByZXByb2Nlc3NOb2RlO2lmKG0pe2IoZSxmLGZ1bmN0aW9uKGEsYil7dmFyIGM9YS5wcmV2aW91c1NpYmxpbmcsZD1tLmNhbGwoaCxhKTtkJiYoYT09PWUmJihlPWRbMF18fGIpLGE9PT1mJiYoZj1kW2QubGVuZ3RoLTFdfHxjKSl9KTtjLmxlbmd0aD0wO2lmKCFlKXJldHVybjtlPT09Zj9jLnB1c2goZSk6XG4oYy5wdXNoKGUsZiksYS5hLlVhKGMsZykpfWIoZSxmLGZ1bmN0aW9uKGIpezEhPT1iLm5vZGVUeXBlJiY4IT09Yi5ub2RlVHlwZXx8YS52YyhkLGIpfSk7YihlLGYsZnVuY3Rpb24oYil7MSE9PWIubm9kZVR5cGUmJjghPT1iLm5vZGVUeXBlfHxhLmFhLmNkKGIsW2RdKX0pO2EuYS5VYShjLGcpfX1mdW5jdGlvbiBkKGEpe3JldHVybiBhLm5vZGVUeXBlP2E6MDxhLmxlbmd0aD9hWzBdOm51bGx9ZnVuY3Rpb24gZShiLGUsZixoLG0pe209bXx8e307dmFyIG49KGImJmQoYil8fGZ8fHt9KS5vd25lckRvY3VtZW50LEI9bS50ZW1wbGF0ZUVuZ2luZXx8ZzthLmtjLnhkKGYsQixuKTtmPUIucmVuZGVyVGVtcGxhdGUoZixoLG0sbik7aWYoXCJudW1iZXJcIiE9dHlwZW9mIGYubGVuZ3RofHwwPGYubGVuZ3RoJiZcIm51bWJlclwiIT10eXBlb2YgZlswXS5ub2RlVHlwZSl0aHJvdyBFcnJvcihcIlRlbXBsYXRlIGVuZ2luZSBtdXN0IHJldHVybiBhbiBhcnJheSBvZiBET00gbm9kZXNcIik7bj0hMTtzd2l0Y2goZSl7Y2FzZSBcInJlcGxhY2VDaGlsZHJlblwiOmEuaC52YShiLFxuZik7bj0hMDticmVhaztjYXNlIFwicmVwbGFjZU5vZGVcIjphLmEuWGMoYixmKTtuPSEwO2JyZWFrO2Nhc2UgXCJpZ25vcmVUYXJnZXROb2RlXCI6YnJlYWs7ZGVmYXVsdDp0aHJvdyBFcnJvcihcIlVua25vd24gcmVuZGVyTW9kZTogXCIrZSk7fW4mJihjKGYsaCksbS5hZnRlclJlbmRlciYmYS51LkcobS5hZnRlclJlbmRlcixudWxsLFtmLGhbbS5hc3x8XCIkZGF0YVwiXV0pLFwicmVwbGFjZUNoaWxkcmVuXCI9PWUmJmEuaS5tYShiLGEuaS5IKSk7cmV0dXJuIGZ9ZnVuY3Rpb24gZihiLGMsZCl7cmV0dXJuIGEuTyhiKT9iKCk6XCJmdW5jdGlvblwiPT09dHlwZW9mIGI/YihjLGQpOmJ9dmFyIGc7YS5nYz1mdW5jdGlvbihiKXtpZihiIT1uJiYhKGIgaW5zdGFuY2VvZiBhLmNhKSl0aHJvdyBFcnJvcihcInRlbXBsYXRlRW5naW5lIG11c3QgaW5oZXJpdCBmcm9tIGtvLnRlbXBsYXRlRW5naW5lXCIpO2c9Yn07YS5kYz1mdW5jdGlvbihiLGMsaCxtLHQpe2g9aHx8e307aWYoKGgudGVtcGxhdGVFbmdpbmV8fGcpPT1cbm4pdGhyb3cgRXJyb3IoXCJTZXQgYSB0ZW1wbGF0ZSBlbmdpbmUgYmVmb3JlIGNhbGxpbmcgcmVuZGVyVGVtcGxhdGVcIik7dD10fHxcInJlcGxhY2VDaGlsZHJlblwiO2lmKG0pe3ZhciB4PWQobSk7cmV0dXJuIGEuJChmdW5jdGlvbigpe3ZhciBnPWMmJmMgaW5zdGFuY2VvZiBhLmZhP2M6bmV3IGEuZmEoYyxudWxsLG51bGwsbnVsbCx7ZXhwb3J0RGVwZW5kZW5jaWVzOiEwfSksbj1mKGIsZy4kZGF0YSxnKSxnPWUobSx0LG4sZyxoKTtcInJlcGxhY2VOb2RlXCI9PXQmJihtPWcseD1kKG0pKX0sbnVsbCx7U2E6ZnVuY3Rpb24oKXtyZXR1cm4heHx8IWEuYS5TYih4KX0sbDp4JiZcInJlcGxhY2VOb2RlXCI9PXQ/eC5wYXJlbnROb2RlOnh9KX1yZXR1cm4gYS5hYS5YYihmdW5jdGlvbihkKXthLmRjKGIsYyxoLGQsXCJyZXBsYWNlTm9kZVwiKX0pfTthLlFkPWZ1bmN0aW9uKGIsZCxnLGgsbSl7ZnVuY3Rpb24geChiLGMpe2EudS5HKGEuYS5lYyxudWxsLFtoLGIsdSxnLHIsY10pO2EuaS5tYShoLGEuaS5IKX1cbmZ1bmN0aW9uIHIoYSxiKXtjKGIsdik7Zy5hZnRlclJlbmRlciYmZy5hZnRlclJlbmRlcihiLGEpO3Y9bnVsbH1mdW5jdGlvbiB1KGEsYyl7dj1tLmNyZWF0ZUNoaWxkQ29udGV4dChhLHthczp6LG5vQ2hpbGRDb250ZXh0Omcubm9DaGlsZENvbnRleHQsZXh0ZW5kOmZ1bmN0aW9uKGEpe2EuJGluZGV4PWM7eiYmKGFbeitcIkluZGV4XCJdPWMpfX0pO3ZhciBkPWYoYixhLHYpO3JldHVybiBlKGgsXCJpZ25vcmVUYXJnZXROb2RlXCIsZCx2LGcpfXZhciB2LHo9Zy5hcyx3PSExPT09Zy5pbmNsdWRlRGVzdHJveWVkfHxhLm9wdGlvbnMuZm9yZWFjaEhpZGVzRGVzdHJveWVkJiYhZy5pbmNsdWRlRGVzdHJveWVkO2lmKHd8fGcuYmVmb3JlUmVtb3ZlfHwhYS5QYyhkKSlyZXR1cm4gYS4kKGZ1bmN0aW9uKCl7dmFyIGI9YS5hLmYoZCl8fFtdO1widW5kZWZpbmVkXCI9PXR5cGVvZiBiLmxlbmd0aCYmKGI9W2JdKTt3JiYoYj1hLmEuamIoYixmdW5jdGlvbihiKXtyZXR1cm4gYj09PW58fG51bGw9PT1ifHxcbiFhLmEuZihiLl9kZXN0cm95KX0pKTt4KGIpfSxudWxsLHtsOmh9KTt4KGQudigpKTt2YXIgQT1kLnN1YnNjcmliZShmdW5jdGlvbihhKXt4KGQoKSxhKX0sbnVsbCxcImFycmF5Q2hhbmdlXCIpO0EubChoKTtyZXR1cm4gQX07dmFyIGg9YS5hLmcuWigpLG09YS5hLmcuWigpO2EuYy50ZW1wbGF0ZT17aW5pdDpmdW5jdGlvbihiLGMpe3ZhciBkPWEuYS5mKGMoKSk7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGR8fFwibmFtZVwiaW4gZClhLmguRWEoYik7ZWxzZSBpZihcIm5vZGVzXCJpbiBkKXtkPWQubm9kZXN8fFtdO2lmKGEuTyhkKSl0aHJvdyBFcnJvcignVGhlIFwibm9kZXNcIiBvcHRpb24gbXVzdCBiZSBhIHBsYWluLCBub24tb2JzZXJ2YWJsZSBhcnJheS4nKTt2YXIgZT1kWzBdJiZkWzBdLnBhcmVudE5vZGU7ZSYmYS5hLmcuZ2V0KGUsbSl8fChlPWEuYS5ZYihkKSxhLmEuZy5zZXQoZSxtLCEwKSk7KG5ldyBhLkMuaWEoYikpLm5vZGVzKGUpfWVsc2UgaWYoZD1hLmguY2hpbGROb2RlcyhiKSwwPGQubGVuZ3RoKWU9XG5hLmEuWWIoZCksKG5ldyBhLkMuaWEoYikpLm5vZGVzKGUpO2Vsc2UgdGhyb3cgRXJyb3IoXCJBbm9ueW1vdXMgdGVtcGxhdGUgZGVmaW5lZCwgYnV0IG5vIHRlbXBsYXRlIGNvbnRlbnQgd2FzIHByb3ZpZGVkXCIpO3JldHVybntjb250cm9sc0Rlc2NlbmRhbnRCaW5kaW5nczohMH19LHVwZGF0ZTpmdW5jdGlvbihiLGMsZCxlLGYpe3ZhciBnPWMoKTtjPWEuYS5mKGcpO2Q9ITA7ZT1udWxsO1wic3RyaW5nXCI9PXR5cGVvZiBjP2M9e306KGc9XCJuYW1lXCJpbiBjP2MubmFtZTpiLFwiaWZcImluIGMmJihkPWEuYS5mKGNbXCJpZlwiXSkpLGQmJlwiaWZub3RcImluIGMmJihkPSFhLmEuZihjLmlmbm90KSksZCYmIWcmJihkPSExKSk7XCJmb3JlYWNoXCJpbiBjP2U9YS5RZChnLGQmJmMuZm9yZWFjaHx8W10sYyxiLGYpOmQ/KGQ9ZixcImRhdGFcImluIGMmJihkPWYuY3JlYXRlQ2hpbGRDb250ZXh0KGMuZGF0YSx7YXM6Yy5hcyxub0NoaWxkQ29udGV4dDpjLm5vQ2hpbGRDb250ZXh0LGV4cG9ydERlcGVuZGVuY2llczohMH0pKSxcbmU9YS5kYyhnLGQsYyxiKSk6YS5oLkVhKGIpO2Y9ZTsoYz1hLmEuZy5nZXQoYixoKSkmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGMucyYmYy5zKCk7YS5hLmcuc2V0KGIsaCwhZnx8Zi5qYSYmIWYuamEoKT9uOmYpfX07YS5tLlJhLnRlbXBsYXRlPWZ1bmN0aW9uKGIpe2I9YS5tLmFjKGIpO3JldHVybiAxPT1iLmxlbmd0aCYmYlswXS51bmtub3dufHxhLm0uSWQoYixcIm5hbWVcIik/bnVsbDpcIlRoaXMgdGVtcGxhdGUgZW5naW5lIGRvZXMgbm90IHN1cHBvcnQgYW5vbnltb3VzIHRlbXBsYXRlcyBuZXN0ZWQgd2l0aGluIGl0cyB0ZW1wbGF0ZXNcIn07YS5oLmVhLnRlbXBsYXRlPSEwfSkoKTthLmIoXCJzZXRUZW1wbGF0ZUVuZ2luZVwiLGEuZ2MpO2EuYihcInJlbmRlclRlbXBsYXRlXCIsYS5kYyk7YS5hLktjPWZ1bmN0aW9uKGEsYyxkKXtpZihhLmxlbmd0aCYmYy5sZW5ndGgpe3ZhciBlLGYsZyxoLG07Zm9yKGU9Zj0wOyghZHx8ZTxkKSYmKGg9YVtmXSk7KytmKXtmb3IoZz0wO209Y1tnXTsrK2cpaWYoaC52YWx1ZT09PVxubS52YWx1ZSl7aC5tb3ZlZD1tLmluZGV4O20ubW92ZWQ9aC5pbmRleDtjLnNwbGljZShnLDEpO2U9Zz0wO2JyZWFrfWUrPWd9fX07YS5hLlBiPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYihiLGQsZSxmLGcpe3ZhciBoPU1hdGgubWluLG09TWF0aC5tYXgsaz1bXSxsLHA9Yi5sZW5ndGgscSxuPWQubGVuZ3RoLHI9bi1wfHwxLHY9cCtuKzEsdSx3LHo7Zm9yKGw9MDtsPD1wO2wrKylmb3Iodz11LGsucHVzaCh1PVtdKSx6PWgobixsK3IpLHE9bSgwLGwtMSk7cTw9ejtxKyspdVtxXT1xP2w/YltsLTFdPT09ZFtxLTFdP3dbcS0xXTpoKHdbcV18fHYsdVtxLTFdfHx2KSsxOnErMTpsKzE7aD1bXTttPVtdO3I9W107bD1wO2ZvcihxPW47bHx8cTspbj1rW2xdW3FdLTEscSYmbj09PWtbbF1bcS0xXT9tLnB1c2goaFtoLmxlbmd0aF09e3N0YXR1czplLHZhbHVlOmRbLS1xXSxpbmRleDpxfSk6bCYmbj09PWtbbC0xXVtxXT9yLnB1c2goaFtoLmxlbmd0aF09e3N0YXR1czpmLHZhbHVlOmJbLS1sXSxpbmRleDpsfSk6XG4oLS1xLC0tbCxnLnNwYXJzZXx8aC5wdXNoKHtzdGF0dXM6XCJyZXRhaW5lZFwiLHZhbHVlOmRbcV19KSk7YS5hLktjKHIsbSwhZy5kb250TGltaXRNb3ZlcyYmMTAqcCk7cmV0dXJuIGgucmV2ZXJzZSgpfXJldHVybiBmdW5jdGlvbihhLGQsZSl7ZT1cImJvb2xlYW5cIj09PXR5cGVvZiBlP3tkb250TGltaXRNb3ZlczplfTplfHx7fTthPWF8fFtdO2Q9ZHx8W107cmV0dXJuIGEubGVuZ3RoPGQubGVuZ3RoP2IoYSxkLFwiYWRkZWRcIixcImRlbGV0ZWRcIixlKTpiKGQsYSxcImRlbGV0ZWRcIixcImFkZGVkXCIsZSl9fSgpO2EuYihcInV0aWxzLmNvbXBhcmVBcnJheXNcIixhLmEuUGIpOyhmdW5jdGlvbigpe2Z1bmN0aW9uIGIoYixjLGQsaCxtKXt2YXIgaz1bXSxsPWEuJChmdW5jdGlvbigpe3ZhciBsPWMoZCxtLGEuYS5VYShrLGIpKXx8W107MDxrLmxlbmd0aCYmKGEuYS5YYyhrLGwpLGgmJmEudS5HKGgsbnVsbCxbZCxsLG1dKSk7ay5sZW5ndGg9MDthLmEuTmIoayxsKX0sbnVsbCx7bDpiLFNhOmZ1bmN0aW9uKCl7cmV0dXJuIWEuYS5rZChrKX19KTtcbnJldHVybntZOmssJDpsLmphKCk/bDpufX12YXIgYz1hLmEuZy5aKCksZD1hLmEuZy5aKCk7YS5hLmVjPWZ1bmN0aW9uKGUsZixnLGgsbSxrKXtmdW5jdGlvbiBsKGIpe3k9e0FhOmIscGI6YS50YSh3KyspfTt2LnB1c2goeSk7cnx8Ri5wdXNoKHkpfWZ1bmN0aW9uIHAoYil7eT10W2JdO3chPT15LnBiLnYoKSYmRC5wdXNoKHkpO3kucGIodysrKTthLmEuVWEoeS5ZLGUpO3YucHVzaCh5KX1mdW5jdGlvbiBxKGIsYyl7aWYoYilmb3IodmFyIGQ9MCxlPWMubGVuZ3RoO2Q8ZTtkKyspYS5hLkQoY1tkXS5ZLGZ1bmN0aW9uKGEpe2IoYSxkLGNbZF0uQWEpfSl9Zj1mfHxbXTtcInVuZGVmaW5lZFwiPT10eXBlb2YgZi5sZW5ndGgmJihmPVtmXSk7aD1ofHx7fTt2YXIgdD1hLmEuZy5nZXQoZSxjKSxyPSF0LHY9W10sdT0wLHc9MCx6PVtdLEE9W10sQz1bXSxEPVtdLEY9W10seSxJPTA7aWYocilhLmEuRChmLGwpO2Vsc2V7aWYoIWt8fHQmJnQuX2NvdW50V2FpdGluZ0ZvclJlbW92ZSl7dmFyIEU9XG5hLmEuTWIodCxmdW5jdGlvbihhKXtyZXR1cm4gYS5BYX0pO2s9YS5hLlBiKEUsZix7ZG9udExpbWl0TW92ZXM6aC5kb250TGltaXRNb3ZlcyxzcGFyc2U6ITB9KX1mb3IodmFyIEU9MCxHLEgsSztHPWtbRV07RSsrKXN3aXRjaChIPUcubW92ZWQsSz1HLmluZGV4LEcuc3RhdHVzKXtjYXNlIFwiZGVsZXRlZFwiOmZvcig7dTxLOylwKHUrKyk7SD09PW4mJih5PXRbdV0seS4kJiYoeS4kLnMoKSx5LiQ9biksYS5hLlVhKHkuWSxlKS5sZW5ndGgmJihoLmJlZm9yZVJlbW92ZSYmKHYucHVzaCh5KSxJKysseS5BYT09PWQ/eT1udWxsOkMucHVzaCh5KSkseSYmei5wdXNoLmFwcGx5KHoseS5ZKSkpO3UrKzticmVhaztjYXNlIFwiYWRkZWRcIjpmb3IoO3c8SzspcCh1KyspO0ghPT1uPyhBLnB1c2godi5sZW5ndGgpLHAoSCkpOmwoRy52YWx1ZSl9Zm9yKDt3PGYubGVuZ3RoOylwKHUrKyk7di5fY291bnRXYWl0aW5nRm9yUmVtb3ZlPUl9YS5hLmcuc2V0KGUsYyx2KTtxKGguYmVmb3JlTW92ZSxEKTthLmEuRCh6LFxuaC5iZWZvcmVSZW1vdmU/YS5vYTphLnJlbW92ZU5vZGUpO3ZhciBNLE8sUDt0cnl7UD1lLm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudH1jYXRjaChOKXt9aWYoQS5sZW5ndGgpZm9yKDsoRT1BLnNoaWZ0KCkpIT1uOyl7eT12W0VdO2ZvcihNPW47RTspaWYoKE89dlstLUVdLlkpJiZPLmxlbmd0aCl7TT1PW08ubGVuZ3RoLTFdO2JyZWFrfWZvcihmPTA7dT15LllbZl07TT11LGYrKylhLmguV2IoZSx1LE0pfWZvcihFPTA7eT12W0VdO0UrKyl7eS5ZfHxhLmEuZXh0ZW5kKHksYihlLGcseS5BYSxtLHkucGIpKTtmb3IoZj0wO3U9eS5ZW2ZdO009dSxmKyspYS5oLldiKGUsdSxNKTsheS5FZCYmbSYmKG0oeS5BYSx5LlkseS5wYikseS5FZD0hMCxNPXkuWVt5LlkubGVuZ3RoLTFdKX1QJiZlLm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudCE9UCYmUC5mb2N1cygpO3EoaC5iZWZvcmVSZW1vdmUsQyk7Zm9yKEU9MDtFPEMubGVuZ3RoOysrRSlDW0VdLkFhPWQ7cShoLmFmdGVyTW92ZSxEKTtcbnEoaC5hZnRlckFkZCxGKX19KSgpO2EuYihcInV0aWxzLnNldERvbU5vZGVDaGlsZHJlbkZyb21BcnJheU1hcHBpbmdcIixhLmEuZWMpO2EuYmE9ZnVuY3Rpb24oKXt0aGlzLmFsbG93VGVtcGxhdGVSZXdyaXRpbmc9ITF9O2EuYmEucHJvdG90eXBlPW5ldyBhLmNhO2EuYmEucHJvdG90eXBlLmNvbnN0cnVjdG9yPWEuYmE7YS5iYS5wcm90b3R5cGUucmVuZGVyVGVtcGxhdGVTb3VyY2U9ZnVuY3Rpb24oYixjLGQsZSl7aWYoYz0oOT5hLmEuVz8wOmIubm9kZXMpP2Iubm9kZXMoKTpudWxsKXJldHVybiBhLmEubGEoYy5jbG9uZU5vZGUoITApLmNoaWxkTm9kZXMpO2I9Yi50ZXh0KCk7cmV0dXJuIGEuYS51YShiLGUpfTthLmJhLk1hPW5ldyBhLmJhO2EuZ2MoYS5iYS5NYSk7YS5iKFwibmF0aXZlVGVtcGxhdGVFbmdpbmVcIixhLmJhKTsoZnVuY3Rpb24oKXthLiRhPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5IZD1mdW5jdGlvbigpe2lmKCF2fHwhdi50bXBsKXJldHVybiAwO3RyeXtpZigwPD12LnRtcGwudGFnLnRtcGwub3Blbi50b1N0cmluZygpLmluZGV4T2YoXCJfX1wiKSlyZXR1cm4gMn1jYXRjaChhKXt9cmV0dXJuIDF9KCk7XG50aGlzLnJlbmRlclRlbXBsYXRlU291cmNlPWZ1bmN0aW9uKGIsZSxmLGcpe2c9Z3x8dztmPWZ8fHt9O2lmKDI+YSl0aHJvdyBFcnJvcihcIllvdXIgdmVyc2lvbiBvZiBqUXVlcnkudG1wbCBpcyB0b28gb2xkLiBQbGVhc2UgdXBncmFkZSB0byBqUXVlcnkudG1wbCAxLjAuMHByZSBvciBsYXRlci5cIik7dmFyIGg9Yi5kYXRhKFwicHJlY29tcGlsZWRcIik7aHx8KGg9Yi50ZXh0KCl8fFwiXCIsaD12LnRlbXBsYXRlKG51bGwsXCJ7e2tvX3dpdGggJGl0ZW0ua29CaW5kaW5nQ29udGV4dH19XCIraCtcInt7L2tvX3dpdGh9fVwiKSxiLmRhdGEoXCJwcmVjb21waWxlZFwiLGgpKTtiPVtlLiRkYXRhXTtlPXYuZXh0ZW5kKHtrb0JpbmRpbmdDb250ZXh0OmV9LGYudGVtcGxhdGVPcHRpb25zKTtlPXYudG1wbChoLGIsZSk7ZS5hcHBlbmRUbyhnLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO3YuZnJhZ21lbnRzPXt9O3JldHVybiBlfTt0aGlzLmNyZWF0ZUphdmFTY3JpcHRFdmFsdWF0b3JCbG9jaz1mdW5jdGlvbihhKXtyZXR1cm5cInt7a29fY29kZSAoKGZ1bmN0aW9uKCkgeyByZXR1cm4gXCIrXG5hK1wiIH0pKCkpIH19XCJ9O3RoaXMuYWRkVGVtcGxhdGU9ZnVuY3Rpb24oYSxiKXt3LndyaXRlKFwiPHNjcmlwdCB0eXBlPSd0ZXh0L2h0bWwnIGlkPSdcIithK1wiJz5cIitiK1wiXFx4M2Mvc2NyaXB0PlwiKX07MDxhJiYodi50bXBsLnRhZy5rb19jb2RlPXtvcGVuOlwiX18ucHVzaCgkMSB8fCAnJyk7XCJ9LHYudG1wbC50YWcua29fd2l0aD17b3BlbjpcIndpdGgoJDEpIHtcIixjbG9zZTpcIn0gXCJ9KX07YS4kYS5wcm90b3R5cGU9bmV3IGEuY2E7YS4kYS5wcm90b3R5cGUuY29uc3RydWN0b3I9YS4kYTt2YXIgYj1uZXcgYS4kYTswPGIuSGQmJmEuZ2MoYik7YS5iKFwianF1ZXJ5VG1wbFRlbXBsYXRlRW5naW5lXCIsYS4kYSl9KSgpfSl9KSgpO30pKCk7XG4iLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvKiEganMtY29va2llIHYzLjAuMSB8IE1JVCAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tdmFyICovXG5mdW5jdGlvbiBhc3NpZ24gKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldFxufVxuLyogZXNsaW50LWVuYWJsZSBuby12YXIgKi9cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdmFyICovXG52YXIgZGVmYXVsdENvbnZlcnRlciA9IHtcbiAgcmVhZDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlWzBdID09PSAnXCInKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDEsIC0xKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoLyglW1xcZEEtRl17Mn0pKy9naSwgZGVjb2RlVVJJQ29tcG9uZW50KVxuICB9LFxuICB3cml0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkucmVwbGFjZShcbiAgICAgIC8lKDJbMzQ2QkZdfDNbQUMtRl18NDB8NVtCREVdfDYwfDdbQkNEXSkvZyxcbiAgICAgIGRlY29kZVVSSUNvbXBvbmVudFxuICAgIClcbiAgfVxufTtcbi8qIGVzbGludC1lbmFibGUgbm8tdmFyICovXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXZhciAqL1xuXG5mdW5jdGlvbiBpbml0IChjb252ZXJ0ZXIsIGRlZmF1bHRBdHRyaWJ1dGVzKSB7XG4gIGZ1bmN0aW9uIHNldCAoa2V5LCB2YWx1ZSwgYXR0cmlidXRlcykge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBhdHRyaWJ1dGVzID0gYXNzaWduKHt9LCBkZWZhdWx0QXR0cmlidXRlcywgYXR0cmlidXRlcyk7XG5cbiAgICBpZiAodHlwZW9mIGF0dHJpYnV0ZXMuZXhwaXJlcyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGF0dHJpYnV0ZXMuZXhwaXJlcyA9IG5ldyBEYXRlKERhdGUubm93KCkgKyBhdHRyaWJ1dGVzLmV4cGlyZXMgKiA4NjRlNSk7XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGVzLmV4cGlyZXMpIHtcbiAgICAgIGF0dHJpYnV0ZXMuZXhwaXJlcyA9IGF0dHJpYnV0ZXMuZXhwaXJlcy50b1VUQ1N0cmluZygpO1xuICAgIH1cblxuICAgIGtleSA9IGVuY29kZVVSSUNvbXBvbmVudChrZXkpXG4gICAgICAucmVwbGFjZSgvJSgyWzM0NkJdfDVFfDYwfDdDKS9nLCBkZWNvZGVVUklDb21wb25lbnQpXG4gICAgICAucmVwbGFjZSgvWygpXS9nLCBlc2NhcGUpO1xuXG4gICAgdmFyIHN0cmluZ2lmaWVkQXR0cmlidXRlcyA9ICcnO1xuICAgIGZvciAodmFyIGF0dHJpYnV0ZU5hbWUgaW4gYXR0cmlidXRlcykge1xuICAgICAgaWYgKCFhdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIHN0cmluZ2lmaWVkQXR0cmlidXRlcyArPSAnOyAnICsgYXR0cmlidXRlTmFtZTtcblxuICAgICAgaWYgKGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0gPT09IHRydWUpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gQ29uc2lkZXJzIFJGQyA2MjY1IHNlY3Rpb24gNS4yOlxuICAgICAgLy8gLi4uXG4gICAgICAvLyAzLiAgSWYgdGhlIHJlbWFpbmluZyB1bnBhcnNlZC1hdHRyaWJ1dGVzIGNvbnRhaW5zIGEgJXgzQiAoXCI7XCIpXG4gICAgICAvLyAgICAgY2hhcmFjdGVyOlxuICAgICAgLy8gQ29uc3VtZSB0aGUgY2hhcmFjdGVycyBvZiB0aGUgdW5wYXJzZWQtYXR0cmlidXRlcyB1cCB0byxcbiAgICAgIC8vIG5vdCBpbmNsdWRpbmcsIHRoZSBmaXJzdCAleDNCIChcIjtcIikgY2hhcmFjdGVyLlxuICAgICAgLy8gLi4uXG4gICAgICBzdHJpbmdpZmllZEF0dHJpYnV0ZXMgKz0gJz0nICsgYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXS5zcGxpdCgnOycpWzBdO1xuICAgIH1cblxuICAgIHJldHVybiAoZG9jdW1lbnQuY29va2llID1cbiAgICAgIGtleSArICc9JyArIGNvbnZlcnRlci53cml0ZSh2YWx1ZSwga2V5KSArIHN0cmluZ2lmaWVkQXR0cmlidXRlcylcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldCAoa2V5KSB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgfHwgKGFyZ3VtZW50cy5sZW5ndGggJiYgIWtleSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIFRvIHByZXZlbnQgdGhlIGZvciBsb29wIGluIHRoZSBmaXJzdCBwbGFjZSBhc3NpZ24gYW4gZW1wdHkgYXJyYXlcbiAgICAvLyBpbiBjYXNlIHRoZXJlIGFyZSBubyBjb29raWVzIGF0IGFsbC5cbiAgICB2YXIgY29va2llcyA9IGRvY3VtZW50LmNvb2tpZSA/IGRvY3VtZW50LmNvb2tpZS5zcGxpdCgnOyAnKSA6IFtdO1xuICAgIHZhciBqYXIgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb2tpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwYXJ0cyA9IGNvb2tpZXNbaV0uc3BsaXQoJz0nKTtcbiAgICAgIHZhciB2YWx1ZSA9IHBhcnRzLnNsaWNlKDEpLmpvaW4oJz0nKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGZvdW5kS2V5ID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhcnRzWzBdKTtcbiAgICAgICAgamFyW2ZvdW5kS2V5XSA9IGNvbnZlcnRlci5yZWFkKHZhbHVlLCBmb3VuZEtleSk7XG5cbiAgICAgICAgaWYgKGtleSA9PT0gZm91bmRLZXkpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cblxuICAgIHJldHVybiBrZXkgPyBqYXJba2V5XSA6IGphclxuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5jcmVhdGUoXG4gICAge1xuICAgICAgc2V0OiBzZXQsXG4gICAgICBnZXQ6IGdldCxcbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gKGtleSwgYXR0cmlidXRlcykge1xuICAgICAgICBzZXQoXG4gICAgICAgICAga2V5LFxuICAgICAgICAgICcnLFxuICAgICAgICAgIGFzc2lnbih7fSwgYXR0cmlidXRlcywge1xuICAgICAgICAgICAgZXhwaXJlczogLTFcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIHdpdGhBdHRyaWJ1dGVzOiBmdW5jdGlvbiAoYXR0cmlidXRlcykge1xuICAgICAgICByZXR1cm4gaW5pdCh0aGlzLmNvbnZlcnRlciwgYXNzaWduKHt9LCB0aGlzLmF0dHJpYnV0ZXMsIGF0dHJpYnV0ZXMpKVxuICAgICAgfSxcbiAgICAgIHdpdGhDb252ZXJ0ZXI6IGZ1bmN0aW9uIChjb252ZXJ0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGluaXQoYXNzaWduKHt9LCB0aGlzLmNvbnZlcnRlciwgY29udmVydGVyKSwgdGhpcy5hdHRyaWJ1dGVzKVxuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgYXR0cmlidXRlczogeyB2YWx1ZTogT2JqZWN0LmZyZWV6ZShkZWZhdWx0QXR0cmlidXRlcykgfSxcbiAgICAgIGNvbnZlcnRlcjogeyB2YWx1ZTogT2JqZWN0LmZyZWV6ZShjb252ZXJ0ZXIpIH1cbiAgICB9XG4gIClcbn1cblxudmFyIGFwaSA9IGluaXQoZGVmYXVsdENvbnZlcnRlciwgeyBwYXRoOiAnLycgfSk7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXZhciAqL1xuXG5leHBvcnQgZGVmYXVsdCBhcGk7XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdGlkOiBtb2R1bGVJZCxcblx0XHRsb2FkZWQ6IGZhbHNlLFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcblx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4vLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuX193ZWJwYWNrX3JlcXVpcmVfXy5tID0gX193ZWJwYWNrX21vZHVsZXNfXztcblxuIiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG5cdFx0KCkgPT4gKG1vZHVsZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCJ2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgPyAob2JqKSA9PiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikpIDogKG9iaikgPT4gKG9iai5fX3Byb3RvX18pO1xudmFyIGxlYWZQcm90b3R5cGVzO1xuLy8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4vLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbi8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuLy8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4vLyBtb2RlICYgMTY6IHJldHVybiB2YWx1ZSB3aGVuIGl0J3MgUHJvbWlzZS1saWtlXG4vLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuXHRpZihtb2RlICYgMSkgdmFsdWUgPSB0aGlzKHZhbHVlKTtcblx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcblx0aWYodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSkge1xuXHRcdGlmKChtb2RlICYgNCkgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuXHRcdGlmKChtb2RlICYgMTYpICYmIHR5cGVvZiB2YWx1ZS50aGVuID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdmFsdWU7XG5cdH1cblx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcblx0dmFyIGRlZiA9IHt9O1xuXHRsZWFmUHJvdG90eXBlcyA9IGxlYWZQcm90b3R5cGVzIHx8IFtudWxsLCBnZXRQcm90byh7fSksIGdldFByb3RvKFtdKSwgZ2V0UHJvdG8oZ2V0UHJvdG8pXTtcblx0Zm9yKHZhciBjdXJyZW50ID0gbW9kZSAmIDIgJiYgdmFsdWU7IHR5cGVvZiBjdXJyZW50ID09ICdvYmplY3QnICYmICF+bGVhZlByb3RvdHlwZXMuaW5kZXhPZihjdXJyZW50KTsgY3VycmVudCA9IGdldFByb3RvKGN1cnJlbnQpKSB7XG5cdFx0T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY3VycmVudCkuZm9yRWFjaCgoa2V5KSA9PiAoZGVmW2tleV0gPSAoKSA9PiAodmFsdWVba2V5XSkpKTtcblx0fVxuXHRkZWZbJ2RlZmF1bHQnXSA9ICgpID0+ICh2YWx1ZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChucywgZGVmKTtcblx0cmV0dXJuIG5zO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmYgPSB7fTtcbi8vIFRoaXMgZmlsZSBjb250YWlucyBvbmx5IHRoZSBlbnRyeSBjaHVuay5cbi8vIFRoZSBjaHVuayBsb2FkaW5nIGZ1bmN0aW9uIGZvciBhZGRpdGlvbmFsIGNodW5rc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5lID0gKGNodW5rSWQpID0+IHtcblx0cmV0dXJuIFByb21pc2UuYWxsKE9iamVjdC5rZXlzKF9fd2VicGFja19yZXF1aXJlX18uZikucmVkdWNlKChwcm9taXNlcywga2V5KSA9PiB7XG5cdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5mW2tleV0oY2h1bmtJZCwgcHJvbWlzZXMpO1xuXHRcdHJldHVybiBwcm9taXNlcztcblx0fSwgW10pKTtcbn07IiwiLy8gVGhpcyBmdW5jdGlvbiBhbGxvdyB0byByZWZlcmVuY2UgYXN5bmMgY2h1bmtzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnUgPSAoY2h1bmtJZCkgPT4ge1xuXHQvLyByZXR1cm4gdXJsIGZvciBmaWxlbmFtZXMgYmFzZWQgb24gdGVtcGxhdGVcblx0cmV0dXJuIFwiXCIgKyBjaHVua0lkICsgXCJcIiArIHtcInNyY19tb3JzZVJzc1BsdWdpbl9qc1wiOlwiMTU0YzI4NjFmYjg1ODMxODI3Y2NcIixcIm5vZGVfbW9kdWxlc193aGl0ZS1ub2lzZS1ub2RlX2luZGV4X2pzXCI6XCI4ZjcyMTFkOGRiZjgzOTU5NGVjOFwiLFwibm9kZV9tb2R1bGVzX2Jyb3duLW5vaXNlLW5vZGVfaW5kZXhfanNcIjpcIjQ4MDIwZTE3MDM1N2E1NGUyZGI4XCIsXCJub2RlX21vZHVsZXNfcGluay1ub2lzZS1ub2RlX2luZGV4X2pzXCI6XCI2NmQxOTE0MDZmNjg4OGE3ZGQ2NlwiLFwidmVuZG9ycy1ub2RlX21vZHVsZXNfcnNzLXBhcnNlcl9pbmRleF9qc1wiOlwiMGNiNjFiZGM5ZTE4ZGZjNTAxMzFcIixcIl9lZDFiLV9kMTdlXCI6XCI1OTA3ZmMyZjc3MGJjMWFlNzVhYVwifVtjaHVua0lkXSArIFwiLmpzXCI7XG59OyIsIi8vIFRoaXMgZnVuY3Rpb24gYWxsb3cgdG8gcmVmZXJlbmNlIGFzeW5jIGNodW5rc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5taW5pQ3NzRiA9IChjaHVua0lkKSA9PiB7XG5cdC8vIHJldHVybiB1cmwgZm9yIGZpbGVuYW1lcyBiYXNlZCBvbiB0ZW1wbGF0ZVxuXHRyZXR1cm4gdW5kZWZpbmVkO1xufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuXHR9XG59KSgpOyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCJ2YXIgaW5Qcm9ncmVzcyA9IHt9O1xuLy8gZGF0YS13ZWJwYWNrIGlzIG5vdCB1c2VkIGFzIGJ1aWxkIGhhcyBubyB1bmlxdWVOYW1lXG4vLyBsb2FkU2NyaXB0IGZ1bmN0aW9uIHRvIGxvYWQgYSBzY3JpcHQgdmlhIHNjcmlwdCB0YWdcbl9fd2VicGFja19yZXF1aXJlX18ubCA9ICh1cmwsIGRvbmUsIGtleSwgY2h1bmtJZCkgPT4ge1xuXHRpZihpblByb2dyZXNzW3VybF0pIHsgaW5Qcm9ncmVzc1t1cmxdLnB1c2goZG9uZSk7IHJldHVybjsgfVxuXHR2YXIgc2NyaXB0LCBuZWVkQXR0YWNoO1xuXHRpZihrZXkgIT09IHVuZGVmaW5lZCkge1xuXHRcdHZhciBzY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzY3JpcHRcIik7XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHNjcmlwdHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBzID0gc2NyaXB0c1tpXTtcblx0XHRcdGlmKHMuZ2V0QXR0cmlidXRlKFwic3JjXCIpID09IHVybCkgeyBzY3JpcHQgPSBzOyBicmVhazsgfVxuXHRcdH1cblx0fVxuXHRpZighc2NyaXB0KSB7XG5cdFx0bmVlZEF0dGFjaCA9IHRydWU7XG5cdFx0c2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG5cblx0XHRzY3JpcHQuY2hhcnNldCA9ICd1dGYtOCc7XG5cdFx0c2NyaXB0LnRpbWVvdXQgPSAxMjA7XG5cdFx0aWYgKF9fd2VicGFja19yZXF1aXJlX18ubmMpIHtcblx0XHRcdHNjcmlwdC5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCBfX3dlYnBhY2tfcmVxdWlyZV9fLm5jKTtcblx0XHR9XG5cblx0XHRzY3JpcHQuc3JjID0gdXJsO1xuXHR9XG5cdGluUHJvZ3Jlc3NbdXJsXSA9IFtkb25lXTtcblx0dmFyIG9uU2NyaXB0Q29tcGxldGUgPSAocHJldiwgZXZlbnQpID0+IHtcblx0XHQvLyBhdm9pZCBtZW0gbGVha3MgaW4gSUUuXG5cdFx0c2NyaXB0Lm9uZXJyb3IgPSBzY3JpcHQub25sb2FkID0gbnVsbDtcblx0XHRjbGVhclRpbWVvdXQodGltZW91dCk7XG5cdFx0dmFyIGRvbmVGbnMgPSBpblByb2dyZXNzW3VybF07XG5cdFx0ZGVsZXRlIGluUHJvZ3Jlc3NbdXJsXTtcblx0XHRzY3JpcHQucGFyZW50Tm9kZSAmJiBzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpO1xuXHRcdGRvbmVGbnMgJiYgZG9uZUZucy5mb3JFYWNoKChmbikgPT4gKGZuKGV2ZW50KSkpO1xuXHRcdGlmKHByZXYpIHJldHVybiBwcmV2KGV2ZW50KTtcblx0fVxuXHQ7XG5cdHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChvblNjcmlwdENvbXBsZXRlLmJpbmQobnVsbCwgdW5kZWZpbmVkLCB7IHR5cGU6ICd0aW1lb3V0JywgdGFyZ2V0OiBzY3JpcHQgfSksIDEyMDAwMCk7XG5cdHNjcmlwdC5vbmVycm9yID0gb25TY3JpcHRDb21wbGV0ZS5iaW5kKG51bGwsIHNjcmlwdC5vbmVycm9yKTtcblx0c2NyaXB0Lm9ubG9hZCA9IG9uU2NyaXB0Q29tcGxldGUuYmluZChudWxsLCBzY3JpcHQub25sb2FkKTtcblx0bmVlZEF0dGFjaCAmJiBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XG59OyIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubm1kID0gKG1vZHVsZSkgPT4ge1xuXHRtb2R1bGUucGF0aHMgPSBbXTtcblx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRyZXR1cm4gbW9kdWxlO1xufTsiLCJ2YXIgc2NyaXB0VXJsO1xuaWYgKF9fd2VicGFja19yZXF1aXJlX18uZy5pbXBvcnRTY3JpcHRzKSBzY3JpcHRVcmwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmcubG9jYXRpb24gKyBcIlwiO1xudmFyIGRvY3VtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXy5nLmRvY3VtZW50O1xuaWYgKCFzY3JpcHRVcmwgJiYgZG9jdW1lbnQpIHtcblx0aWYgKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQpXG5cdFx0c2NyaXB0VXJsID0gZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmNcblx0aWYgKCFzY3JpcHRVcmwpIHtcblx0XHR2YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpO1xuXHRcdGlmKHNjcmlwdHMubGVuZ3RoKSBzY3JpcHRVcmwgPSBzY3JpcHRzW3NjcmlwdHMubGVuZ3RoIC0gMV0uc3JjXG5cdH1cbn1cbi8vIFdoZW4gc3VwcG9ydGluZyBicm93c2VycyB3aGVyZSBhbiBhdXRvbWF0aWMgcHVibGljUGF0aCBpcyBub3Qgc3VwcG9ydGVkIHlvdSBtdXN0IHNwZWNpZnkgYW4gb3V0cHV0LnB1YmxpY1BhdGggbWFudWFsbHkgdmlhIGNvbmZpZ3VyYXRpb25cbi8vIG9yIHBhc3MgYW4gZW1wdHkgc3RyaW5nIChcIlwiKSBhbmQgc2V0IHRoZSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyB2YXJpYWJsZSBmcm9tIHlvdXIgY29kZSB0byB1c2UgeW91ciBvd24gbG9naWMuXG5pZiAoIXNjcmlwdFVybCkgdGhyb3cgbmV3IEVycm9yKFwiQXV0b21hdGljIHB1YmxpY1BhdGggaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXJcIik7XG5zY3JpcHRVcmwgPSBzY3JpcHRVcmwucmVwbGFjZSgvIy4qJC8sIFwiXCIpLnJlcGxhY2UoL1xcPy4qJC8sIFwiXCIpLnJlcGxhY2UoL1xcL1teXFwvXSskLywgXCIvXCIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5wID0gc2NyaXB0VXJsOyIsIi8vIG5vIGJhc2VVUklcblxuLy8gb2JqZWN0IHRvIHN0b3JlIGxvYWRlZCBhbmQgbG9hZGluZyBjaHVua3Ncbi8vIHVuZGVmaW5lZCA9IGNodW5rIG5vdCBsb2FkZWQsIG51bGwgPSBjaHVuayBwcmVsb2FkZWQvcHJlZmV0Y2hlZFxuLy8gW3Jlc29sdmUsIHJlamVjdCwgUHJvbWlzZV0gPSBjaHVuayBsb2FkaW5nLCAwID0gY2h1bmsgbG9hZGVkXG52YXIgaW5zdGFsbGVkQ2h1bmtzID0ge1xuXHRcImJ1bmRsZVwiOiAwXG59O1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmYuaiA9IChjaHVua0lkLCBwcm9taXNlcykgPT4ge1xuXHRcdC8vIEpTT05QIGNodW5rIGxvYWRpbmcgZm9yIGphdmFzY3JpcHRcblx0XHR2YXIgaW5zdGFsbGVkQ2h1bmtEYXRhID0gX193ZWJwYWNrX3JlcXVpcmVfXy5vKGluc3RhbGxlZENodW5rcywgY2h1bmtJZCkgPyBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF0gOiB1bmRlZmluZWQ7XG5cdFx0aWYoaW5zdGFsbGVkQ2h1bmtEYXRhICE9PSAwKSB7IC8vIDAgbWVhbnMgXCJhbHJlYWR5IGluc3RhbGxlZFwiLlxuXG5cdFx0XHQvLyBhIFByb21pc2UgbWVhbnMgXCJjdXJyZW50bHkgbG9hZGluZ1wiLlxuXHRcdFx0aWYoaW5zdGFsbGVkQ2h1bmtEYXRhKSB7XG5cdFx0XHRcdHByb21pc2VzLnB1c2goaW5zdGFsbGVkQ2h1bmtEYXRhWzJdKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmKHRydWUpIHsgLy8gYWxsIGNodW5rcyBoYXZlIEpTXG5cdFx0XHRcdFx0Ly8gc2V0dXAgUHJvbWlzZSBpbiBjaHVuayBjYWNoZVxuXHRcdFx0XHRcdHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gKGluc3RhbGxlZENodW5rRGF0YSA9IGluc3RhbGxlZENodW5rc1tjaHVua0lkXSA9IFtyZXNvbHZlLCByZWplY3RdKSk7XG5cdFx0XHRcdFx0cHJvbWlzZXMucHVzaChpbnN0YWxsZWRDaHVua0RhdGFbMl0gPSBwcm9taXNlKTtcblxuXHRcdFx0XHRcdC8vIHN0YXJ0IGNodW5rIGxvYWRpbmdcblx0XHRcdFx0XHR2YXIgdXJsID0gX193ZWJwYWNrX3JlcXVpcmVfXy5wICsgX193ZWJwYWNrX3JlcXVpcmVfXy51KGNodW5rSWQpO1xuXHRcdFx0XHRcdC8vIGNyZWF0ZSBlcnJvciBiZWZvcmUgc3RhY2sgdW53b3VuZCB0byBnZXQgdXNlZnVsIHN0YWNrdHJhY2UgbGF0ZXJcblx0XHRcdFx0XHR2YXIgZXJyb3IgPSBuZXcgRXJyb3IoKTtcblx0XHRcdFx0XHR2YXIgbG9hZGluZ0VuZGVkID0gKGV2ZW50KSA9PiB7XG5cdFx0XHRcdFx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oaW5zdGFsbGVkQ2h1bmtzLCBjaHVua0lkKSkge1xuXHRcdFx0XHRcdFx0XHRpbnN0YWxsZWRDaHVua0RhdGEgPSBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF07XG5cdFx0XHRcdFx0XHRcdGlmKGluc3RhbGxlZENodW5rRGF0YSAhPT0gMCkgaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRpZihpbnN0YWxsZWRDaHVua0RhdGEpIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgZXJyb3JUeXBlID0gZXZlbnQgJiYgKGV2ZW50LnR5cGUgPT09ICdsb2FkJyA/ICdtaXNzaW5nJyA6IGV2ZW50LnR5cGUpO1xuXHRcdFx0XHRcdFx0XHRcdHZhciByZWFsU3JjID0gZXZlbnQgJiYgZXZlbnQudGFyZ2V0ICYmIGV2ZW50LnRhcmdldC5zcmM7XG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3IubWVzc2FnZSA9ICdMb2FkaW5nIGNodW5rICcgKyBjaHVua0lkICsgJyBmYWlsZWQuXFxuKCcgKyBlcnJvclR5cGUgKyAnOiAnICsgcmVhbFNyYyArICcpJztcblx0XHRcdFx0XHRcdFx0XHRlcnJvci5uYW1lID0gJ0NodW5rTG9hZEVycm9yJztcblx0XHRcdFx0XHRcdFx0XHRlcnJvci50eXBlID0gZXJyb3JUeXBlO1xuXHRcdFx0XHRcdFx0XHRcdGVycm9yLnJlcXVlc3QgPSByZWFsU3JjO1xuXHRcdFx0XHRcdFx0XHRcdGluc3RhbGxlZENodW5rRGF0YVsxXShlcnJvcik7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18ubCh1cmwsIGxvYWRpbmdFbmRlZCwgXCJjaHVuay1cIiArIGNodW5rSWQsIGNodW5rSWQpO1xuXHRcdFx0XHR9IGVsc2UgaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdID0gMDtcblx0XHRcdH1cblx0XHR9XG59O1xuXG4vLyBubyBwcmVmZXRjaGluZ1xuXG4vLyBubyBwcmVsb2FkZWRcblxuLy8gbm8gSE1SXG5cbi8vIG5vIEhNUiBtYW5pZmVzdFxuXG4vLyBubyBvbiBjaHVua3MgbG9hZGVkXG5cbi8vIGluc3RhbGwgYSBKU09OUCBjYWxsYmFjayBmb3IgY2h1bmsgbG9hZGluZ1xudmFyIHdlYnBhY2tKc29ucENhbGxiYWNrID0gKHBhcmVudENodW5rTG9hZGluZ0Z1bmN0aW9uLCBkYXRhKSA9PiB7XG5cdHZhciBbY2h1bmtJZHMsIG1vcmVNb2R1bGVzLCBydW50aW1lXSA9IGRhdGE7XG5cdC8vIGFkZCBcIm1vcmVNb2R1bGVzXCIgdG8gdGhlIG1vZHVsZXMgb2JqZWN0LFxuXHQvLyB0aGVuIGZsYWcgYWxsIFwiY2h1bmtJZHNcIiBhcyBsb2FkZWQgYW5kIGZpcmUgY2FsbGJhY2tcblx0dmFyIG1vZHVsZUlkLCBjaHVua0lkLCBpID0gMDtcblx0aWYoY2h1bmtJZHMuc29tZSgoaWQpID0+IChpbnN0YWxsZWRDaHVua3NbaWRdICE9PSAwKSkpIHtcblx0XHRmb3IobW9kdWxlSWQgaW4gbW9yZU1vZHVsZXMpIHtcblx0XHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhtb3JlTW9kdWxlcywgbW9kdWxlSWQpKSB7XG5cdFx0XHRcdF9fd2VicGFja19yZXF1aXJlX18ubVttb2R1bGVJZF0gPSBtb3JlTW9kdWxlc1ttb2R1bGVJZF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmKHJ1bnRpbWUpIHZhciByZXN1bHQgPSBydW50aW1lKF9fd2VicGFja19yZXF1aXJlX18pO1xuXHR9XG5cdGlmKHBhcmVudENodW5rTG9hZGluZ0Z1bmN0aW9uKSBwYXJlbnRDaHVua0xvYWRpbmdGdW5jdGlvbihkYXRhKTtcblx0Zm9yKDtpIDwgY2h1bmtJZHMubGVuZ3RoOyBpKyspIHtcblx0XHRjaHVua0lkID0gY2h1bmtJZHNbaV07XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGluc3RhbGxlZENodW5rcywgY2h1bmtJZCkgJiYgaW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdKSB7XG5cdFx0XHRpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF1bMF0oKTtcblx0XHR9XG5cdFx0aW5zdGFsbGVkQ2h1bmtzW2NodW5rSWRdID0gMDtcblx0fVxuXG59XG5cbnZhciBjaHVua0xvYWRpbmdHbG9iYWwgPSBzZWxmW1wid2VicGFja0NodW5rXCJdID0gc2VsZltcIndlYnBhY2tDaHVua1wiXSB8fCBbXTtcbmNodW5rTG9hZGluZ0dsb2JhbC5mb3JFYWNoKHdlYnBhY2tKc29ucENhbGxiYWNrLmJpbmQobnVsbCwgMCkpO1xuY2h1bmtMb2FkaW5nR2xvYmFsLnB1c2ggPSB3ZWJwYWNrSnNvbnBDYWxsYmFjay5iaW5kKG51bGwsIGNodW5rTG9hZGluZ0dsb2JhbC5wdXNoLmJpbmQoY2h1bmtMb2FkaW5nR2xvYmFsKSk7IiwiaW1wb3J0IGtvIGZyb20gJ2tub2Nrb3V0J1xuXG4vLyBzZWUgaHR0cHM6Ly9nZXRib290c3RyYXAuY29tL2RvY3MvNS4wL2dldHRpbmctc3RhcnRlZC93ZWJwYWNrL1xuaW1wb3J0ICdib290c3RyYXAvZGlzdC9jc3MvYm9vdHN0cmFwLm1pbi5jc3MnXG4vLyBZb3UgY2FuIHNwZWNpZnkgd2hpY2ggcGx1Z2lucyB5b3UgbmVlZFxuLy8gTm90ZSB0aGF0IGV2ZW4gdGhvdWdoIHRoZXNlIGRvbid0IHNlZW0gdG8gYmUgdXNlZCBkaXJlY3RseSxcbi8vIHRoZXkgYXJlIHVzZWQgYnkgdGhlIGFjY29yZGlhbi5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuaW1wb3J0IHsgVG9vbHRpcCwgVG9hc3QsIFBvcG92ZXIgfSBmcm9tICdib290c3RyYXAnXG5cbmltcG9ydCBNb3JzZVN0cmluZ1V0aWxzIGZyb20gJy4vbW9yc2VTdHJpbmdVdGlscy5qcydcbmltcG9ydCB7IE1vcnNlU3RyaW5nVG9XYXZCdWZmZXJDb25maWcgfSBmcm9tICcuL21vcnNlU3RyaW5nVG9XYXZCdWZmZXIuanMnXG5pbXBvcnQgeyBNb3JzZVdvcmRQbGF5ZXIgfSBmcm9tICcuL21vcnNlV29yZFBsYXllci5qcydcblxuLy8gTk9URTogbW92ZWQgdGhpcyB0byBkeW5hbWljIGltcG9ydCgpIHNvIHRoYXQgbm9uLVJTUyB1c2VycyBkb24ndCBuZWVkIHRvIGJvdGhlclxuLy8gZXZlbiBsb2FkaW5nIHRoaXMgY29kZSBpbnRvIHRoZSBicm93c2VyOlxuLy8gaW1wb3J0IFJTU1BhcnNlciBmcm9tICdyc3MtcGFyc2VyJztcblxuaW1wb3J0IENvb2tpZXMgZnJvbSAnanMtY29va2llJ1xuaW1wb3J0IE1vcnNlTGVzc29uUGx1Z2luIGZyb20gJy4vbW9yc2VMZXNzb25QbHVnaW4uanMnXG5pbXBvcnQgeyBNb3JzZUxvYWRJbWFnZXMgfSBmcm9tICcuL21vcnNlTG9hZEltYWdlcy5qcydcblxuY2xhc3MgTW9yc2VWaWV3TW9kZWwge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5tb3JzZUxvYWRJbWFnZXMobmV3IE1vcnNlTG9hZEltYWdlcygpKVxuXG4gICAgLy8gY3JlYXRlIHRoZSBoZWxwZXIgZXh0ZW5kZXJzXG4gICAga28uZXh0ZW5kZXJzLnNhdmVDb29raWUgPSAodGFyZ2V0LCBvcHRpb24pID0+IHtcbiAgICAgIHRhcmdldC5zdWJzY3JpYmUoKG5ld1ZhbHVlKSA9PiB7XG4gICAgICAgIENvb2tpZXMuc2V0KG9wdGlvbiwgbmV3VmFsdWUsIHsgZXhwaXJlczogMzY1IH0pXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHRhcmdldFxuICAgIH1cblxuICAgIGtvLmV4dGVuZGVycy5zaG93aW5nQ2hhbmdlID0gKHRhcmdldCwgb3B0aW9uKSA9PiB7XG4gICAgICB0YXJnZXQuc3Vic2NyaWJlKChuZXdWYWx1ZSkgPT4ge1xuICAgICAgICBpZiAodGhpcy5zaG93UmF3KCkpIHtcbiAgICAgICAgICB0aGlzLnJhd1RleHQobmV3VmFsdWUpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICByZXR1cm4gdGFyZ2V0XG4gICAgfVxuICAgIGtvLmV4dGVuZGVycy5zaG93UmF3Q2hhbmdlID0gKHRhcmdldCwgb3B0aW9uKSA9PiB7XG4gICAgICB0YXJnZXQuc3Vic2NyaWJlKChuZXdWYWx1ZSkgPT4ge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhvcHRpb24gKyBcIjogXCIgKyBuZXdWYWx1ZSk7XG4gICAgICAgIGlmIChuZXdWYWx1ZSkge1xuICAgICAgICAgIHRoaXMuc2hvd2luZ1RleHQodGhpcy5yYXdUZXh0KCkpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zaG93aW5nVGV4dCgnJylcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIHJldHVybiB0YXJnZXRcbiAgICB9XG5cbiAgICBrby5leHRlbmRlcnMuc2V0Vm9sdW1lID0gKHRhcmdldCwgb3B0aW9uKSA9PiB7XG4gICAgICB0YXJnZXQuc3Vic2NyaWJlKChuZXdWYWx1ZSkgPT4ge1xuICAgICAgICB0aGlzLm1vcnNlV29yZFBsYXllci5zZXRWb2x1bWUobmV3VmFsdWUpXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHRhcmdldFxuICAgIH1cblxuICAgIGtvLmV4dGVuZGVycy5zZXROb2lzZVZvbHVtZSA9ICh0YXJnZXQsIG9wdGlvbikgPT4ge1xuICAgICAgdGFyZ2V0LnN1YnNjcmliZSgobmV3VmFsdWUpID0+IHtcbiAgICAgICAgdGhpcy5tb3JzZVdvcmRQbGF5ZXIuc2V0Tm9pc2VWb2x1bWUobmV3VmFsdWUpXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHRhcmdldFxuICAgIH1cblxuICAgIGtvLmV4dGVuZGVycy5zZXROb2lzZVR5cGUgPSAodGFyZ2V0LCBvcHRpb24pID0+IHtcbiAgICAgIHRhcmdldC5zdWJzY3JpYmUoKG5ld1ZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuZ2V0TW9yc2VTdHJpbmdUb1dhdkJ1ZmZlckNvbmZpZygnJylcbiAgICAgICAgY29uZmlnLm5vaXNlLnR5cGUgPSB0aGlzLm5vaXNlRW5hYmxlZCgpID8gbmV3VmFsdWUgOiAnb2ZmJ1xuICAgICAgICB0aGlzLm1vcnNlV29yZFBsYXllci5zZXROb2lzZVR5cGUoY29uZmlnKVxuICAgICAgfSlcbiAgICAgIHJldHVybiB0YXJnZXRcbiAgICB9XG5cbiAgICAvLyBhcHBseSBleHRlbmRlcnNcbiAgICB0aGlzLndwbS5leHRlbmQoeyBzYXZlQ29va2llOiAnd3BtJyB9KVxuICAgIHRoaXMuZndwbS5leHRlbmQoeyBzYXZlQ29va2llOiAnZndwbScgfSlcbiAgICB0aGlzLmRpdEZyZXF1ZW5jeS5leHRlbmQoeyBzYXZlQ29va2llOiAnZGl0RnJlcXVlbmN5JyB9KVxuICAgIHRoaXMuZGFoRnJlcXVlbmN5LmV4dGVuZCh7IHNhdmVDb29raWU6ICdkYWhGcmVxdWVuY3knIH0pXG4gICAgdGhpcy5oaWRlTGlzdC5leHRlbmQoeyBzYXZlQ29va2llOiAnaGlkZUxpc3QnIH0pXG4gICAgdGhpcy5zaG93aW5nVGV4dC5leHRlbmQoeyBzaG93aW5nQ2hhbmdlOiAnc2hvd2luZ0NoYW5nZScgfSlcbiAgICB0aGlzLnNob3dSYXcuZXh0ZW5kKHsgc2hvd1Jhd0NoYW5nZTogJ3Nob3dSYXdDaGFuZ2UnIH0pXG4gICAgdGhpcy5wcmVTcGFjZS5leHRlbmQoeyBzYXZlQ29va2llOiAncHJlU3BhY2UnIH0pXG4gICAgdGhpcy54dHJhV29yZFNwYWNlRGl0cy5leHRlbmQoeyBzYXZlQ29va2llOiAneHRyYVdvcmRTcGFjZURpdHMnIH0pXG4gICAgdGhpcy52b2x1bWUuZXh0ZW5kKHsgc2F2ZUNvb2tpZTogJ3ZvbHVtZScgfSkuZXh0ZW5kKHsgc2V0Vm9sdW1lOiAndm9sdW1lJyB9KVxuICAgIHRoaXMubm9pc2VWb2x1bWUuZXh0ZW5kKHsgc2F2ZUNvb2tpZTogJ25vaXNlVm9sdW1lJyB9KS5leHRlbmQoeyBzZXROb2lzZVZvbHVtZTogJ25vaXNlVm9sdW1lJyB9KVxuICAgIHRoaXMubm9pc2VUeXBlLmV4dGVuZCh7IHNhdmVDb29raWU6ICdub2lzZVR5cGUnIH0pLmV4dGVuZCh7IHNldE5vaXNlVHlwZTogJ25vaXNlVHlwZScgfSlcbiAgICB0aGlzLnN5bmNXcG0uZXh0ZW5kKHsgc2F2ZUNvb2tpZTogJ3N5bmNXcG0nIH0pXG4gICAgdGhpcy5zeW5jRnJlcS5leHRlbmQoeyBzYXZlQ29va2llOiAnc3luY0ZyZXEnIH0pXG5cbiAgICAvLyBpbml0aWFsaXplIHRoZSBtYWluIHJhd1RleHRcbiAgICB0aGlzLnJhd1RleHQodGhpcy5zaG93aW5nVGV4dCgpKVxuXG4gICAgTW9yc2VMZXNzb25QbHVnaW4uYWRkTGVzc29uRmVhdHVyZXMoa28sIHRoaXMpXG5cbiAgICAvLyBjaGVjayBmb3IgUlNTIGZlYXR1cmUgdHVybmVkIG9uXG4gICAgaWYgKHRoaXMuZ2V0UGFyYW1ldGVyQnlOYW1lKCdyc3NFbmFibGVkJykpIHtcbiAgICAgIGltcG9ydCgnLi9tb3JzZVJzc1BsdWdpbi5qcycpLnRoZW4oKHsgZGVmYXVsdDogTW9yc2VSc3NQbHVnaW4gfSkgPT4ge1xuICAgICAgICBNb3JzZVJzc1BsdWdpbi5hZGRSc3NGZWF0dXJlcyhrbywgdGhpcylcbiAgICAgICAgLy8gZG9uJ3Qgc2V0IHRoaXMgdW50aWwgdGhlIHBsdWdpbiBoYXMgaW5pdGlhbGl6ZWQgYWJvdmVcbiAgICAgICAgdGhpcy5yc3NFbmFibGVkKHRydWUpXG4gICAgICAgIC8vIHBvc3NpYmx5IHJzcy1yZWxhdGVkIGNvb2tpZXMgbWlzc2VkXG4gICAgICAgIC8vIFRPRE8gcHJvYmFibHkgaW4gZ2VuZXJhbCAncGx1Z2lucycgc2hvdWxkIGJlIHNvbWUgc29ydCBvZiBwcm9taXNlIGJhc2VkXG4gICAgICAgIC8vIGFuZCBsb2FkIGNvb2tpZXMgYWZ0ZXIgYWxsIHBsdWdpbnMgYnV0IGZvciBub3cganVzdCBkbyB0aGlzLi4uLlxuICAgICAgICB0aGlzLmxvYWRDb29raWVzKClcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgLy8gY2hlY2sgZm9yIG5vaXNlIGZlYXR1cmUgdHVybmVkIG9uXG4gICAgaWYgKHRoaXMuZ2V0UGFyYW1ldGVyQnlOYW1lKCdub2lzZUVuYWJsZWQnKSkge1xuICAgICAgdGhpcy5ub2lzZUVuYWJsZWQodHJ1ZSlcbiAgICB9XG5cbiAgICB0aGlzLmxvYWRDb29raWVzKClcblxuICAgIC8vIGluaXRpYWxpemUgdGhlIHdvcmRsaXN0XG4gICAgdGhpcy5pbml0aWFsaXplV29yZExpc3QoKVxuICB9XG5cbiAgIHRleHRCdWZmZXIgPSBrby5vYnNlcnZhYmxlKCcnKVxuICAgdHJ1ZVdwbSA9IGtvLm9ic2VydmFibGUoMjApXG4gICB0cnVlRndwbSA9IGtvLm9ic2VydmFibGUoMjApXG4gICBzeW5jV3BtID0ga28ub2JzZXJ2YWJsZSh0cnVlKVxuXG4gICB3cG0gPSBrby5wdXJlQ29tcHV0ZWQoe1xuICAgICByZWFkOiAoKSA9PiB7XG4gICAgICAgcmV0dXJuIHRoaXMudHJ1ZVdwbSgpXG4gICAgIH0sXG4gICAgIHdyaXRlOiAodmFsdWUpID0+IHtcbiAgICAgICB0aGlzLnRydWVXcG0odmFsdWUpXG4gICAgICAgaWYgKHRoaXMuc3luY1dwbSgpIHx8IHBhcnNlSW50KHZhbHVlKSA8IHBhcnNlSW50KHRoaXMudHJ1ZUZ3cG0oKSkpIHtcbiAgICAgICAgIHRoaXMudHJ1ZUZ3cG0odmFsdWUpXG4gICAgICAgfVxuICAgICB9LFxuICAgICBvd25lcjogdGhpc1xuICAgfSlcblxuICAgZndwbSA9IGtvLnB1cmVDb21wdXRlZCh7XG4gICAgIHJlYWQ6ICgpID0+IHtcbiAgICAgICBpZiAoIXRoaXMuc3luY1dwbSgpKSB7XG4gICAgICAgICBpZiAocGFyc2VJbnQodGhpcy50cnVlRndwbSgpKSA8PSBwYXJzZUludCh0aGlzLnRydWVXcG0oKSkpIHtcbiAgICAgICAgICAgcmV0dXJuIHRoaXMudHJ1ZUZ3cG0oKVxuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgcmV0dXJuIHRoaXMudHJ1ZVdwbSgpXG4gICAgICAgICB9XG4gICAgICAgfSBlbHNlIHtcbiAgICAgICAgIHRoaXMudHJ1ZUZ3cG0odGhpcy50cnVlV3BtKCkpXG4gICAgICAgICByZXR1cm4gdGhpcy50cnVlRndwbSgpXG4gICAgICAgfVxuICAgICB9LFxuICAgICB3cml0ZTogKHZhbHVlKSA9PiB7XG4gICAgICAgaWYgKHBhcnNlSW50KHZhbHVlKSA8PSBwYXJzZUludCh0aGlzLnRydWVXcG0oKSkpIHtcbiAgICAgICAgIHRoaXMudHJ1ZUZ3cG0odmFsdWUpXG4gICAgICAgfVxuICAgICB9LFxuICAgICBvd25lcjogdGhpc1xuICAgfSlcblxuICAgdHJ1ZERpdEZyZXF1ZW5jeSA9IGtvLm9ic2VydmFibGUoNTUwKVxuICAgdHJ1RGFoRnJlcXVlbmN5ID0ga28ub2JzZXJ2YWJsZSg1NTApXG4gICBzeW5jRnJlcSA9IGtvLm9ic2VydmFibGUodHJ1ZSlcbiAgIGRpdEZyZXF1ZW5jeSA9IGtvLnB1cmVDb21wdXRlZCh7XG4gICAgIHJlYWQ6ICgpID0+IHtcbiAgICAgICByZXR1cm4gdGhpcy50cnVkRGl0RnJlcXVlbmN5KClcbiAgICAgfSxcbiAgICAgd3JpdGU6ICh2YWx1ZSkgPT4ge1xuICAgICAgIHRoaXMudHJ1ZERpdEZyZXF1ZW5jeSh2YWx1ZSlcbiAgICAgICBpZiAodGhpcy5zeW5jRnJlcSgpKSB7XG4gICAgICAgICB0aGlzLnRydURhaEZyZXF1ZW5jeSh2YWx1ZSlcbiAgICAgICB9XG4gICAgIH0sXG4gICAgIG93bmVyOiB0aGlzXG4gICB9KVxuXG4gICBkYWhGcmVxdWVuY3kgPSBrby5wdXJlQ29tcHV0ZWQoe1xuICAgICByZWFkOiAoKSA9PiB7XG4gICAgICAgaWYgKCF0aGlzLnN5bmNGcmVxKCkpIHtcbiAgICAgICAgIHJldHVybiB0aGlzLnRydURhaEZyZXF1ZW5jeSgpXG4gICAgICAgfSBlbHNlIHtcbiAgICAgICAgIHRoaXMudHJ1RGFoRnJlcXVlbmN5KHRoaXMudHJ1ZERpdEZyZXF1ZW5jeSgpKVxuICAgICAgICAgcmV0dXJuIHRoaXMudHJ1ZERpdEZyZXF1ZW5jeSgpXG4gICAgICAgfVxuICAgICB9LFxuICAgICB3cml0ZTogKHZhbHVlKSA9PiB7XG4gICAgICAgdGhpcy50cnVEYWhGcmVxdWVuY3kodmFsdWUpXG4gICAgIH0sXG4gICAgIG93bmVyOiB0aGlzXG4gICB9KVxuXG4gICBoaWRlTGlzdCA9IGtvLm9ic2VydmFibGUodHJ1ZSlcbiAgIGN1cnJlbnRTZW50YW5jZUluZGV4ID0ga28ub2JzZXJ2YWJsZSgwKVxuICAgY3VycmVudEluZGV4ID0ga28ub2JzZXJ2YWJsZSgwKVxuICAgcGxheWVyUGxheWluZyA9IGtvLm9ic2VydmFibGUoZmFsc2UpXG4gICBsYXN0RnVsbFBsYXlUaW1lID0ga28ub2JzZXJ2YWJsZShuZXcgRGF0ZSgxOTAwLCAwLCAwKSlcbiAgIHByZVNwYWNlID0ga28ub2JzZXJ2YWJsZSgwKVxuICAgcHJlU3BhY2VVc2VkID0ga28ub2JzZXJ2YWJsZShmYWxzZSlcbiAgIHh0cmFXb3JkU3BhY2VEaXRzID0ga28ub2JzZXJ2YWJsZSgwKVxuICAgZmxhZ2dlZFdvcmRzID0ga28ub2JzZXJ2YWJsZSgnJylcbiAgIGlzU2h1ZmZsZWQgPSBrby5vYnNlcnZhYmxlKGZhbHNlKVxuICAgdHJhaWxSZXZlYWwgPSBrby5vYnNlcnZhYmxlKGZhbHNlKVxuICAgcHJlU2h1ZmZsZWQgPSAnJ1xuICAgd29yZExpc3RzID0ga28ub2JzZXJ2YWJsZUFycmF5KClcbiAgIG1vcnNlV29yZFBsYXllciA9IG5ldyBNb3JzZVdvcmRQbGF5ZXIoKVxuICAgcmF3VGV4dCA9IGtvLm9ic2VydmFibGUoKVxuICAgc2hvd2luZ1RleHQgPSBrby5vYnNlcnZhYmxlKCdoZWxsbyB3b3JsZCcpXG4gICBzaG93UmF3ID0ga28ub2JzZXJ2YWJsZSh0cnVlKVxuICAgcnNzRW5hYmxlZCA9IGtvLm9ic2VydmFibGUoZmFsc2UpXG4gICB2b2x1bWUgPSBrby5vYnNlcnZhYmxlKDEwKVxuICAgbm9pc2VFbmFibGVkID0ga28ub2JzZXJ2YWJsZShmYWxzZSlcbiAgIG5vaXNlVm9sdW1lID0ga28ub2JzZXJ2YWJsZSgyKVxuICAgbm9pc2VUeXBlID0ga28ub2JzZXJ2YWJsZSgnb2ZmJylcbiAgIHVzZXJUYXJnZXQgPSBrby5vYnNlcnZhYmxlKCcnKVxuICAgc2VsZWN0ZWRDbGFzcyA9IGtvLm9ic2VydmFibGUoJycpXG4gICB1c2VyVGFyZ2V0SW5pdGlhbGl6ZWQgPSBmYWxzZVxuICAgc2VsZWN0ZWRDbGFzc0luaXRpYWxpemVkID0gZmFsc2VcbiAgIGxldHRlckdyb3VwSW5pdGlhbGl6ZWQgPSBmYWxzZVxuICAgZGlzcGxheXNJbml0aWFsaXplZCA9IGZhbHNlXG4gICBsZXR0ZXJHcm91cCA9IGtvLm9ic2VydmFibGUoJycpXG4gICBzZWxlY3RlZERpc3BsYXkgPSBrby5vYnNlcnZhYmxlKHt9KVxuICAgbGFzdFBsYXlGdWxsU3RhcnQgPSBudWxsO1xuICAgcmFuZG9taXplTGVzc29ucyA9IGtvLm9ic2VydmFibGUodHJ1ZSlcbiAgIGlmT3ZlcnJpZGVUaW1lID0ga28ub2JzZXJ2YWJsZShmYWxzZSlcbiAgIG92ZXJyaWRlTWlucyA9IGtvLm9ic2VydmFibGUoMilcbiAgIGN1c3RvbUdyb3VwID0ga28ub2JzZXJ2YWJsZSgnJylcbiAgIGlmT3ZlcnJpZGVNaW5NYXggPSBrby5vYnNlcnZhYmxlKGZhbHNlKVxuICAgdHJ1ZU92ZXJyaWRlTWluID0ga28ub2JzZXJ2YWJsZSgzKVxuICAgb3ZlcnJpZGVNaW4gPSBrby5wdXJlQ29tcHV0ZWQoe1xuICAgICByZWFkOiAoKSA9PiB7XG4gICAgICAgcmV0dXJuIHRoaXMudHJ1ZU92ZXJyaWRlTWluKClcbiAgICAgfSxcbiAgICAgd3JpdGU6ICh2YWx1ZSkgPT4ge1xuICAgICAgIHRoaXMudHJ1ZU92ZXJyaWRlTWluKHZhbHVlKVxuICAgICAgIGlmICh0aGlzLnN5bmNTaXplKCkpIHtcbiAgICAgICAgIHRoaXMudHJ1ZU92ZXJyaWRlTWF4KHZhbHVlKVxuICAgICAgIH1cbiAgICAgfSxcbiAgICAgb3duZXI6IHRoaXNcbiAgIH0pXG5cbiAgIHRydWVPdmVycmlkZU1heCA9IGtvLm9ic2VydmFibGUoMylcbiAgIG92ZXJyaWRlTWF4ID0ga28ucHVyZUNvbXB1dGVkKHtcbiAgICAgcmVhZDogKCkgPT4ge1xuICAgICAgIGlmICghdGhpcy5zeW5jU2l6ZSgpKSB7XG4gICAgICAgICByZXR1cm4gdGhpcy50cnVlT3ZlcnJpZGVNYXgoKVxuICAgICAgIH0gZWxzZSB7XG4gICAgICAgICB0aGlzLnRydWVPdmVycmlkZU1heCh0aGlzLnRydWVPdmVycmlkZU1pbigpKVxuICAgICAgICAgcmV0dXJuIHRoaXMudHJ1ZU92ZXJyaWRlTWluKClcbiAgICAgICB9XG4gICAgIH0sXG4gICAgIHdyaXRlOiAodmFsdWUpID0+IHtcbiAgICAgICBpZiAodmFsdWUgPj0gdGhpcy50cnVlT3ZlcnJpZGVNaW4oKSkge1xuICAgICAgICAgdGhpcy50cnVlT3ZlcnJpZGVNYXgodmFsdWUpXG4gICAgICAgfVxuICAgICB9LFxuICAgICBvd25lcjogdGhpc1xuICAgfSlcblxuICAgaWZQYXJzZVNlbnRlbmNlcyA9IGtvLm9ic2VydmFibGUoZmFsc2UpXG4gICBpZlN0aWNreVNldHMgPSBrby5vYnNlcnZhYmxlKHRydWUpXG4gICBzdGlja3lTZXRzID0ga28ub2JzZXJ2YWJsZSgnQksnKVxuICAgcnVubmluZ1BsYXlNcyA9IGtvLm9ic2VydmFibGUoMClcbiAgIGxhc3RQYXJ0aWFsUGxheVN0YXJ0ID0ga28ub2JzZXJ2YWJsZSgpXG4gICBpc1BhdXNlZD1rby5vYnNlcnZhYmxlKGZhbHNlKVxuICAgc3luY1NpemU9a28ub2JzZXJ2YWJsZSh0cnVlKVxuICAgbW9yc2VMb2FkSW1hZ2VzID1rby5vYnNlcnZhYmxlKClcblxuICAgLy8gaGVscGVyXG4gICBsb2FkQ29va2llcyA9ICgpID0+IHtcbiAgICAgLy8gbG9hZCBhbnkgZXhpc3RpbmcgY29va2llIHZhbHVlc1xuXG4gICAgIC8vIGhlbHBlclxuICAgICBjb25zdCBib29sZWFuaXplID0gKHgpID0+IHtcbiAgICAgICBpZiAoeCA9PT0gJ3RydWUgJyB8fCB4ID09PSAnZmFsc2UnKSB7XG4gICAgICAgICByZXR1cm4geCA9PT0gdHJ1ZVxuICAgICAgIH0gZWxzZSB7XG4gICAgICAgICByZXR1cm4geFxuICAgICAgIH1cbiAgICAgfVxuXG4gICAgIGNvbnN0IGNrcyA9IENvb2tpZXMuZ2V0KClcbiAgICAgaWYgKGNrcykge1xuICAgICAgIGNvbnN0IHNwZWNpYWxIYW5kbGluZyA9IFtdXG4gICAgICAgZm9yIChjb25zdCBrZXkgaW4gY2tzKSB7XG4gICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICBjYXNlICdzeW5jV3BtJzpcbiAgICAgICAgICAgY2FzZSAnd3BtJzpcbiAgICAgICAgICAgY2FzZSAnZndwbSc6XG4gICAgICAgICAgIGNhc2UgJ3N5bmNGcmVxJzpcbiAgICAgICAgICAgY2FzZSAnZGl0RnJlcXVlbmN5JzpcbiAgICAgICAgICAgY2FzZSAnZGFoRnJlcXVlbmN5JzpcbiAgICAgICAgICAgICBzcGVjaWFsSGFuZGxpbmcucHVzaCh7IGtleSwgdmFsOiBib29sZWFuaXplKGNrc1trZXldKSB9KVxuICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzW2tleV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICB0aGlzW2tleV0oY2tzW2tleV0pXG4gICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgICBsZXQgdGFyZ2V0ID0gc3BlY2lhbEhhbmRsaW5nLmZpbmQoeCA9PiB4LmtleSA9PT0gJ3N5bmNXcG0nKVxuICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgIHRoaXNbdGFyZ2V0LmtleV0odGFyZ2V0LnZhbClcbiAgICAgICB9XG4gICAgICAgdGFyZ2V0ID0gc3BlY2lhbEhhbmRsaW5nLmZpbmQoeCA9PiB4LmtleSA9PT0gJ3N5bmNGcmVxJylcbiAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICB0aGlzW3RhcmdldC5rZXldKHRhcmdldC52YWwpXG4gICAgICAgfVxuICAgICAgIHNwZWNpYWxIYW5kbGluZy5mb3JFYWNoKCh4KSA9PiB7XG4gICAgICAgICB0aGlzW3gua2V5XSh4LnZhbClcbiAgICAgICB9KVxuICAgICB9XG4gICB9XG5cbiAgIC8vIGhlbHBlclxuICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTAxMTE1L2hvdy1jYW4taS1nZXQtcXVlcnktc3RyaW5nLXZhbHVlcy1pbi1qYXZhc2NyaXB0XG4gICBnZXRQYXJhbWV0ZXJCeU5hbWUgPSAobmFtZSwgdXJsID0gd2luZG93LmxvY2F0aW9uLmhyZWYpID0+IHtcbiAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG4gICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoL1tcXFtcXF1dL2csICdcXFxcJCYnKVxuICAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoJ1s/Jl0nICsgbmFtZSArICcoPShbXiYjXSopfCZ8I3wkKScpXG4gICAgIGNvbnN0IHJlc3VsdHMgPSByZWdleC5leGVjKHVybClcbiAgICAgaWYgKCFyZXN1bHRzKSByZXR1cm4gbnVsbFxuICAgICBpZiAoIXJlc3VsdHNbMl0pIHJldHVybiAnJ1xuICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHJlc3VsdHNbMl0ucmVwbGFjZSgvXFwrL2csICcgJykpXG4gICB9XG5cbiAgIGNoYW5nZVNlbnRhbmNlID0gKCkgPT4ge1xuICAgICB0aGlzLmN1cnJlbnRJbmRleCgwKVxuICAgfVxuXG4gICBzZXRUZXh0ID0gKHMpID0+IHtcbiAgICAgaWYgKHRoaXMuc2hvd1JhdygpKSB7XG4gICAgICAgdGhpcy5zaG93aW5nVGV4dChzKVxuICAgICB9IGVsc2Uge1xuICAgICAgIHRoaXMucmF3VGV4dChzKVxuICAgICB9XG4gICB9XG5cbiAgIHNlbnRlbmNlcyA9IGtvLmNvbXB1dGVkKCgpID0+IHtcbiAgICAgaWYgKCF0aGlzLnJhd1RleHQoKSkge1xuICAgICAgIHJldHVybiBbXVxuICAgICB9XG5cbiAgICAgcmV0dXJuIE1vcnNlU3RyaW5nVXRpbHMuZ2V0U2VudGVuY2VzKHRoaXMucmF3VGV4dCgpLCAhdGhpcy5pZlBhcnNlU2VudGVuY2VzKCkpXG4gICB9LCB0aGlzKVxuXG4gICBzZW50ZW5jZU1heCA9IGtvLmNvbXB1dGVkKCgpID0+IHtcbiAgICAgcmV0dXJuIHRoaXMuc2VudGVuY2VzKCkubGVuZ3RoIC0gMVxuICAgfSwgdGhpcylcblxuICAgd29yZHMgPSBrby5jb21wdXRlZCgoKSA9PiB7XG4gICAgIHJldHVybiB0aGlzLnNlbnRlbmNlcygpW3RoaXMuY3VycmVudFNlbnRhbmNlSW5kZXgoKV1cbiAgIH0sIHRoaXMpXG5cbiAgIGZsYWdnZWRXb3Jkc0NvdW50ID0ga28uY29tcHV0ZWQoKCkgPT4ge1xuICAgICBpZiAoIXRoaXMuZmxhZ2dlZFdvcmRzKCkudHJpbSgpKSB7XG4gICAgICAgcmV0dXJuIDBcbiAgICAgfVxuICAgICByZXR1cm4gdGhpcy5mbGFnZ2VkV29yZHMoKS50cmltKCkuc3BsaXQoJyAnKS5sZW5ndGhcbiAgIH0sIHRoaXMpXG5cbiAgIHNodWZmbGVXb3JkcyA9ICgpID0+IHtcbiAgICAgaWYgKCF0aGlzLmlzU2h1ZmZsZWQoKSkge1xuICAgICAgIHRoaXMucHJlU2h1ZmZsZWQgPSB0aGlzLnJhd1RleHQoKVxuICAgICAgIHRoaXMuc2V0VGV4dCh0aGlzLnJhd1RleHQoKS5zcGxpdCgnICcpLnNvcnQoKCkgPT4geyByZXR1cm4gMC41IC0gTWF0aC5yYW5kb20oKSB9KS5qb2luKCcgJykpXG4gICAgIH0gZWxzZSB7XG4gICAgICAgdGhpcy5zZXRUZXh0KHRoaXMucHJlU2h1ZmZsZWQpXG4gICAgIH1cbiAgICAgdGhpcy5pc1NodWZmbGVkKCF0aGlzLmlzU2h1ZmZsZWQoKSlcbiAgIH1cblxuICAgaW5jcmVtZW50SW5kZXggPSAoKSA9PiB7XG4gICAgIGlmICh0aGlzLmN1cnJlbnRJbmRleCgpIDwgdGhpcy53b3JkcygpLmxlbmd0aCAtIDEpIHtcbiAgICAgICB0aGlzLmN1cnJlbnRJbmRleCh0aGlzLmN1cnJlbnRJbmRleCgpICsgMSlcbiAgICAgfSBlbHNlIHtcbiAgICAgICAvLyBtb3ZlIHRvIG5leHQgc2VudGVuY2VcbiAgICAgICBpZiAodGhpcy5jdXJyZW50U2VudGFuY2VJbmRleCgpIDwgdGhpcy5zZW50ZW5jZU1heCgpKSB7XG4gICAgICAgICB0aGlzLmN1cnJlbnRTZW50YW5jZUluZGV4KE51bWJlcih0aGlzLmN1cnJlbnRTZW50YW5jZUluZGV4KCkpICsgMSlcbiAgICAgICAgIHRoaXMuY3VycmVudEluZGV4KDApXG4gICAgICAgfVxuICAgICB9XG4gICB9XG5cbiAgZGVjcmVtZW50SW5kZXggPSAoKSA9PiB7XG4gICAgdGhpcy5tb3JzZVdvcmRQbGF5ZXIucGF1c2UoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuY3VycmVudEluZGV4KCkgPiAwICYmIHRoaXMud29yZHMoKS5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRoaXMuY3VycmVudEluZGV4KHRoaXMuY3VycmVudEluZGV4KCkgLSAxKVxuICAgICAgICAvLyBleHBlcmllbmNlIHNob3dzIGl0IGlzIGdvb2QgdG8gcHV0IGEgbGl0dGxlIHBhdXNlIGhlcmVcbiAgICAgICAgLy8gc28gdGhleSBkb250JyBibHVyIHRvZ2V0aGVyXG4gICAgICAgIHNldFRpbWVvdXQodGhpcy5kb1BsYXksIDEwMDApXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGZ1bGxSZXdpbmQgPSAoKSA9PiB7XG4gICAgLy8gaWYgKHRoaXMuc2VudGVuY2VNYXgoKT4wKSB7XG4gICAgdGhpcy5jdXJyZW50U2VudGFuY2VJbmRleCgwKVxuICAgIHRoaXMuY3VycmVudEluZGV4KDApXG4gICAgLy8gfVxuICB9XG5cbiAgc2VudGFuY2VSZXdpbmQgPSAoKSA9PiB7XG4gICAgLy8gaWYgKHRoaXMuc2VudGVuY2VNYXgoKT4wKSB7XG4gICAgLy8gc2VsZi5jdXJyZW50U2VudGFuY2VJbmRleCgwKTtcbiAgICB0aGlzLmN1cnJlbnRJbmRleCgwKVxuICAgIC8vIH1cbiAgfVxuXG4gIHNldFdvcmRJbmRleCA9IChpbmRleCkgPT4ge1xuICAgIGlmICghdGhpcy5wbGF5ZXJQbGF5aW5nKCkpIHtcbiAgICAgIHRoaXMuY3VycmVudEluZGV4KGluZGV4KVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRvUGF1c2UoZmFsc2UsIGZhbHNlKVxuICAgICAgdGhpcy5jdXJyZW50SW5kZXgoaW5kZXgpXG4gICAgICB0aGlzLmRvUGxheShmYWxzZSwgZmFsc2UpXG4gICAgfVxuICB9XG5cbiAgYWRkRmxhZ2dlZFdvcmQgPSAod29yZCkgPT4ge1xuICAgIGlmICghdGhpcy5mbGFnZ2VkV29yZHMoKS50cmltKCkpIHtcbiAgICAgIHRoaXMuZmxhZ2dlZFdvcmRzKHRoaXMuZmxhZ2dlZFdvcmRzKCkudHJpbSgpICsgd29yZClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZGVhbCB3aXRoIGRvdWJsZSBjbGljayB3aGljaCBpcyBhbHNvIHVzZWQgdG8gcGljayBhIHdvcmRcbiAgICAgIGNvbnN0IHdvcmRzID0gdGhpcy5mbGFnZ2VkV29yZHMoKS50cmltKCkuc3BsaXQoJyAnKVxuICAgICAgY29uc3QgbGFzdFdvcmQgPSB3b3Jkc1t3b3Jkcy5sZW5ndGggLSAxXVxuICAgICAgaWYgKGxhc3RXb3JkID09PSB3b3JkKSB7XG4gICAgICAgIC8vIHdlIGhhdmUgZWl0aGVyIGEgZG91YmxlIGNsaWNrIHNjZW5hcmlvLCBvciBvdGhlcndpc2UgdXNlclxuICAgICAgICAvLyBzZWxlY3RlZCB3b3JkIHR3aWNlIHNvIGVpdGhlciB3YXkgYXNzdW1lIHJlbW92YWxcbiAgICAgICAgd29yZHMucG9wKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdvcmRzLnB1c2god29yZClcbiAgICAgIH1cbiAgICAgIGlmICh3b3Jkcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5mbGFnZ2VkV29yZHMoJycpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmZsYWdnZWRXb3Jkcyh3b3Jkcy5qb2luKCcgJykpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc2V0RmxhZ2dlZCA9ICgpID0+IHtcbiAgICB0aGlzLnNldFRleHQodGhpcy5mbGFnZ2VkV29yZHMoKSlcbiAgICB0aGlzLmZ1bGxSZXdpbmQoKVxuICB9XG5cbiAgZG9DdXN0b21Hcm91cCA9ICgpID0+IHtcbiAgICBpZiAodGhpcy5jdXN0b21Hcm91cCgpKSB7XG4gICAgICBjb25zdCBkYXRhID0geyBsZXR0ZXJzOiB0aGlzLmN1c3RvbUdyb3VwKCkudHJpbSgpLnJlcGxhY2UoLyAvZywgJycpIH1cbiAgICAgIHRoaXMucmFuZG9tV29yZExpc3QoZGF0YSwgdHJ1ZSlcbiAgICB9XG4gIH1cblxuICByYW5kb21Xb3JkTGlzdCA9IChkYXRhLCBpZkN1c3RvbSkgPT4ge1xuICAgIGxldCBzdHIgPSAnJ1xuICAgIGNvbnN0IHNwbGl0V2l0aFByb3NpZ25zQW5kU3RjaWt5cyA9IChzKSA9PiB7XG4gICAgICBsZXQgc3RpY2t5cyA9ICcnXG4gICAgICBpZiAodGhpcy5pZlN0aWNreVNldHMoKSAmJiB0aGlzLnN0aWNreVNldHMoKS50cmltKCkpIHtcbiAgICAgICAgc3RpY2t5cyA9ICd8JyArIHRoaXMuc3RpY2t5U2V0cygpLnRvVXBwZXJDYXNlKCkudHJpbSgpLnJlcGxhY2UoLyB7Mn0vZywgJyAnKS5yZXBsYWNlKC8gL2csICd8JylcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVnU3RyID0gYDwuKj8+JHtzdGlja3lzfXxbXjwuKj8+XXxcXFxcV2BcbiAgICAgIC8vIGNvbnNvbGUubG9nKHJlZ1N0cilcbiAgICAgIGNvbnN0IHJlID0gbmV3IFJlZ0V4cChyZWdTdHIsICdnJylcbiAgICAgIGNvbnN0IG1hdGNoID0gcy50b1VwcGVyQ2FzZSgpLm1hdGNoKHJlKVxuICAgICAgLy8gY29uc29sZS5sb2cobWF0Y2gpXG4gICAgICByZXR1cm4gbWF0Y2hcbiAgICB9XG4gICAgY29uc3QgY2hhcnMgPSBzcGxpdFdpdGhQcm9zaWduc0FuZFN0Y2lreXMoZGF0YS5sZXR0ZXJzKVxuICAgIGxldCBzZWNvbmRzID0gMFxuICAgIGNvbnN0IGNvbnRyb2xUaW1lID0gKHRoaXMuaWZPdmVycmlkZVRpbWUoKSB8fCBpZkN1c3RvbSkgPyAodGhpcy5vdmVycmlkZU1pbnMoKSAqIDYwKSA6IGRhdGEucHJhY3RpY2VTZWNvbmRzXG4gICAgY29uc3QgbWluV29yZFNpemUgPSAodGhpcy5pZk92ZXJyaWRlTWluTWF4KCkgfHwgaWZDdXN0b20pID8gdGhpcy5vdmVycmlkZU1pbigpIDogZGF0YS5taW5Xb3JkU2l6ZVxuICAgIGNvbnN0IG1heFdvcmRTaXplID0gKHRoaXMuaWZPdmVycmlkZU1pbk1heCgpIHx8IGlmQ3VzdG9tKSA/IHRoaXMub3ZlcnJpZGVNYXgoKSA6IGRhdGEubWF4V29yZFNpemVcbiAgICAvLyBGbiB0byBnZW5lcmF0ZSByYW5kb20gbnVtYmVyIG1pbi9tYXggaW5jbHVzaXZlXG4gICAgLy8gaHR0cHM6Ly93d3cuZ2Vla3Nmb3JnZWVrcy5vcmcvaG93LXRvLWdlbmVyYXRlLXJhbmRvbS1udW1iZXItaW4tZ2l2ZW4tcmFuZ2UtdXNpbmctamF2YXNjcmlwdC9cbiAgICBjb25zdCByYW5kb21OdW1iZXIgPSAobWluLCBtYXgpID0+IHtcbiAgICAgIG1pbiA9IE1hdGguY2VpbChtaW4pXG4gICAgICBtYXggPSBNYXRoLmZsb29yKG1heClcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpICsgbWluXG4gICAgfVxuXG4gICAgZG8ge1xuICAgICAgbGV0IHdvcmQgPSAnJ1xuXG4gICAgICBpZiAodGhpcy5yYW5kb21pemVMZXNzb25zKCkpIHtcbiAgICAgICAgLy8gZGV0ZXJtaW5lIHdvcmQgbGVuZ3RoXG4gICAgICAgIGNvbnN0IHdvcmRMZW5ndGggPSBtaW5Xb3JkU2l6ZSA9PT0gbWF4V29yZFNpemUgPyBtaW5Xb3JkU2l6ZSA6IHJhbmRvbU51bWJlcihtaW5Xb3JkU2l6ZSwgbWF4V29yZFNpemUpXG5cbiAgICAgICAgZm9yIChsZXQgaiA9IDE7IGogPD0gd29yZExlbmd0aDsgaisrKSB7IC8vIGZvciBlYWNoIGxldHRlclxuICAgICAgICAgIC8vIGRldGVybWluZSB0aGUgbGV0dGVyXG4gICAgICAgICAgd29yZCArPSBjaGFyc1tyYW5kb21OdW1iZXIoMSwgY2hhcnMubGVuZ3RoKSAtIDFdXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdvcmQgPSBkYXRhLmxldHRlcnNcbiAgICAgIH1cblxuICAgICAgc3RyICs9IHNlY29uZHMgPiAwID8gKCcgJyArIHdvcmQudG9VcHBlckNhc2UoKSkgOiB3b3JkLnRvVXBwZXJDYXNlKClcblxuICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5nZXRNb3JzZVN0cmluZ1RvV2F2QnVmZmVyQ29uZmlnKHN0cilcbiAgICAgIGNvbnN0IGVzdCA9IHRoaXMubW9yc2VXb3JkUGxheWVyLmdldFRpbWVFc3RpbWF0ZShjb25maWcpXG4gICAgICBzZWNvbmRzID0gZXN0LnRpbWVDYWxjcy50b3RhbFRpbWUgLyAxMDAwXG4gICAgfSB3aGlsZSAoc2Vjb25kcyA8IGNvbnRyb2xUaW1lKVxuXG4gICAgdGhpcy5zZXRUZXh0KHN0cilcbiAgfVxuXG4gIGdldE1vcnNlU3RyaW5nVG9XYXZCdWZmZXJDb25maWcgPSAodGV4dCkgPT4ge1xuICAgIGNvbnN0IGNvbmZpZyA9IG5ldyBNb3JzZVN0cmluZ1RvV2F2QnVmZmVyQ29uZmlnKClcbiAgICBjb25maWcud29yZCA9IHRleHRcbiAgICBjb25maWcud3BtID0gcGFyc2VJbnQodGhpcy53cG0oKSlcbiAgICBjb25maWcuZndwbSA9IHBhcnNlSW50KHRoaXMuZndwbSgpKVxuICAgIGNvbmZpZy5kaXRGcmVxdWVuY3kgPSBwYXJzZUludCh0aGlzLmRpdEZyZXF1ZW5jeSgpKVxuICAgIGNvbmZpZy5kYWhGcmVxdWVuY3kgPSBwYXJzZUludCh0aGlzLmRhaEZyZXF1ZW5jeSgpKVxuICAgIGNvbmZpZy5wcmVQYWRkaW5nTXMgPSB0aGlzLnByZVNwYWNlVXNlZCgpID8gMCA6IHRoaXMucHJlU3BhY2UoKSAqIDEwMDBcbiAgICBjb25maWcueHRyYVdvcmRTcGFjZURpdHMgPSBwYXJzZUludCh0aGlzLnh0cmFXb3JkU3BhY2VEaXRzKCkpXG4gICAgY29uZmlnLnZvbHVtZSA9IHBhcnNlSW50KHRoaXMudm9sdW1lKCkpXG4gICAgY29uZmlnLm5vaXNlID0ge1xuICAgICAgdHlwZTogdGhpcy5ub2lzZUVuYWJsZWQoKSA/IHRoaXMubm9pc2VUeXBlKCkgOiAnb2ZmJyxcbiAgICAgIHZvbHVtZTogcGFyc2VJbnQodGhpcy5ub2lzZVZvbHVtZSgpKVxuICAgIH1cbiAgICBjb25maWcucGxheWVyUGxheWluZyA9IHRoaXMucGxheWVyUGxheWluZygpXG4gICAgcmV0dXJuIGNvbmZpZ1xuICB9XG5cbiAgZG9QbGF5ID0gKHBsYXlKdXN0RW5kZWQsIGZyb21QbGF5QnV0dG9uKSA9PiB7XG4gICAgLy8gd2UgZ2V0IGhlcmUgc2V2ZXJhbCB3YXlzOlxuICAgIC8vIDEuIHVzZXIgcHJlc3NlcyBwbGF5IGZvciB0aGUgZmlyc3QgdGltZVxuICAgIC8vIDFhLiBzZXQgcHJlc3BhY2V1c2VkIHRvIGZhbHNlLCBzbyBpdCB3aWxsIGdldCB1c2VkLlxuICAgIC8vIDFiLiBzZXQgdGhlIGVsYXBzZWQgbXMgdG8gMFxuICAgIC8vIDIuIHVzZXIgcHJlc3NlcyBwbGF5IGFmdGVyIGEgcGF1c2VcbiAgICAvLyAyYS4gc2V0IHByZXNwYWNldXNlZCB0byBmYWxzZSwgc28gaXQgd2lsbCBnZXQgdXNlZCBhZ2Fpbi5cbiAgICAvLyAzLiB3ZSBqdXN0IGZpbmlzaGVkIHBsYXlpbmcgYSB3b3JkXG4gICAgLy8gNC4gdXNlciBtaWdodCBwcmVzcyBwbGF5IHRvIHJlLXBsYXkgYSB3b3JkXG4gICAgY29uc3Qgd2FzUGxheWVyUGxheWluZyA9IHRoaXMucGxheWVyUGxheWluZygpXG4gICAgY29uc3QgZnJlc2hTdGFydCA9IGZyb21QbGF5QnV0dG9uICYmICF3YXNQbGF5ZXJQbGF5aW5nXG4gICAgaWYgKCF0aGlzLmxhc3RQbGF5RnVsbFN0YXJ0IHx8ICh0aGlzLmxhc3RGdWxsUGxheVRpbWUoKSA+IHRoaXMubGFzdFBsYXlGdWxsU3RhcnQpKSB7XG4gICAgICB0aGlzLmxhc3RQbGF5RnVsbFN0YXJ0ID0gRGF0ZS5ub3coKVxuICAgIH1cbiAgICB0aGlzLmlzUGF1c2VkKGZhbHNlKVxuICAgIHRoaXMucGxheWVyUGxheWluZyh0cnVlKVxuICAgIGlmICghcGxheUp1c3RFbmRlZCkge1xuICAgICAgdGhpcy5wcmVTcGFjZVVzZWQoZmFsc2UpXG4gICAgfVxuXG4gICAgaWYgKGZyZXNoU3RhcnQpIHtcbiAgICAgIHRoaXMucnVubmluZ1BsYXlNcygwKVxuICAgIH1cbiAgICAvLyBleHBlcmllbmNlIHNob3dzIGl0IGlzIGdvb2QgdG8gcHV0IGEgbGl0dGxlIHBhdXNlIGhlcmUgd2hlbiB1c2VyIGZvcmNlcyB1cyBoZXJlLFxuICAgIC8vIGUuZy4gaGl0dGluZyBiYWNrIG9yIHBsYXkgYi9jIHdvcmQgd2FzIG1pc3VuZGVyc3Rvb2QsXG4gICAgLy8gc28gdGhleSBkb250JyBibHVyIHRvZ2V0aGVyLlxuICAgIGlmICh0aGlzLmRvUGxheVRpbWVPdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmRvUGxheVRpbWVPdXQpXG4gICAgfVxuICAgIHRoaXMuZG9QbGF5VGltZU91dCA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5tb3JzZVdvcmRQbGF5ZXIucGF1c2UoKCkgPT4ge1xuICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5nZXRNb3JzZVN0cmluZ1RvV2F2QnVmZmVyQ29uZmlnKHRoaXMud29yZHMoKVt0aGlzLmN1cnJlbnRJbmRleCgpXSlcbiAgICAgIHRoaXMubW9yc2VXb3JkUGxheWVyLnBsYXkoY29uZmlnLCB0aGlzLnBsYXlFbmRlZClcbiAgICAgIHRoaXMubGFzdFBhcnRpYWxQbGF5U3RhcnQoRGF0ZS5ub3coKSlcbiAgICAgIHRoaXMucHJlU3BhY2VVc2VkKHRydWUpXG4gICAgfSksXG4gICAgcGxheUp1c3RFbmRlZCB8fCBmcm9tUGxheUJ1dHRvbiA/IDAgOiAxMDAwKVxuICB9XG5cbiAgcGxheUVuZGVkID0gKCkgPT4ge1xuICAgIHRoaXMucnVubmluZ1BsYXlNcyh0aGlzLnJ1bm5pbmdQbGF5TXMoKSArIChEYXRlLm5vdygpIC0gdGhpcy5sYXN0UGFydGlhbFBsYXlTdGFydCgpKSlcbiAgICBpZiAodGhpcy5jdXJyZW50SW5kZXgoKSA8IHRoaXMud29yZHMoKS5sZW5ndGggLSAxKSB7XG4gICAgICB0aGlzLmluY3JlbWVudEluZGV4KClcbiAgICAgIHRoaXMuZG9QbGF5KHRydWUpXG4gICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnRTZW50YW5jZUluZGV4KCkgPCB0aGlzLnNlbnRlbmNlTWF4KCkpIHtcbiAgICAgIC8vIG1vdmUgdG8gbmV4dCBzZW50ZW5jZVxuICAgICAgdGhpcy5jdXJyZW50U2VudGFuY2VJbmRleChOdW1iZXIodGhpcy5jdXJyZW50U2VudGFuY2VJbmRleCgpKSArIDEpXG4gICAgICB0aGlzLmN1cnJlbnRJbmRleCgwKVxuICAgICAgdGhpcy5kb1BsYXkodHJ1ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbm90aGluZyBtb3JlIHRvIHBsYXlcbiAgICAgIHRoaXMuZG9QYXVzZSh0cnVlKVxuICAgIH1cbiAgfVxuXG4gIGRvUGF1c2UgPSAoZnVsbFJld2luZCwgZnJvbVBhdXNlQnV0dG9uKSA9PiB7XG4gICAgaWYgKGZyb21QYXVzZUJ1dHRvbikge1xuICAgICAgdGhpcy5ydW5uaW5nUGxheU1zKHRoaXMucnVubmluZ1BsYXlNcygpICsgKERhdGUubm93KCkgLSB0aGlzLmxhc3RQYXJ0aWFsUGxheVN0YXJ0KCkpKVxuICAgICAgdGhpcy5pc1BhdXNlZCghdGhpcy5pc1BhdXNlZCgpKVxuICAgIH1cbiAgICB0aGlzLnBsYXllclBsYXlpbmcoZmFsc2UpXG4gICAgdGhpcy5tb3JzZVdvcmRQbGF5ZXIucGF1c2UoKCkgPT4ge1xuICAgICAgLy8gd2UncmUgaGVyZSBpZiBhIGNvbXBsZXRlIHJhd3RleHQgZmluaXNoZWRcbiAgICAgIGNvbnNvbGUubG9nKCdzZXR0aW5nbGFzdGZ1bGxwbGF5dGltZScpXG4gICAgICB0aGlzLmxhc3RGdWxsUGxheVRpbWUoRGF0ZS5ub3coKSlcbiAgICAgIGNvbnNvbGUubG9nKGBwbGF5dGltZToke3RoaXMubGFzdEZ1bGxQbGF5VGltZSgpIC0gdGhpcy5sYXN0UGxheUZ1bGxTdGFydH1gKVxuICAgICAgLy8gVE9ETyBtYWtlIHRoaXMgbW9yZSBnZW5lcmljIGZvciBhbnkgZnV0dXJlIFwicGx1Z2luc1wiXG4gICAgICBpZiAodGhpcy5yc3NQbGF5Q2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5yc3NQbGF5Q2FsbGJhY2soKVxuICAgICAgfVxuXG4gICAgICB0aGlzLnByZVNwYWNlVXNlZChmYWxzZSlcbiAgICB9LCB0cnVlKVxuICAgIGlmIChmdWxsUmV3aW5kKSB7XG4gICAgICB0aGlzLmZ1bGxSZXdpbmQoKVxuICAgIH1cbiAgfVxuXG4gIGlucHV0RmlsZUNoYW5nZSA9IChmaWxlKSA9PiB7XG4gICAgLy8gdGhhbmtzIHRvIGh0dHBzOi8vbmV3YmVkZXYuY29tL2hvdy10by1hY2Nlc3MtZmlsZS1pbnB1dC13aXRoLWtub2Nrb3V0LWJpbmRpbmdcbiAgICBjb25zdCBmciA9IG5ldyBGaWxlUmVhZGVyKClcbiAgICBmci5vbmxvYWQgPSAoZGF0YSkgPT4ge1xuICAgICAgdGhpcy5zZXRUZXh0KGRhdGEudGFyZ2V0LnJlc3VsdClcbiAgICB9XG4gICAgZnIucmVhZEFzVGV4dChmaWxlKVxuICB9XG5cbiAgZG9Eb3dubG9hZCA9ICgpID0+IHtcbiAgICBsZXQgYWxsV29yZHMgPSAnJ1xuICAgIGNvbnN0IHNlbnRlbmNlcyA9IHRoaXMuc2VudGVuY2VzKClcbiAgICBzZW50ZW5jZXMuZm9yRWFjaCgoc2VudGVuY2UpID0+IHtcbiAgICAgIHNlbnRlbmNlLmZvckVhY2goKHdvcmQpID0+IHtcbiAgICAgICAgYWxsV29yZHMgKz0gYWxsV29yZHMubGVuZ3RoID4gMCA/ICcgJyArIHdvcmQgOiB3b3JkXG4gICAgICB9KVxuICAgIH0pXG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5nZXRNb3JzZVN0cmluZ1RvV2F2QnVmZmVyQ29uZmlnKGFsbFdvcmRzKVxuICAgIGNvbnN0IHdhdiA9IHRoaXMubW9yc2VXb3JkUGxheWVyLmdldFdhdkFuZFNhbXBsZShjb25maWcpXG4gICAgY29uc3QgYXJ5ID0gbmV3IFVpbnQ4QXJyYXkod2F2LndhdilcbiAgICBjb25zdCBsaW5rID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Rvd25sb2FkTGluaycpXG4gICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFthcnldLCB7IHR5cGU6ICdhdWRpby93YXYnIH0pXG4gICAgbGluay5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKVxuICAgIGxpbmsuZG93bmxvYWQgPSAnbW9yc2Uud2F2J1xuICAgIGxpbmsuZGlzcGF0Y2hFdmVudChuZXcgTW91c2VFdmVudCgnY2xpY2snKSlcbiAgfVxuXG4gIGR1bW15ID0gKCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdkdW1teScpXG4gIH1cblxuICB0aW1lRXN0aW1hdGUgPSBrby5jb21wdXRlZCgoKSA9PiB7XG4gICAgLy8gdGhpcyBjb21wdXRlZCBkb2Vzbid0IHNlZW0gYm91bmQgdG8gYW55dGhpbmcgYnV0IC5yYXdUZXh0LCBidXQgZm9yIHNvbWUgcmVhc29uIGl0IGlzXG4gICAgLy8gc3RpbGwgcmVjb21wdXRpbmcgb24gd3BtL2Z3cG0veHRyYSBjaGFuZ2VzLCBzby4uLm9rXG4gICAgaWYgKCF0aGlzLnJhd1RleHQoKSkge1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5nZXRNb3JzZVN0cmluZ1RvV2F2QnVmZmVyQ29uZmlnKHRoaXMucmF3VGV4dCgpKVxuICAgIGNvbnN0IGVzdCA9IHRoaXMubW9yc2VXb3JkUGxheWVyLmdldFRpbWVFc3RpbWF0ZShjb25maWcpXG4gICAgY29uc3QgbWludXRlcyA9IE1hdGguZmxvb3IoZXN0LnRpbWVDYWxjcy50b3RhbFRpbWUgLyA2MDAwMClcbiAgICBjb25zdCBzZWNvbmRzID0gKChlc3QudGltZUNhbGNzLnRvdGFsVGltZSAlIDYwMDAwKSAvIDEwMDApLnRvRml4ZWQoMClcbiAgICBjb25zdCBub3JtZWRTZWNvbmRzID0gKHNlY29uZHMgPCAxMCA/ICcwJyA6ICcnKSArIHNlY29uZHNcbiAgICBjb25zdCB0aW1lRmlndXJlcyA9IHsgbWludXRlcywgc2Vjb25kcywgbm9ybWVkU2Vjb25kcyB9XG4gICAgY29uc29sZS5sb2codGltZUZpZ3VyZXMpXG4gICAgY29uc29sZS5sb2coZXN0KVxuICAgIHJldHVybiB0aW1lRmlndXJlc1xuICB9LCB0aGlzKVxuXG4gIHBsYXlpbmdUaW1lID0ga28uY29tcHV0ZWQoKCkgPT4ge1xuICAgIGNvbnN0IG1pbnV0ZXMgPSBNYXRoLmZsb29yKHRoaXMucnVubmluZ1BsYXlNcygpIC8gNjAwMDApXG4gICAgY29uc3Qgc2Vjb25kcyA9ICgodGhpcy5ydW5uaW5nUGxheU1zKCkgJSA2MDAwMCkgLyAxMDAwKS50b0ZpeGVkKDApXG4gICAgY29uc3Qgbm9ybWVkU2Vjb25kcyA9IChzZWNvbmRzIDwgMTAgPyAnMCcgOiAnJykgKyBzZWNvbmRzXG4gICAgY29uc3QgdGltZUZpZ3VyZXMgPSB7IG1pbnV0ZXMsIHNlY29uZHMsIG5vcm1lZFNlY29uZHMgfVxuICAgIC8vIGNvbnNvbGUubG9nKHRpbWVGaWd1cmVzKVxuICAgIC8vIGNvbnNvbGUubG9nKGVzdClcbiAgICByZXR1cm4gdGltZUZpZ3VyZXNcbiAgfSwgdGhpcylcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5ldy1jYXBcbmtvLmFwcGx5QmluZGluZ3MobmV3IE1vcnNlVmlld01vZGVsKCkpXG4iXSwibmFtZXMiOlsiTW9yc2VDVyIsIk1vcnNlQ1dXYXZlIiwidXNlUHJvc2lnbnMiLCJ3cG0iLCJmd3BtIiwiZnJlcXVlbmN5Iiwic2FtcGxlUmF0ZSIsInNpbmdsZUZyZXF1ZW5jeSIsImRpdCIsImVuZFBhZGRpbmciLCJwcmVQYWRkaW5nIiwiZ2V0U2FtcGxlR2VuZXJhbCIsImdldFRpbWluZ3MiLCJNYXRoIiwibWF4IiwidGltaW5ncyIsInB1c2giLCJvZmZsaW5lQXVkaW9Db250ZXh0Q2xhc3MiLCJ3aW5kb3ciLCJPZmZsaW5lQXVkaW9Db250ZXh0Iiwid2Via2l0T2ZmbGluZUF1ZGlvQ29udGV4dCIsInVuZGVmaW5lZCIsIkVycm9yIiwib2ZmbGluZUN0eCIsImdldER1cmF0aW9uIiwiZ2Fpbk5vZGUiLCJjcmVhdGVHYWluIiwiZ2FpbiIsInNldFZhbHVlQXRUaW1lIiwibG93UGFzc05vZGUiLCJjcmVhdGVCaXF1YWRGaWx0ZXIiLCJ0eXBlIiwiY29ubmVjdCIsImRlc3RpbmF0aW9uIiwidCIsIm9zY2lsbGF0b3IiLCJkdXJhdGlvbiIsImkiLCJsZW5ndGgiLCJhYnMiLCJjcmVhdGVPc2NpbGxhdG9yIiwic3RhcnQiLCJzdG9wIiwic3RhcnRSZW5kZXJpbmciLCJ0aGVuIiwicmVuZGVyZWRCdWZmZXIiLCJnZXRDaGFubmVsRGF0YSIsInNhbXBsZSIsInVuc2hpZnQiLCJub0RldGFpbHMiLCJ0aW1lIiwic2lsZW5jZUxlbmd0aCIsImZpcnN0TGVuZ3RoIiwib24iLCJ4MCIsIngxIiwieDIiLCJ5MCIsInkxIiwieTIiLCJkaXRGcmVxdWVuY3kiLCJkYWhGcmVxdWVuY3kiLCJkYWgiLCJkaXRTdGVwIiwiUEkiLCJkYWhTdGVwIiwic3RlcFRvVXNlIiwiZnJlcVRvVXNlIiwic2luIiwibG93cGFzc0ZyZXEiLCJxIiwiU1FSVDFfMiIsImNvcyIsImFscGhhIiwicG93IiwiYTAiLCJiMCIsImIxIiwiYjIiLCJhMSIsImEyIiwiV1BNIiwiTW9yc2VNZXNzYWdlIiwiX3dwbSIsIl9md3BtIiwid29yZFNwYWNlIiwid2l0aERldGFpbHMiLCJnZXRUaW1pbmdzR2VuZXJhbCIsImRpdExlbmd0aCIsImRhaExlbmd0aCIsImRpdFNwYWNlIiwiY2hhclNwYWNlIiwibW9yc2UiLCJ0aW1lcyIsInJlcGxhY2UiLCJtYXAiLCJ4IiwiTW9yc2UiLCJpbnB1dCIsIm91dHB1dCIsIm1lc3NhZ2UiLCJpbnB1dFdhc01vcnNlIiwiaGFzRXJyb3IiLCJpc01vcnNlIiwidHJhbnNsYXRpb24iLCJsb29rc0xpa2VNb3JzZSIsIm1vcnNlMnRleHQiLCJ0ZXh0Mm1vcnNlIiwidTMyVG9BcnJheSIsInUxNlRvQXJyYXkiLCJzcGxpdDE2Yml0QXJyYXkiLCJkYXRhIiwiciIsImoiLCJsZW4iLCJmVG9VOCIsIm1pbiIsInJvdW5kIiwiZ2V0RGF0YSIsImJpdHNQZXJTYW1wbGUiLCJoZWFkZXIiLCJjaHVua0lkIiwiY2h1bmtTaXplIiwiZm9ybWF0Iiwic3ViQ2h1bmsxSWQiLCJzdWJDaHVuazFTaXplIiwiYXVkaW9Gb3JtYXQiLCJudW1DaGFubmVscyIsImJ5dGVSYXRlIiwiYmxvY2tBbGlnbiIsInN1YkNodW5rMklkIiwic3ViQ2h1bmsyU2l6ZSIsImNvbmNhdCIsImdldE1JTUVUeXBlIiwiRElUU19QRVJfV09SRCIsIlNQQUNFU19JTl9QQVJJUyIsIk1TX0lOX01JTlVURSIsIl9kaXRMZW5ndGgiLCJfZmRpdExlbmd0aCIsImRpdExlbiIsImZkaXRMZW5ndGgiLCJyYXRpbyIsIlN0cmluZyIsInByb3RvdHlwZSIsInRyaW0iLCJ0ZXh0Mm1vcnNlSCIsIm1vcnNlMnRleHRIIiwicHJvc2lnbjJtb3JzZUgiLCJtb3JzZXBybzJ0ZXh0SCIsInRleHQybW9yc2Vwcm9IIiwidGV4dCIsInNpZ24iLCJ0aWR5VGV4dCIsInRvVXBwZXJDYXNlIiwicmV0IiwidG9rZW5zIiwicHJvc2lnbiIsInRva2VuX2xlbmd0aCIsIm1hdGNoIiwic2xpY2UiLCJkaWN0IiwiYyIsInRleHQyZGl0ZGFoIiwiZGl0ZGFoIiwidGlkeU1vcnNlIiwic3BsaXQiLCJNb3JzZUxlc3NvblBsdWdpbiIsImtvIiwiY3R4dCIsInNldFVzZXJUYXJnZXRJbml0aWFsaXplZCIsInVzZXJUYXJnZXRJbml0aWFsaXplZCIsInNldFNlbGVjdGVkQ2xhc3NJbml0aWFsaXplZCIsInNlbGVjdGVkQ2xhc3NJbml0aWFsaXplZCIsInNldExldHRlckdyb3VwSW5pdGlhbGl6ZWQiLCJjb25zb2xlIiwibG9nIiwibGV0dGVyR3JvdXBJbml0aWFsaXplZCIsInNldERpc3BsYXlzSW5pdGlhbGl6ZWQiLCJkaXNwbGF5c0luaXRpYWxpemVkIiwiY2hhbmdlVXNlclRhcmdldCIsInVzZXJUYXJnZXQiLCJjaGFuZ2VTZWxlY3RlZENsYXNzIiwic2VsZWN0ZWRDbGFzcyIsInNldExldHRlckdyb3VwIiwibGV0dGVyR3JvdXAiLCJzZXREaXNwbGF5U2VsZWN0ZWQiLCJkaXNwbGF5Iiwic2VsZWN0ZWREaXNwbGF5Iiwic2V0VGV4dCIsImZpbGVOYW1lIiwiZ2V0V29yZExpc3QiLCJpbml0aWFsaXplV29yZExpc3QiLCJmZXRjaCIsInJlc3BvbnNlIiwianNvbiIsIndvcmRMaXN0cyIsImZpbGVPcHRpb25zIiwiZXJyIiwidXNlclRhcmdldHMiLCJjb21wdXRlZCIsInRhcmdzIiwiZm9yRWFjaCIsImZpbmQiLCJ5IiwiY2xhc3NlcyIsImNscyIsImxldHRlckdyb3VwcyIsImxncyIsIm1pc3NpbmciLCJqb2luIiwiZmlsdGVyIiwibGlzdCIsImRpc3BsYXlzIiwiZHBzIiwiZmlsZW5hbWUiLCJpc1RleHQiLCJlbmRzV2l0aCIsInJhbmRvbVdvcmRMaXN0IiwibGljd2xvZ28iLCJkb3duTG9hZFBuZyIsInZvbHVtZVBuZyIsImdpdGh1YlBuZyIsImJvb2tQbmciLCJmbGFnUG5nIiwibG9ja1BuZyIsInVubG9ja1BuZyIsIk1vcnNlTG9hZEltYWdlcyIsImtleSIsInRhcmdldCIsImluZm8iLCJzcmMiLCJsaWN3bG9nb0ltZyIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJkb3dubG9hZEltZyIsInZvbHVtZUltZyIsImdpdGh1YkltZyIsImJvb2tJbWciLCJmbGFnSW1nIiwiUmlmZldhdmUiLCJNb3JzZUNvdW50VW5pdHMiLCJNb3JzZVRpbWluZ0NhbGN1bGF0b3IiLCJNb3JzZVN0cmluZ1RvV2F2QnVmZmVyQ29uZmlnIiwiTW9yc2VTdHJpbmdUb1dhdkJ1ZmZlciIsImNvbmZpZyIsInRpbWluZ1VuaXRzIiwiZ2V0VGltaW5nVW5pdHMiLCJjb3VudFVuaXRzIiwiZXh0cmFXb3JkU3BhY2luZ0RpdHNDb3VudCIsInh0cmFXb3JkU3BhY2VEaXRzIiwibW9yc2VDV1dhdmUiLCJ0cmFuc2xhdGUiLCJ3b3JkIiwiaW5pdCIsImdldEluaXQiLCJjYWxjcyIsImdldFRpbWVzIiwiZ2V0U2FtcGxlIiwic2luZ2xlV29yZFNwYWNlVGltZSIsInByZVBhZGRpbmdNcyIsIndhdiIsInVuaXRDb3VudHMiLCJ0aW1lQ2FsY3MiLCJNb3JzZVN0cmluZ1V0aWxzIiwicyIsInJlcGxhY2VkIiwic3BsaXRTZW50cyIsInNwbGl0c0dsdWVkIiwidmFsIiwiYXJ5IiwiZG9udFNwbGl0IiwiZG9SZXBsYWNlbWVudHMiLCJzcGxpdEludG9TZW50ZW5jZXMiLCJzZW50cyIsInNlbnRlbmNlIiwiY2FsY3VsYXRlZFNlY29uZHNQZXJEaXQiLCJjYWxjdWxhdGVkVW5pdHNNcyIsImNhbGN1bGF0ZWRGV1VuaXRTZWNvbmRzIiwiY2FsY3VsYXRlZEZXVW5pdHNNcyIsImRpdFVuaXRNdWx0aVBsaWVyIiwiZGFoVW5pdE11bHRpcGxpZXIiLCJpbnRyYUNoYXJhY3RlclNwYWNlTXVsdGlwbGllciIsImludGVyQ2hhcmFjdGVyU3BhY2VNdWx0aXBsaWVyIiwid29yZFNwYWNlTXVsdGlwbGllciIsIm1vcnNlY3d3YXYiLCJwcmVQb3B1bGF0ZWQiLCJjbnRzIiwibW9yc2VXb3JkcyIsIndvcmRTcGFjZXNDb3VudCIsImNoYXJhY3RlcnMiLCJpbnRlckNoYXJhY3RlclNwYWNlQ291bnQiLCJjaGFyYWN0ZXIiLCJpbnRyYUNoYXJhY3RlclNwYWNlQ291bnQiLCJkaXRDb3VudCIsImRhaENvdW50IiwiZGl0VGltZSIsImRhaFRpbWUiLCJpbnRyYUNoYXJhY3RlclNwYWNlVGltZSIsImludGVyQ2hhcmFjdGVyU3BhY2VUaW1lIiwid29yZFNwYWNlVGltZSIsImV4dHJhV29yZFNwYWNpbmdEaXRzVGltZSIsInRvdGFsVGltZSIsInRvdGFsUGx1c1RyYWlsIiwiTW9yc2VXYXZCdWZmZXJQbGF5ZXIiLCJub2lzZU5vZGVNYWtlciIsImFmdGVySW1wb3J0IiwiZGVmIiwiaW5zdGFsbCIsIm5vaXNlR2Fpbk5vZGUiLCJteUF1ZGlvQ29udGV4dCIsInNldE5vaXNlVm9sdW1lIiwibm9pc2UiLCJzY2FsZWROb2lzZVZvbHVtZSIsIm5vaXNlTm9kZSIsIm5vaXNlUGxheWluZyIsImNyZWF0ZVdoaXRlTm9pc2UiLCJjcmVhdGVCcm93bk5vaXNlIiwiY3JlYXRlUGlua05vaXNlIiwic2NhbGVkVm9sdW1lIiwiY3VycmVudFRpbWUiLCJub2lzZVdhc1BsYXlpbmciLCJ0eXBlQ2hhbmdlZCIsImxhc3ROb2lzZVR5cGUiLCJ0eXBlSXNPZmYiLCJzdG9wTm9pc2UiLCJwbGF5ZXJQbGF5aW5nIiwic3RhcnROb2lzZSIsIm9uRW5kZWQiLCJzb3VyY2VFbmRlZCIsInNvdXJjZUVuZGVkQ2FsbEJhY2siLCJBdWRpb0NvbnRleHQiLCJzb3VyY2UiLCJjcmVhdGVCdWZmZXJTb3VyY2UiLCJhZGRFdmVudExpc3RlbmVyIiwibXlidWYiLCJJbnQ4QXJyYXkiLCJidWZmZXIiLCJteWJ1ZjIiLCJkZWNvZGVBdWRpb0RhdGEiLCJzZXRWb2x1bWUiLCJoYW5kbGVOb2lzZVNldHRpbmdzIiwiZSIsInBhdXNlQ2FsbEJhY2siLCJraWxsTm9pc2UiLCJNb3JzZVdvcmRQbGF5ZXIiLCJteUJ1ZmZlclBsYXllciIsInZvbHVtZSIsImNyZWF0ZVdhdiIsInBsYXkiLCJmb3JjZVN0b3AiLCJlc3RpbWF0ZVBsYXlUaW1lIiwiVG9vbHRpcCIsIlRvYXN0IiwiUG9wb3ZlciIsIkNvb2tpZXMiLCJNb3JzZVZpZXdNb2RlbCIsIm9ic2VydmFibGUiLCJwdXJlQ29tcHV0ZWQiLCJyZWFkIiwidHJ1ZVdwbSIsIndyaXRlIiwidmFsdWUiLCJzeW5jV3BtIiwicGFyc2VJbnQiLCJ0cnVlRndwbSIsIm93bmVyIiwidHJ1ZERpdEZyZXF1ZW5jeSIsInN5bmNGcmVxIiwidHJ1RGFoRnJlcXVlbmN5IiwiRGF0ZSIsIm9ic2VydmFibGVBcnJheSIsInRydWVPdmVycmlkZU1pbiIsInN5bmNTaXplIiwidHJ1ZU92ZXJyaWRlTWF4IiwiYm9vbGVhbml6ZSIsImNrcyIsImdldCIsInNwZWNpYWxIYW5kbGluZyIsIm5hbWUiLCJ1cmwiLCJsb2NhdGlvbiIsImhyZWYiLCJyZWdleCIsIlJlZ0V4cCIsInJlc3VsdHMiLCJleGVjIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiY3VycmVudEluZGV4Iiwic2hvd1JhdyIsInNob3dpbmdUZXh0IiwicmF3VGV4dCIsImdldFNlbnRlbmNlcyIsImlmUGFyc2VTZW50ZW5jZXMiLCJzZW50ZW5jZXMiLCJjdXJyZW50U2VudGFuY2VJbmRleCIsImZsYWdnZWRXb3JkcyIsImlzU2h1ZmZsZWQiLCJwcmVTaHVmZmxlZCIsInNvcnQiLCJyYW5kb20iLCJ3b3JkcyIsInNlbnRlbmNlTWF4IiwiTnVtYmVyIiwibW9yc2VXb3JkUGxheWVyIiwicGF1c2UiLCJzZXRUaW1lb3V0IiwiZG9QbGF5IiwiaW5kZXgiLCJkb1BhdXNlIiwibGFzdFdvcmQiLCJwb3AiLCJmdWxsUmV3aW5kIiwiY3VzdG9tR3JvdXAiLCJsZXR0ZXJzIiwiaWZDdXN0b20iLCJzdHIiLCJzcGxpdFdpdGhQcm9zaWduc0FuZFN0Y2lreXMiLCJzdGlja3lzIiwiaWZTdGlja3lTZXRzIiwic3RpY2t5U2V0cyIsInJlZ1N0ciIsInJlIiwiY2hhcnMiLCJzZWNvbmRzIiwiY29udHJvbFRpbWUiLCJpZk92ZXJyaWRlVGltZSIsIm92ZXJyaWRlTWlucyIsInByYWN0aWNlU2Vjb25kcyIsIm1pbldvcmRTaXplIiwiaWZPdmVycmlkZU1pbk1heCIsIm92ZXJyaWRlTWluIiwibWF4V29yZFNpemUiLCJvdmVycmlkZU1heCIsInJhbmRvbU51bWJlciIsImNlaWwiLCJmbG9vciIsInJhbmRvbWl6ZUxlc3NvbnMiLCJ3b3JkTGVuZ3RoIiwiZ2V0TW9yc2VTdHJpbmdUb1dhdkJ1ZmZlckNvbmZpZyIsImVzdCIsImdldFRpbWVFc3RpbWF0ZSIsInByZVNwYWNlVXNlZCIsInByZVNwYWNlIiwibm9pc2VFbmFibGVkIiwibm9pc2VUeXBlIiwibm9pc2VWb2x1bWUiLCJwbGF5SnVzdEVuZGVkIiwiZnJvbVBsYXlCdXR0b24iLCJ3YXNQbGF5ZXJQbGF5aW5nIiwiZnJlc2hTdGFydCIsImxhc3RQbGF5RnVsbFN0YXJ0IiwibGFzdEZ1bGxQbGF5VGltZSIsIm5vdyIsImlzUGF1c2VkIiwicnVubmluZ1BsYXlNcyIsImRvUGxheVRpbWVPdXQiLCJjbGVhclRpbWVvdXQiLCJwbGF5RW5kZWQiLCJsYXN0UGFydGlhbFBsYXlTdGFydCIsImluY3JlbWVudEluZGV4IiwiZnJvbVBhdXNlQnV0dG9uIiwicnNzUGxheUNhbGxiYWNrIiwiZmlsZSIsImZyIiwiRmlsZVJlYWRlciIsIm9ubG9hZCIsInJlc3VsdCIsInJlYWRBc1RleHQiLCJhbGxXb3JkcyIsImdldFdhdkFuZFNhbXBsZSIsIlVpbnQ4QXJyYXkiLCJsaW5rIiwiYmxvYiIsIkJsb2IiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJkb3dubG9hZCIsImRpc3BhdGNoRXZlbnQiLCJNb3VzZUV2ZW50IiwibWludXRlcyIsInRvRml4ZWQiLCJub3JtZWRTZWNvbmRzIiwidGltZUZpZ3VyZXMiLCJtb3JzZUxvYWRJbWFnZXMiLCJleHRlbmRlcnMiLCJzYXZlQ29va2llIiwib3B0aW9uIiwic3Vic2NyaWJlIiwibmV3VmFsdWUiLCJzZXQiLCJleHBpcmVzIiwic2hvd2luZ0NoYW5nZSIsInNob3dSYXdDaGFuZ2UiLCJzZXROb2lzZVR5cGUiLCJleHRlbmQiLCJoaWRlTGlzdCIsImFkZExlc3NvbkZlYXR1cmVzIiwiZ2V0UGFyYW1ldGVyQnlOYW1lIiwiTW9yc2VSc3NQbHVnaW4iLCJhZGRSc3NGZWF0dXJlcyIsInJzc0VuYWJsZWQiLCJsb2FkQ29va2llcyIsImFwcGx5QmluZGluZ3MiXSwic291cmNlUm9vdCI6IiJ9